<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dark Matter JS Game</title>
    <meta name="description" content="A game created with Dark Matter JS">
    
    <!-- External Dependencies -->
    <!-- Fallback CDN for Matter.js if local file fails -->
    <script>
        // Check if Matter.js was loaded from local files, if not load from CDN
        document.addEventListener('DOMContentLoaded', function() {
            if (typeof Matter === 'undefined') {
                console.log('Loading Matter.js from CDN as fallback...');
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js';
                script.onload = function() {
                    console.log('Matter.js loaded from CDN');
                    // Trigger a custom event to let the game know Matter.js is ready
                    window.dispatchEvent(new Event('matter-loaded'));
                };
                document.head.appendChild(script);
            } else {
                // Matter.js already loaded, trigger ready event
                window.dispatchEvent(new Event('matter-loaded'));
            }
        });
    </script>
    
    <style id="game-styles">
/* Prevent scrollbars from reacting to key presses */
html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #000;
    font-family: Arial, sans-serif;
    /* Prevent scrolling with arrow keys */
    overscroll-behavior: none;
}

/* Prevent default key behaviors that cause scrolling */
body {
    /* Disable default key behaviors */
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
}

/* Main container fills entire viewport */
#game-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #000;
}

/* Canvas styling for proper fit scaling */
#gameCanvas {
    display: block;
    background: #000;
    max-width: 100vw;
    max-height: 100vh;
    width: auto;
    height: auto;
    /* Maintain aspect ratio while fitting to screen */
    object-fit: contain;
    /* Center the canvas */
    margin: auto;
    /* Smooth scaling */
    image-rendering: auto;
    image-rendering: crisp-edges;
    image-rendering: pixelated;
    image-rendering: -webkit-optimize-contrast;
}

/* Loading screen covers entire viewport */
#loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: #000;
    color: #fff;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: Arial, sans-serif;
    z-index: 1000;
}

/* Prevent context menu on right click */
#gameCanvas {
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    outline: none;
}

/* Mobile optimizations */
@media (max-width: 768px) {
    #gameCanvas {
        /* Ensure canvas scales properly on mobile */
        width: 100vw;
        height: 100vh;
        object-fit: contain;
    }
    
    /* Prevent mobile browser UI from interfering */
    body {
        position: fixed;
        overflow: hidden;
        -webkit-overflow-scrolling: touch;
    }
}

/* Prevent scrolling with keyboard */
body:focus {
    outline: none;
}

/* Hide scrollbars completely */
::-webkit-scrollbar {
    display: none;
}

html {
    -ms-overflow-style: none;
    scrollbar-width: none;
}
</style>
    <script id="game-script">// Dark Matter JS Engine
// src/core/Math/Vector2.js
class Vector2 {
    constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
    }

    add(other) {
        return new Vector2(this.x + other.x, this.y + other.y);
    }

    subtract(other) {
        return new Vector2(this.x - other.x, this.y - other.y);
    }

    multiply(scalar) {
        return new Vector2(this.x * scalar, this.y * scalar);
    }

    magnitude() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }

    normalize() {
        const mag = this.magnitude();
        return mag === 0 ? new Vector2() : new Vector2(this.x / mag, this.y / mag);
    }

    distanceTo(other) {
        return Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);
    }

    // Static constructors
    static zero() { return new Vector2(0, 0); }
    static one() { return new Vector2(1, 1); }
    static up() { return new Vector2(0, 1); }
    static down() { return new Vector2(0, -1); }
    static left() { return new Vector2(-1, 0); }
    static right() { return new Vector2(1, 0); }
    static fromAngle(angle) {
        return new Vector2(Math.cos(angle), Math.sin(angle));
    }

    static random() {
        return new Vector2(Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();
    }

    // Basic operations
    add(other) {
        return new Vector2(this.x + other.x, this.y + other.y);
    }

    subtract(other) {
        return new Vector2(this.x - other.x, this.y - other.y);
    }

    sub(other) {
        return new Vector2(this.x - other.x, this.y - other.y);
    }

    multiply(scalar) {
        return new Vector2(this.x * scalar, this.y * scalar);
    }

    divide(scalar) {
        if (scalar === 0) throw new Error("Division by zero");
        return new Vector2(this.x / scalar, this.y / scalar);
    }

    // Vector operations
    dot(other) {
        return this.x * other.x + this.y * other.y;
    }

    cross(other) {
        return this.x * other.y - this.y * other.x;
    }

    magnitude() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }

    magnitudeSquared() {
        return this.x * this.x + this.y * this.y;
    }

    normalize() {
        const mag = this.magnitude();
        return mag === 0 ? Vector2.zero() : this.divide(mag);
    }

    // Angle operations
    angle() {
        return Math.atan2(this.y, this.x);
    }

    rotate(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        return new Vector2(
            this.x * cos - this.y * sin,
            this.x * sin + this.y * cos
        );
    }

    // Utility methods
    distance(other) {
        return this.subtract(other).magnitude();
    }

    distanceSquared(other) {
        return this.subtract(other).magnitudeSquared();
    }

    lerp(other, t) {
        return new Vector2(
            this.x + (other.x - this.x) * t,
            this.y + (other.y - this.y) * t
        );
    }

    clamp(min, max) {
        return new Vector2(
            Math.min(Math.max(this.x, min.x), max.x),
            Math.min(Math.max(this.y, min.y), max.y)
        );
    }

    reflect(normal) {
        const dot = this.dot(normal);
        return this.subtract(normal.multiply(2 * dot));
    }

    project(other) {
        const normalized = other.normalize();
        return normalized.multiply(this.dot(normalized));
    }

    perpendicular() {
        return new Vector2(-this.y, this.x);
    }

    // Comparison methods
    equals(other, epsilon = 0.000001) {
        return Math.abs(this.x - other.x) < epsilon && 
               Math.abs(this.y - other.y) < epsilon;
    }

    // Conversion methods
    toString() {
        return `Vector2(${this.x}, ${this.y})`;
    }

    toArray() {
        return [this.x, this.y];
    }

    clone() {
        return new Vector2(this.x, this.y);
    }

    toJSON() {
        return { x: this.x, y: this.y };
    }

    // Public API methods
    static up() { return new Vector2(0, 1); }
    static down() { return new Vector2(0, -1); }
    static left() { return new Vector2(-1, 0); }
    static right() { return new Vector2(1, 0); }

    static fromJSON(data) {
        if (!data) return Vector2.zero();
        return new Vector2(data.x ?? 0, data.y ?? 0);
    }
}

window.Vector2 = Vector2;

// src/core/Math/Vector3.js
/**
 * Vector3 - A 3D vector implementation for the Dark Matter JS engine
 */
class Vector3 {
    /**
     * Create a new Vector3
     * @param {number} x - X component
     * @param {number} y - Y component
     * @param {number} z - Z component
     */
    constructor(x = 0, y = 0, z = 0) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    /**
     * Clone this vector
     * @returns {Vector3} A new vector with the same values
     */
    clone() {
        return new Vector3(this.x, this.y, this.z);
    }

    /**
     * Add a vector to this one
     * @param {Vector3} v - Vector to add
     * @returns {Vector3} New vector with the result
     */
    add(v) {
        return new Vector3(this.x + v.x, this.y + v.y, this.z + v.z);
    }

    /**
     * Subtract a vector from this one
     * @param {Vector3} v - Vector to subtract
     * @returns {Vector3} New vector with the result
     */
    subtract(v) {
        return new Vector3(this.x - v.x, this.y - v.y, this.z - v.z);
    }

    /**
     * Multiply this vector by a scalar value
     * @param {number} scalar - Value to multiply by
     * @returns {Vector3} New vector with the result
     */
    multiply(scalar) {
        return new Vector3(this.x * scalar, this.y * scalar, this.z * scalar);
    }

    /**
     * Calculate the dot product of this vector and another
     * @param {Vector3} v - The other vector
     * @returns {number} The dot product
     */
    dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
    }

    /**
     * Calculate the cross product of this vector and another
     * @param {Vector3} v - The other vector
     * @returns {Vector3} New vector with the result
     */
    cross(v) {
        return new Vector3(
            this.y * v.z - this.z * v.y,
            this.z * v.x - this.x * v.z,
            this.x * v.y - this.y * v.x
        );
    }

    /**
     * Calculate the magnitude (length) of this vector
     * @returns {number} The magnitude
     */
    magnitude() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }

    /**
     * Normalize this vector (make it unit length)
     * @returns {Vector3} A new normalized vector
     */
    normalize() {
        const mag = this.magnitude();
        if (mag === 0) return this.clone();
        return new Vector3(this.x / mag, this.y / mag, this.z / mag);
    }

    /**
     * Convert this vector to a 2D vector by projecting onto XY plane
     * @returns {Vector2} 2D projection of this vector
     */
    toVector2() {
        return new Vector2(this.x, this.y);
    }

    /**
     * Create a Vector3 from a Vector2 by setting Z to 0
     * @param {Vector2} v2 - The 2D vector
     * @returns {Vector3} A new 3D vector
     */
    static fromVector2(v2, z = 0) {
        return new Vector3(v2.x, v2.y, z);
    }

    /**
     * Calculate the distance between this vector and another
     * @param {Vector3} v - The other vector
     * @returns {number} The distance
     */
    distance(v) {
        const dx = this.x - v.x;
        const dy = this.y - v.y;
        const dz = this.z - v.z;
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }

    /**
     * Rotate this vector around the X axis
     * @param {number} angle - Rotation angle in radians
     * @returns {Vector3} The rotated vector
     */
    rotateX(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const y = this.y * cos - this.z * sin;
        const z = this.y * sin + this.z * cos;
        return new Vector3(this.x, y, z);
    }

    /**
     * Rotate this vector around the Y axis
     * @param {number} angle - Rotation angle in radians
     * @returns {Vector3} The rotated vector
     */
    rotateY(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const x = this.x * cos + this.z * sin;
        const z = -this.x * sin + this.z * cos;
        return new Vector3(x, this.y, z);
    }

    /**
     * Rotate this vector around the Z axis
     * @param {number} angle - Rotation angle in radians
     * @returns {Vector3} The rotated vector
     */
    rotateZ(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const x = this.x * cos - this.y * sin;
        const y = this.x * sin + this.y * cos;
        return new Vector3(x, y, this.z);
    }

    /**
     * Convert to a string representation
     * @returns {string} String representation of the vector
     */
    toString() {
        return `(${this.x}, ${this.y}, ${this.z})`;
    }
}

// Make the Vector3 class available globally
window.Vector3 = Vector3;

// src/core/Math/CollisionSystem.js
/**
 * CollisionSystem - Handles collision detection between GameObjects
 */
class CollisionSystem {
    constructor() {
        // Store collisions from last frame for collision events
        this.lastFrameCollisions = new Set();
        this.currentFrameCollisions = new Set();
    }
    
    /**
     * Check if two bounding boxes are colliding
     * @param {Object} box1 - First bounding box {x, y, width, height, rotation}
     * @param {Object} box2 - Second bounding box {x, y, width, height, rotation}
     * @returns {boolean} True if the boxes are colliding
     */
    checkCollision(box1, box2) {
        // Handle axis-aligned bounding boxes (no rotation)
        if ((box1.rotation === 0 || box1.rotation === undefined) && 
            (box2.rotation === 0 || box2.rotation === undefined)) {
            return this.checkAABBCollision(box1, box2);
        }
        
        // Handle oriented bounding boxes (with rotation)
        return this.checkOBBCollision(box1, box2);
    }
    
    /**
     * Check collision between two axis-aligned bounding boxes
     * @param {Object} box1 - First AABB {x, y, width, height}
     * @param {Object} box2 - Second AABB {x, y, width, height}
     * @returns {boolean} True if colliding
     */
    checkAABBCollision(box1, box2) {
        // Calculate bounds for box1 (centered bounding box)
        const box1Left = box1.x - box1.width / 2;
        const box1Right = box1.x + box1.width / 2;
        const box1Top = box1.y - box1.height / 2;
        const box1Bottom = box1.y + box1.height / 2;
        
        // Calculate bounds for box2 (centered bounding box)
        const box2Left = box2.x - box2.width / 2;
        const box2Right = box2.x + box2.width / 2;
        const box2Top = box2.y - box2.height / 2;
        const box2Bottom = box2.y + box2.height / 2;
        
        // Check for overlap
        if (box1Right < box2Left || box1Left > box2Right ||
            box1Bottom < box2Top || box1Top > box2Bottom) {
            return false; // No overlap
        }
        
        return true; // Overlap exists
    }
    
    /**
     * Check collision between two oriented bounding boxes
     * @param {Object} box1 - First OBB {x, y, width, height, rotation}
     * @param {Object} box2 - Second OBB {x, y, width, height, rotation}
     * @returns {boolean} True if colliding
     */
    checkOBBCollision(box1, box2) {
        // Convert to polygon representation
        const polygon1 = this.boxToPolygon(box1);
        const polygon2 = this.boxToPolygon(box2);
        
        // Use Separating Axis Theorem (SAT) to check collision
        return this.checkSATCollision(polygon1, polygon2);
    }
    
    /**
     * Convert a bounding box to a polygon (array of vertices)
     * @param {Object} box - Bounding box {x, y, width, height, rotation}
     * @returns {Array} Array of vertices as Vector2 objects
     */
    boxToPolygon(box) {
        const halfWidth = box.width / 2;
        const halfHeight = box.height / 2;
        
        // Define corners relative to center
        const corners = [
            new Vector2(-halfWidth, -halfHeight),
            new Vector2(halfWidth, -halfHeight),
            new Vector2(halfWidth, halfHeight),
            new Vector2(-halfWidth, halfHeight)
        ];
        
        // Apply rotation and translation
        const rotationRad = (box.rotation || 0) * Math.PI / 180;
        return corners.map(corner => {
            return corner.rotate(rotationRad).add(new Vector2(box.x, box.y));
        });
    }
    
    /**
     * Check collision using Separating Axis Theorem
     * @param {Array} polygon1 - Array of Vector2 vertices
     * @param {Array} polygon2 - Array of Vector2 vertices
     * @returns {boolean} True if colliding
     */
    checkSATCollision(polygon1, polygon2) {
        // Get all axes to check
        const axes = this.getAxes(polygon1).concat(this.getAxes(polygon2));
        
        // Check projection overlap on each axis
        for (const axis of axes) {
            const projection1 = this.projectPolygon(polygon1, axis);
            const projection2 = this.projectPolygon(polygon2, axis);
            
            // If we found a separating axis, objects don't collide
            if (projection1.max < projection2.min || projection2.max < projection1.min) {
                return false;
            }
        }
        
        // No separating axis found, objects collide
        return true;
    }
    
    /**
     * Get all axes for Separating Axis Theorem check
     * @param {Array} polygon - Array of Vector2 vertices
     * @returns {Array} Array of Vector2 axes (normalized)
     */
    getAxes(polygon) {
        const axes = [];
        const vertexCount = polygon.length;
        
        for (let i = 0; i < vertexCount; i++) {
            // Get edge vector
            const p1 = polygon[i];
            const p2 = polygon[(i + 1) % vertexCount];
            const edge = p2.subtract(p1);
            
            // Get perpendicular axis (normal)
            const normal = new Vector2(-edge.y, edge.x).normalize();
            axes.push(normal);
        }
        
        return axes;
    }
    
    /**
     * Project a polygon onto an axis
     * @param {Array} polygon - Array of Vector2 vertices
     * @param {Vector2} axis - Axis to project onto
     * @returns {Object} Object with min and max projection values
     */
    projectPolygon(polygon, axis) {
        // Initialize with first vertex
        let min = polygon[0].dot(axis);
        let max = min;
        
        // Find min and max projections
        for (let i = 1; i < polygon.length; i++) {
            const projection = polygon[i].dot(axis);
            min = Math.min(min, projection);
            max = Math.max(max, projection);
        }
        
        return { min, max };
    }
    
    /**
     * Test collision between a ray and an object's bounding box
     * @param {Object} ray - Ray {origin: Vector2, direction: Vector2}
     * @param {Object} box - Bounding box {x, y, width, height, rotation}
     * @returns {Object|null} Hit information or null if no hit
     */
    raycast(ray, box) {
        if (box.rotation && box.rotation !== 0) {
            // Handle OBB (oriented bounding box)
            return this.raycastOBB(ray, box);
        } else {
            // Handle AABB (axis-aligned bounding box)
            return this.raycastAABB(ray, box);
        }
    }
    
    /**
     * Test collision between a ray and an axis-aligned bounding box
     * @param {Object} ray - Ray {origin: Vector2, direction: Vector2}
     * @param {Object} box - Box {x, y, width, height}
     * @returns {Object|null} Hit information or null if no hit
     */
    raycastAABB(ray, box) {
        // Calculate box bounds
        const minX = box.x - box.width / 2;
        const maxX = box.x + box.width / 2;
        const minY = box.y - box.height / 2;
        const maxY = box.y + box.height / 2;
        
        // Calculate ray parameters
        const rayOrigin = ray.origin;
        const rayDirection = ray.direction.normalize();
        
        // Calculate inverse direction to avoid division
        const invDirX = 1.0 / (rayDirection.x === 0 ? 0.00001 : rayDirection.x);
        const invDirY = 1.0 / (rayDirection.y === 0 ? 0.00001 : rayDirection.y);
        
        // Calculate intersection distances
        const t1 = (minX - rayOrigin.x) * invDirX;
        const t2 = (maxX - rayOrigin.x) * invDirX;
        const t3 = (minY - rayOrigin.y) * invDirY;
        const t4 = (maxY - rayOrigin.y) * invDirY;
        
        // Get min and max intersection distances
        const tMin = Math.max(Math.min(t1, t2), Math.min(t3, t4));
        const tMax = Math.min(Math.max(t1, t2), Math.max(t3, t4));
        
        // If tMax < 0, ray is intersecting box, but entire box is behind ray origin
        if (tMax < 0) {
            return null;
        }
        
        // If tMin > tMax, ray doesn't intersect box
        if (tMin > tMax) {
            return null;
        }
        
        // If tMin < 0, ray origin is inside the box
        const t = tMin < 0 ? tMax : tMin;
        
        // Calculate hit position and normal
        const hitPosition = rayOrigin.add(rayDirection.multiply(t));
        
        // Calculate hit normal based on which face was hit
        let normal;
        const epsilon = 0.001; // Small value for floating-point comparison
        
        if (Math.abs(hitPosition.x - minX) < epsilon) {
            normal = new Vector2(-1, 0); // Left face
        } else if (Math.abs(hitPosition.x - maxX) < epsilon) {
            normal = new Vector2(1, 0); // Right face
        } else if (Math.abs(hitPosition.y - minY) < epsilon) {
            normal = new Vector2(0, -1); // Top face
        } else {
            normal = new Vector2(0, 1); // Bottom face
        }
        
        return {
            distance: t,
            position: hitPosition,
            normal: normal
        };
    }
    
    /**
     * Test collision between a ray and an oriented bounding box
     * @param {Object} ray - Ray {origin: Vector2, direction: Vector2}
     * @param {Object} box - Box {x, y, width, height, rotation}
     * @returns {Object|null} Hit information or null if no hit
     */
    raycastOBB(ray, box) {
        // Convert to local space where OBB becomes AABB
        const rotationRad = -(box.rotation * Math.PI / 180);
        const boxCenter = new Vector2(box.x, box.y);
        
        // Transform ray to local space
        const localOrigin = ray.origin.subtract(boxCenter).rotate(rotationRad);
        const localDirection = ray.direction.rotate(rotationRad);
        
        // Create local space ray
        const localRay = {
            origin: localOrigin,
            direction: localDirection
        };
        
        // Create local space AABB
        const localBox = {
            x: 0,
            y: 0,
            width: box.width,
            height: box.height,
            rotation: 0
        };
        
        // Test against local space AABB
        const hit = this.raycastAABB(localRay, localBox);
        
        if (!hit) return null;
        
        // Transform hit back to world space
        const worldHitPos = hit.position.rotate(-rotationRad).add(boxCenter);
        const worldHitNormal = hit.normal.rotate(-rotationRad);
        
        return {
            distance: hit.distance,
            position: worldHitPos,
            normal: worldHitNormal
        };
    }
    
    /**
     * Update the collision system for the current frame
     * @param {Array} gameObjects - All active game objects
     */
    update(gameObjects) {
        // Store last frame's collisions
        this.lastFrameCollisions = new Set(this.currentFrameCollisions);
        this.currentFrameCollisions.clear();
        
        // Check collisions between all pairs of objects
        const objCount = gameObjects.length;
        
        for (let i = 0; i < objCount; i++) {
            const objA = gameObjects[i];
            
            if (!objA.active || !objA.collisionEnabled) continue;
            
            for (let j = i + 1; j < objCount; j++) {
                const objB = gameObjects[j];
                
                if (!objB.active || !objB.collisionEnabled) continue;
                
                // Skip collision check if they're on non-colliding layers
                if ((objA.collisionLayer & objB.collisionMask) === 0 && 
                    (objB.collisionLayer & objA.collisionMask) === 0) {
                    continue;
                }
                
                // Get bounding boxes
                const boxA = objA.getBoundingBox();
                const boxB = objB.getBoundingBox();
                
                // Check collision
                if (this.checkCollision(boxA, boxB)) {
                    // Create a unique identifier for this collision pair
                    const collisionId = `${objA.id}_${objB.id}`;
                    
                    // Store in current frame collisions
                    this.currentFrameCollisions.add(collisionId);
                    
                    // Check if this is a new collision (enter)
                    const isNewCollision = !this.lastFrameCollisions.has(collisionId);
                    
                    // Trigger collision events
                    if (isNewCollision) {
                        this.triggerCollisionEnter(objA, objB);
                    } else {
                        this.triggerCollisionStay(objA, objB);
                    }
                }
            }
        }
        
        // Check for collision exit events
        for (const collisionId of this.lastFrameCollisions) {
            if (!this.currentFrameCollisions.has(collisionId)) {
                // This collision was present last frame but not this frame
                const [idA, idB] = collisionId.split('_');
                
                // Find the objects by ID
                const objA = gameObjects.find(obj => obj.id === idA);
                const objB = gameObjects.find(obj => obj.id === idB);
                
                // Trigger exit event if objects still exist
                if (objA && objB) {
                    this.triggerCollisionExit(objA, objB);
                }
            }
        }
    }
    
    /**
     * Trigger collision enter event
     * @param {GameObject} objA - First object
     * @param {GameObject} objB - Second object
     */
    triggerCollisionEnter(objA, objB) {
        // Call event methods on both objects if they exist
        if (objA.onCollisionEnter) objA.onCollisionEnter(objB);
        if (objB.onCollisionEnter) objB.onCollisionEnter(objA);
        
        // Also trigger events on modules
        this.triggerModuleCollisionEvents(objA, objB, 'onCollisionEnter');
        this.triggerModuleCollisionEvents(objB, objA, 'onCollisionEnter');
    }
    
    /**
     * Trigger collision stay event
     * @param {GameObject} objA - First object
     * @param {GameObject} objB - Second object 
     */
    triggerCollisionStay(objA, objB) {
        if (objA.onCollisionStay) objA.onCollisionStay(objB);
        if (objB.onCollisionStay) objB.onCollisionStay(objA);
        
        this.triggerModuleCollisionEvents(objA, objB, 'onCollisionStay');
        this.triggerModuleCollisionEvents(objB, objA, 'onCollisionStay');
    }
    
    /**
     * Trigger collision exit event
     * @param {GameObject} objA - First object
     * @param {GameObject} objB - Second object
     */
    triggerCollisionExit(objA, objB) {
        if (objA.onCollisionExit) objA.onCollisionExit(objB);
        if (objB.onCollisionExit) objB.onCollisionExit(objA);
        
        this.triggerModuleCollisionEvents(objA, objB, 'onCollisionExit');
        this.triggerModuleCollisionEvents(objB, objA, 'onCollisionExit');
    }
    
    /**
     * Trigger collision events on modules
     * @param {GameObject} obj - Object with modules
     * @param {GameObject} other - Other colliding object
     * @param {string} eventName - Name of event to trigger
     */
    triggerModuleCollisionEvents(obj, other, eventName) {
        if (!obj.modules) return;
        
        obj.modules.forEach(module => {
            if (module.enabled && typeof module[eventName] === 'function') {
                try {
                    module[eventName](other);
                } catch (error) {
                    console.error(`Error in ${eventName} event for module ${module.type || module.constructor.name}:`, error);
                }
            }
        });
    }
}

// Create a global instance
window.collisionSystem = new CollisionSystem;

// src/core/Math/Raycast.js
/**
 * Raycast - Utility for raycasting in 2D space
 */
class Raycast {
    /**
     * Cast a ray against all objects in the scene
     * @param {Vector2} origin - Starting point of the ray
     * @param {Vector2} direction - Direction of the ray
     * @param {number} [maxDistance=Infinity] - Maximum distance to check
     * @param {Array} [gameObjects=[]] - GameObjects to check against
     * @param {number} [layerMask=0xFFFF] - Layer mask for filtering objects
     * @returns {Object|null} Hit information or null if no hit
     */
    static cast(origin, direction, maxDistance = Infinity, gameObjects = [], layerMask = 0xFFFF) {
        // Normalize the direction
        const normalizedDirection = direction.normalize();
        
        // Create the ray
        const ray = {
            origin: origin,
            direction: normalizedDirection
        };
        
        // Variables to track the closest hit
        let closestHit = null;
        let closestDistance = maxDistance;
        let hitObject = null;
        
        // Check all active game objects
        for (const obj of gameObjects) {
            if (!obj.active || !obj.collisionEnabled) {
                continue;
            }
            
            // Apply layer mask filtering
            if ((obj.collisionLayer & layerMask) === 0) {
                continue;
            }
            
            // Get the object's bounding box
            const box = obj.getBoundingBox();
            
            // Test ray against the box
            const hit = window.collisionSystem.raycast(ray, box);
            
            // If we hit something and it's closer than previous hits
            if (hit && hit.distance < closestDistance) {
                closestHit = hit;
                closestDistance = hit.distance;
                hitObject = obj;
            }
        }
        
        // Return null if no hit found
        if (!closestHit) {
            return null;
        }
        
        // Add the hit object to the result
        closestHit.object = hitObject;
        
        return closestHit;
    }
    
    /**
     * Cast a ray and return all objects that are hit
     * @param {Vector2} origin - Starting point of the ray
     * @param {Vector2} direction - Direction of the ray
     * @param {number} [maxDistance=Infinity] - Maximum distance to check
     * @param {Array} [gameObjects=[]] - GameObjects to check against
     * @param {number} [layerMask=0xFFFF] - Layer mask for filtering objects
     * @returns {Array} Array of hit information
     */
    static castAll(origin, direction, maxDistance = Infinity, gameObjects = [], layerMask = 0xFFFF) {
        // Normalize the direction
        const normalizedDirection = direction.normalize();
        
        // Create the ray
        const ray = {
            origin: origin,
            direction: normalizedDirection
        };
        
        // Array to store all hits
        const hits = [];
        
        // Check all active game objects
        for (const obj of gameObjects) {
            if (!obj.active || !obj.collisionEnabled) {
                continue;
            }
            
            // Apply layer mask filtering
            if ((obj.collisionLayer & layerMask) === 0) {
                continue;
            }
            
            // Get the object's bounding box
            const box = obj.getBoundingBox();
            
            // Test ray against the box
            const hit = window.collisionSystem.raycast(ray, box);
            
            // If we hit something within the max distance
            if (hit && hit.distance <= maxDistance) {
                // Add the hit object to the result
                hit.object = obj;
                hits.push(hit);
            }
        }
        
        // Sort hits by distance
        hits.sort((a, b) => a.distance - b.distance);
        
        return hits;
    }
    
    /**
     * Draw a ray in the scene for debugging
     * @param {CanvasRenderingContext2D} ctx - Canvas rendering context
     * @param {Vector2} origin - Starting point of the ray
     * @param {Vector2} direction - Direction of the ray
     * @param {number} [length=100] - Length of the ray to draw
     * @param {string} [color='#ff0000'] - Color of the ray
     * @param {boolean} [showHit=true] - Whether to show hit information
     * @param {Array} [gameObjects=[]] - GameObjects to check against
     */
    static drawRay(ctx, origin, direction, length = 100, color = '#ff0000', showHit = true, gameObjects = []) {
        // Draw the ray line
        ctx.beginPath();
        ctx.moveTo(origin.x, origin.y);
        
        // If we want to show hit information and have objects to check against
        if (showHit && gameObjects.length > 0) {
            const hit = Raycast.cast(origin, direction, length, gameObjects);
            
            if (hit) {
                // Draw line to hit point
                ctx.lineTo(hit.position.x, hit.position.y);
                ctx.strokeStyle = color;
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Draw hit point
                ctx.beginPath();
                ctx.arc(hit.position.x, hit.position.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = '#ffcc00';
                ctx.fill();
                
                // Draw normal vector
                ctx.beginPath();
                ctx.moveTo(hit.position.x, hit.position.y);
                ctx.lineTo(
                    hit.position.x + hit.normal.x * 10,
                    hit.position.y + hit.normal.y * 10
                );
                ctx.strokeStyle = '#00ccff';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                return;
            }
        }
        
        // If no hit, or not showing hit, draw the full ray
        const endPoint = origin.add(direction.normalize().multiply(length));
        ctx.lineTo(endPoint.x, endPoint.y);
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.stroke();
    }
}

// Make Raycast available globally
window.Raycast = Raycast;

// src/core/Math/MatterMath.js
class MatterMath {
    constructor() {
        this.timescale = 1; // Timescale variable
    }

    /*
      Some basic and advanced math functions
    */
    //this.time = time();

    // We all know what pi() is
    pi() {
        return (Math.PI); // PI
    }

    pi2() {
        return (Math.PI * 2);
    }

    // Get the current time in a long number
    time() {
        return (new Date().getTime()); // Get the current time, can be good for random number functions
    }

    // Delta time. Set a floating number to change the rate at which delta time is calculated(0.1 is default)
    dt(rate = 0.1) {
        return ((1000 / 60) * this.timescale * rate);
    }

    setTimescale(timescale) {
        this.timescale = timescale;
    }

    getTimescale() {
        return (this.timescale);
    }

    ts() {
        return (this.timescale);
    }

    // ARRAY STUFF

    // Create a new list
    listCreate() {
        var arr = [];

        return (arr);
    }

    // Add to the list
    listAdd(id, value) {
        id.push(value);
    }

    // Set an item to a certain value in the list
    listSet(id, pos, value) {
        id[pos] = value;
    }

    // Get the value of an item in the list
    listGet(id, pos) {
        return (id[pos]);
    }

    // Create and initialize a 2d array
    array2dCreate(width, height, defaultValue) {
        var arr = [];

        for (var i = 0; i < width; i += 1) {
            for (var j = 0; j < height; j += 1) {
                arr.push([i, j]);
                arr[i][j] = defaultValue;
            }
        }

        return (arr);
    }

    // Set the value of the 2d array
    array2dSet(array, x, y, value) {
        array[x][y] = value;
    }

    // Get the value of the 2d array
    array2dGet(array, x, y) {
        return (array[x][y]);
    }

    // Create and initialize a 2d array
    array3dCreate(width, height, depth, defaultValue) {
        var arr = [];

        for (var i = 0; i < width; i += 1) {
            for (var j = 0; j < height; j += 1) {
                for (var f = 0; f < depth; f += 1) {
                    arr.push([i, j, f]);
                    arr[i][j][f] = defaultValue;
                }
            }
        }

        return (arr);
    }

    // Set the value of the 2d array
    array3dSet(array, x, y, z, value) {
        array[x][y][z] = value;
    }

    // Get the value of the 2d array
    array3dGet(array, x, y, z) {
        return (array[x][y][z]);
    }

    // Clear the array
    arrayClear(array) {
        array = [];

        return (array);
    }

    // MATH STUFF

    // Returns the cosine of a number from degrees to radians
    dcos(x) {
        return (Math.cos(this.degtorad(x)));
    }

    // Returns degrees to radians
    degtorad2 = function () {
        return ((this.pi() * 2) / -360);
    }

    // Returns degrees to radians
    degtorad(x) {
        return (x * this.pi() / 180);
    }

    // Returns radians to degrees
    radtodeg(x) {
        return (x * 180 / this.pi());
    }

    // Snap a position to a grid position. Position being for example, an x or y position
    snap(position, grid_size) {
        return (floor(position / grid_size) * grid_size);
    }

    // Return the distance between 2 points
    pointDistance(x1, y1, x2, y2) {
        var a = (x1) - (x2);
        var b = (y1) - (y2);
        return (Math.sqrt((a * a) + (b * b)));
    }

    // Return the direction from one point to another
    pointDirection(x1, y1, x2, y2) {
        var xdiff = (x2) - x1;
        var ydiff = (y2) - y1;

        return (-(Math.atan2(ydiff, xdiff) * 180.0 / Math.PI));
    }

    angleDifference(angle1, angle2) {
        // Normalize angles to the range [0, 360)
        const normalizedAngle1 = (angle1 % 360 + 360) % 360;
        const normalizedAngle2 = (angle2 % 360 + 360) % 360;

        // Calculate the absolute difference
        let diff = Math.abs(normalizedAngle1 - normalizedAngle2);

        // Ensure the result is within the range [0, 180)
        if (diff > 180) {
            diff = 360 - diff;
        }

        return diff;
    }

    // Returns the length and direction on the x axis
    lengthDirX(length, direction) {
        return (length * Math.cos(direction * this.degtorad2()));
    }

    // Returns the length and direction on the y axis
    lengthDirY(length, direction) {
        return (length * Math.sin(direction * this.degtorad2()));
    }

    // Lerp a value towards another value
    lerp(from, to, amount) {
        return (from + amount * (to - from));
    }

    // Returns a random floating point from 1 to max value
    random(max) {
        return ((Math.random() * max) + 1);
    }

    // Returns a random floating point from min to max value
    randomRange(min, max) {
        return (Math.random() * (max - min) + min);
    }

    // Returns a random integer from 1 to max value
    irandom(max) {
        return (Math.floor((Math.random() * max) + 1));
    }

    // Returns a random integer from min to max value
    irandomRange(min, max) {
        return (Math.floor(Math.random() * (max - min) + min));
    }

    // Returns either true or false
    randomBool() {
        return (Math.random() >= 0.5);
    }

    // Choose a random item out of a bunch of given items
    choose(...items) {
        if (items.length === 0) {
            throw new Error('No items provided to choose from.');
        }
        const randomIndex = Math.floor(Math.random() * items.length);

        return items[randomIndex];
    }

    // Replace every occurance of a string inside another string
    stringReplaceAll(str, find, replace) {
        return (str.replace(new RegExp(escapeRegExp(find), 'g'), replace));
    }

    // Returns a value to a string
    toString(val) {
        return (val.toString());
    }

    // Converts a string to an integer
    toInt(val) {
        return (parseInt(val));
    }

    // Returns a value pulsing at the rate of delay to a maximum number
    /*
        var red = pulse(10, 255);
    */
    sine(delay, max) {
        var time = this.time();
        var val = Math.sin(time / delay) * max;

        return (val);
    }

    // Returns a value pulsing at the rate of delay from 0 to a maximum number
    sinePositive(delay, max) {
        var val = Math.sin(this.time() / delay) * max;
        return (keepPositive(val));
    }

    // Returns a value pulsing at the rate of delay from 0 to a maximum number
    sineNegative(delay, max) {
        var val = Math.sin(this.time() / delay) * max;
        return (keepNegative(val));
    }

    // Linear interpolation function
    interpolate(start, end, t) {
        return start + (end - start) * t;
    }

    // Smoothstep interpolation function
    smoothstep(t) {
        return t * t * (3 - 2 * t);
    }

    // Sine interpolation function
    sineInterpolation(t) {
        return 0.5 - 0.5 * Math.cos(Math.PI * t);
    }

    // Clamp a value to a max and min value
    clamp(value, min, max) {
        if (value > max) { value = max; }
        if (value < min) { value = min; }

        return (value);
    }

    // Return a number that is always positive
    keepPositive(x) {
        if (x < 0) {
            x *= -1;
        }

        return (x);
    }

    // Return a number that is always negative
    keepNegative(x) {
        if (x > 0) {
            x *= -1;
        }

        return (x);
    }

    // Rotate an angle smoothly towards another angle
    rotateSmooth(direction, targetDirection, speed) {
        let delta = targetDirection - direction;

        delta = ((delta + 360) % 360 - 180);

        const rotateDirection = delta > 0 ? 1 : -1;

        let rotationAmount = rotateDirection * Math.min(Math.abs(delta), speed);

        direction = ((direction + (rotationAmount + 360)) % 360);
        //console.log(direction);

        return (direction);
    }

    // Execute javascript code from a string
    executeString(string) {
        try {
            eval(string);
        } catch (error) {
            console.error("Error executing string:", error);
        }
    }

    // Get color from rgb color values
    rgb(r, g, b) {
        r = Math.floor(r);
        g = Math.floor(g);
        b = Math.floor(b);
        return ["rgb(", r, ",", g, ",", b, ")"].join("");
    }

    hsl(h, s, l) {
        r = Math.floor(h);
        g = Math.floor(s) * 100;
        b = Math.floor(l) * 100;
        return ["hsl(", r, ",", g, "%,", b, "%)"].join("");
    }
}

window.MatterMath = MatterMath; // Make available globally

// src/core/Math/Polygon.js
class Polygon {
  constructor(parent, position, ...vectors) {
    this.vertices = vectors.map(v => v.sub(position)); // Local coordinates of vertices
    this.position = position; // Position of the parent object
    this.rotation = 0; // Rotation angle in radians

    this.math = new MatterMath();

    this.parent = parent; // Parent object

    this.originalVertices = this.vertices;
  }

  projectOntoAxis(axis) {
    let min = Infinity;
    let max = -Infinity;

    this.vertices.forEach(vertex => {
      const globalVertex = vertex.add(this.position);
      const projection = vertex.x * axis.x + vertex.y * axis.y;
      min = Math.min(min, projection);
      max = Math.max(max, projection);
    });

    return ({ min, max });
  }

  collidesWith(otherPolygon) {
    if (this === otherPolygon) {
      return false;
    }

    const axes = this.getAxes().concat(otherPolygon.getAxes());

    for (let axis of axes) {
      const projection1 = this.projectOntoAxis(axis);
      const projection2 = otherPolygon.projectOntoAxis(axis);

      if (projection1.max < projection2.min || projection2.max < projection1.min) {
        // No collision
        return false;
      }
    }


    // Collision detected
    return true;
  }

  // Check if a point is within this polygon
  collisionPoint(x, y) {
    const polygon = this;
    let inside = false;

    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
      const xi = polygon[i][0];
      const yi = polygon[i][1];
      const xj = polygon[j][0];
      const yj = polygon[j][1];

      const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
      if (intersect) {
        inside = !inside;
      }
    }

    return inside;
  }

  // Snaps the parent objects position back to the edge of the other polygon
  snapPositionBack(otherPolygon) {
    const mtv = this.calculateMTV(otherPolygon);
    if (mtv) {
      // Move the parent object by the negative of the MTV
      this.parent.x -= mtv.x;
      this.parent.y -= mtv.y;
    }
  }

  easePositionBack(otherPolygon, steps = 10) {
    const mtv = this.calculateMTV(otherPolygon);
    const stepSize = { x: mtv.x / steps, y: mtv.y / steps };

    for (let i = 0; i < steps; i++) {
      this.parent.x -= stepSize.x;
      this.parent.y -= stepSize.y;
      // Update the game/rendering logic here
    }
  }

  calculateMTV(otherPolygon) {
    let minOverlap = Infinity;
    let mtv = { x: 0, y: 0 };

    // Iterate over all edges (axes) of both polygons
    const axes = this.getAxes().concat(otherPolygon.getAxes());
    for (const axis of axes) {
      const projection1 = this.projectOntoAxis(axis);
      const projection2 = otherPolygon.projectOntoAxis(axis);

      // Check for overlap (collision)
      const overlap = Math.min(projection1.max, projection2.max) - Math.max(projection1.min, projection2.min);
      if (overlap < 0) {
        // No overlap on this axis, no collision
        return null;
      }

      // Keep track of the smallest overlap (MTV)
      if (overlap < minOverlap) {
        minOverlap = overlap;
        mtv = { x: axis.x * overlap, y: axis.y * overlap }; // Create a new vector
      }
    }

    return mtv;
  }

  // Check for a collision between a line and this polygon
  collisionLine(x1, y1, x2, y2) {
    const polygon = this;

    // Check if both line endpoints are inside the polygon
    if (this.collisionPoint(x1, y1) || this.collisionLine(x2, y2)) {
      return true;
    }

    // Check if the line intersects any polygon edge
    for (let i = 0; i < polygon.length; i++) {
      const x3 = polygon[i][0];
      const y3 = polygon[i][1];
      const x4 = polygon[(i + 1) % polygon.length][0];
      const y4 = polygon[(i + 1) % polygon.length][1];

      if (this.collisionLineLine(x1, y1, x2, y2, x3, y3, x4, y4)) {
        return true;
      }
    }

    return false;
  }

  // Check for a collision between a line and this polygon
  collisionLineLine(x1, y1, x2, y2, x3, y3, x4, y4) {
    const polygon = this;

    // Calculate the direction vectors of the lines
    const dx1 = x2 - x1;
    const dy1 = y2 - y1;
    const dx2 = x4 - x3;
    const dy2 = y4 - y3;

    // Calculate determinants
    const det = dx1 * dy2 - dx2 * dy1;
    const detInv = 1 / det;

    // Check if lines are parallel (det === 0)
    if (Math.abs(det) < 1e-6) {
      return false;
    }

    // Calculate intersection point
    const t1 = (x3 - x1) * dy2 - (y3 - y1) * dx2;
    const t2 = (x3 - x1) * dy1 - (y3 - y1) * dx1;
    const tIntersect1 = t1 * detInv;
    const tIntersect2 = t2 * detInv;

    // Check if intersection point lies within both line segments
    if (tIntersect1 >= 0 && tIntersect1 <= 1 && tIntersect2 >= 0 && tIntersect2 <= 1) {
      return true;
    }

    return false;
  }

  getAxes() {
    const axes = [];
    for (let i = 0; i < this.vertices.length; i++) {
      const p1 = this.vertices[i];
      const p2 = this.vertices[i + 1 === this.vertices.length ? 0 : i + 1];
      const edge = (new Vector2(p2.x - p1.x, p2.y - p1.y));
      const normal = (new Vector2(-edge.y, edge.x));
      const length = Math.sqrt(normal.x * normal.x + normal.y * normal.y);
      const norm = new Vector2(normal.x / length, normal.y / length);
      axes.push(norm);
    }
    return axes;
  }

  update(position, rotation) {
    this.position = position;
    const r = rotation % 360;
    this.rotation = this.math.degtorad(r);

    const cos = Math.cos(this.rotation);
    const sin = Math.sin(this.rotation);

    this.vertices = this.originalVertices.map(vertex => {
      const rotatedX = cos * vertex.x - sin * vertex.y;
      const rotatedY = sin * vertex.x + cos * vertex.y;

      // console.log(rotatedX);

      return (new Vector2(rotatedX + this.position.x, rotatedY + this.position.y));
    });
  }

  // Preset shapes
  static rectangle(position, width, height, parent) {
    return (new Polygon(parent, position, new Vector2(position.x - (width), position.y - (height)),
      new Vector2(position.x + (width), position.y - (height)),
      new Vector2(position.x + (width), position.y + (height)),
      new Vector2(position.x - (width), position.y + (height))
    ));
  }

  // A rounded shape with resolution as the number of points, at a position for the center point and a radius size
  static round(position, resolution, radius, parent) {
    const vertices = [];
    for (let i = 0; i < resolution; i++) {
      const angle = (i / resolution) * 2 * Math.PI;

      const x = position.x + radius * Math.cos(angle);
      const y = position.y + radius * Math.sin(angle);

      vertices.push(new Vector2(x, y));
    }

    return (new Polygon(parent, position, ...vertices));
  }

  draw(ctx, color) {
    ctx.save();
    ctx.strokeStyle = color || "white";
    ctx.beginPath();
    for (let i = 0; i < this.vertices.length; i++) {
      const v = this.vertices[i];
      const to = this.vertices[(i + 1) % this.vertices.length];
      if (i === 0) {
        ctx.moveTo(v.x, v.y);
      }
      ctx.lineTo(to.x, to.y);
    }
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }

  toJSON() {
    return {
      x: this.position.x,
      y: this.position.y,
      position: { x: this.position.x, y: this.position.y },
      rotation: this.rotation,
      vertices: this.vertices.map(v => ({ x: v.x, y: v.y }))
    };
  }
}

window.Polygon = Polygon;

// src/core/matter-js/matter.min.js
/*!
 * matter-js 0.20.0 by @liabru
 * http://brm.io/matter-js/
 * License MIT
 */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("Matter",[],t):"object"==typeof exports?exports.Matter=t():e.Matter=t()}(this,(function(){return function(e){var t={};function n(o){if(t[o])return t[o].exports;var i=t[o]={i:o,l:!1,exports:{}};return e[o].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=e,n.c=t,n.d=function(e,t,o){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:o})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(n.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)n.d(o,i,function(t){return e[t]}.bind(null,i));return o},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=20)}([function(e,t){var n={};e.exports=n,function(){n._baseDelta=1e3/60,n._nextId=0,n._seed=0,n._nowStartTime=+new Date,n._warnedOnce={},n._decomp=null,n.extend=function(e,t){var o,i;"boolean"==typeof t?(o=2,i=t):(o=1,i=!0);for(var r=o;r<arguments.length;r++){var a=arguments[r];if(a)for(var s in a)i&&a[s]&&a[s].constructor===Object?e[s]&&e[s].constructor!==Object?e[s]=a[s]:(e[s]=e[s]||{},n.extend(e[s],i,a[s])):e[s]=a[s]}return e},n.clone=function(e,t){return n.extend({},t,e)},n.keys=function(e){if(Object.keys)return Object.keys(e);var t=[];for(var n in e)t.push(n);return t},n.values=function(e){var t=[];if(Object.keys){for(var n=Object.keys(e),o=0;o<n.length;o++)t.push(e[n[o]]);return t}for(var i in e)t.push(e[i]);return t},n.get=function(e,t,n,o){t=t.split(".").slice(n,o);for(var i=0;i<t.length;i+=1)e=e[t[i]];return e},n.set=function(e,t,o,i,r){var a=t.split(".").slice(i,r);return n.get(e,t,0,-1)[a[a.length-1]]=o,o},n.shuffle=function(e){for(var t=e.length-1;t>0;t--){var o=Math.floor(n.random()*(t+1)),i=e[t];e[t]=e[o],e[o]=i}return e},n.choose=function(e){return e[Math.floor(n.random()*e.length)]},n.isElement=function(e){return"undefined"!=typeof HTMLElement?e instanceof HTMLElement:!!(e&&e.nodeType&&e.nodeName)},n.isArray=function(e){return"[object Array]"===Object.prototype.toString.call(e)},n.isFunction=function(e){return"function"==typeof e},n.isPlainObject=function(e){return"object"==typeof e&&e.constructor===Object},n.isString=function(e){return"[object String]"===toString.call(e)},n.clamp=function(e,t,n){return e<t?t:e>n?n:e},n.sign=function(e){return e<0?-1:1},n.now=function(){if("undefined"!=typeof window&&window.performance){if(window.performance.now)return window.performance.now();if(window.performance.webkitNow)return window.performance.webkitNow()}return Date.now?Date.now():new Date-n._nowStartTime},n.random=function(t,n){return n=void 0!==n?n:1,(t=void 0!==t?t:0)+e()*(n-t)};var e=function(){return n._seed=(9301*n._seed+49297)%233280,n._seed/233280};n.colorToNumber=function(e){return 3==(e=e.replace("#","")).length&&(e=e.charAt(0)+e.charAt(0)+e.charAt(1)+e.charAt(1)+e.charAt(2)+e.charAt(2)),parseInt(e,16)},n.logLevel=1,n.log=function(){console&&n.logLevel>0&&n.logLevel<=3&&console.log.apply(console,["matter-js:"].concat(Array.prototype.slice.call(arguments)))},n.info=function(){console&&n.logLevel>0&&n.logLevel<=2&&console.info.apply(console,["matter-js:"].concat(Array.prototype.slice.call(arguments)))},n.warn=function(){console&&n.logLevel>0&&n.logLevel<=3&&console.warn.apply(console,["matter-js:"].concat(Array.prototype.slice.call(arguments)))},n.warnOnce=function(){var e=Array.prototype.slice.call(arguments).join(" ");n._warnedOnce[e]||(n.warn(e),n._warnedOnce[e]=!0)},n.deprecated=function(e,t,o){e[t]=n.chain((function(){n.warnOnce(" deprecated ",o)}),e[t])},n.nextId=function(){return n._nextId++},n.indexOf=function(e,t){if(e.indexOf)return e.indexOf(t);for(var n=0;n<e.length;n++)if(e[n]===t)return n;return-1},n.map=function(e,t){if(e.map)return e.map(t);for(var n=[],o=0;o<e.length;o+=1)n.push(t(e[o]));return n},n.topologicalSort=function(e){var t=[],o=[],i=[];for(var r in e)o[r]||i[r]||n._topologicalSort(r,o,i,e,t);return t},n._topologicalSort=function(e,t,o,i,r){var a=i[e]||[];o[e]=!0;for(var s=0;s<a.length;s+=1){var l=a[s];o[l]||(t[l]||n._topologicalSort(l,t,o,i,r))}o[e]=!1,t[e]=!0,r.push(e)},n.chain=function(){for(var e=[],t=0;t<arguments.length;t+=1){var n=arguments[t];n._chained?e.push.apply(e,n._chained):e.push(n)}var o=function(){for(var t,n=new Array(arguments.length),o=0,i=arguments.length;o<i;o++)n[o]=arguments[o];for(o=0;o<e.length;o+=1){var r=e[o].apply(t,n);void 0!==r&&(t=r)}return t};return o._chained=e,o},n.chainPathBefore=function(e,t,o){return n.set(e,t,n.chain(o,n.get(e,t)))},n.chainPathAfter=function(e,t,o){return n.set(e,t,n.chain(n.get(e,t),o))},n.setDecomp=function(e){n._decomp=e},n.getDecomp=function(){var e=n._decomp;try{e||"undefined"==typeof window||(e=window.decomp),e||"undefined"==typeof global||(e=global.decomp)}catch(t){e=null}return e}}()},function(e,t){var n={};e.exports=n,n.create=function(e){var t={min:{x:0,y:0},max:{x:0,y:0}};return e&&n.update(t,e),t},n.update=function(e,t,n){e.min.x=1/0,e.max.x=-1/0,e.min.y=1/0,e.max.y=-1/0;for(var o=0;o<t.length;o++){var i=t[o];i.x>e.max.x&&(e.max.x=i.x),i.x<e.min.x&&(e.min.x=i.x),i.y>e.max.y&&(e.max.y=i.y),i.y<e.min.y&&(e.min.y=i.y)}n&&(n.x>0?e.max.x+=n.x:e.min.x+=n.x,n.y>0?e.max.y+=n.y:e.min.y+=n.y)},n.contains=function(e,t){return t.x>=e.min.x&&t.x<=e.max.x&&t.y>=e.min.y&&t.y<=e.max.y},n.overlaps=function(e,t){return e.min.x<=t.max.x&&e.max.x>=t.min.x&&e.max.y>=t.min.y&&e.min.y<=t.max.y},n.translate=function(e,t){e.min.x+=t.x,e.max.x+=t.x,e.min.y+=t.y,e.max.y+=t.y},n.shift=function(e,t){var n=e.max.x-e.min.x,o=e.max.y-e.min.y;e.min.x=t.x,e.max.x=t.x+n,e.min.y=t.y,e.max.y=t.y+o}},function(e,t){var n={};e.exports=n,n.create=function(e,t){return{x:e||0,y:t||0}},n.clone=function(e){return{x:e.x,y:e.y}},n.magnitude=function(e){return Math.sqrt(e.x*e.x+e.y*e.y)},n.magnitudeSquared=function(e){return e.x*e.x+e.y*e.y},n.rotate=function(e,t,n){var o=Math.cos(t),i=Math.sin(t);n||(n={});var r=e.x*o-e.y*i;return n.y=e.x*i+e.y*o,n.x=r,n},n.rotateAbout=function(e,t,n,o){var i=Math.cos(t),r=Math.sin(t);o||(o={});var a=n.x+((e.x-n.x)*i-(e.y-n.y)*r);return o.y=n.y+((e.x-n.x)*r+(e.y-n.y)*i),o.x=a,o},n.normalise=function(e){var t=n.magnitude(e);return 0===t?{x:0,y:0}:{x:e.x/t,y:e.y/t}},n.dot=function(e,t){return e.x*t.x+e.y*t.y},n.cross=function(e,t){return e.x*t.y-e.y*t.x},n.cross3=function(e,t,n){return(t.x-e.x)*(n.y-e.y)-(t.y-e.y)*(n.x-e.x)},n.add=function(e,t,n){return n||(n={}),n.x=e.x+t.x,n.y=e.y+t.y,n},n.sub=function(e,t,n){return n||(n={}),n.x=e.x-t.x,n.y=e.y-t.y,n},n.mult=function(e,t){return{x:e.x*t,y:e.y*t}},n.div=function(e,t){return{x:e.x/t,y:e.y/t}},n.perp=function(e,t){return{x:(t=!0===t?-1:1)*-e.y,y:t*e.x}},n.neg=function(e){return{x:-e.x,y:-e.y}},n.angle=function(e,t){return Math.atan2(t.y-e.y,t.x-e.x)},n._temp=[n.create(),n.create(),n.create(),n.create(),n.create(),n.create()]},function(e,t,n){var o={};e.exports=o;var i=n(2),r=n(0);o.create=function(e,t){for(var n=[],o=0;o<e.length;o++){var i=e[o],r={x:i.x,y:i.y,index:o,body:t,isInternal:!1};n.push(r)}return n},o.fromPath=function(e,t){var n=[];return e.replace(/L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/gi,(function(e,t,o){n.push({x:parseFloat(t),y:parseFloat(o)})})),o.create(n,t)},o.centre=function(e){for(var t,n,r,a=o.area(e,!0),s={x:0,y:0},l=0;l<e.length;l++)r=(l+1)%e.length,t=i.cross(e[l],e[r]),n=i.mult(i.add(e[l],e[r]),t),s=i.add(s,n);return i.div(s,6*a)},o.mean=function(e){for(var t={x:0,y:0},n=0;n<e.length;n++)t.x+=e[n].x,t.y+=e[n].y;return i.div(t,e.length)},o.area=function(e,t){for(var n=0,o=e.length-1,i=0;i<e.length;i++)n+=(e[o].x-e[i].x)*(e[o].y+e[i].y),o=i;return t?n/2:Math.abs(n)/2},o.inertia=function(e,t){for(var n,o,r=0,a=0,s=e,l=0;l<s.length;l++)o=(l+1)%s.length,r+=(n=Math.abs(i.cross(s[o],s[l])))*(i.dot(s[o],s[o])+i.dot(s[o],s[l])+i.dot(s[l],s[l])),a+=n;return t/6*(r/a)},o.translate=function(e,t,n){n=void 0!==n?n:1;var o,i=e.length,r=t.x*n,a=t.y*n;for(o=0;o<i;o++)e[o].x+=r,e[o].y+=a;return e},o.rotate=function(e,t,n){if(0!==t){var o,i,r,a,s=Math.cos(t),l=Math.sin(t),c=n.x,u=n.y,d=e.length;for(a=0;a<d;a++)i=(o=e[a]).x-c,r=o.y-u,o.x=c+(i*s-r*l),o.y=u+(i*l+r*s);return e}},o.contains=function(e,t){for(var n,o=t.x,i=t.y,r=e.length,a=e[r-1],s=0;s<r;s++){if(n=e[s],(o-a.x)*(n.y-a.y)+(i-a.y)*(a.x-n.x)>0)return!1;a=n}return!0},o.scale=function(e,t,n,r){if(1===t&&1===n)return e;var a,s;r=r||o.centre(e);for(var l=0;l<e.length;l++)a=e[l],s=i.sub(a,r),e[l].x=r.x+s.x*t,e[l].y=r.y+s.y*n;return e},o.chamfer=function(e,t,n,o,a){t="number"==typeof t?[t]:t||[8],n=void 0!==n?n:-1,o=o||2,a=a||14;for(var s=[],l=0;l<e.length;l++){var c=e[l-1>=0?l-1:e.length-1],u=e[l],d=e[(l+1)%e.length],p=t[l<t.length?l:t.length-1];if(0!==p){var f=i.normalise({x:u.y-c.y,y:c.x-u.x}),v=i.normalise({x:d.y-u.y,y:u.x-d.x}),m=Math.sqrt(2*Math.pow(p,2)),y=i.mult(r.clone(f),p),g=i.normalise(i.mult(i.add(f,v),.5)),x=i.sub(u,i.mult(g,m)),h=n;-1===n&&(h=1.75*Math.pow(p,.32)),(h=r.clamp(h,o,a))%2==1&&(h+=1);for(var b=Math.acos(i.dot(f,v))/h,S=0;S<h;S++)s.push(i.add(i.rotate(y,b*S),x))}else s.push(u)}return s},o.clockwiseSort=function(e){var t=o.mean(e);return e.sort((function(e,n){return i.angle(t,e)-i.angle(t,n)})),e},o.isConvex=function(e){var t,n,o,i,r=0,a=e.length;if(a<3)return null;for(t=0;t<a;t++)if(o=(t+2)%a,i=(e[n=(t+1)%a].x-e[t].x)*(e[o].y-e[n].y),(i-=(e[n].y-e[t].y)*(e[o].x-e[n].x))<0?r|=1:i>0&&(r|=2),3===r)return!1;return 0!==r||null},o.hull=function(e){var t,n,o=[],r=[];for((e=e.slice(0)).sort((function(e,t){var n=e.x-t.x;return 0!==n?n:e.y-t.y})),n=0;n<e.length;n+=1){for(t=e[n];r.length>=2&&i.cross3(r[r.length-2],r[r.length-1],t)<=0;)r.pop();r.push(t)}for(n=e.length-1;n>=0;n-=1){for(t=e[n];o.length>=2&&i.cross3(o[o.length-2],o[o.length-1],t)<=0;)o.pop();o.push(t)}return o.pop(),r.pop(),o.concat(r)}},function(e,t,n){var o={};e.exports=o;var i=n(3),r=n(2),a=n(7),s=n(0),l=n(1),c=n(11);!function(){o._timeCorrection=!0,o._inertiaScale=4,o._nextCollidingGroupId=1,o._nextNonCollidingGroupId=-1,o._nextCategory=1,o._baseDelta=1e3/60,o.create=function(t){var n={id:s.nextId(),type:"body",label:"Body",parts:[],plugin:{},angle:0,vertices:i.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"),position:{x:0,y:0},force:{x:0,y:0},torque:0,positionImpulse:{x:0,y:0},constraintImpulse:{x:0,y:0,angle:0},totalContacts:0,speed:0,angularSpeed:0,velocity:{x:0,y:0},angularVelocity:0,isSensor:!1,isStatic:!1,isSleeping:!1,motion:0,sleepThreshold:60,density:.001,restitution:0,friction:.1,frictionStatic:.5,frictionAir:.01,collisionFilter:{category:1,mask:4294967295,group:0},slop:.05,timeScale:1,render:{visible:!0,opacity:1,strokeStyle:null,fillStyle:null,lineWidth:null,sprite:{xScale:1,yScale:1,xOffset:0,yOffset:0}},events:null,bounds:null,chamfer:null,circleRadius:0,positionPrev:null,anglePrev:0,parent:null,axes:null,area:0,mass:0,inertia:0,deltaTime:1e3/60,_original:null},o=s.extend(n,t);return e(o,t),o},o.nextGroup=function(e){return e?o._nextNonCollidingGroupId--:o._nextCollidingGroupId++},o.nextCategory=function(){return o._nextCategory=o._nextCategory<<1,o._nextCategory};var e=function(e,t){t=t||{},o.set(e,{bounds:e.bounds||l.create(e.vertices),positionPrev:e.positionPrev||r.clone(e.position),anglePrev:e.anglePrev||e.angle,vertices:e.vertices,parts:e.parts||[e],isStatic:e.isStatic,isSleeping:e.isSleeping,parent:e.parent||e}),i.rotate(e.vertices,e.angle,e.position),c.rotate(e.axes,e.angle),l.update(e.bounds,e.vertices,e.velocity),o.set(e,{axes:t.axes||e.axes,area:t.area||e.area,mass:t.mass||e.mass,inertia:t.inertia||e.inertia});var n=e.isStatic?"#14151f":s.choose(["#f19648","#f5d259","#f55a3c","#063e7b","#ececd1"]),a=e.isStatic?"#555":"#ccc",u=e.isStatic&&null===e.render.fillStyle?1:0;e.render.fillStyle=e.render.fillStyle||n,e.render.strokeStyle=e.render.strokeStyle||a,e.render.lineWidth=e.render.lineWidth||u,e.render.sprite.xOffset+=-(e.bounds.min.x-e.position.x)/(e.bounds.max.x-e.bounds.min.x),e.render.sprite.yOffset+=-(e.bounds.min.y-e.position.y)/(e.bounds.max.y-e.bounds.min.y)};o.set=function(e,t,n){var i;for(i in"string"==typeof t&&(i=t,(t={})[i]=n),t)if(Object.prototype.hasOwnProperty.call(t,i))switch(n=t[i],i){case"isStatic":o.setStatic(e,n);break;case"isSleeping":a.set(e,n);break;case"mass":o.setMass(e,n);break;case"density":o.setDensity(e,n);break;case"inertia":o.setInertia(e,n);break;case"vertices":o.setVertices(e,n);break;case"position":o.setPosition(e,n);break;case"angle":o.setAngle(e,n);break;case"velocity":o.setVelocity(e,n);break;case"angularVelocity":o.setAngularVelocity(e,n);break;case"speed":o.setSpeed(e,n);break;case"angularSpeed":o.setAngularSpeed(e,n);break;case"parts":o.setParts(e,n);break;case"centre":o.setCentre(e,n);break;default:e[i]=n}},o.setStatic=function(e,t){for(var n=0;n<e.parts.length;n++){var o=e.parts[n];t?(o.isStatic||(o._original={restitution:o.restitution,friction:o.friction,mass:o.mass,inertia:o.inertia,density:o.density,inverseMass:o.inverseMass,inverseInertia:o.inverseInertia}),o.restitution=0,o.friction=1,o.mass=o.inertia=o.density=1/0,o.inverseMass=o.inverseInertia=0,o.positionPrev.x=o.position.x,o.positionPrev.y=o.position.y,o.anglePrev=o.angle,o.angularVelocity=0,o.speed=0,o.angularSpeed=0,o.motion=0):o._original&&(o.restitution=o._original.restitution,o.friction=o._original.friction,o.mass=o._original.mass,o.inertia=o._original.inertia,o.density=o._original.density,o.inverseMass=o._original.inverseMass,o.inverseInertia=o._original.inverseInertia,o._original=null),o.isStatic=t}},o.setMass=function(e,t){var n=e.inertia/(e.mass/6);e.inertia=n*(t/6),e.inverseInertia=1/e.inertia,e.mass=t,e.inverseMass=1/e.mass,e.density=e.mass/e.area},o.setDensity=function(e,t){o.setMass(e,t*e.area),e.density=t},o.setInertia=function(e,t){e.inertia=t,e.inverseInertia=1/e.inertia},o.setVertices=function(e,t){t[0].body===e?e.vertices=t:e.vertices=i.create(t,e),e.axes=c.fromVertices(e.vertices),e.area=i.area(e.vertices),o.setMass(e,e.density*e.area);var n=i.centre(e.vertices);i.translate(e.vertices,n,-1),o.setInertia(e,o._inertiaScale*i.inertia(e.vertices,e.mass)),i.translate(e.vertices,e.position),l.update(e.bounds,e.vertices,e.velocity)},o.setParts=function(e,t,n){var r;for(t=t.slice(0),e.parts.length=0,e.parts.push(e),e.parent=e,r=0;r<t.length;r++){var a=t[r];a!==e&&(a.parent=e,e.parts.push(a))}if(1!==e.parts.length){if(n=void 0===n||n){var s=[];for(r=0;r<t.length;r++)s=s.concat(t[r].vertices);i.clockwiseSort(s);var l=i.hull(s),c=i.centre(l);o.setVertices(e,l),i.translate(e.vertices,c)}var u=o._totalProperties(e);e.area=u.area,e.parent=e,e.position.x=u.centre.x,e.position.y=u.centre.y,e.positionPrev.x=u.centre.x,e.positionPrev.y=u.centre.y,o.setMass(e,u.mass),o.setInertia(e,u.inertia),o.setPosition(e,u.centre)}},o.setCentre=function(e,t,n){n?(e.positionPrev.x+=t.x,e.positionPrev.y+=t.y,e.position.x+=t.x,e.position.y+=t.y):(e.positionPrev.x=t.x-(e.position.x-e.positionPrev.x),e.positionPrev.y=t.y-(e.position.y-e.positionPrev.y),e.position.x=t.x,e.position.y=t.y)},o.setPosition=function(e,t,n){var o=r.sub(t,e.position);n?(e.positionPrev.x=e.position.x,e.positionPrev.y=e.position.y,e.velocity.x=o.x,e.velocity.y=o.y,e.speed=r.magnitude(o)):(e.positionPrev.x+=o.x,e.positionPrev.y+=o.y);for(var a=0;a<e.parts.length;a++){var s=e.parts[a];s.position.x+=o.x,s.position.y+=o.y,i.translate(s.vertices,o),l.update(s.bounds,s.vertices,e.velocity)}},o.setAngle=function(e,t,n){var o=t-e.angle;n?(e.anglePrev=e.angle,e.angularVelocity=o,e.angularSpeed=Math.abs(o)):e.anglePrev+=o;for(var a=0;a<e.parts.length;a++){var s=e.parts[a];s.angle+=o,i.rotate(s.vertices,o,e.position),c.rotate(s.axes,o),l.update(s.bounds,s.vertices,e.velocity),a>0&&r.rotateAbout(s.position,o,e.position,s.position)}},o.setVelocity=function(e,t){var n=e.deltaTime/o._baseDelta;e.positionPrev.x=e.position.x-t.x*n,e.positionPrev.y=e.position.y-t.y*n,e.velocity.x=(e.position.x-e.positionPrev.x)/n,e.velocity.y=(e.position.y-e.positionPrev.y)/n,e.speed=r.magnitude(e.velocity)},o.getVelocity=function(e){var t=o._baseDelta/e.deltaTime;return{x:(e.position.x-e.positionPrev.x)*t,y:(e.position.y-e.positionPrev.y)*t}},o.getSpeed=function(e){return r.magnitude(o.getVelocity(e))},o.setSpeed=function(e,t){o.setVelocity(e,r.mult(r.normalise(o.getVelocity(e)),t))},o.setAngularVelocity=function(e,t){var n=e.deltaTime/o._baseDelta;e.anglePrev=e.angle-t*n,e.angularVelocity=(e.angle-e.anglePrev)/n,e.angularSpeed=Math.abs(e.angularVelocity)},o.getAngularVelocity=function(e){return(e.angle-e.anglePrev)*o._baseDelta/e.deltaTime},o.getAngularSpeed=function(e){return Math.abs(o.getAngularVelocity(e))},o.setAngularSpeed=function(e,t){o.setAngularVelocity(e,s.sign(o.getAngularVelocity(e))*t)},o.translate=function(e,t,n){o.setPosition(e,r.add(e.position,t),n)},o.rotate=function(e,t,n,i){if(n){var r=Math.cos(t),a=Math.sin(t),s=e.position.x-n.x,l=e.position.y-n.y;o.setPosition(e,{x:n.x+(s*r-l*a),y:n.y+(s*a+l*r)},i),o.setAngle(e,e.angle+t,i)}else o.setAngle(e,e.angle+t,i)},o.scale=function(e,t,n,r){var a=0,s=0;r=r||e.position;for(var u=0;u<e.parts.length;u++){var d=e.parts[u];i.scale(d.vertices,t,n,r),d.axes=c.fromVertices(d.vertices),d.area=i.area(d.vertices),o.setMass(d,e.density*d.area),i.translate(d.vertices,{x:-d.position.x,y:-d.position.y}),o.setInertia(d,o._inertiaScale*i.inertia(d.vertices,d.mass)),i.translate(d.vertices,{x:d.position.x,y:d.position.y}),u>0&&(a+=d.area,s+=d.inertia),d.position.x=r.x+(d.position.x-r.x)*t,d.position.y=r.y+(d.position.y-r.y)*n,l.update(d.bounds,d.vertices,e.velocity)}e.parts.length>1&&(e.area=a,e.isStatic||(o.setMass(e,e.density*a),o.setInertia(e,s))),e.circleRadius&&(t===n?e.circleRadius*=t:e.circleRadius=null)},o.update=function(e,t){var n=(t=(void 0!==t?t:1e3/60)*e.timeScale)*t,a=o._timeCorrection?t/(e.deltaTime||t):1,u=1-e.frictionAir*(t/s._baseDelta),d=(e.position.x-e.positionPrev.x)*a,p=(e.position.y-e.positionPrev.y)*a;e.velocity.x=d*u+e.force.x/e.mass*n,e.velocity.y=p*u+e.force.y/e.mass*n,e.positionPrev.x=e.position.x,e.positionPrev.y=e.position.y,e.position.x+=e.velocity.x,e.position.y+=e.velocity.y,e.deltaTime=t,e.angularVelocity=(e.angle-e.anglePrev)*u*a+e.torque/e.inertia*n,e.anglePrev=e.angle,e.angle+=e.angularVelocity;for(var f=0;f<e.parts.length;f++){var v=e.parts[f];i.translate(v.vertices,e.velocity),f>0&&(v.position.x+=e.velocity.x,v.position.y+=e.velocity.y),0!==e.angularVelocity&&(i.rotate(v.vertices,e.angularVelocity,e.position),c.rotate(v.axes,e.angularVelocity),f>0&&r.rotateAbout(v.position,e.angularVelocity,e.position,v.position)),l.update(v.bounds,v.vertices,e.velocity)}},o.updateVelocities=function(e){var t=o._baseDelta/e.deltaTime,n=e.velocity;n.x=(e.position.x-e.positionPrev.x)*t,n.y=(e.position.y-e.positionPrev.y)*t,e.speed=Math.sqrt(n.x*n.x+n.y*n.y),e.angularVelocity=(e.angle-e.anglePrev)*t,e.angularSpeed=Math.abs(e.angularVelocity)},o.applyForce=function(e,t,n){var o=t.x-e.position.x,i=t.y-e.position.y;e.force.x+=n.x,e.force.y+=n.y,e.torque+=o*n.y-i*n.x},o._totalProperties=function(e){for(var t={mass:0,area:0,inertia:0,centre:{x:0,y:0}},n=1===e.parts.length?0:1;n<e.parts.length;n++){var o=e.parts[n],i=o.mass!==1/0?o.mass:1;t.mass+=i,t.area+=o.area,t.inertia+=o.inertia,t.centre=r.add(t.centre,r.mult(o.position,i))}return t.centre=r.div(t.centre,t.mass),t}}()},function(e,t,n){var o={};e.exports=o;var i=n(0);o.on=function(e,t,n){for(var o,i=t.split(" "),r=0;r<i.length;r++)o=i[r],e.events=e.events||{},e.events[o]=e.events[o]||[],e.events[o].push(n);return n},o.off=function(e,t,n){if(t){"function"==typeof t&&(n=t,t=i.keys(e.events).join(" "));for(var o=t.split(" "),r=0;r<o.length;r++){var a=e.events[o[r]],s=[];if(n&&a)for(var l=0;l<a.length;l++)a[l]!==n&&s.push(a[l]);e.events[o[r]]=s}}else e.events={}},o.trigger=function(e,t,n){var o,r,a,s,l=e.events;if(l&&i.keys(l).length>0){n||(n={}),o=t.split(" ");for(var c=0;c<o.length;c++)if(a=l[r=o[c]]){(s=i.clone(n,!1)).name=r,s.source=e;for(var u=0;u<a.length;u++)a[u].apply(e,[s])}}}},function(e,t,n){var o={};e.exports=o;var i=n(5),r=n(0),a=n(1),s=n(4);o.create=function(e){return r.extend({id:r.nextId(),type:"composite",parent:null,isModified:!1,bodies:[],constraints:[],composites:[],label:"Composite",plugin:{},cache:{allBodies:null,allConstraints:null,allComposites:null}},e)},o.setModified=function(e,t,n,i){if(e.isModified=t,t&&e.cache&&(e.cache.allBodies=null,e.cache.allConstraints=null,e.cache.allComposites=null),n&&e.parent&&o.setModified(e.parent,t,n,i),i)for(var r=0;r<e.composites.length;r++){var a=e.composites[r];o.setModified(a,t,n,i)}},o.add=function(e,t){var n=[].concat(t);i.trigger(e,"beforeAdd",{object:t});for(var a=0;a<n.length;a++){var s=n[a];switch(s.type){case"body":if(s.parent!==s){r.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)");break}o.addBody(e,s);break;case"constraint":o.addConstraint(e,s);break;case"composite":o.addComposite(e,s);break;case"mouseConstraint":o.addConstraint(e,s.constraint)}}return i.trigger(e,"afterAdd",{object:t}),e},o.remove=function(e,t,n){var r=[].concat(t);i.trigger(e,"beforeRemove",{object:t});for(var a=0;a<r.length;a++){var s=r[a];switch(s.type){case"body":o.removeBody(e,s,n);break;case"constraint":o.removeConstraint(e,s,n);break;case"composite":o.removeComposite(e,s,n);break;case"mouseConstraint":o.removeConstraint(e,s.constraint)}}return i.trigger(e,"afterRemove",{object:t}),e},o.addComposite=function(e,t){return e.composites.push(t),t.parent=e,o.setModified(e,!0,!0,!1),e},o.removeComposite=function(e,t,n){var i=r.indexOf(e.composites,t);if(-1!==i){var a=o.allBodies(t);o.removeCompositeAt(e,i);for(var s=0;s<a.length;s++)a[s].sleepCounter=0}if(n)for(s=0;s<e.composites.length;s++)o.removeComposite(e.composites[s],t,!0);return e},o.removeCompositeAt=function(e,t){return e.composites.splice(t,1),o.setModified(e,!0,!0,!1),e},o.addBody=function(e,t){return e.bodies.push(t),o.setModified(e,!0,!0,!1),e},o.removeBody=function(e,t,n){var i=r.indexOf(e.bodies,t);if(-1!==i&&(o.removeBodyAt(e,i),t.sleepCounter=0),n)for(var a=0;a<e.composites.length;a++)o.removeBody(e.composites[a],t,!0);return e},o.removeBodyAt=function(e,t){return e.bodies.splice(t,1),o.setModified(e,!0,!0,!1),e},o.addConstraint=function(e,t){return e.constraints.push(t),o.setModified(e,!0,!0,!1),e},o.removeConstraint=function(e,t,n){var i=r.indexOf(e.constraints,t);if(-1!==i&&o.removeConstraintAt(e,i),n)for(var a=0;a<e.composites.length;a++)o.removeConstraint(e.composites[a],t,!0);return e},o.removeConstraintAt=function(e,t){return e.constraints.splice(t,1),o.setModified(e,!0,!0,!1),e},o.clear=function(e,t,n){if(n)for(var i=0;i<e.composites.length;i++)o.clear(e.composites[i],t,!0);return t?e.bodies=e.bodies.filter((function(e){return e.isStatic})):e.bodies.length=0,e.constraints.length=0,e.composites.length=0,o.setModified(e,!0,!0,!1),e},o.allBodies=function(e){if(e.cache&&e.cache.allBodies)return e.cache.allBodies;for(var t=[].concat(e.bodies),n=0;n<e.composites.length;n++)t=t.concat(o.allBodies(e.composites[n]));return e.cache&&(e.cache.allBodies=t),t},o.allConstraints=function(e){if(e.cache&&e.cache.allConstraints)return e.cache.allConstraints;for(var t=[].concat(e.constraints),n=0;n<e.composites.length;n++)t=t.concat(o.allConstraints(e.composites[n]));return e.cache&&(e.cache.allConstraints=t),t},o.allComposites=function(e){if(e.cache&&e.cache.allComposites)return e.cache.allComposites;for(var t=[].concat(e.composites),n=0;n<e.composites.length;n++)t=t.concat(o.allComposites(e.composites[n]));return e.cache&&(e.cache.allComposites=t),t},o.get=function(e,t,n){var i,r;switch(n){case"body":i=o.allBodies(e);break;case"constraint":i=o.allConstraints(e);break;case"composite":i=o.allComposites(e).concat(e)}return i?0===(r=i.filter((function(e){return e.id.toString()===t.toString()}))).length?null:r[0]:null},o.move=function(e,t,n){return o.remove(e,t),o.add(n,t),e},o.rebase=function(e){for(var t=o.allBodies(e).concat(o.allConstraints(e)).concat(o.allComposites(e)),n=0;n<t.length;n++)t[n].id=r.nextId();return e},o.translate=function(e,t,n){for(var i=n?o.allBodies(e):e.bodies,r=0;r<i.length;r++)s.translate(i[r],t);return e},o.rotate=function(e,t,n,i){for(var r=Math.cos(t),a=Math.sin(t),l=i?o.allBodies(e):e.bodies,c=0;c<l.length;c++){var u=l[c],d=u.position.x-n.x,p=u.position.y-n.y;s.setPosition(u,{x:n.x+(d*r-p*a),y:n.y+(d*a+p*r)}),s.rotate(u,t)}return e},o.scale=function(e,t,n,i,r){for(var a=r?o.allBodies(e):e.bodies,l=0;l<a.length;l++){var c=a[l],u=c.position.x-i.x,d=c.position.y-i.y;s.setPosition(c,{x:i.x+u*t,y:i.y+d*n}),s.scale(c,t,n)}return e},o.bounds=function(e){for(var t=o.allBodies(e),n=[],i=0;i<t.length;i+=1){var r=t[i];n.push(r.bounds.min,r.bounds.max)}return a.create(n)}},function(e,t,n){var o={};e.exports=o;var i=n(4),r=n(5),a=n(0);o._motionWakeThreshold=.18,o._motionSleepThreshold=.08,o._minBias=.9,o.update=function(e,t){for(var n=t/a._baseDelta,r=o._motionSleepThreshold,s=0;s<e.length;s++){var l=e[s],c=i.getSpeed(l),u=i.getAngularSpeed(l),d=c*c+u*u;if(0===l.force.x&&0===l.force.y){var p=Math.min(l.motion,d),f=Math.max(l.motion,d);l.motion=o._minBias*p+(1-o._minBias)*f,l.sleepThreshold>0&&l.motion<r?(l.sleepCounter+=1,l.sleepCounter>=l.sleepThreshold/n&&o.set(l,!0)):l.sleepCounter>0&&(l.sleepCounter-=1)}else o.set(l,!1)}},o.afterCollisions=function(e){for(var t=o._motionSleepThreshold,n=0;n<e.length;n++){var i=e[n];if(i.isActive){var r=i.collision,a=r.bodyA.parent,s=r.bodyB.parent;if(!(a.isSleeping&&s.isSleeping||a.isStatic||s.isStatic)&&(a.isSleeping||s.isSleeping)){var l=a.isSleeping&&!a.isStatic?a:s,c=l===a?s:a;!l.isStatic&&c.motion>t&&o.set(l,!1)}}}},o.set=function(e,t){var n=e.isSleeping;t?(e.isSleeping=!0,e.sleepCounter=e.sleepThreshold,e.positionImpulse.x=0,e.positionImpulse.y=0,e.positionPrev.x=e.position.x,e.positionPrev.y=e.position.y,e.anglePrev=e.angle,e.speed=0,e.angularSpeed=0,e.motion=0,n||r.trigger(e,"sleepStart")):(e.isSleeping=!1,e.sleepCounter=0,n&&r.trigger(e,"sleepEnd"))}},function(e,t,n){var o={};e.exports=o;var i,r,a,s=n(3),l=n(9);i=[],r={overlap:0,axis:null},a={overlap:0,axis:null},o.create=function(e,t){return{pair:null,collided:!1,bodyA:e,bodyB:t,parentA:e.parent,parentB:t.parent,depth:0,normal:{x:0,y:0},tangent:{x:0,y:0},penetration:{x:0,y:0},supports:[null,null],supportCount:0}},o.collides=function(e,t,n){if(o._overlapAxes(r,e.vertices,t.vertices,e.axes),r.overlap<=0)return null;if(o._overlapAxes(a,t.vertices,e.vertices,t.axes),a.overlap<=0)return null;var i,c,u=n&&n.table[l.id(e,t)];u?i=u.collision:((i=o.create(e,t)).collided=!0,i.bodyA=e.id<t.id?e:t,i.bodyB=e.id<t.id?t:e,i.parentA=i.bodyA.parent,i.parentB=i.bodyB.parent),e=i.bodyA,t=i.bodyB,c=r.overlap<a.overlap?r:a;var d=i.normal,p=i.tangent,f=i.penetration,v=i.supports,m=c.overlap,y=c.axis,g=y.x,x=y.y;g*(t.position.x-e.position.x)+x*(t.position.y-e.position.y)>=0&&(g=-g,x=-x),d.x=g,d.y=x,p.x=-x,p.y=g,f.x=g*m,f.y=x*m,i.depth=m;var h=o._findSupports(e,t,d,1),b=0;if(s.contains(e.vertices,h[0])&&(v[b++]=h[0]),s.contains(e.vertices,h[1])&&(v[b++]=h[1]),b<2){var S=o._findSupports(t,e,d,-1);s.contains(t.vertices,S[0])&&(v[b++]=S[0]),b<2&&s.contains(t.vertices,S[1])&&(v[b++]=S[1])}return 0===b&&(v[b++]=h[0]),i.supportCount=b,i},o._overlapAxes=function(e,t,n,o){var i,r,a,s,l,c,u=t.length,d=n.length,p=t[0].x,f=t[0].y,v=n[0].x,m=n[0].y,y=o.length,g=Number.MAX_VALUE,x=0;for(l=0;l<y;l++){var h=o[l],b=h.x,S=h.y,w=p*b+f*S,A=v*b+m*S,P=w,B=A;for(c=1;c<u;c+=1)(s=t[c].x*b+t[c].y*S)>P?P=s:s<w&&(w=s);for(c=1;c<d;c+=1)(s=n[c].x*b+n[c].y*S)>B?B=s:s<A&&(A=s);if((i=(r=P-A)<(a=B-w)?r:a)<g&&(g=i,x=l,i<=0))break}e.axis=o[x],e.overlap=g},o._findSupports=function(e,t,n,o){var r,a,s,l=t.vertices,c=l.length,u=e.position.x,d=e.position.y,p=n.x*o,f=n.y*o,v=l[0],m=v,y=p*(u-m.x)+f*(d-m.y);for(s=1;s<c;s+=1)(a=p*(u-(m=l[s]).x)+f*(d-m.y))<y&&(y=a,v=m);return y=p*(u-(r=l[(c+v.index-1)%c]).x)+f*(d-r.y),p*(u-(m=l[(v.index+1)%c]).x)+f*(d-m.y)<y?(i[0]=v,i[1]=m,i):(i[0]=v,i[1]=r,i)}},function(e,t,n){var o={};e.exports=o;var i=n(16);o.create=function(e,t){var n=e.bodyA,r=e.bodyB,a={id:o.id(n,r),bodyA:n,bodyB:r,collision:e,contacts:[i.create(),i.create()],contactCount:0,separation:0,isActive:!0,isSensor:n.isSensor||r.isSensor,timeCreated:t,timeUpdated:t,inverseMass:0,friction:0,frictionStatic:0,restitution:0,slop:0};return o.update(a,e,t),a},o.update=function(e,t,n){var o=t.supports,i=t.supportCount,r=e.contacts,a=t.parentA,s=t.parentB;e.isActive=!0,e.timeUpdated=n,e.collision=t,e.separation=t.depth,e.inverseMass=a.inverseMass+s.inverseMass,e.friction=a.friction<s.friction?a.friction:s.friction,e.frictionStatic=a.frictionStatic>s.frictionStatic?a.frictionStatic:s.frictionStatic,e.restitution=a.restitution>s.restitution?a.restitution:s.restitution,e.slop=a.slop>s.slop?a.slop:s.slop,e.contactCount=i,t.pair=e;var l=o[0],c=r[0],u=o[1],d=r[1];d.vertex!==l&&c.vertex!==u||(r[1]=c,r[0]=c=d,d=r[1]),c.vertex=l,d.vertex=u},o.setActive=function(e,t,n){t?(e.isActive=!0,e.timeUpdated=n):(e.isActive=!1,e.contactCount=0)},o.id=function(e,t){return e.id<t.id?e.id.toString(36)+":"+t.id.toString(36):t.id.toString(36)+":"+e.id.toString(36)}},function(e,t,n){var o={};e.exports=o;var i=n(3),r=n(2),a=n(7),s=n(1),l=n(11),c=n(0);o._warming=.4,o._torqueDampen=1,o._minLength=1e-6,o.create=function(e){var t=e;t.bodyA&&!t.pointA&&(t.pointA={x:0,y:0}),t.bodyB&&!t.pointB&&(t.pointB={x:0,y:0});var n=t.bodyA?r.add(t.bodyA.position,t.pointA):t.pointA,o=t.bodyB?r.add(t.bodyB.position,t.pointB):t.pointB,i=r.magnitude(r.sub(n,o));t.length=void 0!==t.length?t.length:i,t.id=t.id||c.nextId(),t.label=t.label||"Constraint",t.type="constraint",t.stiffness=t.stiffness||(t.length>0?1:.7),t.damping=t.damping||0,t.angularStiffness=t.angularStiffness||0,t.angleA=t.bodyA?t.bodyA.angle:t.angleA,t.angleB=t.bodyB?t.bodyB.angle:t.angleB,t.plugin={};var a={visible:!0,lineWidth:2,strokeStyle:"#ffffff",type:"line",anchors:!0};return 0===t.length&&t.stiffness>.1?(a.type="pin",a.anchors=!1):t.stiffness<.9&&(a.type="spring"),t.render=c.extend(a,t.render),t},o.preSolveAll=function(e){for(var t=0;t<e.length;t+=1){var n=e[t],o=n.constraintImpulse;n.isStatic||0===o.x&&0===o.y&&0===o.angle||(n.position.x+=o.x,n.position.y+=o.y,n.angle+=o.angle)}},o.solveAll=function(e,t){for(var n=c.clamp(t/c._baseDelta,0,1),i=0;i<e.length;i+=1){var r=e[i],a=!r.bodyA||r.bodyA&&r.bodyA.isStatic,s=!r.bodyB||r.bodyB&&r.bodyB.isStatic;(a||s)&&o.solve(e[i],n)}for(i=0;i<e.length;i+=1)a=!(r=e[i]).bodyA||r.bodyA&&r.bodyA.isStatic,s=!r.bodyB||r.bodyB&&r.bodyB.isStatic,a||s||o.solve(e[i],n)},o.solve=function(e,t){var n=e.bodyA,i=e.bodyB,a=e.pointA,s=e.pointB;if(n||i){n&&!n.isStatic&&(r.rotate(a,n.angle-e.angleA,a),e.angleA=n.angle),i&&!i.isStatic&&(r.rotate(s,i.angle-e.angleB,s),e.angleB=i.angle);var l=a,c=s;if(n&&(l=r.add(n.position,a)),i&&(c=r.add(i.position,s)),l&&c){var u=r.sub(l,c),d=r.magnitude(u);d<o._minLength&&(d=o._minLength);var p,f,v,m,y,g=(d-e.length)/d,x=e.stiffness>=1||0===e.length?e.stiffness*t:e.stiffness*t*t,h=e.damping*t,b=r.mult(u,g*x),S=(n?n.inverseMass:0)+(i?i.inverseMass:0),w=S+((n?n.inverseInertia:0)+(i?i.inverseInertia:0));if(h>0){var A=r.create();v=r.div(u,d),y=r.sub(i&&r.sub(i.position,i.positionPrev)||A,n&&r.sub(n.position,n.positionPrev)||A),m=r.dot(v,y)}n&&!n.isStatic&&(f=n.inverseMass/S,n.constraintImpulse.x-=b.x*f,n.constraintImpulse.y-=b.y*f,n.position.x-=b.x*f,n.position.y-=b.y*f,h>0&&(n.positionPrev.x-=h*v.x*m*f,n.positionPrev.y-=h*v.y*m*f),p=r.cross(a,b)/w*o._torqueDampen*n.inverseInertia*(1-e.angularStiffness),n.constraintImpulse.angle-=p,n.angle-=p),i&&!i.isStatic&&(f=i.inverseMass/S,i.constraintImpulse.x+=b.x*f,i.constraintImpulse.y+=b.y*f,i.position.x+=b.x*f,i.position.y+=b.y*f,h>0&&(i.positionPrev.x+=h*v.x*m*f,i.positionPrev.y+=h*v.y*m*f),p=r.cross(s,b)/w*o._torqueDampen*i.inverseInertia*(1-e.angularStiffness),i.constraintImpulse.angle+=p,i.angle+=p)}}},o.postSolveAll=function(e){for(var t=0;t<e.length;t++){var n=e[t],c=n.constraintImpulse;if(!(n.isStatic||0===c.x&&0===c.y&&0===c.angle)){a.set(n,!1);for(var u=0;u<n.parts.length;u++){var d=n.parts[u];i.translate(d.vertices,c),u>0&&(d.position.x+=c.x,d.position.y+=c.y),0!==c.angle&&(i.rotate(d.vertices,c.angle,n.position),l.rotate(d.axes,c.angle),u>0&&r.rotateAbout(d.position,c.angle,n.position,d.position)),s.update(d.bounds,d.vertices,n.velocity)}c.angle*=o._warming,c.x*=o._warming,c.y*=o._warming}}},o.pointAWorld=function(e){return{x:(e.bodyA?e.bodyA.position.x:0)+(e.pointA?e.pointA.x:0),y:(e.bodyA?e.bodyA.position.y:0)+(e.pointA?e.pointA.y:0)}},o.pointBWorld=function(e){return{x:(e.bodyB?e.bodyB.position.x:0)+(e.pointB?e.pointB.x:0),y:(e.bodyB?e.bodyB.position.y:0)+(e.pointB?e.pointB.y:0)}},o.currentLength=function(e){var t=(e.bodyA?e.bodyA.position.x:0)+(e.pointA?e.pointA.x:0),n=(e.bodyA?e.bodyA.position.y:0)+(e.pointA?e.pointA.y:0),o=t-((e.bodyB?e.bodyB.position.x:0)+(e.pointB?e.pointB.x:0)),i=n-((e.bodyB?e.bodyB.position.y:0)+(e.pointB?e.pointB.y:0));return Math.sqrt(o*o+i*i)}},function(e,t,n){var o={};e.exports=o;var i=n(2),r=n(0);o.fromVertices=function(e){for(var t={},n=0;n<e.length;n++){var o=(n+1)%e.length,a=i.normalise({x:e[o].y-e[n].y,y:e[n].x-e[o].x}),s=0===a.y?1/0:a.x/a.y;t[s=s.toFixed(3).toString()]=a}return r.values(t)},o.rotate=function(e,t){if(0!==t)for(var n=Math.cos(t),o=Math.sin(t),i=0;i<e.length;i++){var r,a=e[i];r=a.x*n-a.y*o,a.y=a.x*o+a.y*n,a.x=r}}},function(e,t,n){var o={};e.exports=o;var i=n(3),r=n(0),a=n(4),s=n(1),l=n(2);o.rectangle=function(e,t,n,o,s){s=s||{};var l={label:"Rectangle Body",position:{x:e,y:t},vertices:i.fromPath("L 0 0 L "+n+" 0 L "+n+" "+o+" L 0 "+o)};if(s.chamfer){var c=s.chamfer;l.vertices=i.chamfer(l.vertices,c.radius,c.quality,c.qualityMin,c.qualityMax),delete s.chamfer}return a.create(r.extend({},l,s))},o.trapezoid=function(e,t,n,o,s,l){l=l||{},s>=1&&r.warn("Bodies.trapezoid: slope parameter must be < 1.");var c,u=n*(s*=.5),d=u+(1-2*s)*n,p=d+u;c=s<.5?"L 0 0 L "+u+" "+-o+" L "+d+" "+-o+" L "+p+" 0":"L 0 0 L "+d+" "+-o+" L "+p+" 0";var f={label:"Trapezoid Body",position:{x:e,y:t},vertices:i.fromPath(c)};if(l.chamfer){var v=l.chamfer;f.vertices=i.chamfer(f.vertices,v.radius,v.quality,v.qualityMin,v.qualityMax),delete l.chamfer}return a.create(r.extend({},f,l))},o.circle=function(e,t,n,i,a){i=i||{};var s={label:"Circle Body",circleRadius:n};a=a||25;var l=Math.ceil(Math.max(10,Math.min(a,n)));return l%2==1&&(l+=1),o.polygon(e,t,l,n,r.extend({},s,i))},o.polygon=function(e,t,n,s,l){if(l=l||{},n<3)return o.circle(e,t,s,l);for(var c=2*Math.PI/n,u="",d=.5*c,p=0;p<n;p+=1){var f=d+p*c,v=Math.cos(f)*s,m=Math.sin(f)*s;u+="L "+v.toFixed(3)+" "+m.toFixed(3)+" "}var y={label:"Polygon Body",position:{x:e,y:t},vertices:i.fromPath(u)};if(l.chamfer){var g=l.chamfer;y.vertices=i.chamfer(y.vertices,g.radius,g.quality,g.qualityMin,g.qualityMax),delete l.chamfer}return a.create(r.extend({},y,l))},o.fromVertices=function(e,t,n,o,c,u,d,p){var f,v,m,y,g,x,h,b,S,w,A=r.getDecomp();for(f=Boolean(A&&A.quickDecomp),o=o||{},m=[],c=void 0!==c&&c,u=void 0!==u?u:.01,d=void 0!==d?d:10,p=void 0!==p?p:.01,r.isArray(n[0])||(n=[n]),S=0;S<n.length;S+=1)if(g=n[S],!(y=i.isConvex(g))&&!f&&r.warnOnce("Bodies.fromVertices: Install the 'poly-decomp' library and use Common.setDecomp or provide 'decomp' as a global to decompose concave vertices."),y||!f)g=y?i.clockwiseSort(g):i.hull(g),m.push({position:{x:e,y:t},vertices:g});else{var P=g.map((function(e){return[e.x,e.y]}));A.makeCCW(P),!1!==u&&A.removeCollinearPoints(P,u),!1!==p&&A.removeDuplicatePoints&&A.removeDuplicatePoints(P,p);var B=A.quickDecomp(P);for(x=0;x<B.length;x++){var M=B[x].map((function(e){return{x:e[0],y:e[1]}}));d>0&&i.area(M)<d||m.push({position:i.centre(M),vertices:M})}}for(x=0;x<m.length;x++)m[x]=a.create(r.extend(m[x],o));if(c)for(x=0;x<m.length;x++){var _=m[x];for(h=x+1;h<m.length;h++){var C=m[h];if(s.overlaps(_.bounds,C.bounds)){var k=_.vertices,I=C.vertices;for(b=0;b<_.vertices.length;b++)for(w=0;w<C.vertices.length;w++){var T=l.magnitudeSquared(l.sub(k[(b+1)%k.length],I[w])),R=l.magnitudeSquared(l.sub(k[b],I[(w+1)%I.length]));T<5&&R<5&&(k[b].isInternal=!0,I[w].isInternal=!0)}}}}return m.length>1?(v=a.create(r.extend({parts:m.slice(0)},o)),a.setPosition(v,{x:e,y:t}),v):m[0]}},function(e,t,n){var o={};e.exports=o;var i=n(0),r=n(8);o.create=function(e){return i.extend({bodies:[],collisions:[],pairs:null},e)},o.setBodies=function(e,t){e.bodies=t.slice(0)},o.clear=function(e){e.bodies=[],e.collisions=[]},o.collisions=function(e){var t,n,i=e.pairs,a=e.bodies,s=a.length,l=o.canCollide,c=r.collides,u=e.collisions,d=0;for(a.sort(o._compareBoundsX),t=0;t<s;t++){var p=a[t],f=p.bounds,v=p.bounds.max.x,m=p.bounds.max.y,y=p.bounds.min.y,g=p.isStatic||p.isSleeping,x=p.parts.length,h=1===x;for(n=t+1;n<s;n++){var b=a[n];if((C=b.bounds).min.x>v)break;if(!(m<C.min.y||y>C.max.y)&&(!g||!b.isStatic&&!b.isSleeping)&&l(p.collisionFilter,b.collisionFilter)){var S=b.parts.length;if(h&&1===S)(M=c(p,b,i))&&(u[d++]=M);else for(var w=S>1?1:0,A=x>1?1:0;A<x;A++)for(var P=p.parts[A],B=(f=P.bounds,w);B<S;B++){var M,_=b.parts[B],C=_.bounds;f.min.x>C.max.x||f.max.x<C.min.x||f.max.y<C.min.y||f.min.y>C.max.y||(M=c(P,_,i))&&(u[d++]=M)}}}}return u.length!==d&&(u.length=d),u},o.canCollide=function(e,t){return e.group===t.group&&0!==e.group?e.group>0:0!=(e.mask&t.category)&&0!=(t.mask&e.category)},o._compareBoundsX=function(e,t){return e.bounds.min.x-t.bounds.min.x}},function(e,t,n){var o={};e.exports=o;var i=n(0);o.create=function(e){var t={};return e||i.log("Mouse.create: element was undefined, defaulting to document.body","warn"),t.element=e||document.body,t.absolute={x:0,y:0},t.position={x:0,y:0},t.mousedownPosition={x:0,y:0},t.mouseupPosition={x:0,y:0},t.offset={x:0,y:0},t.scale={x:1,y:1},t.wheelDelta=0,t.button=-1,t.pixelRatio=parseInt(t.element.getAttribute("data-pixel-ratio"),10)||1,t.sourceEvents={mousemove:null,mousedown:null,mouseup:null,mousewheel:null},t.mousemove=function(e){var n=o._getRelativeMousePosition(e,t.element,t.pixelRatio);e.changedTouches&&(t.button=0,e.preventDefault()),t.absolute.x=n.x,t.absolute.y=n.y,t.position.x=t.absolute.x*t.scale.x+t.offset.x,t.position.y=t.absolute.y*t.scale.y+t.offset.y,t.sourceEvents.mousemove=e},t.mousedown=function(e){var n=o._getRelativeMousePosition(e,t.element,t.pixelRatio);e.changedTouches?(t.button=0,e.preventDefault()):t.button=e.button,t.absolute.x=n.x,t.absolute.y=n.y,t.position.x=t.absolute.x*t.scale.x+t.offset.x,t.position.y=t.absolute.y*t.scale.y+t.offset.y,t.mousedownPosition.x=t.position.x,t.mousedownPosition.y=t.position.y,t.sourceEvents.mousedown=e},t.mouseup=function(e){var n=o._getRelativeMousePosition(e,t.element,t.pixelRatio);e.changedTouches&&e.preventDefault(),t.button=-1,t.absolute.x=n.x,t.absolute.y=n.y,t.position.x=t.absolute.x*t.scale.x+t.offset.x,t.position.y=t.absolute.y*t.scale.y+t.offset.y,t.mouseupPosition.x=t.position.x,t.mouseupPosition.y=t.position.y,t.sourceEvents.mouseup=e},t.mousewheel=function(e){t.wheelDelta=Math.max(-1,Math.min(1,e.wheelDelta||-e.detail)),e.preventDefault(),t.sourceEvents.mousewheel=e},o.setElement(t,t.element),t},o.setElement=function(e,t){e.element=t,t.addEventListener("mousemove",e.mousemove,{passive:!0}),t.addEventListener("mousedown",e.mousedown,{passive:!0}),t.addEventListener("mouseup",e.mouseup,{passive:!0}),t.addEventListener("wheel",e.mousewheel,{passive:!1}),t.addEventListener("touchmove",e.mousemove,{passive:!1}),t.addEventListener("touchstart",e.mousedown,{passive:!1}),t.addEventListener("touchend",e.mouseup,{passive:!1})},o.clearSourceEvents=function(e){e.sourceEvents.mousemove=null,e.sourceEvents.mousedown=null,e.sourceEvents.mouseup=null,e.sourceEvents.mousewheel=null,e.wheelDelta=0},o.setOffset=function(e,t){e.offset.x=t.x,e.offset.y=t.y,e.position.x=e.absolute.x*e.scale.x+e.offset.x,e.position.y=e.absolute.y*e.scale.y+e.offset.y},o.setScale=function(e,t){e.scale.x=t.x,e.scale.y=t.y,e.position.x=e.absolute.x*e.scale.x+e.offset.x,e.position.y=e.absolute.y*e.scale.y+e.offset.y},o._getRelativeMousePosition=function(e,t,n){var o,i,r=t.getBoundingClientRect(),a=document.documentElement||document.body.parentNode||document.body,s=void 0!==window.pageXOffset?window.pageXOffset:a.scrollLeft,l=void 0!==window.pageYOffset?window.pageYOffset:a.scrollTop,c=e.changedTouches;return c?(o=c[0].pageX-r.left-s,i=c[0].pageY-r.top-l):(o=e.pageX-r.left-s,i=e.pageY-r.top-l),{x:o/(t.clientWidth/(t.width||t.clientWidth)*n),y:i/(t.clientHeight/(t.height||t.clientHeight)*n)}}},function(e,t,n){var o={};e.exports=o;var i=n(0);o._registry={},o.register=function(e){if(o.isPlugin(e)||i.warn("Plugin.register:",o.toString(e),"does not implement all required fields."),e.name in o._registry){var t=o._registry[e.name],n=o.versionParse(e.version).number,r=o.versionParse(t.version).number;n>r?(i.warn("Plugin.register:",o.toString(t),"was upgraded to",o.toString(e)),o._registry[e.name]=e):n<r?i.warn("Plugin.register:",o.toString(t),"can not be downgraded to",o.toString(e)):e!==t&&i.warn("Plugin.register:",o.toString(e),"is already registered to different plugin object")}else o._registry[e.name]=e;return e},o.resolve=function(e){return o._registry[o.dependencyParse(e).name]},o.toString=function(e){return"string"==typeof e?e:(e.name||"anonymous")+"@"+(e.version||e.range||"0.0.0")},o.isPlugin=function(e){return e&&e.name&&e.version&&e.install},o.isUsed=function(e,t){return e.used.indexOf(t)>-1},o.isFor=function(e,t){var n=e.for&&o.dependencyParse(e.for);return!e.for||t.name===n.name&&o.versionSatisfies(t.version,n.range)},o.use=function(e,t){if(e.uses=(e.uses||[]).concat(t||[]),0!==e.uses.length){for(var n=o.dependencies(e),r=i.topologicalSort(n),a=[],s=0;s<r.length;s+=1)if(r[s]!==e.name){var l=o.resolve(r[s]);l?o.isUsed(e,l.name)||(o.isFor(l,e)||(i.warn("Plugin.use:",o.toString(l),"is for",l.for,"but installed on",o.toString(e)+"."),l._warned=!0),l.install?l.install(e):(i.warn("Plugin.use:",o.toString(l),"does not specify an install function."),l._warned=!0),l._warned?(a.push(" "+o.toString(l)),delete l._warned):a.push(" "+o.toString(l)),e.used.push(l.name)):a.push(" "+r[s])}a.length>0&&i.info(a.join("  "))}else i.warn("Plugin.use:",o.toString(e),"does not specify any dependencies to install.")},o.dependencies=function(e,t){var n=o.dependencyParse(e),r=n.name;if(!(r in(t=t||{}))){e=o.resolve(e)||e,t[r]=i.map(e.uses||[],(function(t){o.isPlugin(t)&&o.register(t);var r=o.dependencyParse(t),a=o.resolve(t);return a&&!o.versionSatisfies(a.version,r.range)?(i.warn("Plugin.dependencies:",o.toString(a),"does not satisfy",o.toString(r),"used by",o.toString(n)+"."),a._warned=!0,e._warned=!0):a||(i.warn("Plugin.dependencies:",o.toString(t),"used by",o.toString(n),"could not be resolved."),e._warned=!0),r.name}));for(var a=0;a<t[r].length;a+=1)o.dependencies(t[r][a],t);return t}},o.dependencyParse=function(e){return i.isString(e)?(/^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-+]+)?))?$/.test(e)||i.warn("Plugin.dependencyParse:",e,"is not a valid dependency string."),{name:e.split("@")[0],range:e.split("@")[1]||"*"}):{name:e.name,range:e.range||e.version}},o.versionParse=function(e){var t=/^(\*)|(\^|~|>=|>)?\s*((\d+)\.(\d+)\.(\d+))(-[0-9A-Za-z-+]+)?$/;t.test(e)||i.warn("Plugin.versionParse:",e,"is not a valid version or range.");var n=t.exec(e),o=Number(n[4]),r=Number(n[5]),a=Number(n[6]);return{isRange:Boolean(n[1]||n[2]),version:n[3],range:e,operator:n[1]||n[2]||"",major:o,minor:r,patch:a,parts:[o,r,a],prerelease:n[7],number:1e8*o+1e4*r+a}},o.versionSatisfies=function(e,t){t=t||"*";var n=o.versionParse(t),i=o.versionParse(e);if(n.isRange){if("*"===n.operator||"*"===e)return!0;if(">"===n.operator)return i.number>n.number;if(">="===n.operator)return i.number>=n.number;if("~"===n.operator)return i.major===n.major&&i.minor===n.minor&&i.patch>=n.patch;if("^"===n.operator)return n.major>0?i.major===n.major&&i.number>=n.number:n.minor>0?i.minor===n.minor&&i.patch>=n.patch:i.patch===n.patch}return e===t||"*"===e}},function(e,t){var n={};e.exports=n,n.create=function(e){return{vertex:e,normalImpulse:0,tangentImpulse:0}}},function(e,t,n){var o={};e.exports=o;var i=n(7),r=n(18),a=n(13),s=n(19),l=n(5),c=n(6),u=n(10),d=n(0),p=n(4);o._deltaMax=1e3/60,o.create=function(e){e=e||{};var t=d.extend({positionIterations:6,velocityIterations:4,constraintIterations:2,enableSleeping:!1,events:[],plugin:{},gravity:{x:0,y:1,scale:.001},timing:{timestamp:0,timeScale:1,lastDelta:0,lastElapsed:0,lastUpdatesPerFrame:0}},e);return t.world=e.world||c.create({label:"World"}),t.pairs=e.pairs||s.create(),t.detector=e.detector||a.create(),t.detector.pairs=t.pairs,t.grid={buckets:[]},t.world.gravity=t.gravity,t.broadphase=t.grid,t.metrics={},t},o.update=function(e,t){var n,p=d.now(),f=e.world,v=e.detector,m=e.pairs,y=e.timing,g=y.timestamp;t>o._deltaMax&&d.warnOnce("Matter.Engine.update: delta argument is recommended to be less than or equal to",o._deltaMax.toFixed(3),"ms."),t=void 0!==t?t:d._baseDelta,t*=y.timeScale,y.timestamp+=t,y.lastDelta=t;var x={timestamp:y.timestamp,delta:t};l.trigger(e,"beforeUpdate",x);var h=c.allBodies(f),b=c.allConstraints(f);for(f.isModified&&(a.setBodies(v,h),c.setModified(f,!1,!1,!0)),e.enableSleeping&&i.update(h,t),o._bodiesApplyGravity(h,e.gravity),t>0&&o._bodiesUpdate(h,t),l.trigger(e,"beforeSolve",x),u.preSolveAll(h),n=0;n<e.constraintIterations;n++)u.solveAll(b,t);u.postSolveAll(h);var S=a.collisions(v);s.update(m,S,g),e.enableSleeping&&i.afterCollisions(m.list),m.collisionStart.length>0&&l.trigger(e,"collisionStart",{pairs:m.collisionStart,timestamp:y.timestamp,delta:t});var w=d.clamp(20/e.positionIterations,0,1);for(r.preSolvePosition(m.list),n=0;n<e.positionIterations;n++)r.solvePosition(m.list,t,w);for(r.postSolvePosition(h),u.preSolveAll(h),n=0;n<e.constraintIterations;n++)u.solveAll(b,t);for(u.postSolveAll(h),r.preSolveVelocity(m.list),n=0;n<e.velocityIterations;n++)r.solveVelocity(m.list,t);return o._bodiesUpdateVelocities(h),m.collisionActive.length>0&&l.trigger(e,"collisionActive",{pairs:m.collisionActive,timestamp:y.timestamp,delta:t}),m.collisionEnd.length>0&&l.trigger(e,"collisionEnd",{pairs:m.collisionEnd,timestamp:y.timestamp,delta:t}),o._bodiesClearForces(h),l.trigger(e,"afterUpdate",x),e.timing.lastElapsed=d.now()-p,e},o.merge=function(e,t){if(d.extend(e,t),t.world){e.world=t.world,o.clear(e);for(var n=c.allBodies(e.world),r=0;r<n.length;r++){var a=n[r];i.set(a,!1),a.id=d.nextId()}}},o.clear=function(e){s.clear(e.pairs),a.clear(e.detector)},o._bodiesClearForces=function(e){for(var t=e.length,n=0;n<t;n++){var o=e[n];o.force.x=0,o.force.y=0,o.torque=0}},o._bodiesApplyGravity=function(e,t){var n=void 0!==t.scale?t.scale:.001,o=e.length;if((0!==t.x||0!==t.y)&&0!==n)for(var i=0;i<o;i++){var r=e[i];r.isStatic||r.isSleeping||(r.force.y+=r.mass*t.y*n,r.force.x+=r.mass*t.x*n)}},o._bodiesUpdate=function(e,t){for(var n=e.length,o=0;o<n;o++){var i=e[o];i.isStatic||i.isSleeping||p.update(i,t)}},o._bodiesUpdateVelocities=function(e){for(var t=e.length,n=0;n<t;n++)p.updateVelocities(e[n])}},function(e,t,n){var o={};e.exports=o;var i=n(3),r=n(0),a=n(1);o._restingThresh=2,o._restingThreshTangent=Math.sqrt(6),o._positionDampen=.9,o._positionWarming=.8,o._frictionNormalMultiplier=5,o._frictionMaxStatic=Number.MAX_VALUE,o.preSolvePosition=function(e){var t,n,o,i=e.length;for(t=0;t<i;t++)(n=e[t]).isActive&&(o=n.contactCount,n.collision.parentA.totalContacts+=o,n.collision.parentB.totalContacts+=o)},o.solvePosition=function(e,t,n){var i,a,s,l,c,u,d,p,f=o._positionDampen*(n||1),v=r.clamp(t/r._baseDelta,0,1),m=e.length;for(i=0;i<m;i++)(a=e[i]).isActive&&!a.isSensor&&(l=(s=a.collision).parentA,c=s.parentB,u=s.normal,a.separation=s.depth+u.x*(c.positionImpulse.x-l.positionImpulse.x)+u.y*(c.positionImpulse.y-l.positionImpulse.y));for(i=0;i<m;i++)(a=e[i]).isActive&&!a.isSensor&&(l=(s=a.collision).parentA,c=s.parentB,u=s.normal,p=a.separation-a.slop*v,(l.isStatic||c.isStatic)&&(p*=2),l.isStatic||l.isSleeping||(d=f/l.totalContacts,l.positionImpulse.x+=u.x*p*d,l.positionImpulse.y+=u.y*p*d),c.isStatic||c.isSleeping||(d=f/c.totalContacts,c.positionImpulse.x-=u.x*p*d,c.positionImpulse.y-=u.y*p*d))},o.postSolvePosition=function(e){for(var t=o._positionWarming,n=e.length,r=i.translate,s=a.update,l=0;l<n;l++){var c=e[l],u=c.positionImpulse,d=u.x,p=u.y,f=c.velocity;if(c.totalContacts=0,0!==d||0!==p){for(var v=0;v<c.parts.length;v++){var m=c.parts[v];r(m.vertices,u),s(m.bounds,m.vertices,f),m.position.x+=d,m.position.y+=p}c.positionPrev.x+=d,c.positionPrev.y+=p,d*f.x+p*f.y<0?(u.x=0,u.y=0):(u.x*=t,u.y*=t)}}},o.preSolveVelocity=function(e){var t,n,o=e.length;for(t=0;t<o;t++){var i=e[t];if(i.isActive&&!i.isSensor){var r=i.contacts,a=i.contactCount,s=i.collision,l=s.parentA,c=s.parentB,u=s.normal,d=s.tangent;for(n=0;n<a;n++){var p=r[n],f=p.vertex,v=p.normalImpulse,m=p.tangentImpulse;if(0!==v||0!==m){var y=u.x*v+d.x*m,g=u.y*v+d.y*m;l.isStatic||l.isSleeping||(l.positionPrev.x+=y*l.inverseMass,l.positionPrev.y+=g*l.inverseMass,l.anglePrev+=l.inverseInertia*((f.x-l.position.x)*g-(f.y-l.position.y)*y)),c.isStatic||c.isSleeping||(c.positionPrev.x-=y*c.inverseMass,c.positionPrev.y-=g*c.inverseMass,c.anglePrev-=c.inverseInertia*((f.x-c.position.x)*g-(f.y-c.position.y)*y))}}}}},o.solveVelocity=function(e,t){var n,i,a,s,l=t/r._baseDelta,c=l*l*l,u=-o._restingThresh*l,d=o._restingThreshTangent,p=o._frictionNormalMultiplier*l,f=o._frictionMaxStatic,v=e.length;for(a=0;a<v;a++){var m=e[a];if(m.isActive&&!m.isSensor){var y=m.collision,g=y.parentA,x=y.parentB,h=y.normal.x,b=y.normal.y,S=y.tangent.x,w=y.tangent.y,A=m.inverseMass,P=m.friction*m.frictionStatic*p,B=m.contacts,M=m.contactCount,_=1/M,C=g.position.x-g.positionPrev.x,k=g.position.y-g.positionPrev.y,I=g.angle-g.anglePrev,T=x.position.x-x.positionPrev.x,R=x.position.y-x.positionPrev.y,D=x.angle-x.anglePrev;for(s=0;s<M;s++){var V=B[s],E=V.vertex,L=E.x-g.position.x,F=E.y-g.position.y,O=E.x-x.position.x,H=E.y-x.position.y,q=C-F*I-(T-H*D),j=k+L*I-(R+O*D),U=h*q+b*j,W=S*q+w*j,N=m.separation+U,G=Math.min(N,1),z=(G=N<0?0:G)*P;W<-z||W>z?(i=W>0?W:-W,(n=m.friction*(W>0?1:-1)*c)<-i?n=-i:n>i&&(n=i)):(n=W,i=f);var X=L*b-F*h,Q=O*b-H*h,Y=_/(A+g.inverseInertia*X*X+x.inverseInertia*Q*Q),Z=(1+m.restitution)*U*Y;if(n*=Y,U<u)V.normalImpulse=0;else{var $=V.normalImpulse;V.normalImpulse+=Z,V.normalImpulse>0&&(V.normalImpulse=0),Z=V.normalImpulse-$}if(W<-d||W>d)V.tangentImpulse=0;else{var J=V.tangentImpulse;V.tangentImpulse+=n,V.tangentImpulse<-i&&(V.tangentImpulse=-i),V.tangentImpulse>i&&(V.tangentImpulse=i),n=V.tangentImpulse-J}var K=h*Z+S*n,ee=b*Z+w*n;g.isStatic||g.isSleeping||(g.positionPrev.x+=K*g.inverseMass,g.positionPrev.y+=ee*g.inverseMass,g.anglePrev+=(L*ee-F*K)*g.inverseInertia),x.isStatic||x.isSleeping||(x.positionPrev.x-=K*x.inverseMass,x.positionPrev.y-=ee*x.inverseMass,x.anglePrev-=(O*ee-H*K)*x.inverseInertia)}}}}},function(e,t,n){var o={};e.exports=o;var i=n(9),r=n(0);o.create=function(e){return r.extend({table:{},list:[],collisionStart:[],collisionActive:[],collisionEnd:[]},e)},o.update=function(e,t,n){var o,r,a,s=i.update,l=i.create,c=i.setActive,u=e.table,d=e.list,p=d.length,f=p,v=e.collisionStart,m=e.collisionEnd,y=e.collisionActive,g=t.length,x=0,h=0,b=0;for(a=0;a<g;a++)(r=(o=t[a]).pair)?(r.isActive&&(y[b++]=r),s(r,o,n)):(u[(r=l(o,n)).id]=r,v[x++]=r,d[f++]=r);for(f=0,p=d.length,a=0;a<p;a++)(r=d[a]).timeUpdated>=n?d[f++]=r:(c(r,!1,n),r.collision.bodyA.sleepCounter>0&&r.collision.bodyB.sleepCounter>0?d[f++]=r:(m[h++]=r,delete u[r.id]));d.length!==f&&(d.length=f),v.length!==x&&(v.length=x),m.length!==h&&(m.length=h),y.length!==b&&(y.length=b)},o.clear=function(e){return e.table={},e.list.length=0,e.collisionStart.length=0,e.collisionActive.length=0,e.collisionEnd.length=0,e}},function(e,t,n){var o=e.exports=n(21);o.Axes=n(11),o.Bodies=n(12),o.Body=n(4),o.Bounds=n(1),o.Collision=n(8),o.Common=n(0),o.Composite=n(6),o.Composites=n(22),o.Constraint=n(10),o.Contact=n(16),o.Detector=n(13),o.Engine=n(17),o.Events=n(5),o.Grid=n(23),o.Mouse=n(14),o.MouseConstraint=n(24),o.Pair=n(9),o.Pairs=n(19),o.Plugin=n(15),o.Query=n(25),o.Render=n(26),o.Resolver=n(18),o.Runner=n(27),o.SAT=n(28),o.Sleeping=n(7),o.Svg=n(29),o.Vector=n(2),o.Vertices=n(3),o.World=n(30),o.Engine.run=o.Runner.run,o.Common.deprecated(o.Engine,"run","Engine.run  use Matter.Runner.run(engine) instead")},function(e,t,n){var o={};e.exports=o;var i=n(15),r=n(0);o.name="matter-js",o.version="0.20.0",o.uses=[],o.used=[],o.use=function(){i.use(o,Array.prototype.slice.call(arguments))},o.before=function(e,t){return e=e.replace(/^Matter./,""),r.chainPathBefore(o,e,t)},o.after=function(e,t){return e=e.replace(/^Matter./,""),r.chainPathAfter(o,e,t)}},function(e,t,n){var o={};e.exports=o;var i=n(6),r=n(10),a=n(0),s=n(4),l=n(12),c=a.deprecated;o.stack=function(e,t,n,o,r,a,l){for(var c,u=i.create({label:"Stack"}),d=e,p=t,f=0,v=0;v<o;v++){for(var m=0,y=0;y<n;y++){var g=l(d,p,y,v,c,f);if(g){var x=g.bounds.max.y-g.bounds.min.y,h=g.bounds.max.x-g.bounds.min.x;x>m&&(m=x),s.translate(g,{x:.5*h,y:.5*x}),d=g.bounds.max.x+r,i.addBody(u,g),c=g,f+=1}else d+=r}p+=m+a,d=e}return u},o.chain=function(e,t,n,o,s,l){for(var c=e.bodies,u=1;u<c.length;u++){var d=c[u-1],p=c[u],f=d.bounds.max.y-d.bounds.min.y,v=d.bounds.max.x-d.bounds.min.x,m=p.bounds.max.y-p.bounds.min.y,y={bodyA:d,pointA:{x:v*t,y:f*n},bodyB:p,pointB:{x:(p.bounds.max.x-p.bounds.min.x)*o,y:m*s}},g=a.extend(y,l);i.addConstraint(e,r.create(g))}return e.label+=" Chain",e},o.mesh=function(e,t,n,o,s){var l,c,u,d,p,f=e.bodies;for(l=0;l<n;l++){for(c=1;c<t;c++)u=f[c-1+l*t],d=f[c+l*t],i.addConstraint(e,r.create(a.extend({bodyA:u,bodyB:d},s)));if(l>0)for(c=0;c<t;c++)u=f[c+(l-1)*t],d=f[c+l*t],i.addConstraint(e,r.create(a.extend({bodyA:u,bodyB:d},s))),o&&c>0&&(p=f[c-1+(l-1)*t],i.addConstraint(e,r.create(a.extend({bodyA:p,bodyB:d},s)))),o&&c<t-1&&(p=f[c+1+(l-1)*t],i.addConstraint(e,r.create(a.extend({bodyA:p,bodyB:d},s))))}return e.label+=" Mesh",e},o.pyramid=function(e,t,n,i,r,a,l){return o.stack(e,t,n,i,r,a,(function(t,o,a,c,u,d){var p=Math.min(i,Math.ceil(n/2)),f=u?u.bounds.max.x-u.bounds.min.x:0;if(!(c>p||a<(c=p-c)||a>n-1-c))return 1===d&&s.translate(u,{x:(a+(n%2==1?1:-1))*f,y:0}),l(e+(u?a*f:0)+a*r,o,a,c,u,d)}))},o.newtonsCradle=function(e,t,n,o,a){for(var s=i.create({label:"Newtons Cradle"}),c=0;c<n;c++){var u=l.circle(e+c*(1.9*o),t+a,o,{inertia:1/0,restitution:1,friction:0,frictionAir:1e-4,slop:1}),d=r.create({pointA:{x:e+c*(1.9*o),y:t},bodyB:u});i.addBody(s,u),i.addConstraint(s,d)}return s},c(o,"newtonsCradle","Composites.newtonsCradle  moved to newtonsCradle example"),o.car=function(e,t,n,o,a){var c=s.nextGroup(!0),u=.5*-n+20,d=.5*n-20,p=i.create({label:"Car"}),f=l.rectangle(e,t,n,o,{collisionFilter:{group:c},chamfer:{radius:.5*o},density:2e-4}),v=l.circle(e+u,t+0,a,{collisionFilter:{group:c},friction:.8}),m=l.circle(e+d,t+0,a,{collisionFilter:{group:c},friction:.8}),y=r.create({bodyB:f,pointB:{x:u,y:0},bodyA:v,stiffness:1,length:0}),g=r.create({bodyB:f,pointB:{x:d,y:0},bodyA:m,stiffness:1,length:0});return i.addBody(p,f),i.addBody(p,v),i.addBody(p,m),i.addConstraint(p,y),i.addConstraint(p,g),p},c(o,"car","Composites.car  moved to car example"),o.softBody=function(e,t,n,i,r,s,c,u,d,p){d=a.extend({inertia:1/0},d),p=a.extend({stiffness:.2,render:{type:"line",anchors:!1}},p);var f=o.stack(e,t,n,i,r,s,(function(e,t){return l.circle(e,t,u,d)}));return o.mesh(f,n,i,c,p),f.label="Soft Body",f},c(o,"softBody","Composites.softBody  moved to softBody and cloth examples")},function(e,t,n){var o={};e.exports=o;var i=n(9),r=n(0),a=r.deprecated;o.create=function(e){return r.extend({buckets:{},pairs:{},pairsList:[],bucketWidth:48,bucketHeight:48},e)},o.update=function(e,t,n,i){var r,a,s,l,c,u=n.world,d=e.buckets,p=!1;for(r=0;r<t.length;r++){var f=t[r];if((!f.isSleeping||i)&&(!u.bounds||!(f.bounds.max.x<u.bounds.min.x||f.bounds.min.x>u.bounds.max.x||f.bounds.max.y<u.bounds.min.y||f.bounds.min.y>u.bounds.max.y))){var v=o._getRegion(e,f);if(!f.region||v.id!==f.region.id||i){f.region&&!i||(f.region=v);var m=o._regionUnion(v,f.region);for(a=m.startCol;a<=m.endCol;a++)for(s=m.startRow;s<=m.endRow;s++){l=d[c=o._getBucketId(a,s)];var y=a>=v.startCol&&a<=v.endCol&&s>=v.startRow&&s<=v.endRow,g=a>=f.region.startCol&&a<=f.region.endCol&&s>=f.region.startRow&&s<=f.region.endRow;!y&&g&&g&&l&&o._bucketRemoveBody(e,l,f),(f.region===v||y&&!g||i)&&(l||(l=o._createBucket(d,c)),o._bucketAddBody(e,l,f))}f.region=v,p=!0}}}p&&(e.pairsList=o._createActivePairsList(e))},a(o,"update","Grid.update  replaced by Matter.Detector"),o.clear=function(e){e.buckets={},e.pairs={},e.pairsList=[]},a(o,"clear","Grid.clear  replaced by Matter.Detector"),o._regionUnion=function(e,t){var n=Math.min(e.startCol,t.startCol),i=Math.max(e.endCol,t.endCol),r=Math.min(e.startRow,t.startRow),a=Math.max(e.endRow,t.endRow);return o._createRegion(n,i,r,a)},o._getRegion=function(e,t){var n=t.bounds,i=Math.floor(n.min.x/e.bucketWidth),r=Math.floor(n.max.x/e.bucketWidth),a=Math.floor(n.min.y/e.bucketHeight),s=Math.floor(n.max.y/e.bucketHeight);return o._createRegion(i,r,a,s)},o._createRegion=function(e,t,n,o){return{id:e+","+t+","+n+","+o,startCol:e,endCol:t,startRow:n,endRow:o}},o._getBucketId=function(e,t){return"C"+e+"R"+t},o._createBucket=function(e,t){return e[t]=[]},o._bucketAddBody=function(e,t,n){var o,r=e.pairs,a=i.id,s=t.length;for(o=0;o<s;o++){var l=t[o];if(!(n.id===l.id||n.isStatic&&l.isStatic)){var c=a(n,l),u=r[c];u?u[2]+=1:r[c]=[n,l,1]}}t.push(n)},o._bucketRemoveBody=function(e,t,n){var o,a=e.pairs,s=i.id;t.splice(r.indexOf(t,n),1);var l=t.length;for(o=0;o<l;o++){var c=a[s(n,t[o])];c&&(c[2]-=1)}},o._createActivePairsList=function(e){var t,n,o=e.pairs,i=r.keys(o),a=i.length,s=[];for(n=0;n<a;n++)(t=o[i[n]])[2]>0?s.push(t):delete o[i[n]];return s}},function(e,t,n){var o={};e.exports=o;var i=n(3),r=n(7),a=n(14),s=n(5),l=n(13),c=n(10),u=n(6),d=n(0),p=n(1);o.create=function(e,t){var n=(e?e.mouse:null)||(t?t.mouse:null);n||(e&&e.render&&e.render.canvas?n=a.create(e.render.canvas):t&&t.element?n=a.create(t.element):(n=a.create(),d.warn("MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected")));var i={type:"mouseConstraint",mouse:n,element:null,body:null,constraint:c.create({label:"Mouse Constraint",pointA:n.position,pointB:{x:0,y:0},length:.01,stiffness:.1,angularStiffness:1,render:{strokeStyle:"#90EE90",lineWidth:3}}),collisionFilter:{category:1,mask:4294967295,group:0}},r=d.extend(i,t);return s.on(e,"beforeUpdate",(function(){var t=u.allBodies(e.world);o.update(r,t),o._triggerEvents(r)})),r},o.update=function(e,t){var n=e.mouse,o=e.constraint,a=e.body;if(0===n.button){if(o.bodyB)r.set(o.bodyB,!1),o.pointA=n.position;else for(var c=0;c<t.length;c++)if(a=t[c],p.contains(a.bounds,n.position)&&l.canCollide(a.collisionFilter,e.collisionFilter))for(var u=a.parts.length>1?1:0;u<a.parts.length;u++){var d=a.parts[u];if(i.contains(d.vertices,n.position)){o.pointA=n.position,o.bodyB=e.body=a,o.pointB={x:n.position.x-a.position.x,y:n.position.y-a.position.y},o.angleB=a.angle,r.set(a,!1),s.trigger(e,"startdrag",{mouse:n,body:a});break}}}else o.bodyB=e.body=null,o.pointB=null,a&&s.trigger(e,"enddrag",{mouse:n,body:a})},o._triggerEvents=function(e){var t=e.mouse,n=t.sourceEvents;n.mousemove&&s.trigger(e,"mousemove",{mouse:t}),n.mousedown&&s.trigger(e,"mousedown",{mouse:t}),n.mouseup&&s.trigger(e,"mouseup",{mouse:t}),a.clearSourceEvents(t)}},function(e,t,n){var o={};e.exports=o;var i=n(2),r=n(8),a=n(1),s=n(12),l=n(3);o.collides=function(e,t){for(var n=[],o=t.length,i=e.bounds,s=r.collides,l=a.overlaps,c=0;c<o;c++){var u=t[c],d=u.parts.length,p=1===d?0:1;if(l(u.bounds,i))for(var f=p;f<d;f++){var v=u.parts[f];if(l(v.bounds,i)){var m=s(v,e);if(m){n.push(m);break}}}}return n},o.ray=function(e,t,n,r){r=r||1e-100;for(var a=i.angle(t,n),l=i.magnitude(i.sub(t,n)),c=.5*(n.x+t.x),u=.5*(n.y+t.y),d=s.rectangle(c,u,l,r,{angle:a}),p=o.collides(d,e),f=0;f<p.length;f+=1){var v=p[f];v.body=v.bodyB=v.bodyA}return p},o.region=function(e,t,n){for(var o=[],i=0;i<e.length;i++){var r=e[i],s=a.overlaps(r.bounds,t);(s&&!n||!s&&n)&&o.push(r)}return o},o.point=function(e,t){for(var n=[],o=0;o<e.length;o++){var i=e[o];if(a.contains(i.bounds,t))for(var r=1===i.parts.length?0:1;r<i.parts.length;r++){var s=i.parts[r];if(a.contains(s.bounds,t)&&l.contains(s.vertices,t)){n.push(i);break}}}return n}},function(e,t,n){var o={};e.exports=o;var i=n(4),r=n(0),a=n(6),s=n(1),l=n(5),c=n(2),u=n(14);!function(){var e,t;"undefined"!=typeof window&&(e=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.msRequestAnimationFrame||function(e){window.setTimeout((function(){e(r.now())}),1e3/60)},t=window.cancelAnimationFrame||window.mozCancelAnimationFrame||window.webkitCancelAnimationFrame||window.msCancelAnimationFrame),o._goodFps=30,o._goodDelta=1e3/60,o.create=function(e){var t={engine:null,element:null,canvas:null,mouse:null,frameRequestId:null,timing:{historySize:60,delta:0,deltaHistory:[],lastTime:0,lastTimestamp:0,lastElapsed:0,timestampElapsed:0,timestampElapsedHistory:[],engineDeltaHistory:[],engineElapsedHistory:[],engineUpdatesHistory:[],elapsedHistory:[]},options:{width:800,height:600,pixelRatio:1,background:"#14151f",wireframeBackground:"#14151f",wireframeStrokeStyle:"#bbb",hasBounds:!!e.bounds,enabled:!0,wireframes:!0,showSleeping:!0,showDebug:!1,showStats:!1,showPerformance:!1,showBounds:!1,showVelocity:!1,showCollisions:!1,showSeparations:!1,showAxes:!1,showPositions:!1,showAngleIndicator:!1,showIds:!1,showVertexNumbers:!1,showConvexHulls:!1,showInternalEdges:!1,showMousePosition:!1}},n=r.extend(t,e);return n.canvas&&(n.canvas.width=n.options.width||n.canvas.width,n.canvas.height=n.options.height||n.canvas.height),n.mouse=e.mouse,n.engine=e.engine,n.canvas=n.canvas||p(n.options.width,n.options.height),n.context=n.canvas.getContext("2d"),n.textures={},n.bounds=n.bounds||{min:{x:0,y:0},max:{x:n.canvas.width,y:n.canvas.height}},n.controller=o,n.options.showBroadphase=!1,1!==n.options.pixelRatio&&o.setPixelRatio(n,n.options.pixelRatio),r.isElement(n.element)&&n.element.appendChild(n.canvas),n},o.run=function(t){!function i(r){t.frameRequestId=e(i),n(t,r),o.world(t,r),t.context.setTransform(t.options.pixelRatio,0,0,t.options.pixelRatio,0,0),(t.options.showStats||t.options.showDebug)&&o.stats(t,t.context,r),(t.options.showPerformance||t.options.showDebug)&&o.performance(t,t.context,r),t.context.setTransform(1,0,0,1,0,0)}()},o.stop=function(e){t(e.frameRequestId)},o.setPixelRatio=function(e,t){var n=e.options,o=e.canvas;"auto"===t&&(t=f(o)),n.pixelRatio=t,o.setAttribute("data-pixel-ratio",t),o.width=n.width*t,o.height=n.height*t,o.style.width=n.width+"px",o.style.height=n.height+"px"},o.setSize=function(e,t,n){e.options.width=t,e.options.height=n,e.bounds.max.x=e.bounds.min.x+t,e.bounds.max.y=e.bounds.min.y+n,1!==e.options.pixelRatio?o.setPixelRatio(e,e.options.pixelRatio):(e.canvas.width=t,e.canvas.height=n)},o.lookAt=function(e,t,n,o){o=void 0===o||o,t=r.isArray(t)?t:[t],n=n||{x:0,y:0};for(var i={min:{x:1/0,y:1/0},max:{x:-1/0,y:-1/0}},a=0;a<t.length;a+=1){var s=t[a],l=s.bounds?s.bounds.min:s.min||s.position||s,c=s.bounds?s.bounds.max:s.max||s.position||s;l&&c&&(l.x<i.min.x&&(i.min.x=l.x),c.x>i.max.x&&(i.max.x=c.x),l.y<i.min.y&&(i.min.y=l.y),c.y>i.max.y&&(i.max.y=c.y))}var d=i.max.x-i.min.x+2*n.x,p=i.max.y-i.min.y+2*n.y,f=e.canvas.height,v=e.canvas.width/f,m=d/p,y=1,g=1;m>v?g=m/v:y=v/m,e.options.hasBounds=!0,e.bounds.min.x=i.min.x,e.bounds.max.x=i.min.x+d*y,e.bounds.min.y=i.min.y,e.bounds.max.y=i.min.y+p*g,o&&(e.bounds.min.x+=.5*d-d*y*.5,e.bounds.max.x+=.5*d-d*y*.5,e.bounds.min.y+=.5*p-p*g*.5,e.bounds.max.y+=.5*p-p*g*.5),e.bounds.min.x-=n.x,e.bounds.max.x-=n.x,e.bounds.min.y-=n.y,e.bounds.max.y-=n.y,e.mouse&&(u.setScale(e.mouse,{x:(e.bounds.max.x-e.bounds.min.x)/e.canvas.width,y:(e.bounds.max.y-e.bounds.min.y)/e.canvas.height}),u.setOffset(e.mouse,e.bounds.min))},o.startViewTransform=function(e){var t=e.bounds.max.x-e.bounds.min.x,n=e.bounds.max.y-e.bounds.min.y,o=t/e.options.width,i=n/e.options.height;e.context.setTransform(e.options.pixelRatio/o,0,0,e.options.pixelRatio/i,0,0),e.context.translate(-e.bounds.min.x,-e.bounds.min.y)},o.endViewTransform=function(e){e.context.setTransform(e.options.pixelRatio,0,0,e.options.pixelRatio,0,0)},o.world=function(e,t){var n,i=r.now(),d=e.engine,p=d.world,f=e.canvas,v=e.context,y=e.options,g=e.timing,x=a.allBodies(p),h=a.allConstraints(p),b=y.wireframes?y.wireframeBackground:y.background,S=[],w=[],A={timestamp:d.timing.timestamp};if(l.trigger(e,"beforeRender",A),e.currentBackground!==b&&m(e,b),v.globalCompositeOperation="source-in",v.fillStyle="transparent",v.fillRect(0,0,f.width,f.height),v.globalCompositeOperation="source-over",y.hasBounds){for(n=0;n<x.length;n++){var P=x[n];s.overlaps(P.bounds,e.bounds)&&S.push(P)}for(n=0;n<h.length;n++){var B=h[n],M=B.bodyA,_=B.bodyB,C=B.pointA,k=B.pointB;M&&(C=c.add(M.position,B.pointA)),_&&(k=c.add(_.position,B.pointB)),C&&k&&((s.contains(e.bounds,C)||s.contains(e.bounds,k))&&w.push(B))}o.startViewTransform(e),e.mouse&&(u.setScale(e.mouse,{x:(e.bounds.max.x-e.bounds.min.x)/e.options.width,y:(e.bounds.max.y-e.bounds.min.y)/e.options.height}),u.setOffset(e.mouse,e.bounds.min))}else w=h,S=x,1!==e.options.pixelRatio&&e.context.setTransform(e.options.pixelRatio,0,0,e.options.pixelRatio,0,0);!y.wireframes||d.enableSleeping&&y.showSleeping?o.bodies(e,S,v):(y.showConvexHulls&&o.bodyConvexHulls(e,S,v),o.bodyWireframes(e,S,v)),y.showBounds&&o.bodyBounds(e,S,v),(y.showAxes||y.showAngleIndicator)&&o.bodyAxes(e,S,v),y.showPositions&&o.bodyPositions(e,S,v),y.showVelocity&&o.bodyVelocity(e,S,v),y.showIds&&o.bodyIds(e,S,v),y.showSeparations&&o.separations(e,d.pairs.list,v),y.showCollisions&&o.collisions(e,d.pairs.list,v),y.showVertexNumbers&&o.vertexNumbers(e,S,v),y.showMousePosition&&o.mousePosition(e,e.mouse,v),o.constraints(w,v),y.hasBounds&&o.endViewTransform(e),l.trigger(e,"afterRender",A),g.lastElapsed=r.now()-i},o.stats=function(e,t,n){for(var o=e.engine,i=o.world,r=a.allBodies(i),s=0,l=0,c=0;c<r.length;c+=1)s+=r[c].parts.length;var u={Part:s,Body:r.length,Cons:a.allConstraints(i).length,Comp:a.allComposites(i).length,Pair:o.pairs.list.length};for(var d in t.fillStyle="#0e0f19",t.fillRect(l,0,302.5,44),t.font="12px Arial",t.textBaseline="top",t.textAlign="right",u){var p=u[d];t.fillStyle="#aaa",t.fillText(d,l+55,8),t.fillStyle="#eee",t.fillText(p,l+55,26),l+=55}},o.performance=function(e,t){var n=e.engine,i=e.timing,a=i.deltaHistory,s=i.elapsedHistory,l=i.timestampElapsedHistory,c=i.engineDeltaHistory,u=i.engineUpdatesHistory,p=i.engineElapsedHistory,f=n.timing.lastUpdatesPerFrame,v=n.timing.lastDelta,m=d(a),y=d(s),g=d(c),x=d(u),h=d(p),b=d(l)/m||0,S=Math.round(m/v),w=1e3/m||0,A=10,P=69;t.fillStyle="#0e0f19",t.fillRect(0,50,442,34),o.status(t,A,P,60,4,a.length,Math.round(w)+" fps",w/o._goodFps,(function(e){return a[e]/m-1})),o.status(t,82,P,60,4,c.length,v.toFixed(2)+" dt",o._goodDelta/v,(function(e){return c[e]/g-1})),o.status(t,154,P,60,4,u.length,f+" upf",Math.pow(r.clamp(x/S||1,0,1),4),(function(e){return u[e]/x-1})),o.status(t,226,P,60,4,p.length,h.toFixed(2)+" ut",1-f*h/o._goodFps,(function(e){return p[e]/h-1})),o.status(t,298,P,60,4,s.length,y.toFixed(2)+" rt",1-y/o._goodFps,(function(e){return s[e]/y-1})),o.status(t,370,P,60,4,l.length,b.toFixed(2)+" x",b*b*b,(function(e){return(l[e]/a[e]/b||0)-1}))},o.status=function(e,t,n,o,i,a,s,l,c){e.strokeStyle="#888",e.fillStyle="#444",e.lineWidth=1,e.fillRect(t,n+7,o,1),e.beginPath(),e.moveTo(t,n+7-i*r.clamp(.4*c(0),-2,2));for(var u=0;u<o;u+=1)e.lineTo(t+u,n+7-(u<a?i*r.clamp(.4*c(u),-2,2):0));e.stroke(),e.fillStyle="hsl("+r.clamp(25+95*l,0,120)+",100%,60%)",e.fillRect(t,n-7,4,4),e.font="12px Arial",e.textBaseline="middle",e.textAlign="right",e.fillStyle="#eee",e.fillText(s,t+o,n-5)},o.constraints=function(e,t){for(var n=t,o=0;o<e.length;o++){var i=e[o];if(i.render.visible&&i.pointA&&i.pointB){var a,s,l=i.bodyA,u=i.bodyB;if(a=l?c.add(l.position,i.pointA):i.pointA,"pin"===i.render.type)n.beginPath(),n.arc(a.x,a.y,3,0,2*Math.PI),n.closePath();else{if(s=u?c.add(u.position,i.pointB):i.pointB,n.beginPath(),n.moveTo(a.x,a.y),"spring"===i.render.type)for(var d,p=c.sub(s,a),f=c.perp(c.normalise(p)),v=Math.ceil(r.clamp(i.length/5,12,20)),m=1;m<v;m+=1)d=m%2==0?1:-1,n.lineTo(a.x+p.x*(m/v)+f.x*d*4,a.y+p.y*(m/v)+f.y*d*4);n.lineTo(s.x,s.y)}i.render.lineWidth&&(n.lineWidth=i.render.lineWidth,n.strokeStyle=i.render.strokeStyle,n.stroke()),i.render.anchors&&(n.fillStyle=i.render.strokeStyle,n.beginPath(),n.arc(a.x,a.y,3,0,2*Math.PI),n.arc(s.x,s.y,3,0,2*Math.PI),n.closePath(),n.fill())}}},o.bodies=function(e,t,n){var o,i,r,a,s=n,l=(e.engine,e.options),c=l.showInternalEdges||!l.wireframes;for(r=0;r<t.length;r++)if((o=t[r]).render.visible)for(a=o.parts.length>1?1:0;a<o.parts.length;a++)if((i=o.parts[a]).render.visible){if(l.showSleeping&&o.isSleeping?s.globalAlpha=.5*i.render.opacity:1!==i.render.opacity&&(s.globalAlpha=i.render.opacity),i.render.sprite&&i.render.sprite.texture&&!l.wireframes){var u=i.render.sprite,d=v(e,u.texture);s.translate(i.position.x,i.position.y),s.rotate(i.angle),s.drawImage(d,d.width*-u.xOffset*u.xScale,d.height*-u.yOffset*u.yScale,d.width*u.xScale,d.height*u.yScale),s.rotate(-i.angle),s.translate(-i.position.x,-i.position.y)}else{if(i.circleRadius)s.beginPath(),s.arc(i.position.x,i.position.y,i.circleRadius,0,2*Math.PI);else{s.beginPath(),s.moveTo(i.vertices[0].x,i.vertices[0].y);for(var p=1;p<i.vertices.length;p++)!i.vertices[p-1].isInternal||c?s.lineTo(i.vertices[p].x,i.vertices[p].y):s.moveTo(i.vertices[p].x,i.vertices[p].y),i.vertices[p].isInternal&&!c&&s.moveTo(i.vertices[(p+1)%i.vertices.length].x,i.vertices[(p+1)%i.vertices.length].y);s.lineTo(i.vertices[0].x,i.vertices[0].y),s.closePath()}l.wireframes?(s.lineWidth=1,s.strokeStyle=e.options.wireframeStrokeStyle,s.stroke()):(s.fillStyle=i.render.fillStyle,i.render.lineWidth&&(s.lineWidth=i.render.lineWidth,s.strokeStyle=i.render.strokeStyle,s.stroke()),s.fill())}s.globalAlpha=1}},o.bodyWireframes=function(e,t,n){var o,i,r,a,s,l=n,c=e.options.showInternalEdges;for(l.beginPath(),r=0;r<t.length;r++)if((o=t[r]).render.visible)for(s=o.parts.length>1?1:0;s<o.parts.length;s++){for(i=o.parts[s],l.moveTo(i.vertices[0].x,i.vertices[0].y),a=1;a<i.vertices.length;a++)!i.vertices[a-1].isInternal||c?l.lineTo(i.vertices[a].x,i.vertices[a].y):l.moveTo(i.vertices[a].x,i.vertices[a].y),i.vertices[a].isInternal&&!c&&l.moveTo(i.vertices[(a+1)%i.vertices.length].x,i.vertices[(a+1)%i.vertices.length].y);l.lineTo(i.vertices[0].x,i.vertices[0].y)}l.lineWidth=1,l.strokeStyle=e.options.wireframeStrokeStyle,l.stroke()},o.bodyConvexHulls=function(e,t,n){var o,i,r,a=n;for(a.beginPath(),i=0;i<t.length;i++)if((o=t[i]).render.visible&&1!==o.parts.length){for(a.moveTo(o.vertices[0].x,o.vertices[0].y),r=1;r<o.vertices.length;r++)a.lineTo(o.vertices[r].x,o.vertices[r].y);a.lineTo(o.vertices[0].x,o.vertices[0].y)}a.lineWidth=1,a.strokeStyle="rgba(255,255,255,0.2)",a.stroke()},o.vertexNumbers=function(e,t,n){var o,i,r,a=n;for(o=0;o<t.length;o++){var s=t[o].parts;for(r=s.length>1?1:0;r<s.length;r++){var l=s[r];for(i=0;i<l.vertices.length;i++)a.fillStyle="rgba(255,255,255,0.2)",a.fillText(o+"_"+i,l.position.x+.8*(l.vertices[i].x-l.position.x),l.position.y+.8*(l.vertices[i].y-l.position.y))}}},o.mousePosition=function(e,t,n){var o=n;o.fillStyle="rgba(255,255,255,0.8)",o.fillText(t.position.x+"  "+t.position.y,t.position.x+5,t.position.y-5)},o.bodyBounds=function(e,t,n){var o=n,i=(e.engine,e.options);o.beginPath();for(var r=0;r<t.length;r++){if(t[r].render.visible)for(var a=t[r].parts,s=a.length>1?1:0;s<a.length;s++){var l=a[s];o.rect(l.bounds.min.x,l.bounds.min.y,l.bounds.max.x-l.bounds.min.x,l.bounds.max.y-l.bounds.min.y)}}i.wireframes?o.strokeStyle="rgba(255,255,255,0.08)":o.strokeStyle="rgba(0,0,0,0.1)",o.lineWidth=1,o.stroke()},o.bodyAxes=function(e,t,n){var o,i,r,a,s=n,l=(e.engine,e.options);for(s.beginPath(),i=0;i<t.length;i++){var c=t[i],u=c.parts;if(c.render.visible)if(l.showAxes)for(r=u.length>1?1:0;r<u.length;r++)for(o=u[r],a=0;a<o.axes.length;a++){var d=o.axes[a];s.moveTo(o.position.x,o.position.y),s.lineTo(o.position.x+20*d.x,o.position.y+20*d.y)}else for(r=u.length>1?1:0;r<u.length;r++)for(o=u[r],a=0;a<o.axes.length;a++)s.moveTo(o.position.x,o.position.y),s.lineTo((o.vertices[0].x+o.vertices[o.vertices.length-1].x)/2,(o.vertices[0].y+o.vertices[o.vertices.length-1].y)/2)}l.wireframes?(s.strokeStyle="indianred",s.lineWidth=1):(s.strokeStyle="rgba(255, 255, 255, 0.4)",s.globalCompositeOperation="overlay",s.lineWidth=2),s.stroke(),s.globalCompositeOperation="source-over"},o.bodyPositions=function(e,t,n){var o,i,r,a,s=n,l=(e.engine,e.options);for(s.beginPath(),r=0;r<t.length;r++)if((o=t[r]).render.visible)for(a=0;a<o.parts.length;a++)i=o.parts[a],s.arc(i.position.x,i.position.y,3,0,2*Math.PI,!1),s.closePath();for(l.wireframes?s.fillStyle="indianred":s.fillStyle="rgba(0,0,0,0.5)",s.fill(),s.beginPath(),r=0;r<t.length;r++)(o=t[r]).render.visible&&(s.arc(o.positionPrev.x,o.positionPrev.y,2,0,2*Math.PI,!1),s.closePath());s.fillStyle="rgba(255,165,0,0.8)",s.fill()},o.bodyVelocity=function(e,t,n){var o=n;o.beginPath();for(var r=0;r<t.length;r++){var a=t[r];if(a.render.visible){var s=i.getVelocity(a);o.moveTo(a.position.x,a.position.y),o.lineTo(a.position.x+s.x,a.position.y+s.y)}}o.lineWidth=3,o.strokeStyle="cornflowerblue",o.stroke()},o.bodyIds=function(e,t,n){var o,i,r=n;for(o=0;o<t.length;o++)if(t[o].render.visible){var a=t[o].parts;for(i=a.length>1?1:0;i<a.length;i++){var s=a[i];r.font="12px Arial",r.fillStyle="rgba(255,255,255,0.5)",r.fillText(s.id,s.position.x+10,s.position.y-10)}}},o.collisions=function(e,t,n){var o,i,r,a,s=n,l=e.options;for(s.beginPath(),r=0;r<t.length;r++)if((o=t[r]).isActive)for(i=o.collision,a=0;a<o.contactCount;a++){var c=o.contacts[a].vertex;s.rect(c.x-1.5,c.y-1.5,3.5,3.5)}for(l.wireframes?s.fillStyle="rgba(255,255,255,0.7)":s.fillStyle="orange",s.fill(),s.beginPath(),r=0;r<t.length;r++)if((o=t[r]).isActive&&(i=o.collision,o.contactCount>0)){var u=o.contacts[0].vertex.x,d=o.contacts[0].vertex.y;2===o.contactCount&&(u=(o.contacts[0].vertex.x+o.contacts[1].vertex.x)/2,d=(o.contacts[0].vertex.y+o.contacts[1].vertex.y)/2),i.bodyB===i.supports[0].body||!0===i.bodyA.isStatic?s.moveTo(u-8*i.normal.x,d-8*i.normal.y):s.moveTo(u+8*i.normal.x,d+8*i.normal.y),s.lineTo(u,d)}l.wireframes?s.strokeStyle="rgba(255,165,0,0.7)":s.strokeStyle="orange",s.lineWidth=1,s.stroke()},o.separations=function(e,t,n){var o,i,r,a,s,l=n,c=e.options;for(l.beginPath(),s=0;s<t.length;s++)if((o=t[s]).isActive){r=(i=o.collision).bodyA;var u=1;(a=i.bodyB).isStatic||r.isStatic||(u=.5),a.isStatic&&(u=0),l.moveTo(a.position.x,a.position.y),l.lineTo(a.position.x-i.penetration.x*u,a.position.y-i.penetration.y*u),u=1,a.isStatic||r.isStatic||(u=.5),r.isStatic&&(u=0),l.moveTo(r.position.x,r.position.y),l.lineTo(r.position.x+i.penetration.x*u,r.position.y+i.penetration.y*u)}c.wireframes?l.strokeStyle="rgba(255,165,0,0.5)":l.strokeStyle="orange",l.stroke()},o.inspector=function(e,t){e.engine;var n,o=e.selected,i=e.render,r=i.options;if(r.hasBounds){var a=i.bounds.max.x-i.bounds.min.x,s=i.bounds.max.y-i.bounds.min.y,l=a/i.options.width,c=s/i.options.height;t.scale(1/l,1/c),t.translate(-i.bounds.min.x,-i.bounds.min.y)}for(var u=0;u<o.length;u++){var d=o[u].data;switch(t.translate(.5,.5),t.lineWidth=1,t.strokeStyle="rgba(255,165,0,0.9)",t.setLineDash([1,2]),d.type){case"body":n=d.bounds,t.beginPath(),t.rect(Math.floor(n.min.x-3),Math.floor(n.min.y-3),Math.floor(n.max.x-n.min.x+6),Math.floor(n.max.y-n.min.y+6)),t.closePath(),t.stroke();break;case"constraint":var p=d.pointA;d.bodyA&&(p=d.pointB),t.beginPath(),t.arc(p.x,p.y,10,0,2*Math.PI),t.closePath(),t.stroke()}t.setLineDash([]),t.translate(-.5,-.5)}null!==e.selectStart&&(t.translate(.5,.5),t.lineWidth=1,t.strokeStyle="rgba(255,165,0,0.6)",t.fillStyle="rgba(255,165,0,0.1)",n=e.selectBounds,t.beginPath(),t.rect(Math.floor(n.min.x),Math.floor(n.min.y),Math.floor(n.max.x-n.min.x),Math.floor(n.max.y-n.min.y)),t.closePath(),t.stroke(),t.fill(),t.translate(-.5,-.5)),r.hasBounds&&t.setTransform(1,0,0,1,0,0)};var n=function(e,t){var n=e.engine,i=e.timing,r=i.historySize,a=n.timing.timestamp;i.delta=t-i.lastTime||o._goodDelta,i.lastTime=t,i.timestampElapsed=a-i.lastTimestamp||0,i.lastTimestamp=a,i.deltaHistory.unshift(i.delta),i.deltaHistory.length=Math.min(i.deltaHistory.length,r),i.engineDeltaHistory.unshift(n.timing.lastDelta),i.engineDeltaHistory.length=Math.min(i.engineDeltaHistory.length,r),i.timestampElapsedHistory.unshift(i.timestampElapsed),i.timestampElapsedHistory.length=Math.min(i.timestampElapsedHistory.length,r),i.engineUpdatesHistory.unshift(n.timing.lastUpdatesPerFrame),i.engineUpdatesHistory.length=Math.min(i.engineUpdatesHistory.length,r),i.engineElapsedHistory.unshift(n.timing.lastElapsed),i.engineElapsedHistory.length=Math.min(i.engineElapsedHistory.length,r),i.elapsedHistory.unshift(i.lastElapsed),i.elapsedHistory.length=Math.min(i.elapsedHistory.length,r)},d=function(e){for(var t=0,n=0;n<e.length;n+=1)t+=e[n];return t/e.length||0},p=function(e,t){var n=document.createElement("canvas");return n.width=e,n.height=t,n.oncontextmenu=function(){return!1},n.onselectstart=function(){return!1},n},f=function(e){var t=e.getContext("2d");return(window.devicePixelRatio||1)/(t.webkitBackingStorePixelRatio||t.mozBackingStorePixelRatio||t.msBackingStorePixelRatio||t.oBackingStorePixelRatio||t.backingStorePixelRatio||1)},v=function(e,t){var n=e.textures[t];return n||((n=e.textures[t]=new Image).src=t,n)},m=function(e,t){var n=t;/(jpg|gif|png)$/.test(t)&&(n="url("+t+")"),e.canvas.style.background=n,e.canvas.style.backgroundSize="contain",e.currentBackground=t}}()},function(e,t,n){var o={};e.exports=o;var i=n(5),r=n(17),a=n(0);!function(){o._maxFrameDelta=1e3/15,o._frameDeltaFallback=1e3/60,o._timeBufferMargin=1.5,o._elapsedNextEstimate=1,o._smoothingLowerBound=.1,o._smoothingUpperBound=.9,o.create=function(e){var t=a.extend({delta:1e3/60,frameDelta:null,frameDeltaSmoothing:!0,frameDeltaSnapping:!0,frameDeltaHistory:[],frameDeltaHistorySize:100,frameRequestId:null,timeBuffer:0,timeLastTick:null,maxUpdates:null,maxFrameTime:1e3/30,lastUpdatesDeferred:0,enabled:!0},e);return t.fps=0,t},o.run=function(e,t){return e.timeBuffer=o._frameDeltaFallback,function n(i){e.frameRequestId=o._onNextFrame(e,n),i&&e.enabled&&o.tick(e,t,i)}(),e},o.tick=function(t,n,s){var l=a.now(),c=t.delta,u=0,d=s-t.timeLastTick;if((!d||!t.timeLastTick||d>Math.max(o._maxFrameDelta,t.maxFrameTime))&&(d=t.frameDelta||o._frameDeltaFallback),t.frameDeltaSmoothing){t.frameDeltaHistory.push(d),t.frameDeltaHistory=t.frameDeltaHistory.slice(-t.frameDeltaHistorySize);var p=t.frameDeltaHistory.slice(0).sort(),f=t.frameDeltaHistory.slice(p.length*o._smoothingLowerBound,p.length*o._smoothingUpperBound);d=e(f)||d}t.frameDeltaSnapping&&(d=1e3/Math.round(1e3/d)),t.frameDelta=d,t.timeLastTick=s,t.timeBuffer+=t.frameDelta,t.timeBuffer=a.clamp(t.timeBuffer,0,t.frameDelta+c*o._timeBufferMargin),t.lastUpdatesDeferred=0;var v=t.maxUpdates||Math.ceil(t.maxFrameTime/c),m={timestamp:n.timing.timestamp};i.trigger(t,"beforeTick",m),i.trigger(t,"tick",m);for(var y=a.now();c>0&&t.timeBuffer>=c*o._timeBufferMargin;){i.trigger(t,"beforeUpdate",m),r.update(n,c),i.trigger(t,"afterUpdate",m),t.timeBuffer-=c,u+=1;var g=a.now()-l,x=a.now()-y,h=g+o._elapsedNextEstimate*x/u;if(u>=v||h>t.maxFrameTime){t.lastUpdatesDeferred=Math.round(Math.max(0,t.timeBuffer/c-o._timeBufferMargin));break}}n.timing.lastUpdatesPerFrame=u,i.trigger(t,"afterTick",m),t.frameDeltaHistory.length>=100&&(t.lastUpdatesDeferred&&Math.round(t.frameDelta/c)>v?a.warnOnce("Matter.Runner: runner reached runner.maxUpdates, see docs."):t.lastUpdatesDeferred&&a.warnOnce("Matter.Runner: runner reached runner.maxFrameTime, see docs."),void 0!==t.isFixed&&a.warnOnce("Matter.Runner: runner.isFixed is now redundant, see docs."),(t.deltaMin||t.deltaMax)&&a.warnOnce("Matter.Runner: runner.deltaMin and runner.deltaMax were removed, see docs."),0!==t.fps&&a.warnOnce("Matter.Runner: runner.fps was replaced by runner.delta, see docs."))},o.stop=function(e){o._cancelNextFrame(e)},o._onNextFrame=function(e,t){if("undefined"==typeof window||!window.requestAnimationFrame)throw new Error("Matter.Runner: missing required global window.requestAnimationFrame.");return e.frameRequestId=window.requestAnimationFrame(t),e.frameRequestId},o._cancelNextFrame=function(e){if("undefined"==typeof window||!window.cancelAnimationFrame)throw new Error("Matter.Runner: missing required global window.cancelAnimationFrame.");window.cancelAnimationFrame(e.frameRequestId)};var e=function(e){for(var t=0,n=e.length,o=0;o<n;o+=1)t+=e[o];return t/n||0}}()},function(e,t,n){var o={};e.exports=o;var i=n(8),r=n(0).deprecated;o.collides=function(e,t){return i.collides(e,t)},r(o,"collides","SAT.collides  replaced by Collision.collides")},function(e,t,n){var o={};e.exports=o;n(1);var i=n(0);o.pathToVertices=function(e,t){"undefined"==typeof window||"SVGPathSeg"in window||i.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.");var n,r,a,s,l,c,u,d,p,f,v,m=[],y=0,g=0,x=0;t=t||15;var h=function(e,t,n){var o=n%2==1&&n>1;if(!p||e!=p.x||t!=p.y){p&&o?(f=p.x,v=p.y):(f=0,v=0);var i={x:f+e,y:v+t};!o&&p||(p=i),m.push(i),g=f+e,x=v+t}},b=function(e){var t=e.pathSegTypeAsLetter.toUpperCase();if("Z"!==t){switch(t){case"M":case"L":case"T":case"C":case"S":case"Q":g=e.x,x=e.y;break;case"H":g=e.x;break;case"V":x=e.y}h(g,x,e.pathSegType)}};for(o._svgPathToAbsolute(e),a=e.getTotalLength(),c=[],n=0;n<e.pathSegList.numberOfItems;n+=1)c.push(e.pathSegList.getItem(n));for(u=c.concat();y<a;){if((l=c[e.getPathSegAtLength(y)])!=d){for(;u.length&&u[0]!=l;)b(u.shift());d=l}switch(l.pathSegTypeAsLetter.toUpperCase()){case"C":case"T":case"S":case"Q":case"A":s=e.getPointAtLength(y),h(s.x,s.y,0)}y+=t}for(n=0,r=u.length;n<r;++n)b(u[n]);return m},o._svgPathToAbsolute=function(e){for(var t,n,o,i,r,a,s=e.pathSegList,l=0,c=0,u=s.numberOfItems,d=0;d<u;++d){var p=s.getItem(d),f=p.pathSegTypeAsLetter;if(/[MLHVCSQTA]/.test(f))"x"in p&&(l=p.x),"y"in p&&(c=p.y);else switch("x1"in p&&(o=l+p.x1),"x2"in p&&(r=l+p.x2),"y1"in p&&(i=c+p.y1),"y2"in p&&(a=c+p.y2),"x"in p&&(l+=p.x),"y"in p&&(c+=p.y),f){case"m":s.replaceItem(e.createSVGPathSegMovetoAbs(l,c),d);break;case"l":s.replaceItem(e.createSVGPathSegLinetoAbs(l,c),d);break;case"h":s.replaceItem(e.createSVGPathSegLinetoHorizontalAbs(l),d);break;case"v":s.replaceItem(e.createSVGPathSegLinetoVerticalAbs(c),d);break;case"c":s.replaceItem(e.createSVGPathSegCurvetoCubicAbs(l,c,o,i,r,a),d);break;case"s":s.replaceItem(e.createSVGPathSegCurvetoCubicSmoothAbs(l,c,r,a),d);break;case"q":s.replaceItem(e.createSVGPathSegCurvetoQuadraticAbs(l,c,o,i),d);break;case"t":s.replaceItem(e.createSVGPathSegCurvetoQuadraticSmoothAbs(l,c),d);break;case"a":s.replaceItem(e.createSVGPathSegArcAbs(l,c,p.r1,p.r2,p.angle,p.largeArcFlag,p.sweepFlag),d);break;case"z":case"Z":l=t,c=n}"M"!=f&&"m"!=f||(t=l,n=c)}}},function(e,t,n){var o={};e.exports=o;var i=n(6);n(0);o.create=i.create,o.add=i.add,o.remove=i.remove,o.clear=i.clear,o.addComposite=i.addComposite,o.addBody=i.addBody,o.addConstraint=i.addConstraint}])}));

// src/core/matter-js/PhysicsManager.js
/**
 * PhysicsManager - Manages the physics world and integrates with the game engine
 */
class PhysicsManager {
    constructor() {
        // Create Matter.js engine and world
        this.engine = Matter.Engine.create({
            enableSleeping: true
        });

        this.world = this.engine.world;

        // Configure world properties
        this.world.gravity.y = 0; // Default gravity (Off, we will process gravity per RigidBody)
        this.gravity = { x: 0, y: 1 }; // Custom gravity vector

        // Track all physics bodies and their associated game objects
        this.bodies = new Map(); // Maps Matter.js bodies to game objects
        this.gameObjectBodies = new Map(); // Maps game objects to physics bodies

        // Debug drawing options
        this.debugDraw = false;
        this.wireframes = true;

        // Performance settings
        this.fixedTimeStep = 1000 / 60; // 60 updates per second
        this.timeAccumulator = 0;

        // Wake up bodies without gravity on collision
        Matter.Events.on(this.engine, 'collisionStart', event => {
            event.pairs.forEach(pair => {
                [pair.bodyA, pair.bodyB].forEach(body => {
                    if (body.ignoreGravity && body.isSleeping) {
                        Matter.Sleeping.set(body, false);
                    }
                });
            });
        });

        console.log("Physics manager initialized");
    }

    /**
     * Set the gravity for the physics world
     * @param {number} x - X component of gravity
     * @param {number} y - Y component of gravity
     */
    setGravity(x, y) {
        this.world.gravity.x = x;
        this.world.gravity.y = y;
    }

    /**
     * Update physics world - called every frame
     * @param {number} deltaTime - Time in seconds since last frame
     */
    update(deltaTime) {
        // Use fixed timestep for more stable physics
        this.timeAccumulator += deltaTime * 1000; // Convert to ms

        // Clamp max steps per frame to avoid spiral of death
        const maxSteps = 5;
        let steps = 0;

        while (this.timeAccumulator >= this.fixedTimeStep && steps < maxSteps) {
            Matter.Engine.update(this.engine, this.fixedTimeStep);

            // Custom gravity application per body
            const gravity = this.gravity;
            this.bodies.forEach((gameObject, body) => {
                // Only apply gravity if body is dynamic, not static, and not ignoring gravity
                if (!body.isStatic && !body.ignoreGravity) {
                    // Apply gravity force: F = m * g
                    const force = {
                        x: body.mass * gravity.x * 0.001,
                        y: body.mass * gravity.y * 0.001
                    };
                    Matter.Body.applyForce(body, body.position, force);
                }
            });
            this.timeAccumulator -= this.fixedTimeStep;
            steps++;
        }

        // If too much time accumulated, drop the remainder to avoid spiral
        if (steps === maxSteps) {
            this.timeAccumulator = 0;
        }

        // Update game object positions based on physics bodies
        this.syncPhysicsBodies();
    }

    /**
     * Synchronize game object transforms with physics body positions
     */
    syncPhysicsBodies() {
        if (!this.bodies || this.bodies.size === 0) return;

        this.bodies.forEach((gameObject, body) => {
            if (!gameObject || !body) return;

            // Skip colliders that are managed by their own module
            if (body.plugin && body.plugin.isCollider) return;

            // Only update if the body is dynamic or kinematic
            if (!body.isStatic) {
                // Update position from physics body
                gameObject.position.x = body.position.x;
                gameObject.position.y = body.position.y;

                // Update rotation (Matter.js uses radians)
                gameObject.angle = body.angle * (180 / Math.PI);
            } else if (gameObject.rigidbody && gameObject.rigidbody.bodyNeedsUpdate) {
                // Update static body position if game object moved
                Matter.Body.setPosition(body, gameObject.position);
                Matter.Body.setAngle(body, gameObject.angle * (Math.PI / 180));
                gameObject.rigidbody.bodyNeedsUpdate = false;
            }
        });
    }

    /**
     * Register a body with the physics world and associate it with a game object
     * @param {Matter.Body} body - Physics body to register
     * @param {GameObject} gameObject - GameObject that owns this body
     */
    registerBody(body, gameObject) {
        if (!body || !gameObject) {
            console.warn("PhysicsManager.registerBody: Missing body or gameObject");
            return;
        }

        // Ensure maps are initialized
        if (!this.bodies) this.bodies = new Map();
        if (!this.gameObjectBodies) this.gameObjectBodies = new Map();

        try {
            // Store the mapping between body and game object
            this.bodies.set(body, gameObject);
            this.gameObjectBodies.set(gameObject, body);

            // Add body to the physics world if not already added
            if (this.engine && this.engine.world && !this.engine.world.bodies.includes(body)) {
                Matter.Composite.add(this.engine.world, body);
            }

            // Ensure static bodies are really static
            if (body.isStatic) {
                Matter.Body.setStatic(body, true);
            }
        } catch (error) {
            console.error("Error in PhysicsManager.registerBody:", error);
        }
    }

    /**
     * Remove a physics body from the world
     * @param {Matter.Body} body - The physics body to remove
     */
    removeBody(body) {
        if (body) {
            Matter.Composite.remove(this.world, body);
            this.bodies.delete(body);
        }
    }

    /**
     * Draw debug visualization of the physics world
     * @param {CanvasRenderingContext2D} ctx - The canvas rendering context
     */
    drawDebug(ctx) {
        if (!this.debugDraw) return;

        // Save context state
        ctx.save();

        // Render all bodies
        const bodies = Matter.Composite.allBodies(this.world);

        ctx.beginPath();

        for (let i = 0; i < bodies.length; i++) {
            const body = bodies[i];
            const vertices = body.vertices;

            ctx.moveTo(vertices[0].x, vertices[0].y);

            for (let j = 1; j < vertices.length; j++) {
                ctx.lineTo(vertices[j].x, vertices[j].y);
            }

            ctx.lineTo(vertices[0].x, vertices[0].y);
        }

        ctx.lineWidth = 1;
        ctx.strokeStyle = '#22ff22';
        ctx.stroke();

        // Render constraints
        const constraints = Matter.Composite.allConstraints(this.world);

        ctx.beginPath();

        for (let i = 0; i < constraints.length; i++) {
            const constraint = constraints[i];
            if (!constraint.render.visible) continue;

            const bodyA = constraint.bodyA;
            const bodyB = constraint.bodyB;
            const pointA = constraint.pointA;
            const pointB = constraint.pointB;

            // Point coordinates
            let pAx, pAy, pBx, pBy;

            // Calculate points
            if (bodyA) {
                pAx = bodyA.position.x + pointA.x;
                pAy = bodyA.position.y + pointA.y;
            } else {
                pAx = pointA.x;
                pAy = pointA.y;
            }

            if (bodyB) {
                pBx = bodyB.position.x + pointB.x;
                pBy = bodyB.position.y + pointB.y;
            } else {
                pBx = pointB.x;
                pBy = pointB.y;
            }

            ctx.moveTo(pAx, pAy);
            ctx.lineTo(pBx, pBy);
        }

        ctx.lineWidth = 1;
        ctx.strokeStyle = '#ff8822';
        ctx.stroke();

        // Restore context state
        ctx.restore();
    }

    /**
     * Reset the physics world
     */
    reset() {
        // Get all game objects linked to physics bodies before clearing
        const objectsToReset = new Map();
        this.bodies.forEach((gameObject, body) => {
            // Store the original position and rotation if they need to be reset
            objectsToReset.set(gameObject.id, {
                gameObject,
                originalPosition: gameObject.getOriginalPosition ? gameObject.getOriginalPosition() : gameObject.position.clone(),
                originalRotation: gameObject.originalRotation || 0
            });
        });

        // Clear all bodies and constraints
        Matter.Composite.clear(this.world);
        this.bodies.clear();

        // Reset positions of affected game objects
        objectsToReset.forEach(data => {
            // Reset to original position and rotation if available
            data.gameObject.position = data.originalPosition;
            data.gameObject.angle = data.originalRotation;
        });
    }
}

// src/core/Module.js
/**
 * Module - Base class for all game object modules
 * 
 * Modules can be attached to GameObjects to extend their functionality.
 * Each module goes through a specific lifecycle and can override methods
 * to implement custom behavior at different stages.
 * 
 * Lifecycle:
 * 1. preload - Called before the game starts, used for loading assets
 * 2. start - Called once when the module is first activated
 * 3. beginLoop - Called at the start of each frame
 * 4. loop - Called every frame (main update logic)
 * 5. endLoop - Called at the end of each frame
 * 6. draw - Called when the module should render
 * 7. onDestroy - Called when the module is being destroyed
 * 
 * 
 * NOTE: If you want to draw to a position relative to the viewport, you need to make sure
 * to set the gameObject's position to (0, 0) inside the module's loop method, to prevent any offset.
 * 
 * 
  ICON URL ADDITION(for module icon)
 class MyCustomModule extends Module {
    static iconUrl = 'path/to/icon.png';
    
    constructor() {
        super("MyCustomModule");
        // Module code
    }
}

class MyCustomModule extends Module {
    static iconClass = 'fa-star'; // Just the icon name
    // OR
    static iconClass = 'fas fa-star'; // Full class
    
    constructor() {
        super("MyCustomModule");
        // Module code
    }
}
 */
class Module {
    static allowMultiple = true; // Allow multiple instances of this module type
    static drawInEditor = true; // Whether this module should be drawn in the editor
    static namespace = "Core"; // Namespace for module categorization
    static description = "Base module class for game objects"; // Description of the module
    static iconClass = "fas fa-cube"; // Default icon class for the module

    /**
     * Create a new Module
     * @param {string} name - The name of this module instance
     */
    constructor(name = "Module") {
        this.type = this.constructor.name; // Module type

        /** @type {string} Name of the module */
        this.name = name;

        /** @type {GameObject} GameObject this module is attached to */
        this.gameObject = null;

        /** @type {boolean} Whether this module is active */
        this.enabled = true;

        this.ignoreGameObjectTransform = false; // If true, this module will not be affected by the gameObject's transform

        /** @type {Object} Custom properties for this module */
        this.properties = {};

        /** @type {Array<string>} Required modules for this module */
        this._requirements = [];
    }

    /**
     * Called before the game starts, used for loading assets
     * Override this to load resources needed by your module
     * @returns {Promise<void>}
     */
    async preload() {
        // Override in subclass to implement custom loading behavior
    }

    /**
     * Called once when the module is first activated
     * Use this for initialization logic
     */
    start() {
        // Override in subclass but provide safety
        if (!this.gameObject) {
            console.warn(`Module ${this.name} has no gameObject reference during start()`);
        }
    }

    /**
     * Called at the start of each frame
     * Useful for pre-update operations
     */
    beginLoop() {
        // Override in subclass to implement early frame behavior
    }

    /**
     * Called every frame (main update logic)
     * Use this for your main logic
     * @param {number} deltaTime - Time in seconds since the last frame
     */
    loop(deltaTime) {
        // Override in subclass but provide safety
        if (!this.gameObject) {
            console.warn(`Module ${this.name} has no gameObject reference during loop()`);
            this.enabled = false; // Disable to prevent further errors
        }
    }

    /**
     * Called at the end of each frame
     * Useful for post-update operations
     */
    endLoop() {
        // Override in subclass to implement late frame behavior  
    }

    /**
     * Called when the module should render
     * @param {CanvasRenderingContext2D} ctx - The canvas rendering context
     */
    draw(ctx) {
        // Override in subclass to implement rendering behavior
    }

    /**
     * Called when the module is being destroyed
     * Use this to clean up resources
     */
    onDestroy() {
        // Override in subclass to implement cleanup behavior
    }

    /**
     * Called when the module is attached to a GameObject
     * @param {GameObject} gameObject - The GameObject this module is attached to
     */
    onAttach(gameObject) {
        // This is called when the module is added to a GameObject
        // Override in subclasses if needed
    }

    onEnable() {
        // Called when the module is enabled
        // Override in subclasses if needed
    }

    onDisable() {
        // Called when the module is disabled
        // Override in subclasses if needed
    }

    /**
     * Define required modules for this module
     * Modules listed here will be automatically added before this module
     * @param {...string} moduleNames - List of module names required by this module
     */
    requires(...moduleNames) {
        if (!this._requirements) {
            this._requirements = [];
        }
        this._requirements.push(...moduleNames);
        return this;
    }

    /**
     * Require a single module for this module
     * @param {string} moduleName - The name of the module to require
     */
    requireModule(moduleName) {
        if (!this._requirements) {
            this._requirements = [];
        }
        this._requirements.push(moduleName);
    }

    require(moduleName) {
        this.requireModule(moduleName);
    }

    /**
     * Get all required modules for this module
     * @returns {Array<string>} Array of required module names
     */
    getRequirements() {
        return this._requirements || [];
    }

    /**
     * Get the world position of the attached GameObject
     * @returns {Vector2} World position 
     */
    getWorldPosition() {
        return this.gameObject ? this.gameObject.getWorldPosition() : new Vector2();
    }

    /**
     * Get the local position of the attached GameObject
     * @returns {Vector2} Local position
     */
    getLocalPosition() {
        return this.gameObject ? this.gameObject.position : new Vector2();
    }

    /**
     * Set the local position of the attached GameObject
     * @param {Vector2} position - New local position
     */
    setLocalPosition(position) {
        if (this.gameObject) {
            this.gameObject.position = position;
        }
    }

    set gameObject(go) {
        this._gameObject = go;

        // When a module's gameObject reference changes, we need to update
        // all internal properties that might reference the old gameObject
        if (go && this._previousGameObject && this._previousGameObject !== go) {
            this._updateInternalReferences(this._previousGameObject, go);
        }

        this._previousGameObject = go;
    }

    get gameObject() {
        return this._gameObject;
    }

    /**
     * Clone this module instance
     * @returns {Module} A new instance of this module with the same properties
     */
    clone(newGameObject = null) {
        // 1) create a fresh instance
        const cloned = new this.constructor(this.name);

        // Deep copy image asset and embedded image data
        if (this._image && this._isImageLoaded) {
            // If image is embedded, copy the data URL
            cloned._image = this._image;
            cloned._isImageLoaded = true;
            cloned._imageWidth = this._imageWidth;
            cloned._imageHeight = this._imageHeight;

            if (this.imageAsset && this.imageAsset.embedded) {
                cloned.imageAsset = {
                    path: null,
                    type: 'image',
                    embedded: true,
                    load: () => Promise.resolve(this._image)
                };
            } else if (this.imageAsset) {
                // Copy asset reference
                cloned.imageAsset = { ...this.imageAsset };
            }
        }

        // 2) copy all your own data except any gameObject pointers
        const keys = new Set([
            ...Object.getOwnPropertyNames(this),
            ...Object.keys(this)
        ]);
        keys.delete('gameObject');
        keys.delete('_gameObject');
        keys.delete('_previousGameObject');
        keys.delete('constructor');

        for (const key of keys) {
            const v = this[key];
            if (v == null || typeof v === 'function') {
                cloned[key] = v;
            }
            else if (Array.isArray(v)) {
                cloned[key] = v.map(item =>
                    (item && typeof item.clone === 'function')
                        ? item.clone()
                        : item
                );
            }
            else if (typeof v.clone === 'function') {
                cloned[key] = v.clone();
            }
            else if (typeof v === 'object') {
                cloned[key] = JSON.parse(JSON.stringify(v));
            }
            else {
                cloned[key] = v;
            }
        }

        // 3) reset any stale pointers
        cloned._gameObject = null;
        cloned._previousGameObject = null;

        // 4) if caller supplied an owner, bind now
        if (newGameObject) {
            cloned.attachTo(newGameObject);
        }

        return cloned;
    }

    /**
     * Helper: Deep clone an array
     * @private
     */
    deepCloneArray(arr) {
        if (!arr) return arr;

        return arr.map(item => {
            if (item === null || item === undefined || typeof item !== 'object') {
                return item;
            }
            else if (typeof item.clone === 'function') {
                return item.clone();
            }
            else if (Array.isArray(item)) {
                return this.deepCloneArray(item);
            }
            else if (!(item instanceof HTMLElement)) {
                return this.deepCloneObject(item);
            }
            return item;
        });
    }

    /**
     * Helper: Deep clone an object
     * @private
     */
    deepCloneObject(obj) {
        if (!obj) return obj;
        if (typeof obj.clone === 'function') return obj.clone();
        if (obj instanceof HTMLElement) return obj;

        const clone = Object.create(Object.getPrototypeOf(obj));

        for (const key in obj) {
            if (!Object.prototype.hasOwnProperty.call(obj, key)) continue;

            const value = obj[key];

            if (value === null || value === undefined || typeof value !== 'object') {
                clone[key] = value;
            }
            else if (typeof value.clone === 'function') {
                clone[key] = value.clone();
            }
            else if (Array.isArray(value)) {
                clone[key] = this.deepCloneArray(value);
            }
            else if (!(value instanceof HTMLElement)) {
                clone[key] = this.deepCloneObject(value);
            }
            else {
                clone[key] = value;
            }
        }

        return clone;
    }

    /**
     * Register a module class to be available in the Add Module dropdown
     * @param {Class} moduleClass - The module class to register
     */
    registerModuleClass(moduleClass) {
        if (!moduleClass || !(moduleClass.prototype instanceof Module)) {
            console.error('Not a valid module class:', moduleClass);
            return;
        }

        // Check if already registered
        const alreadyRegistered = this.availableModules.some(mod =>
            mod.name === moduleClass.name || mod === moduleClass);

        if (!alreadyRegistered) {
            this.availableModules.push(moduleClass);
            console.log(`Registered module: ${moduleClass.name}`);

            // Update the dropdown if it's open
            if (this.moduleDropdown &&
                this.moduleDropdown.style.display !== 'none') {
                this.populateModuleDropdown();
            }
        }
    }

    /**
     * Get the list of exposed properties that should be editable in the Inspector
     * @returns {Array<Object>} Array of property descriptors
     */
    getExposedProperties() {
        // Start with properties explicitly marked as exposed
        let exposed = this.exposedProperties || [];

        // Also include any properties in this.properties object
        for (const key in this.properties) {
            if (!exposed.some(prop => prop.name === key)) {
                exposed.push({
                    name: key,
                    type: typeof this.properties[key],
                    value: this.properties[key]
                });
            }
        }

        return exposed;
    }

    /**
     * Register a property to be exposed in the Inspector
     * @param {string} name - Property name
     * @param {string} type - Property type (string, number, boolean, etc.)
     * @param {any} defaultValue - Default value
     * @param {Object} options - Additional options (min, max, step, etc.)
     */
    exposeProperty(name, type, defaultValue, options = {}) {
        if (!this.exposedProperties) {
            this.exposedProperties = [];
        }

        this.exposedProperties.push({
            name,
            type,
            value: defaultValue,
            options
        });

        // Store the value in a private property with a different name
        // to avoid conflicts with getters/setters
        const privatePropName = `_${name}`;

        // Initialize the private property with the default value or current value
        if (this[privatePropName] === undefined) {
            this[privatePropName] = this[name] !== undefined ? this[name] : defaultValue;
        }

        // Create property accessor that uses the private property
        if (!Object.getOwnPropertyDescriptor(this, name)) {
            Object.defineProperty(this, name, {
                get: function () {
                    return this[privatePropName];
                },
                set: function (value) {
                    const oldValue = this[privatePropName];
                    this[privatePropName] = value;

                    // Call onChange handler if specified
                    const propDef = this.exposedProperties?.find(p => p.name === name);
                    if (propDef?.options?.onChange && oldValue !== value) {
                        propDef.options.onChange.call(this, value);
                    }
                },
                enumerable: true,
                configurable: true
            });
        }

        // Ensure the initial value is set properly
        if (this[name] !== this[privatePropName]) {
            this[name] = this[privatePropName];
        }
    }

    /**
     * Enable this module
     */
    enable() {
        this.enabled = true;
        this.onEnable();
    }

    /**
     * Disable this module
     */
    disable() {
        this.enabled = false;
        this.onDisable();
    }

    /**
     * Toggle this module's enabled state
     */
    toggle() {
        this.enabled = !this.enabled;

        if (this.enabled) {
            this.onEnable();
        } else {
            this.onDisable();
        }
    }

    /**
     * Get a module from the parent GameObject by type/class
     * @param {class} moduleType - The class/type of module to find
     * @returns {Module} The found module or null
     */
    getModule(moduleType) {
        if (!this.gameObject) return null;

        return this.gameObject.modules.find(module => module instanceof moduleType);
    }

    /**
     * Set a property value
     * @param {string} name - Property name
     * @param {any} value - New value
     */
    setProperty(name, value) {
        const privatePropName = `_${name}`;

        if (this.hasOwnProperty(privatePropName)) {
            // If we have a private property, use it
            this[privatePropName] = value;
        } else {
            // Otherwise set directly
            this[name] = value;
        }

        // Call onChange handler if specified in property options
        const propDef = this.exposedProperties?.find(p => p.name === name);
        if (propDef?.options?.onChange) {
            propDef.options.onChange.call(this, value);
        }
    }

    /**
     * Get a property value
     * @param {string} key - Property name
     * @param {any} defaultValue - Default value if property doesn't exist
     * @returns {any} The property value or default value
     */
    getProperty(name, defaultValue) {
        const privatePropName = `_${name}`;

        if (this.hasOwnProperty(privatePropName)) {
            // If we have a private property, use it
            return this[privatePropName];
        }

        // Otherwise get directly
        return this[name] !== undefined ? this[name] : defaultValue;
    }

    /**
     * Reassign this module to a new GameObject,
     * update internal refs and call onAttach.
     * @param {GameObject} newGameObject
     */
    attachTo(newGameObject) {
        // clear any stale pointer
        this._previousGameObject = null;
        // set the new owner
        this._gameObject = newGameObject;   // calls our setter
        // keep _previousGameObject in sync
        this._previousGameObject = newGameObject;

        if (typeof this.onAttach === 'function') {
            this.onAttach(newGameObject);
        }
    }

    /**
     * Serialize this module to JSON
     * @returns {Object} Serialized module data
     */
    toJSON() {
        // Basic module data
        const data = {
            name: this.name,
            type: this.constructor.name,
            enabled: this.enabled,
            requirements: this._requirements
        };

        // Serialize regular properties object
        data.properties = { ...this.properties };

        // Serialize exposed properties (both from exposedProperties and custom getters/setters)
        data.exposedValues = {};

        // Handle properties registered via exposeProperty
        if (Array.isArray(this.exposedProperties)) {
            for (const prop of this.exposedProperties) {
                const propName = prop.name;
                // Get the current value using our getter
                const value = this[propName];

                // Only serialize non-undefined values
                if (value !== undefined) {
                    // Special handling for objects that have their own toJSON method
                    if (value && typeof value === 'object' && typeof value.toJSON === 'function') {
                        data.exposedValues[propName] = value.toJSON();
                    } else if (value instanceof Vector2) {
                        // Special case for Vector2 objects
                        data.exposedValues[propName] = { x: value.x, y: value.y };
                    } else {
                        // For primitive values and regular objects
                        data.exposedValues[propName] = value;
                    }
                }
            }
        }

        // Allow subclasses to add their own serialization
        if (typeof this._serializeCustomData === 'function') {
            const customData = this._serializeCustomData();
            if (customData && typeof customData === 'object') {
                data.customData = customData;
            }
        }

        return data;
    }

    /**
     * Deserialize from JSON data
     * @param {Object} json - Serialized module data 
     */
    fromJSON(json) {
        if (!json) return this;

        // Restore basic properties
        this.name = json.name || this.name;
        this.enabled = json.enabled !== undefined ? json.enabled : this.enabled;
        this._requirements = json.requirements || this._requirements || [];

        // Restore regular properties object
        this.properties = json.properties || {};

        // Restore exposed property values
        if (json.exposedValues) {
            for (const propName in json.exposedValues) {
                const value = json.exposedValues[propName];

                // Handle Vector2 values
                if (value && typeof value === 'object' &&
                    'x' in value && 'y' in value &&
                    typeof this[propName] === 'object' &&
                    this[propName] instanceof Vector2) {
                    this[propName].x = value.x;
                    this[propName].y = value.y;
                }
                // Handle objects with fromJSON method
                else if (this[propName] &&
                    typeof this[propName] === 'object' &&
                    typeof this[propName].fromJSON === 'function' &&
                    value) {
                    this[propName].fromJSON(value);
                }
                // Regular values
                else {
                    // Use setProperty if available, otherwise set directly
                    if (typeof this.setProperty === 'function') {
                        this.setProperty(propName, value);
                    } else {
                        this[propName] = value;
                    }
                }
            }
        }

        // Allow subclasses to handle custom data
        if (json.customData && typeof this._deserializeCustomData === 'function') {
            this._deserializeCustomData(json.customData);
        }

        return this;
    }

    /**
     * Update all internal references to the old gameObject with the new one
     * @param {GameObject} oldGO - The old GameObject reference
     * @param {GameObject} newGO - The new GameObject reference
     */
    _updateInternalReferences(oldGO, newGO) {
        if (!oldGO || !newGO || oldGO === newGO) return;

        // Recursively scan all properties
        const scanObject = (obj) => {
            if (!obj || typeof obj !== 'object') return;

            // Skip DOM elements and functions
            if (obj instanceof HTMLElement) return;

            // Use a WeakSet to track visited objects to avoid circular references
            const visited = new WeakSet();

            const traverse = (o) => {
                if (!o || typeof o !== 'object' || visited.has(o)) return;
                visited.add(o);

                // Check all enumerable properties of the object
                for (const key in o) {
                    try {
                        const value = o[key];

                        // If the value is the old GameObject, replace it with the new one
                        if (value === oldGO) {
                            o[key] = newGO;
                            continue;
                        }

                        // Recursively traverse objects and arrays
                        if (value && typeof value === 'object' && !visited.has(value)) {
                            traverse(value);
                        }
                    } catch (err) {
                        // Some properties may not be accessible, just skip them
                    }
                }

                // Check non-enumerable properties as well (for properties defined with Object.defineProperty)
                const propNames = Object.getOwnPropertyNames(o);
                for (const propName of propNames) {
                    try {
                        if (propName === 'constructor' || propName === 'prototype' || propName === '__proto__') {
                            continue;
                        }

                        const desc = Object.getOwnPropertyDescriptor(o, propName);
                        if (desc && desc.get && !desc.configurable) {
                            // We can't modify non-configurable getters/setters
                            continue;
                        }

                        const value = o[propName];
                        if (value === oldGO) {
                            o[propName] = newGO;
                            continue;
                        }

                        if (value && typeof value === 'object' && !visited.has(value)) {
                            traverse(value);
                        }
                    } catch (err) {
                        // Some properties may not be accessible, just skip them
                    }
                }
            };

            traverse(obj);
        };

        // Check own properties first
        for (const key in this) {
            if (key !== 'gameObject' && key !== '_gameObject' && key !== '_previousGameObject') {
                const value = this[key];
                if (value === oldGO) {
                    this[key] = newGO;
                } else if (value && typeof value === 'object') {
                    scanObject(value);
                }
            }
        }
    }

    /**
     * Override in subclasses to serialize additional module-specific data
     * @protected
     * @returns {Object|null} Custom serialized data
     */
    _serializeCustomData() {
        return null; // Default implementation
    }

    /**
     * Override in subclasses to deserialize module-specific data
     * @protected
     * @param {Object} data - Custom data to deserialize
     */
    _deserializeCustomData(data) {
        // Default implementation does nothing
    }
}

// Make the Module class available globally
window.Module = Module;

// src/core/ModuleRegistry.js
/**
 * ModuleRegistry - Central registry for all module types available in the engine
 * Used for tracking available modules across the editor
 */
class ModuleRegistry {
    constructor() {
        this.modules = new Map();
        this.listeners = [];
    }

    /**
     * Register a module class with the registry
     * @param {Class} moduleClass - The module class to register
     * @returns {boolean} True if successfully registered
     */
    register(moduleClass) {
        if (!moduleClass || !(moduleClass.prototype instanceof Module)) {
            console.error('Cannot register invalid module class:', moduleClass);
            return false;
        }

        // Skip if already registered
        if (this.modules.has(moduleClass.name)) {
            return false;
        }

        // Register the module
        this.modules.set(moduleClass.name, moduleClass);
        console.log(`Registered module: ${moduleClass.name}`);
        
        // Notify listeners
        this.notifyListeners('register', moduleClass);
        return true;
    }

    /**
     * Unregister a module class
     * @param {string|Class} moduleNameOrClass - Module name or class to unregister
     * @returns {boolean} True if successfully unregistered
     */
    unregister(moduleNameOrClass) {
        const moduleName = typeof moduleNameOrClass === 'string' 
            ? moduleNameOrClass 
            : moduleNameOrClass.name;
        
        const moduleClass = this.modules.get(moduleName);
        if (!moduleClass) {
            return false;
        }
        
        this.modules.delete(moduleName);
        console.log(`Unregistered module: ${moduleName}`);
        
        // Notify listeners
        this.notifyListeners('unregister', moduleClass);
        return true;
    }

    /**
     * Get a module class by name
     * @param {string} name - Name of the module class
     * @returns {Class|null} The module class, or null if not found
     */
    getModuleClass(name) {
        return this.modules.get(name) || null;
    }

    /**
     * Get all registered module classes
     * @returns {Array<Class>} Array of module classes
     */
    getAllModules() {
        return Array.from(this.modules.values());
    }

    /**
     * Add a listener for registry events
     * @param {Function} callback - Callback function(event, moduleClass)
     */
    addListener(callback) {
        if (typeof callback === 'function' && !this.listeners.includes(callback)) {
            this.listeners.push(callback);
        }
    }

    /**
     * Remove a listener
     * @param {Function} callback - The callback to remove
     */
    removeListener(callback) {
        const index = this.listeners.indexOf(callback);
        if (index !== -1) {
            this.listeners.splice(index, 1);
        }
    }

    /**
     * Notify all listeners of an event
     * @param {string} eventName - Name of the event ('register', 'unregister')
     * @param {Class} moduleClass - The module class involved
     */
    notifyListeners(eventName, moduleClass) {
        this.listeners.forEach(callback => {
            try {
                callback(eventName, moduleClass);
            } catch (error) {
                console.error('Error in module registry listener:', error);
            }
        });
    }
}

// Create and export the global registry
window.moduleRegistry = new ModuleRegistry();

// src/core/ModuleReloader.js
/**
 * ModuleReloader - Handles dynamic reloading of modules without requiring browser refresh
 */
class ModuleReloader {
    constructor() {
        this.moduleRegistry = window.moduleRegistry || null;
        this.scriptCache = new Map(); // Store the latest script content
    }

    /**
     * Reload a specific module class from its script content
     * @param {string} className - The module class name
     * @param {string} scriptContent - The script content
     * @returns {boolean} Success status
     */
    reloadModuleClass(className, scriptContent) {
        try {
            // Cache the script content
            this.scriptCache.set(className, scriptContent);

            // Check for ES module syntax
            if (/^\s*(import|export)\s/m.test(scriptContent)) {
                console.error(`Module script for ${className} contains ES module syntax (import/export). Cannot reload dynamically.`);
                return false;
            }

            // Debug log the script content
            // console.log("Evaluating module script for", className, ":\n", scriptContent);

            // Wrap in IIFE to avoid leaking variables
            const wrappedScript = `
            try {
                (function() {
                    ${scriptContent}
                })();
                return ${className};
            } catch (error) {
                console.error("Error evaluating module script:", error);
                return null;
            }
        `;

            // Create a new function to evaluate the script in the global scope
            const scriptFunction = new Function(wrappedScript);

            // Execute the script to get the class
            const ModuleClass = scriptFunction();

            if (!ModuleClass) {
                console.error(`Failed to reload module ${className}: Script did not return a class`);
                return false;
            }

            // Register the class globally
            window[className] = ModuleClass;

            // Register with moduleRegistry if available
            if (this.moduleRegistry) {
                this.moduleRegistry.register(ModuleClass);
            } else {
                console.warn("ModuleRegistry not available, could not register updated module");
            }

            console.log(`Successfully reloaded module: ${className}`);
            return true;
        } catch (error) {
            console.error(`Error reloading module ${className}:`, error);
            return false;
        }
    }

    /**
     * Update all instances of a module type with new class implementation
     * @param {string} className - Module class name to update
     * @param {Array<GameObject>} gameObjects - Array of GameObjects to search through
     * @returns {number} Number of module instances updated
     */
    updateModuleInstances(className, gameObjects) {
        let updatedCount = 0;

        const ModuleClass = window[className];
        if (!ModuleClass) {
            console.error(`Cannot update instances of ${className}: Class not found`);
            return 0;
        }

        // Helper function to traverse the game object hierarchy
        const traverseAndUpdate = (objects) => {
            objects.forEach(obj => {
                // Find matching modules
                obj.modules.forEach((module, index) => {
                    if (module.constructor.name === className) {
                        // Store the module's current properties
                        const oldProps = {};
                        Object.keys(module).forEach(key => {
                            if (key !== 'constructor' && typeof module[key] !== 'function') {
                                oldProps[key] = module[key];
                            }
                        });

                        // Create a new module instance
                        const newModule = new ModuleClass();

                        // Copy over important references and properties
                        newModule.gameObject = obj;
                        newModule.enabled = module.enabled;
                        newModule.id = module.id; // Keep the same ID

                        // Copy over all other properties from old module
                        Object.keys(oldProps).forEach(key => {
                            if (key !== 'gameObject' && key !== 'constructor') {
                                newModule[key] = oldProps[key];
                            }
                        });

                        // Replace the module in the object's modules array
                        obj.modules[index] = newModule;
                        updatedCount++;
                    }
                });

                // Recursively process children
                if (obj.children && obj.children.length > 0) {
                    traverseAndUpdate(obj.children);
                }
            });
        };

        traverseAndUpdate(gameObjects);
        return updatedCount;
    }
}

// Create global instance
window.moduleReloader = new ModuleReloader();

// src/core/ModuleManager.js
/**
 * ModulesManager - Handles registration and initialization of modules
 */
class ModulesManager {
    constructor() {
        this.loadedModules = new Map();
        
        // Define core modules that should always be available
        this.coreModules = [
            'SpriteRenderer',
            'RigidBody', 
            'Collider',
            'BoundingBoxCollider',
            'DrawCircle',
            'DrawRectangle'
            //'BabylonRenderer'
        ];
    }

    /**
     * Initialize all core modules
     */
    initializeCoreModules() {
        console.log("Initializing core modules...");
        
        // Ensure moduleRegistry exists
        if (!window.moduleRegistry) {
            console.error("ModuleRegistry not found, modules cannot be loaded");
            return;
        }
        
        // Load core modules
        for (const moduleName of this.coreModules) {
            // Check if module constructor exists in window
            if (window[moduleName]) {
                console.log(`Registering core module: ${moduleName}`);
                window.moduleRegistry.register(window[moduleName]);
                this.loadedModules.set(moduleName, window[moduleName]);
            } else {
                console.error(`Core module not found: ${moduleName}`);
            }
        }
        
        console.log("Core modules initialized");
    }

    /**
     * Get available modules for adding to GameObjects
     * @returns {Array} Array of module names
     */
    getAvailableModules() {
        return Array.from(this.loadedModules.keys());
    }
    
    /**
     * Create a new instance of a module
     * @param {string} moduleName - The name of the module to create
     * @returns {Module|null} The created module or null if not found
     */
    createModule(moduleName) {
        const ModuleClass = this.loadedModules.get(moduleName);
        
        if (ModuleClass) {
            try {
                return new ModuleClass();
            } catch (error) {
                console.error(`Error creating module ${moduleName}:`, error);
                return null;
            }
        }
        
        return null;
    }
}

// Make the ModulesManager available globally
window.modulesManager = new ModulesManager();

// src/core/GameObject.js
class GameObject {
    constructor(name = "GameObject", engine = null) {
        this.name = name;
        this.position = new Vector2();
        this.size = new Vector2(50, 50); // Default size in pixels for collision detection
        this.useCollisions = false; // Whether to use collision detection
        this.origin = new Vector2(0.5, 0.5); // Centered by default
        this.scale = new Vector2(1, 1);
        this.angle = 0;
        this.depth = 0;
        this.depthToY = false; // Whether to adjust depth based on Y position
        this.visible = true;
        this.modules = [];
        this.children = [];
        this.parent = null;
        this.active = true;
        this.colliderWidth = this.size.x; // For collision detection
        this.colliderHeight = this.size.y; // For collision detection
        this.tags = [];
        this.selected = false; // Track if selected in editor
        this.expanded = false; // Track if expanded in hierarchy
        this.editorColor = this.generateRandomColor(); // Color in editor view
        this.id = crypto.randomUUID(); // Generate unique ID

        this.usePolygonCollision = false; // Enable polygon collision
        this.polygonPointCount = 3; // Number of points in the polygon
        this.polygonAngleOffset = 0; // Angle offset for polygon points
        this.polygonPoints = []; // Array of Vector2 points for polygon
        this.polygon = null; // Polygon instance

        this.engine = engine; // Reference to the engine instance, set when added to engine

        this.xd = 0; // X Position for drawing (for viewport offsets)
        this.yd = 0; // Y Position for drawing (for viewport offsets)

        this.collisionEnabled = true;  // Flag to enable/disable collision
        this.collisionLayer = 0;       // Collision layer for filtering
        this.collisionMask = 0xFFFF;   // Collision mask for filtering

        // Keep track of original position and rotation
        this.originalPosition = this.position.clone();
        this.originalRotation = this.angle;

        this.previousPosition = this.position.clone(); // For movement tracking

        if (this.usePolygonCollision) {
            this.generatePolygonPoints();
        }
    }

    getNearestObject(gameObjectName, maxRange = Infinity) {
        // Use global gameObjects array if available
        const eng = window.engine || this.engine || null;

        return eng.findNearestObjectByName(this.position.x, this.position.y, gameObjectName, maxRange);
    }

    generateRandomColor() {
        // Generate a semi-bright color for better visibility on dark backgrounds
        const hue = Math.floor(Math.random() * 360);
        return `hsl(${hue}, 70%, 60%)`;
    }

    // Track original position (useful when cloning)
    getOriginalPosition() {
        return this.originalPosition || this.position.clone();
    }

    async preload() {
        for (const module of this.modules) {
            try {
                if (module.enabled && module.preload) await module.preload();
            } catch (error) {
                console.error(`Error in module ${module.type || module.constructor.name} preload on ${this.name}:`, error);
            }
        }
        for (const child of this.children) {
            await child.preload();
        }
    }

    start() {
        if (!this.active) return;

        // Save initial position and rotation when the game starts
        this.originalPosition = this.position.clone();
        this.originalRotation = this.angle;

        // Initialize modules and children
        this.modules.forEach(module => {
            try {
                if (module.enabled && module.start) module.start();
            } catch (error) {
                console.error(`Error in module ${module.type || module.constructor.name} start on ${this.name}:`, error);
            }
        });
        this.children.forEach(child => child.start());
    }

    beginLoop() {
        if (!this.active) return;

        this.colliderWidth = this.size.x; // For collision detection
        this.colliderHeight = this.size.y; // For collision detection

        this.previousPosition = this.position.clone(); // For movement tracking

        this.modules.forEach(module => {
            try {
                if (module.enabled && module.beginLoop) module.beginLoop();
            } catch (error) {
                console.error(`Error in module ${module.type || module.constructor.name} beginLoop on ${this.name}:`, error);
            }
        });
        this.children.forEach(child => child.beginLoop());
    }

    loop(deltaTime) {
        if (!this.active) return;

        // Update depth based on Y position if enabled
        if (this.depthToY) {
            this.depth = Math.floor(this.position.y);
        }

        // Update polygon if enabled
        if (this.usePolygonCollision && this.polygon) {
            this.polygon.update(this.position.clone(), this.angle + this.polygonAngleOffset);
        }

        this.modules.forEach(module => {
            try {
                if (module.enabled && module.loop) module.loop(deltaTime);
            } catch (error) {
                console.error(`Error in module ${module.type || module.constructor.name} loop on ${this.name}:`, error);
            }
        });
        this.children.forEach(child => child.loop(deltaTime));
    }

    endLoop() {
        if (!this.active) return;
        this.modules.forEach(module => {
            try {
                if (module.enabled && module.endLoop) module.endLoop();
            } catch (error) {
                console.error(`Error in module ${module.type || module.constructor.name} endLoop on ${this.name}:`, error);
            }
        });
        this.children.forEach(child => child.endLoop());
    }

    /**
     * Draw this GameObject and its modules during runtime
     * @param {CanvasRenderingContext2D} ctx - The rendering context
     */
    draw(ctx) {
        if (!this.active || !this.visible) return;

        // PIXI rendering path
        if (window.engine && window.engine.usePixi && window.engine.pixiRenderer && ctx === window.engine.pixiRenderer) {
            // Ensure Pixi display object exists
            if (!this.pixiDisplayObject) {
                this.createPixiDisplayObject();
                window.engine.pixiRenderer.addDisplayObject(this.pixiDisplayObject);
            }
            this.updatePixiDisplayObject();

            // Draw modules that support Pixi rendering
            for (const module of this.modules) {
                if (module.enabled && typeof module.draw === 'function') {
                    try {
                        // If module supports Pixi, pass pixiDisplayObject or pixiRenderer
                        module.draw(ctx, this.pixiDisplayObject);
                    } catch (error) {
                        console.error(`Error in module ${module.type || module.constructor.name} draw (Pixi) on ${this.name}:`, error);
                    }
                }
            }

            // Draw children
            this.children.forEach(child => {
                if (child.active && child.visible) {
                    child.draw(ctx);
                }
            });

            return;
        }

        ctx.save();

        // Apply local transform
        const worldPos = this.getWorldPosition();
        const worldAngle = this.getWorldRotation();
        const worldScale = this.getWorldScale();

        ctx.translate(worldPos.x, worldPos.y);
        ctx.rotate(worldAngle * Math.PI / 180);
        ctx.scale(worldScale.x, worldScale.y);

        // Track if any module actually drew something
        let moduleDidDraw = false;

        // Always draw the fallback shape first to ensure object visibility
        //this.drawFallbackShape(ctx);

        // Draw modules
        for (const module of this.modules) {
            if (module.enabled && typeof module.draw === 'function') {
                try {
                    if (module.ignoreGameObjectTransform) {
                        ctx.restore(); // Remove transform
                        module.draw(ctx); // Draw in world space
                        ctx.save();
                        ctx.translate(worldPos.x, worldPos.y);
                        ctx.rotate(worldAngle * Math.PI / 180);
                        ctx.scale(worldScale.x, worldScale.y);
                    } else {
                        module.draw(ctx);
                    }
                    moduleDidDraw = true;
                } catch (error) {
                    console.error(`Error in module ${module.type || module.constructor.name} draw on ${this.name}:`, error);
                }
            }
        }

        ctx.restore();

        // Draw all children
        this.children.forEach(child => {
            if (child.active && child.visible) {
                child.draw(ctx);
            }
        });
    }

    /**
     * Draw representation of this GameObject in the editor
     * @param {CanvasRenderingContext2D} ctx - The rendering context
     */
    drawInEditor(ctx) {
        if (!this.active) return;

        // Draw this object
        ctx.save();

        // Apply transformations
        const worldPos = this.getWorldPosition();
        const worldAngle = this.getWorldRotation();
        const worldScale = this.getWorldScale();

        ctx.translate(worldPos.x, worldPos.y);
        ctx.rotate(worldAngle * Math.PI / 180);
        ctx.scale(worldScale.x, worldScale.y);

        // Check if any module has a draw method and can be drawn in editor
        let moduleDidDraw = false;

        // Draw modules that support rendering
        for (const module of this.modules) {
            // Check for modules that should draw in editor
            if (module.enabled && typeof module.draw === 'function') {
                try {
                    // Instead of trying to analyze the function code, let's use a pattern
                    // where modules can explicitly indicate if they should be drawn in editor

                    // Option 1: Check for module.drawInEditor flag
                    if (module.drawInEditor === false) {
                        continue;
                    }

                    // Option 2: Use a canvas measuring approach - detect if anything was drawn
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = 100;
                    tempCanvas.height = 100;
                    const tempCtx = tempCanvas.getContext('2d');

                    // Clear the temp canvas and save its state
                    tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                    tempCtx.save();
                    tempCtx.translate(50, 50); // Center for drawing

                    // Get image data before drawing
                    const beforeData = tempCtx.getImageData(0, 0, 100, 100).data;

                    // Try to draw
                    module.draw(tempCtx);

                    // Get image data after drawing
                    const afterData = tempCtx.getImageData(0, 0, 100, 100).data;

                    // Check if anything changed
                    let hasDrawnSomething = false;
                    for (let i = 0; i < beforeData.length; i += 4) {
                        if (beforeData[i] !== afterData[i] ||
                            beforeData[i + 1] !== afterData[i + 1] ||
                            beforeData[i + 2] !== afterData[i + 2] ||
                            beforeData[i + 3] !== afterData[i + 3]) {
                            hasDrawnSomething = true;
                            break;
                        }
                    }

                    // Restore temp context
                    tempCtx.restore();

                    if (!hasDrawnSomething) {
                        continue; // Module's draw didn't change anything visually
                    }

                    // Now we know the module actually draws something, so use it in the main context
                    module.draw(ctx);
                    moduleDidDraw = true;
                } catch (error) {
                    console.error(`Error drawing module ${module.type || module.constructor.name} in editor:`, error);
                }
            }
        }

        // If no module drew anything, draw the default representation
        if (!moduleDidDraw) {
            // Draw square representation
            const size = 20; // Base size
            ctx.beginPath();
            ctx.rect(-size / 2, -size / 2, size, size);
            ctx.fillStyle = this.selected ? '#ffffff' : this.editorColor;
            ctx.fill();

            // Draw origin point
            ctx.beginPath();
            ctx.arc(0, 0, 2, 0, Math.PI * 2);
            ctx.fillStyle = '#ff0000';
            ctx.fill();
        }

        // Always draw the angle indicator line for better orientation
        const size = 20; // Base size for consistency with default representation
        const lineLength = size * 1.5; // Length of the line - 1.5x the size
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(lineLength, 0);
        ctx.strokeStyle = '#ffcc00'; // Distinct yellow color for angle line
        ctx.lineWidth = 2 / (this.editor?.camera?.zoom || 1);
        ctx.stroke();

        // Add arrowhead to angle line
        ctx.beginPath();
        ctx.moveTo(lineLength, 0);
        ctx.lineTo(lineLength - 5, -3);
        ctx.lineTo(lineLength - 5, 3);
        ctx.closePath();
        ctx.fillStyle = '#ffcc00';
        ctx.fill();

        if (!this.usePolygonCollision && this.useCollisions) {
            ctx.beginPath();
            ctx.rect(
                -this.size.x / 2,
                -this.size.y / 2,
                this.size.x,
                this.size.y
            );
            ctx.setLineDash([5, 3]); // Dashed line: 5px dash, 3px gap
            ctx.strokeStyle = "#00ff00";
            ctx.lineWidth = 1 / (this.editor?.camera?.zoom || 1);
            ctx.stroke();
            ctx.setLineDash([]); // Reset to solid for future drawing
        }

        if (this.usePolygonCollision && this.polygon) {
            ctx.save();
            ctx.setLineDash([5, 3]);
            // Apply polygonAngleOffset rotation
            ctx.rotate((this.polygonAngleOffset || 0) * Math.PI / 180);
            this.polygon.draw(ctx, "#00ff00");
            ctx.setLineDash([]);
            ctx.restore();
        }

        // Draw selection outline if selected
        if (this.selected) {
            // Draw either around the module bounds or the default square
            if (moduleDidDraw) {
                // Draw a slightly larger selection outline
                ctx.strokeStyle = '#00aaff';
                ctx.lineWidth = 2 / (this.editor?.camera?.zoom || 1);
                // A slightly larger rectangle than the typical module would draw
                // This is an approximation - ideally modules would report their bounds
                ctx.strokeRect(-size / 2, -size / 2, size, size);
            } else {
                ctx.strokeStyle = '#00aaff';
                ctx.lineWidth = 2 / (this.editor?.camera?.zoom || 1);
                ctx.strokeRect(-size / 2, -size / 2, size, size);
            }
        }

        ctx.restore();

        // Draw name (always upright)
        if (this.selected) {
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText(this.name, worldPos.x, worldPos.y - 25);
        }

        // Draw children
        this.children.forEach(child => {
            if (child.active) {
                child.drawInEditor(ctx);
            }
        });
    }

    /**
     * Get the bounding box of this GameObject in world coordinates
     * @returns {Object} The bounding box with x, y, width, height properties
     */
    getBoundingBox() {
        const worldPos = this.getWorldPosition();
        const worldScale = this.getWorldScale();
        const worldAngle = this.getWorldRotation();

        // Calculate the effective width and height
        const effectiveWidth = this.width * worldScale.x;
        const effectiveHeight = this.height * worldScale.y;

        // If there's no rotation, return a simple axis-aligned box
        if (worldAngle % 360 === 0) {
            return {
                x: worldPos.x - effectiveWidth / 2,
                y: worldPos.y - effectiveHeight / 2,
                width: effectiveWidth,
                height: effectiveHeight,
                rotation: 0
            };
        }

        // For rotated objects, return an oriented bounding box
        return {
            x: worldPos.x,
            y: worldPos.y,
            width: effectiveWidth,
            height: effectiveHeight,
            rotation: worldAngle
        };
    }

    /**
     * Draw a simple shape to represent the GameObject when no modules are drawing
     * @param {CanvasRenderingContext2D} ctx - The rendering context
     */
    drawFallbackShape(ctx) {
        // Draw circle representation
        const size = 10;
        ctx.beginPath();
        ctx.arc(0, 0, size, 0, Math.PI * 2);
        ctx.fillStyle = this.editorColor || '#ffffff';
        ctx.fill();
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.stroke();
    }

    onDestroy() {
        this.modules.forEach(module => {
            if (module.onDestroy) module.onDestroy();
        });
        this.children.forEach(child => child.onDestroy());
    }

    /**
     * Check collision with any nearby GameObjects of a given name within a set range
     * @param {string} name - The name of GameObjects to check against
     * @param {number} range - The range (in pixels) to search for nearby objects
     * @param {Array<GameObject>} [gameObjects] - Optional array of all game objects to search (defaults to window.gameObjects)
     * @returns {GameObject|null} The first colliding GameObject found, or null if none
     */
    collidesWithNearby(name, range, gameObjects) {
        // Use global gameObjects array if not provided
        const allObjects = gameObjects || window.gameObjects || [];
        const myPos = this.getWorldPosition();

        for (const obj of allObjects) {
            if (
                obj !== this &&
                obj.name === name &&
                obj.active &&
                obj.visible &&
                obj.collisionEnabled
            ) {
                // Quick distance check
                const objPos = obj.getWorldPosition();
                const dx = objPos.x - myPos.x;
                const dy = objPos.y - myPos.y;
                if ((dx * dx + dy * dy) <= range * range) {
                    // Check collision
                    if (this.collidesWith(obj)) {
                        return obj;
                    }
                }
            }
        }
        return null;
    }

    /**
     * Check if this GameObject collides with another GameObject
     * @param {GameObject} other - The other GameObject to check collision with
     * @returns {boolean} True if colliding
     */
    collidesWith(other) {
        // Skip collision check if either object has collisions disabled
        if (!this.collisionEnabled || !other.collisionEnabled) {
            return false;
        }

        // Skip collision check if collision layers don't match
        if ((this.collisionLayer & other.collisionMask) === 0 &&
            (other.collisionLayer & this.collisionMask) === 0) {
            return false;
        }

        // Get bounding boxes
        const thisBox = this.getBoundingBox();
        const otherBox = other.getBoundingBox();

        // AABB collision check (ignoring rotation)
        return (
            thisBox.x < otherBox.x + otherBox.width &&
            thisBox.x + thisBox.width > otherBox.x &&
            thisBox.y < otherBox.y + otherBox.height &&
            thisBox.y + thisBox.height > otherBox.y
        );
    }

    /*
        Returns an array of all GameObjects this object is currently colliding with
    */
    checkForCollisions() {
        const collisions = [];
        const allObjects = window.engine.getAllObjects();

        allObjects.forEach(obj => {
            if (obj !== this && this.collidesWith(obj) && obj.collisionEnabled) {
                collisions.push(obj);
            }
        });

        return collisions;
    }

    /**
     * Set collision layer and mask
     * @param {number} layer - The collision layer this object belongs to
     * @param {number} mask - Bitmask of layers this object should collide with
     */
    setCollision(layer, mask = 0xFFFF) {
        this.collisionLayer = layer;
        this.collisionMask = mask;
    }

    /**
     * Enable or disable collision for this GameObject
     * @param {boolean} enabled - Whether collision should be enabled
     */
    setCollisionEnabled(enabled) {
        this.collisionEnabled = enabled;
    }

    /**
     * Check polygon collision with another GameObject
     * @param {GameObject} other
     * @returns {boolean}
     */
    collidesWithPolygon(other) {
        if (!this.usePolygonCollision || !other.usePolygonCollision) return false;
        if (!this.polygon || !other.polygon) return false;
        return this.polygon.collidesWith(other.polygon);
    }

    /**
     * Check if a point is inside this GameObject's polygon
     * @param {number} x
     * @param {number} y
     * @returns {boolean}
     */
    polygonContainsPoint(x, y) {
        if (!this.usePolygonCollision || !this.polygon) return false;
        return this.polygon.collisionPoint(x, y);
    }

    /**
     * Get all GameObjects this polygon collides with
     * @returns {Array<GameObject>}
     */
    checkPolygonCollisions() {
        if (!this.usePolygonCollision || !this.polygon) return [];
        const allObjects = window.engine.getAllObjects();
        return allObjects.filter(obj =>
            obj !== this &&
            obj.usePolygonCollision &&
            obj.polygon &&
            this.collidesWithPolygon(obj)
        );
    }

    generatePolygonPoints() {
        const count = Math.max(3, this.polygonPointCount);
        const radius = Math.max(this.size.x, this.size.y) / 2;
        this.polygonPoints = [];
        for (let i = 0; i < count; i++) {
            const angle = (2 * Math.PI * i) / count;
            const x = this.position.x + Math.cos(angle) * radius;
            const y = this.position.y + Math.sin(angle) * radius;
            // Points should be relative to (0,0), not this.position
            this.polygonPoints.push(new Vector2(x, y));
        }
        // Always center polygon at the GameObject's position
        this.polygon = new Polygon(this, this.position.clone(), ...this.polygonPoints.map(pt => pt.clone()));
    }

    /**
     * Add a module to this GameObject
     * @param {Module} module - The module to add
     * @returns {Module} The added module
     */
    addModule(module) {
        if (!module) return null;

        // Check if this type of module is already attached
        const cls = module.constructor;
        if (cls.allowMultiple === false) {
            const already = this.getModuleByType(cls.name);
            if (already) {
                console.warn(`Only one ${cls.name} allowed on a GameObject.`);
                return already;
            }
        }

        // Generate a unique ID for the module if it doesn't have one
        if (!module.id) {
            module.id = crypto.randomUUID ? crypto.randomUUID() : `m-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
        }

        // Add required modules first
        const requirements = module.getRequirements ? module.getRequirements() : [];
        for (const requiredName of requirements) {
            // Check if we already have this module
            const existingReq = this.getModuleByType(requiredName);
            if (!existingReq) {
                console.log(`Adding required module: ${requiredName} for ${module.constructor.name}`);

                // Try to get the module class
                let ModuleClass = null;

                // First try to get from registry
                if (window.moduleRegistry) {
                    ModuleClass = window.moduleRegistry.getModuleClass(requiredName);
                }

                // Fall back to global scope
                if (!ModuleClass && window[requiredName]) {
                    ModuleClass = window[requiredName];
                }

                if (ModuleClass) {
                    // Create a new instance and add it
                    const requiredModule = new ModuleClass();
                    this.addModule(requiredModule); // Recursive to handle nested requirements
                } else {
                    console.warn(`Required module ${requiredName} not found`);
                }
            }
        }

        // Set the gameObject reference
        module.gameObject = this;

        // Add to modules array
        this.modules.push(module);

        // Call onAttach
        if (typeof module.onAttach === 'function') {
            module.onAttach(this);
        }

        return module;
    }

    /**
     * Check for and add required modules
     * @param {Module} module - The module to check requirements for
     * @private
     */
    addRequiredModules(module) {
        // Get the requirements
        const requirements = module.getRequirements ? module.getRequirements() : [];

        // Process each requirement
        for (const requiredName of requirements) {
            // Check if we already have this required module
            const existing = this.getModuleByType(requiredName);

            if (!existing) {
                console.log(`Module ${module.constructor.name} requires ${requiredName}, adding it automatically`);

                // Find the module class from registry or global scope
                let ModuleClass = null;

                // Try to get from registry first
                if (window.moduleRegistry) {
                    ModuleClass = window.moduleRegistry.getModuleClass(requiredName);
                }

                // Fall back to global namespace
                if (!ModuleClass && window[requiredName]) {
                    ModuleClass = window[requiredName];
                }

                if (ModuleClass) {
                    // Create and add the required module
                    const requiredModule = new ModuleClass();

                    // Check if this required module itself has requirements
                    this.addRequiredModules(requiredModule);

                    // Add the module normally
                    requiredModule.gameObject = this;
                    requiredModule.id = crypto.randomUUID ? crypto.randomUUID() : `m-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
                    this.modules.push(requiredModule);

                    // Call onAttach
                    if (typeof requiredModule.onAttach === 'function') {
                        requiredModule.onAttach(this);
                    }
                } else {
                    console.warn(`Required module ${requiredName} not found, cannot add automatically`);
                }
            }
        }
    }

    /**
     * Get a module by type
     * @param {class} moduleType - The class/type of module to find
     * @returns {Module} The found module or null
     */
    getModule(moduleType) {
        // Handle module type as string
        if (typeof moduleType === 'string') {
            return this.modules.find(module =>
                module.constructor.name === moduleType ||
                module.type === moduleType
            );
        }

        // Handle module type as class
        if (typeof moduleType === 'function') {
            return this.modules.find(module => module instanceof moduleType);
        }

        // If moduleType is neither string nor function, return null
        return null;
    }

    /**
     * Reorder modules based on an array of module IDs
     * @param {Array<string>} moduleIds - Ordered array of module IDs
     */
    reorderModules(moduleIds) {
        if (!moduleIds || !moduleIds.length) return;

        // Create a new ordered modules array
        const orderedModules = [];

        // First add modules in the specified order
        for (const moduleId of moduleIds) {
            const module = this.getModuleById(moduleId);
            if (module) {
                orderedModules.push(module);
            }
        }

        // Add any remaining modules that weren't in the moduleIds array
        for (const module of this.modules) {
            if (!orderedModules.includes(module)) {
                orderedModules.push(module);
            }
        }

        // Replace the modules array with the ordered one
        this.modules = orderedModules;
    }

    /**
     * Get a module by type name
     * @param {string} typeName - The name of the module type to find
     * @returns {Module} The found module or null
     */
    getModuleByType(typeName) {
        return this.modules.find(module =>
            module.constructor.name === typeName ||
            module.type === typeName
        );
    }

    /**
     * Get a module by its ID
     * @param {string} id - The module ID
     * @returns {Module|null} The found module or null
     */
    getModuleById(id) {
        return this.modules.find(module => module.id === id) || null;
    }

    /**
     * Remove a module by reference
     * @param {Module} module - The module to remove
     * @returns {boolean} True if the module was removed
     */
    removeModule(module) {
        const index = this.modules.indexOf(module);
        if (index !== -1) {
            module.gameObject = null;
            this.modules.splice(index, 1);
            if (module.onDestroy) module.onDestroy();
            return true;
        }
        return false;
    }

    /**
     * Remove a module by type
     * @param {class} moduleType - The class/type of module to remove
     * @returns {boolean} True if a module was removed
     */
    removeModuleByType(moduleType) {
        const module = this.getModule(moduleType);
        if (module) {
            return this.removeModule(module);
        }
        return false;
    }

    /**
     * Add a child GameObject
     * @param {GameObject} child - The child to add
     * @returns {GameObject} The added child
     */
    addChild(child) {
        if (child.parent) {
            child.parent.removeChild(child);
        }
        child.parent = this;
        this.children.push(child);
        return child;
    }

    /**
     * Remove a child GameObject
     * @param {GameObject} child - The child to remove
     * @returns {boolean} True if the child was removed
     */
    removeChild(child) {
        const index = this.children.indexOf(child);
        if (index !== -1) {
            this.children.splice(index, 1);
            child.parent = null;
            return true;
        }
        return false;
    }

    /**
     * Set the active state of this GameObject
     * @param {boolean} value - Whether the GameObject should be active
     */
    setActive(value) {
        this.active = value;
    }

    /**
     * Toggle the active state of this GameObject
     */
    toggleActive() {
        this.active = !this.active;
    }

    /**
     * Add a tag to this GameObject
     * @param {string} tag - The tag to add
     */
    addTag(tag) {
        if (!this.tags.includes(tag)) {
            this.tags.push(tag);
        }
    }

    /**
     * Check if this GameObject has a specific tag
     * @param {string} tag - The tag to check for
     * @returns {boolean} True if the GameObject has the tag
     */
    hasTag(tag) {
        return this.tags.includes(tag);
    }

    /**
     * Remove a tag from this GameObject
     * @param {string} tag - The tag to remove
     */
    removeTag(tag) {
        const index = this.tags.indexOf(tag);
        if (index !== -1) {
            this.tags.splice(index, 1);
        }
    }

    /**
     * Find a child by name (including deep search through children)
     * @param {string} name - The name of the GameObject to find
     * @param {boolean} deep - Whether to search recursively through all children
     * @returns {GameObject|null} The found GameObject or null
     */
    findChild(name, deep = true) {
        // First, check direct children
        for (const child of this.children) {
            if (child.name === name) return child;
        }

        // If not found and deep search is enabled, search in children's children
        if (deep) {
            for (const child of this.children) {
                const found = child.findChild(name, true);
                if (found) return found;
            }
        }

        return null;
    }

    /**
     * Set the selection state of this GameObject
     * @param {boolean} selected - Whether the GameObject is selected
     */
    setSelected(selected) {
        this.selected = selected;
    }

    /**
     * Rename this GameObject
     * @param {string} newName - The new name
     */
    rename(newName) {
        this.name = newName;
    }

    /**
     * Get the world position of this GameObject
     * @returns {Vector2} The world position
     */
    getWorldPositionOriginal() {
        let worldPos = this.position.clone();
        if (this.parent) {
            const parentWorldPos = this.parent.getWorldPosition();
            worldPos = worldPos.rotate(this.parent.angle * Math.PI / 180);
            worldPos = worldPos.add(parentWorldPos);
        }
        return worldPos;
    }

    getWorldPosition() {
        let worldPos = this.position.clone();
        let currentParent = this.parent;
        let totalAngle = 0;

        // Accumulate rotation from all ancestors
        while (currentParent) {
            totalAngle += currentParent.angle;
            currentParent = currentParent.parent;
        }

        // Rotate local position by total ancestor angle
        worldPos = worldPos.rotate(totalAngle * Math.PI / 180);

        // Add world position of topmost parent (if any)
        if (this.parent) {
            worldPos = worldPos.add(this.parent.getWorldPosition());
        }

        // Round to 2 decimal places
        worldPos.x = Math.round(worldPos.x * 100) / 100;
        worldPos.y = Math.round(worldPos.y * 100) / 100;

        return worldPos;
    }

    /**
     * Convert a world position to local space
     * @param {Vector2} worldPosition - Position in world space
     * @returns {Vector2} Position in local space
     */
    worldToLocalPosition(worldPosition) {
        if (!this.parent) return worldPosition.subtract(this.position);

        const parentWorldPos = this.parent.getWorldPosition();
        let localToParent = worldPosition.subtract(parentWorldPos);
        localToParent = localToParent.rotate(-this.parent.angle * Math.PI / 180);
        return localToParent.subtract(this.position);
    }

    getWorldRotation() {
        let rotation = this.angle;
        let currentParent = this.parent;

        while (currentParent) {
            rotation += currentParent.angle;
            currentParent = currentParent.parent;
        }

        return rotation;
    }

    getWorldScale() {
        let scale = this.scale.clone();
        let currentParent = this.parent;

        while (currentParent) {
            scale.x *= currentParent.scale.x;
            scale.y *= currentParent.scale.y;
            currentParent = currentParent.parent;
        }

        return scale;
    }

    createPixiDisplayObject() {
        // Example: create a simple rectangle using PIXI.Graphics
        const graphics = new PIXI.Graphics();
        graphics.beginFill(0xffffff); // White fill
        graphics.drawRect(-this.size.x / 2, -this.size.y / 2, this.size.x, this.size.y);
        graphics.endFill();
        graphics.pivot.set(0, 0);
        graphics.x = this.position.x;
        graphics.y = this.position.y;
        graphics.rotation = this.angle * Math.PI / 180;
        graphics.scale.set(this.scale.x, this.scale.y);
        graphics.visible = this.visible;
        this.pixiDisplayObject = graphics;
        return graphics;
    }

    updatePixiDisplayObject() {
        if (!this.pixiDisplayObject) return;
        this.pixiDisplayObject.x = this.position.x;
        this.pixiDisplayObject.y = this.position.y;
        this.pixiDisplayObject.rotation = this.angle * Math.PI / 180;
        this.pixiDisplayObject.scale.set(this.scale.x, this.scale.y);
        this.pixiDisplayObject.visible = this.visible;
    }

    /**
     * Serialize this GameObject to JSON
     * @returns {Object} Serialized GameObject data
     */
    toJSON() {
        return {
            id: this.id, // Include the ID for reference
            name: this.name,
            position: { x: this.position.x, y: this.position.y },
            scale: { x: this.scale.x, y: this.scale.y },
            useCollisions: this.useCollisions,
            polygonPointCount: this.polygonPointCount,
            polygonPoints: this.polygonPoints.map(pt => ({ x: pt.x, y: pt.y })),
            usePolygonCollision: this.usePolygonCollision,
            polygon: this.polygon ? this.polygon.toJSON() : null,
            size: this.size ? { width: this.size.x, height: this.size.y } : { width: 50, height: 50 },
            colliderWidth: this.colliderWidth || 0,
            colliderHeight: this.colliderHeight || 0,
            angle: this.angle,
            depth: this.depth,
            active: this.active,
            editorColor: this.editorColor,
            visible: this.visible,
            tags: [...this.tags],
            collisionEnabled: this.collisionEnabled,
            collisionLayer: this.collisionLayer,
            collisionMask: this.collisionMask,
            modules: this.modules.map(module => ({
                type: module.constructor.name,
                id: module.id,
                data: module.toJSON ? module.toJSON() : {}
            })),
            children: this.children.map(child => child.toJSON())
        };
    }

    /**
     * Create a GameObject from serialized data
     * @param {Object} json - Serialized GameObject data
     * @returns {GameObject} The created GameObject
     */
    static fromJSON(json) {
        const obj = new GameObject(json.name);
        // Restore ID if available
        if (json.id) obj.id = json.id;

        obj.colliderWidth = json.colliderWidth || 0;
        obj.colliderHeight = json.colliderHeight || 0;

        obj.position = new Vector2(json.position.x, json.position.y);
        obj.useCollisions = json.useCollisions || false;
        obj.size = json.size ? new Vector2(json.size.width, json.size.height) : new Vector2(50, 50);
        // Restore scale if available
        if (json.scale) obj.scale = new Vector2(json.scale.x, json.scale.y);
        obj.editorColor = json.editorColor || obj.generateRandomColor();

        if (json.polygonPointCount !== undefined) {
            obj.polygonPointCount = json.polygonPointCount;
        }
        if (json.polygonPoints && Array.isArray(json.polygonPoints)) {
            obj.polygonPoints = json.polygonPoints.map(pt => new Vector2(pt.x, pt.y));
            // Pass parent, position, ...points
            obj.polygon = new Polygon(obj, obj.position.clone(), ...obj.polygonPoints.map(pt => pt.clone()));
        }

        if (json.usePolygonCollision !== undefined) {
            obj.usePolygonCollision = json.usePolygonCollision;
        }

        obj.angle = json.angle;
        obj.depth = json.depth;
        obj.active = json.active;
        if (json.visible !== undefined) obj.visible = json.visible;
        obj.tags = Array.isArray(json.tags) ? [...json.tags] : [];

        if (json.collisionEnabled !== undefined) obj.collisionEnabled = json.collisionEnabled;
        if (json.collisionLayer !== undefined) obj.collisionLayer = json.collisionLayer;
        if (json.collisionMask !== undefined) obj.collisionMask = json.collisionMask;

        // Add modules - with improved module class lookup
        if (json.modules && Array.isArray(json.modules)) {
            json.modules.forEach(moduleData => {
                // Try to get the module class from registry or window
                const moduleTypeName = moduleData.type;
                let ModuleClass = null;

                // Try module registry first
                if (window.moduleRegistry) {
                    ModuleClass = window.moduleRegistry.getModuleClass(moduleTypeName);
                }

                // Fall back to global scope with various naming conventions
                if (!ModuleClass) {
                    // Try PascalCase (standard naming convention)
                    if (window[moduleTypeName]) {
                        ModuleClass = window[moduleTypeName];
                    }
                    // If not found, try other possible variations to be more robust
                    else if (moduleTypeName) {
                        // Try camelCase variation
                        const camelCase = moduleTypeName.charAt(0).toLowerCase() + moduleTypeName.slice(1);
                        if (window[camelCase]) {
                            ModuleClass = window[camelCase];
                        }
                        // Try capitalized version
                        const capitalized = moduleTypeName.charAt(0).toUpperCase() + moduleTypeName.slice(1);
                        if (window[capitalized]) {
                            ModuleClass = window[capitalized];
                        }
                    }
                }

                if (ModuleClass) {
                    try {
                        // Create the module instance
                        const module = new ModuleClass();

                        // Restore the module's ID and type
                        if (moduleData.id) module.id = moduleData.id;
                        module.type = moduleTypeName; // Explicitly set type to what was saved

                        // Initialize from saved data if module has fromJSON method
                        if (moduleData.data && typeof module.fromJSON === 'function') {
                            module.fromJSON(moduleData.data);
                        } else if (moduleData.exposedValues) {
                            // Fall back to copying exposed values if no specific fromJSON method
                            for (const key in moduleData.exposedValues) {
                                if (key in module) {
                                    module[key] = moduleData.exposedValues[key];
                                }
                            }
                        }

                        // Add module to game object
                        obj.addModule(module);

                    } catch (error) {
                        console.error(`Error restoring module ${moduleTypeName}:`, error);
                        // Create a placeholder module to preserve data
                        createPlaceholderModule(obj, moduleData, moduleTypeName);
                    }
                } else {
                    console.warn(`Module class ${moduleTypeName} not found when restoring game object.`);
                    // Create a placeholder module to preserve data
                    createPlaceholderModule(obj, moduleData, moduleTypeName);
                }
            });
        }

        // Add children
        json.children.forEach(childJson => {
            const child = GameObject.fromJSON(childJson);
            obj.addChild(child);
        });

        // Now call start() on all modules to initialize physics bodies
        /*obj.modules.forEach(module => {
            if (typeof module.start === 'function') {
                try { module.start(); } catch (e) { console.error(e); }
            }
        });*/

        return obj;
    }

    /**
     * Copy properties from one module to another, with special handling for GameObject references
     * @param {Module} sourceModule - The source module to copy from
     * @param {Module} targetModule - The target module to copy to
     * @param {GameObject} newGameObject - The new GameObject that owns the target module
     */
    copyModuleProperties(sourceModule, targetModule, newGameObject) {
        // First, ensure we have all the necessary objects
        if (!sourceModule || !targetModule || !newGameObject) {
            console.warn("copyModuleProperties: Missing required arguments");
            return;
        }

        const originalGameObject = this; // Store reference to original GameObject

        // Get all property names (including non-enumerable ones)
        const propertyNames = new Set([
            ...Object.getOwnPropertyNames(sourceModule),
            ...Object.keys(sourceModule)
        ]);

        // Process each property
        for (const key of propertyNames) {
            try {
                // Skip special properties and functions
                if (key === 'id' || key === 'gameObject' || key === 'constructor' ||
                    key.startsWith('__') || typeof sourceModule[key] === 'function') {
                    continue;
                }

                // Get the source value
                const value = sourceModule[key];

                // Handle different value types
                if (value === null || value === undefined) {
                    targetModule[key] = value;
                }
                else if (value === originalGameObject) {
                    // Direct reference to the original GameObject
                    targetModule[key] = newGameObject;
                }
                else if (value === sourceModule.gameObject) {
                    // Another way to reference the original GameObject
                    targetModule[key] = newGameObject;
                }
                else if (value instanceof Vector2) {
                    // Deep clone Vector2 (or anything with a clone method)
                    targetModule[key] = value.clone();
                }
                else if (Array.isArray(value)) {
                    // Process arrays - create a new array for the clone
                    targetModule[key] = deepCloneArray(value, originalGameObject, newGameObject);
                }
                else if (typeof value === 'object' && value !== null &&
                    !(value instanceof HTMLElement)) {
                    // For any other objects that aren't DOM elements
                    if (typeof value.clone === 'function') {
                        // Use clone method if available
                        targetModule[key] = value.clone();
                    } else {
                        // Do a deep clone with reference replacement
                        targetModule[key] = deepCloneWithReplacements(value, originalGameObject, newGameObject);
                    }
                } else {
                    // For primitives, do direct assignment
                    targetModule[key] = value;
                }
            } catch (e) {
                console.warn(`Error cloning property ${key} in module ${sourceModule.constructor.name}:`, e);
            }
        }

        // Handle private properties for exposed properties
        if (Array.isArray(sourceModule.exposedProperties)) {
            for (const prop of sourceModule.exposedProperties) {
                const propName = prop.name;
                const privatePropName = `_${propName}`;

                // Copy the private property if it exists
                if (privatePropName in sourceModule) {
                    const privateValue = sourceModule[privatePropName];

                    if (privateValue === originalGameObject) {
                        targetModule[privatePropName] = newGameObject;
                    } else if (typeof privateValue === 'object' && privateValue !== null) {
                        if (typeof privateValue.clone === 'function') {
                            targetModule[privatePropName] = privateValue.clone();
                        } else {
                            targetModule[privatePropName] = deepCloneWithReplacements(
                                privateValue, originalGameObject, newGameObject
                            );
                        }
                    } else {
                        targetModule[privatePropName] = privateValue;
                    }
                }
            }
        }
    }

    deepCloneObject(obj, newGameObject) {
        if (!obj) return obj;

        try {
            // For DOM elements, return as-is
            if (obj instanceof HTMLElement) return obj;

            // For objects with clone method, use it
            if (typeof obj.clone === 'function') return obj.clone();

            const clone = {};

            for (const key in obj) {
                if (!Object.prototype.hasOwnProperty.call(obj, key)) continue;

                const value = obj[key];

                if (value === this || value === this.gameObject) {
                    clone[key] = newGameObject;
                } else if (value instanceof Vector2) {
                    clone[key] = value.clone();
                } else if (Array.isArray(value)) {
                    clone[key] = this.deepCloneArray(value, newGameObject);
                } else if (typeof value === 'object' && value !== null && !(value instanceof HTMLElement)) {
                    clone[key] = this.deepCloneObject(value, newGameObject);
                } else {
                    clone[key] = value;
                }
            }

            return clone;

        } catch (e) {
            console.warn("Failed to deep clone object:", e);
            return {}; // Return empty object as fallback
        }
    }

    /**
     * Deep clone an array, replacing GameObject references
     * @param {Array} arr - The array to clone
     * @param {GameObject} newGameObject - The new GameObject to use for replacements
     * @returns {Array} - Cloned array
     */
    deepCloneArray(arr, originalGameObject, newGameObject) {
        if (!arr) return arr;

        return arr.map(item => {
            if (item === originalGameObject || item === originalGameObject.gameObject) {
                return newGameObject;
            }
            else if (item === null || item === undefined || typeof item !== 'object') {
                return item; // Direct copy for primitives
            }
            else if (typeof item.clone === 'function') {
                return item.clone();
            }
            else if (Array.isArray(item)) {
                return this.deepCloneArray(item, originalGameObject, newGameObject);
            }
            else if (item instanceof HTMLElement) {
                return item; // Keep DOM references intact
            }
            else {
                return this.deepCloneWithReplacements(item, originalGameObject, newGameObject);
            }
        });
    }

    /**
     * Deep clone an object with GameObject reference replacements
     * @param {Object} obj - Object to clone
     * @param {GameObject} newGameObject - The new GameObject to use for replacements
     * @returns {Object} Cloned object
     */
    deepCloneWithReplacements(obj, originalGameObject, newGameObject) {
        if (!obj) return obj;
        if (obj === originalGameObject) return newGameObject;

        // Skip non-objects and DOM elements
        if (typeof obj !== 'object' || obj instanceof HTMLElement) return obj;

        // Handle special objects
        if (typeof obj.clone === 'function') return obj.clone();
        if (obj instanceof Date) return new Date(obj.getTime());

        // Handle arrays
        if (Array.isArray(obj)) {
            return this.deepCloneArray(obj, originalGameObject, newGameObject);
        }

        // Create a new object of the same type
        const clone = Object.create(Object.getPrototypeOf(obj));

        // Copy all properties with reference checks
        for (const key in obj) {
            if (!Object.prototype.hasOwnProperty.call(obj, key)) continue;

            const value = obj[key];

            if (value === originalGameObject || value === originalGameObject.gameObject) {
                // Replace GameObject references
                clone[key] = newGameObject;
            }
            else if (value === null || value === undefined || typeof value !== 'object') {
                // Direct copy for primitives and null/undefined
                clone[key] = value;
            }
            else if (typeof value.clone === 'function') {
                // Use clone method if available
                clone[key] = value.clone();
            }
            else if (value instanceof HTMLElement) {
                // Keep references to DOM elements intact
                clone[key] = value;
            }
            else if (Array.isArray(value)) {
                // Deep clone arrays
                clone[key] = this.deepCloneArray(value, originalGameObject, newGameObject);
            }
            else {
                // Deep clone other objects
                clone[key] = this.deepCloneWithReplacements(value, originalGameObject, newGameObject);
            }
        }

        return clone;
    }

    /**
     * Recursively replace missed GameObject references in the cloned module
     * @param {Object} obj - The module or object to scan
     * @param {GameObject} newGameObject - The new GameObject to use for replacements
     */
    replaceMissedReferences(obj, newGameObject) {
        if (!obj || typeof obj !== 'object') return;

        // Use a Set to track visited objects and avoid circular reference issues
        const visited = new Set();

        function scan(o) {
            if (!o || typeof o !== 'object' || visited.has(o)) return;
            visited.add(o);

            // Check all properties
            for (const key in o) {
                if (!Object.prototype.hasOwnProperty.call(o, key)) continue;
                if (key === 'gameObject') continue; // Skip the gameObject property itself

                const value = o[key];

                if (value === this) {
                    // Replace references to the original GameObject
                    o[key] = newGameObject;
                } else if (value && typeof value === 'object' && !visited.has(value)) {
                    // Recursively scan nested objects
                    scan(value);
                }
            }
        }

        scan.call(this, obj);
    }

    /**
     * Thoroughly scan an object to find and replace all references to the original GameObject
     * @param {Object} obj - The object to scan
     * @param {GameObject} originalObj - The original GameObject to replace
     * @param {GameObject} newObj - The replacement GameObject
     */
    deepScanAndReplaceAllReferences(obj, originalObj, newObj) {
        if (!obj || typeof obj !== 'object') return;

        // Use a WeakMap to track visited objects and avoid circular reference issues
        const visited = new WeakMap();

        const scan = (o) => {
            if (!o || typeof o !== 'object' || visited.has(o)) return;
            visited.set(o, true);

            // Check all properties recursively
            for (const key in o) {
                if (!Object.prototype.hasOwnProperty.call(o, key)) continue;

                const value = o[key];

                // Replace direct references
                if (value === originalObj || value === originalObj.gameObject) {
                    o[key] = newObj;
                    continue;
                }

                // Recursively scan objects and arrays
                if (typeof value === 'object' && value !== null && !visited.has(value)) {
                    scan(value);
                }
            }
        };

        scan(obj);
    }

    /**
     * Clone this GameObject, including all modules and children
     * @returns {GameObject} A deep copy of this GameObject
     */
    clone(addNameCopySuffix = true) {
        const originalGameObject = this;

        // Create new GameObject
        // Only add " (Copy)" if not already present
        let newName = this.name;
        if (addNameCopySuffix && !newName.trim().endsWith("(Copy)")) {
            newName += " (Copy)";
        }
        const cloned = GameObject.fromJSON(this.toJSON());

        cloned.name = newName;

        // Generate a new unique ID for the cloned GameObject
        cloned.id = crypto.randomUUID ? crypto.randomUUID() : `go-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;

        return cloned;

        // Copy basic properties
        /*cloned.position = this.position.clone();
        cloned.scale = this.scale.clone();
        cloned.size = this.size.clone();
        cloned.origin = this.origin.clone();
        cloned.angle = this.angle;
        cloned.depth = this.depth;
        cloned.active = this.active;
        cloned.visible = this.visible;
        cloned.tags = [...this.tags];
        cloned.editorColor = this.editorColor;
        cloned.collisionEnabled = this.collisionEnabled;
        cloned.collisionLayer = this.collisionLayer;
        cloned.collisionMask = this.collisionMask;

        // Copy original position if it exists
        if (this._originalPosition) {
            cloned._originalPosition = { x: this._originalPosition.x, y: this._originalPosition.y };
        }

        // Clone modules with proper reference handling
        for (const module of this.modules) {
            try {
                // First get the module class
                let ModuleClass = module.constructor;
                if (!ModuleClass && module.type) {
                    ModuleClass = window.moduleRegistry?.getModuleClass(module.type)
                        || window[module.type];
                }

                if (!ModuleClass) {
                    console.warn(`Could not find class for module type ${module.type}`);
                    createPlaceholderModule(cloned, { id: module.id, type: module.type }, module.type);
                    continue;
                }

                // Create a new module instance
                const clonedModule = new ModuleClass();

                // Generate a new unique ID for the cloned module
                clonedModule.id = crypto.randomUUID();

                // Store the module type explicitly
                clonedModule.type = module.type || ModuleClass.name;

                // IMPORTANT: Set the gameObject reference first so that 
                // fromJSON has the correct reference when restoring properties
                clonedModule.gameObject = cloned;

                // Now restore data from the original module
                const data = module.toJSON();
                if (data) {
                    clonedModule.fromJSON(data);
                }

                // Proper attachment
                clonedModule.attachTo(cloned);

                // Add the module to the cloned game object's modules array
                cloned.modules.push(clonedModule);

                // Call onAttach explicitly if it exists
                if (typeof clonedModule.onAttach === 'function') {
                    clonedModule.onAttach(cloned);
                }

                // Deep scan for any missed references
                deepScanAndReplaceReferences(clonedModule, originalGameObject, cloned);

            } catch (error) {
                console.error(`Error cloning module ${module.type || module.constructor?.name}:`, error);
            }
        }

        // Clone children recursively
        for (const child of this.children) {
            const clonedChild = child.clone();
            cloned.addChild(clonedChild);
        }

        // Final pass to catch any remaining references
        for (const module of cloned.modules) {
            // Replace any remaining references to the original GameObject
            deepScanAndReplaceAllReferences(module, originalGameObject, cloned);

            // Also check for private properties
            for (const key in module) {
                if (key.startsWith('_') && module[key] === originalGameObject) {
                    module[key] = cloned;
                }
            }
        }*/

        return cloned;
    }

}

function deepScanAndReplaceAllReferences(obj, originalObj, newObj) {
    if (!obj || typeof obj !== 'object') return;

    const visited = new WeakMap();

    const scan = (o) => {
        if (!o || typeof o !== 'object' || visited.has(o)) return;
        visited.set(o, true);

        for (const key in o) {
            if (!Object.prototype.hasOwnProperty.call(o, key)) continue;

            const value = o[key];

            if (value === originalObj || value === originalObj.gameObject) {
                console.log(`Replacing reference in ${o.constructor.name}.${key}`);
                o[key] = newObj;
            }

            if (typeof value === 'object' && value !== null && !visited.has(value)) {
                scan(value);
            }
        }
    };

    scan(obj);
}

/**
 * Helper to find available module class 
 * @param {string} moduleName - The module class name to find
 * @returns {Class|null} - The module class or null if not found
 */
function findModuleClass(moduleName) {
    if (!moduleName) return null;

    // Check registry first (most reliable source)
    if (window.moduleRegistry) {
        const moduleClass = window.moduleRegistry.getModuleClass(moduleName);
        if (moduleClass) return moduleClass;
    }

    // Try direct global lookup with original name
    if (window[moduleName]) return window[moduleName];

    // Try camelCase variation
    const camelCase = moduleName.charAt(0).toLowerCase() + moduleName.slice(1);
    if (window[camelCase]) return window[camelCase];

    // Try capitalized version
    const capitalized = moduleName.charAt(0).toUpperCase() + moduleName.slice(1);
    if (window[capitalized]) return window[capitalized];

    // Not found
    return null;
}

/**
 * Function to copy module properties (outside class to avoid 'this' context issues)
 */
function copyModuleProperties(sourceModule, targetModule, newGameObject, originalGameObject) {
    // First, ensure we have all the necessary objects
    if (!sourceModule || !targetModule || !newGameObject || !originalGameObject) {
        console.warn("copyModuleProperties: Missing required arguments");
        return;
    }

    // Get all property names (including non-enumerable ones)
    const propertyNames = new Set([
        ...Object.getOwnPropertyNames(sourceModule),
        ...Object.keys(sourceModule)
    ]);

    // Process each property
    for (const key of propertyNames) {
        try {
            // Skip special properties and functions
            if (key === 'id' || key === 'gameObject' || key === 'constructor' ||
                key.startsWith('__') || typeof sourceModule[key] === 'function') {
                continue;
            }

            // Get the source value
            const value = sourceModule[key];

            // Handle different value types
            if (value === null || value === undefined) {
                targetModule[key] = value;
            }
            else if (value === originalGameObject) {
                // Direct reference to the original GameObject
                targetModule[key] = newGameObject;
            }
            else if (value === sourceModule.gameObject) {
                // Another way to reference the original GameObject
                targetModule[key] = newGameObject;
            }
            else if (value instanceof Vector2) {
                // Deep clone Vector2 (or anything with a clone method)
                targetModule[key] = value.clone();
            }
            else if (Array.isArray(value)) {
                // Process arrays - create a new array for the clone
                targetModule[key] = deepCloneArray(value, originalGameObject, newGameObject);
            }
            else if (typeof value === 'object' && value !== null &&
                !(value instanceof HTMLElement)) {
                // For any other objects that aren't DOM elements
                if (typeof value.clone === 'function') {
                    // Use clone method if available
                    targetModule[key] = value.clone();
                } else {
                    // Do a deep clone with reference replacement
                    targetModule[key] = deepCloneWithReplacements(value, originalGameObject, newGameObject);
                }
            } else {
                // For primitives, do direct assignment
                targetModule[key] = value;
            }
        } catch (e) {
            console.warn(`Error cloning property ${key} in module ${sourceModule.constructor.name}:`, e);
        }
    }

    // Handle private properties for exposed properties
    if (Array.isArray(sourceModule.exposedProperties)) {
        for (const prop of sourceModule.exposedProperties) {
            const propName = prop.name;
            const privatePropName = `_${propName}`;

            // Copy the private property if it exists
            if (privatePropName in sourceModule) {
                const privateValue = sourceModule[privatePropName];

                if (privateValue === originalGameObject) {
                    targetModule[privatePropName] = newGameObject;
                } else if (typeof privateValue === 'object' && privateValue !== null) {
                    if (typeof privateValue.clone === 'function') {
                        targetModule[privatePropName] = privateValue.clone();
                    } else {
                        targetModule[privatePropName] = deepCloneWithReplacements(
                            privateValue, originalGameObject, newGameObject
                        );
                    }
                } else {
                    targetModule[privatePropName] = privateValue;
                }
            }
        }
    }

    targetModule.gameObject = newGameObject;
}

/**
 * Deep clone an array, replacing GameObject references (standalone function)
 */
function deepCloneArray(arr, originalGameObject, newGameObject) {
    if (!arr) return arr;

    return arr.map(item => {
        if (item === originalGameObject || item === originalGameObject.gameObject) {
            return newGameObject;
        }
        else if (item === null || item === undefined || typeof item !== 'object') {
            return item; // Direct copy for primitives
        }
        else if (typeof item.clone === 'function') {
            return item.clone();
        }
        else if (Array.isArray(item)) {
            return deepCloneArray(item, originalGameObject, newGameObject);
        }
        else if (item instanceof HTMLElement) {
            return item; // Keep DOM references intact
        }
        else {
            return deepCloneWithReplacements(item, originalGameObject, newGameObject);
        }
    });
}

/**
 * Deep clone an object with GameObject reference replacements (standalone function)
 */
function deepCloneWithReplacements(obj, originalGameObject, newGameObject) {
    if (!obj) return obj;
    if (obj === originalGameObject) return newGameObject;

    // Skip non-objects and DOM elements
    if (typeof obj !== 'object' || obj instanceof HTMLElement) return obj;

    // Handle special objects
    if (typeof obj.clone === 'function') return obj.clone();
    if (obj instanceof Date) return new Date(obj.getTime());

    // Handle arrays
    if (Array.isArray(obj)) {
        return deepCloneArray(obj, originalGameObject, newGameObject);
    }

    // Create a new object of the same type
    const clone = Object.create(Object.getPrototypeOf(obj));

    // Copy all properties with reference checks
    for (const key in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, key)) continue;

        const value = obj[key];

        if (value === originalGameObject || value === originalGameObject.gameObject) {
            // Replace GameObject references
            clone[key] = newGameObject;
        }
        else if (value === null || value === undefined || typeof value !== 'object') {
            // Direct copy for primitives and null/undefined
            clone[key] = value;
        }
        else if (typeof value.clone === 'function') {
            // Use clone method if available
            clone[key] = value.clone();
        }
        else if (value instanceof HTMLElement) {
            // Keep references to DOM elements intact
            clone[key] = value;
        }
        else if (Array.isArray(value)) {
            // Deep clone arrays
            clone[key] = deepCloneArray(value, originalGameObject, newGameObject);
        }
        else {
            // Deep clone other objects
            clone[key] = deepCloneWithReplacements(value, originalGameObject, newGameObject);
        }
    }

    return clone;
}

/**
 * Perform a deep scan of an object to find and replace all references to the original GameObject
 * @param {Object} obj - The object to scan
 * @param {GameObject} original - The original GameObject to replace
 * @param {GameObject} replacement - The replacement GameObject
 */
function deepScanAndReplaceReferences(obj, original, replacement) {
    if (!obj || typeof obj !== 'object') return;

    // Use a Set to track objects we've already visited to avoid circular references
    const visited = new Set();

    function _scan(o) {
        if (!o || typeof o !== 'object' || visited.has(o)) return;
        visited.add(o);

        // Check all properties of the object
        for (const key in o) {
            if (!o.hasOwnProperty(key)) continue;

            // Skip the 'gameObject' property as it's already set correctly
            if (key === 'gameObject') continue;

            const value = o[key];

            // If the value is a reference to the original GameObject, replace it
            if (value === original) {
                o[key] = replacement;
            }
            // Recursively scan objects
            else if (value && typeof value === 'object' && !visited.has(value)) {
                _scan(value);
            }
        }
    }

    _scan(obj);
}

/**
 * Deep clone an object while replacing references to the original GameObject with the cloned one
 * @param {Object} obj - The object to clone
 * @param {GameObject} originalGameObject - The original GameObject to replace references to
 * @param {GameObject} clonedGameObject - The new GameObject to replace references with
 * @returns {Object} - A deep clone with replaced references
 */
function deepCloneWithReferenceReplacement(obj, originalGameObject, clonedGameObject) {
    if (!obj || typeof obj !== 'object') return obj;

    // Handle null
    if (obj === null) return null;

    // Handle Date objects
    if (obj instanceof Date) return new Date(obj.getTime());

    // Handle GameObject references
    if (obj === originalGameObject) return clonedGameObject;

    // Handle Vector2 instances
    if (obj instanceof Vector2) return obj.clone();

    // Handle arrays
    if (Array.isArray(obj)) {
        return obj.map(item => {
            if (item === originalGameObject) return clonedGameObject;
            return deepCloneWithReferenceReplacement(item, originalGameObject, clonedGameObject);
        });
    }

    // Skip functions (they can't be reliably cloned)
    if (typeof obj === 'function') return undefined;

    // Handle objects with their own clone method
    if (typeof obj.clone === 'function') return obj.clone();

    // Handle regular objects - deep copy each property
    try {
        // For regular objects, create a new object of the same type
        const clone = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));

        // Copy each property with reference replacement
        for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                if (obj[key] === originalGameObject) {
                    clone[key] = clonedGameObject;
                } else if (typeof obj[key] === 'object' && obj[key] !== null) {
                    clone[key] = deepCloneWithReferenceReplacement(obj[key], originalGameObject, clonedGameObject);
                } else {
                    clone[key] = obj[key];
                }
            }
        }

        return clone;
    } catch (e) {
        // Fallback to simpler approach for objects that cause errors
        console.warn("Error during deep clone, using simpler clone:", e);

        const simpleClone = {};
        for (const key in obj) {
            if (obj[key] === originalGameObject) {
                simpleClone[key] = clonedGameObject;
            } else if (typeof obj[key] !== 'function') {
                simpleClone[key] = obj[key];
            }
        }

        return simpleClone;
    }
}

/**
 * Replace all references to originalObj with newObj in the given object
 * @param {Object} obj - The object to search through
 * @param {Object} originalObj - The object to replace
 * @param {Object} newObj - The replacement object
 */
function replaceReferences(obj, originalObj, newObj) {
    if (!obj || typeof obj !== 'object' || originalObj === null || newObj === null) {
        return;
    }

    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            if (obj[key] === originalObj) {
                obj[key] = newObj;
            } else if (typeof obj[key] === 'object' && obj[key] !== null) {
                replaceReferences(obj[key], originalObj, newObj);
            }
        }
    }
}

/**
 * Safely clone an object, handling non-serializable values like functions, and replacing gameObject references
 * @param {any} obj - The object to clone
 * @param {GameObject} originalGameObject - The original GameObject to replace references to
 * @param {GameObject} newGameObject - The new GameObject to replace references with
 * @returns {any} - A deep clone of the object
 */
function safeClone(obj, originalGameObject, newGameObject) {
    if (obj === null || obj === undefined) {
        return obj;
    }

    // Handle GameObject references
    if (originalGameObject && obj === originalGameObject) {
        return newGameObject;
    }

    // Handle primitive types
    if (typeof obj !== 'object' && typeof obj !== 'function') {
        return obj;
    }

    // Handle Vector2 objects
    if (obj instanceof Vector2) {
        return obj.clone();
    }

    // Handle Date objects
    if (obj instanceof Date) {
        return new Date(obj.getTime());
    }

    // Handle arrays with special item handling
    if (Array.isArray(obj)) {
        return obj.map(item => {
            if (originalGameObject && item === originalGameObject) {
                return newGameObject;
            }
            return safeClone(item, originalGameObject, newGameObject);
        });
    }

    // Skip functions - they can't be cloned reliably
    if (typeof obj === 'function') {
        return undefined;
    }

    // Handle objects that have their own clone method
    if (typeof obj.clone === 'function') {
        return obj.clone();
    }

    // For regular objects, create a new object and copy properties
    try {
        // Try using structuredClone first for performance
        const cloned = structuredClone(obj);

        // Still need to check for and replace gameObject references
        if (originalGameObject && newGameObject) {
            // Recursively search for references to replace
            replaceReferences(cloned, originalGameObject, newGameObject);
        }

        return cloned;
    } catch (e) {
        // Fall back to manual cloning when structuredClone fails
        const clonedObj = Array.isArray(obj) ? [] : {};

        for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                if (typeof obj[key] === 'function') {
                    // Skip functions - they can't be cloned reliably
                    continue;
                }

                // Replace GameObject references
                if (originalGameObject && obj[key] === originalGameObject) {
                    clonedObj[key] = newGameObject;
                } else {
                    clonedObj[key] = safeClone(obj[key], originalGameObject, newGameObject);
                }
            }
        }

        return clonedObj;
    }
}

function createPlaceholderModule(gameObj, moduleData, typeName) {
    try {
        // Check if Module class is available
        if (typeof Module === 'undefined') {
            console.error("Module base class not available for placeholder creation");
            return null;
        }

        // Create a basic module that preserves the data
        const placeholderModule = new Module(`${typeName || 'Unknown'} (Missing)`);
        placeholderModule.id = moduleData.id || crypto.randomUUID();
        placeholderModule.type = typeName || 'UnknownModule';
        placeholderModule.missingModule = true;
        placeholderModule.originalData = moduleData;
        placeholderModule.gameObject = gameObj;  // Make sure to set this reference

        // Add the placeholder module directly to avoid using addModule which could have side effects
        gameObj.modules.push(placeholderModule);

        console.warn(`Created placeholder for missing module: ${typeName}. Available modules: ${Array.from(window.moduleRegistry?.modules?.keys() || []).join(', ')
            }`);

        return placeholderModule;
    } catch (e) {
        console.error("Failed to create placeholder module:", e);
        return null;
    }
}

// src/core/InputManager.js
/**
 * InputManager - Handles keyboard, mouse and touch input
 * 
 * This is a global system that manages all input in a centralized way,
 * allowing modules to easily check for input states without adding their
 * own event listeners.
 */
class InputManager {
    constructor() {
        // Keyboard state tracking
        this.keys = {};          // Current key states (down/up)
        this.keysDown = {};      // Keys that went down this frame
        this.keysUp = {};        // Keys that went up this frame
        this.keysPressed = {};   // Keys that were pressed this frame (for continuous input)

        // Mouse state tracking
        this.mousePosition = new Vector2(0, 0);       // Current mouse position
        this.worldMousePosition = new Vector2(0, 0);  // Mouse position in world coordinates
        this.mouseButtons = {                         // Mouse button states
            left: false,
            middle: false,
            right: false
        };
        this.mouseButtonsDown = {                     // Mouse buttons that went down this frame
            left: false,
            middle: false,
            right: false
        };
        this.mouseButtonsUp = {                       // Mouse buttons that went up this frame
            left: false,
            middle: false,
            right: false
        };
        this.mouseWheel = 0;                          // Mouse wheel delta
        this.mouseMoveThisFrame = false;              // Whether the mouse moved this frame

        // Touch state tracking
        this.touches = {};                            // Current active touches
        this.touchesStarted = {};                     // Touches that started this frame
        this.touchesEnded = {};                       // Touches that ended this frame

        // Engine reference for coordinate transformations
        this.engine = null;

        // DOM element to attach listeners to
        this.targetElement = document;

        // Flag to indicate if input is enabled
        this.enabled = true;

        // Bind event handlers to preserve 'this' context
        this._handleKeyDown = this._handleKeyDown.bind(this);
        this._handleKeyUp = this._handleKeyUp.bind(this);
        this._handleMouseMove = this._handleMouseMove.bind(this);
        this._handleMouseDown = this._handleMouseDown.bind(this);
        this._handleMouseUp = this._handleMouseUp.bind(this);
        this._handleWheel = this._handleWheel.bind(this);
        this._handleTouchStart = this._handleTouchStart.bind(this);
        this._handleTouchMove = this._handleTouchMove.bind(this);
        this._handleTouchEnd = this._handleTouchEnd.bind(this);

        // Initialize
        this.initialize();
    }

    /**
     * Initialize the input manager and attach event listeners
     */
    initialize() {
        // Keyboard events
        window.addEventListener('keydown', this._handleKeyDown);
        window.addEventListener('keyup', this._handleKeyUp);

        // Mouse events
        this.targetElement.addEventListener('mousemove', this._handleMouseMove);
        this.targetElement.addEventListener('mousedown', this._handleMouseDown);
        this.targetElement.addEventListener('mouseup', this._handleMouseUp);
        this.targetElement.addEventListener('wheel', this._handleWheel);
        this.targetElement.addEventListener('contextmenu', (e) => {
            if (this.preventContextMenu) e.preventDefault();
        });

        // Touch events
        this.targetElement.addEventListener('touchstart', this._handleTouchStart);
        this.targetElement.addEventListener('touchmove', this._handleTouchMove);
        this.targetElement.addEventListener('touchend', this._handleTouchEnd);
        this.targetElement.addEventListener('touchcancel', this._handleTouchEnd);

        /*window.addEventListener('mousedown', this._handleMouseDown);
        window.addEventListener('mouseup', this._handleMouseUp);
        window.addEventListener('mousemove', this._handleMouseMove);
        window.addEventListener('wheel', this._handleWheel);
        window.addEventListener('contextmenu', (e) => {
            if (this.preventContextMenu) e.preventDefault();
        });*/

        console.log('InputManager initialized');
    }

    /**
     * Set the engine reference for coordinate transformations
     * @param {Engine} engine - The game engine
     */
    setEngine(engine) {
        this.engine = engine;
    }

    /**
     * Update input states (called at the beginning of each frame)
     */
    beginFrame() {
        // Reset frame-specific states
        this.keysDown = {};
        this.keysUp = {};
        this.mouseButtonsDown = { left: false, middle: false, right: false };
        this.mouseButtonsUp = { left: false, middle: false, right: false };
        this.mouseWheel = 0;
        this.mouseMoveThisFrame = false;
        this.touchesStarted = {};
        this.touchesEnded = {};
    }

    /**
     * Update input states (called at the end of each frame)
     */
    endFrame() {
        // Update pressed keys (held down)
        this.keysPressed = Object.assign({}, this.keys);
        // Update pressed mouse buttons (held down)
        //this.mouseButtonsPressed = Object.assign({}, this.mouseButtons);
        // Clear ended touches
        //this.touchesEnded = {};
        //this.touchesStarted = {};

        // Update world mouse position if engine is available
        if (this.engine && this.engine.ctx) {
            this.updateWorldMousePosition();
        }
    }

    /**
     * Convert screen mouse position to world coordinates
     */
    updateWorldMousePosition() {
        if (!this.engine || !this.engine.ctx) return;

        const canvas = this.engine.canvas;
        const ctx = this.engine.ctx;

        // Get the current transformation matrix
        const transform = ctx.getTransform();

        // Get the canvas bounds
        const rect = canvas.getBoundingClientRect();

        // Calculate mouse position relative to canvas
        const mouseX = this.mousePosition.x - rect.left;
        const mouseY = this.mousePosition.y - rect.top;

        // Apply inverse of the transformation matrix to get world coordinates
        const transformedX = (mouseX / transform.a) - (transform.e / transform.a);
        const transformedY = (mouseY / transform.d) - (transform.f / transform.d);

        this.worldMousePosition.x = transformedX;
        this.worldMousePosition.y = transformedY;
    }

    // ----------------------
    // Keyboard Input Methods
    // ----------------------

    /**
     * Check if a key is currently down
     * @param {string} keyCode - The key code or name
     * @returns {boolean} True if the key is down
     */
    keyDown(keyCode) {
        return this.keys[keyCode.toLowerCase()] === true;
    }

    /**
     * Check if a key was pressed this frame
     * @param {string} keyCode - The key code or name
     * @returns {boolean} True if the key was pressed this frame
     */
    keyPressed(keyCode) {
        return this.keysDown[keyCode.toLowerCase()] === true;
    }

    /**
     * Check if a key was released this frame
     * @param {string} keyCode - The key code or name
     * @returns {boolean} True if the key was released this frame
     */
    keyReleased(keyCode) {
        return this.keysUp[keyCode.toLowerCase()] === true;
    }

    /**
     * Handle key down events
     * @private
     */
    _handleKeyDown(e) {
        if (!this.enabled) return;

        const key = e.key.toLowerCase();

        // Skip if already down (handles key repeat)
        if (!this.keys[key]) {
            this.keys[key] = true;
            this.keysDown[key] = true;
        }
    }

    /**
     * Handle key up events
     * @private
     */
    _handleKeyUp(e) {
        if (!this.enabled) return;

        const key = e.key.toLowerCase();
        this.keys[key] = false;
        this.keysUp[key] = true;
    }

    // -------------------
    // Mouse Input Methods
    // -------------------

    /**
     * Check if a mouse button is currently down
     * @param {string|number} button - Button to check ('left', 'middle', 'right' or button code)
     * @returns {boolean} True if the button is down
     */
    mouseDown(button) {
        if (typeof button === 'string') {
            return this.mouseButtons[button] === true;
        }

        switch (button) {
            case 0: return this.mouseButtons.left;
            case 1: return this.mouseButtons.middle;
            case 2: return this.mouseButtons.right;
            default: return false;
        }
    }

    /**
     * Check if a mouse button was pressed this frame
     * @param {string|number} button - Button to check ('left', 'middle', 'right' or button code)
     * @returns {boolean} True if the button was pressed this frame
     */
    mousePressed(button) {
        if (typeof button === 'string') {
            return this.mouseButtonsDown[button] === true;
        }

        switch (button) {
            case 0: return this.mouseButtonsDown.left;
            case 1: return this.mouseButtonsDown.middle;
            case 2: return this.mouseButtonsDown.right;
            default: return false;
        }
    }

    /**
     * Check if a mouse button was released this frame
     * @param {string|number} button - Button to check ('left', 'middle', 'right' or button code)
     * @returns {boolean} True if the button was released this frame
     */
    mouseReleased(button) {
        if (typeof button === 'string') {
            return this.mouseButtonsUp[button] === true;
        }

        switch (button) {
            case 0: return this.mouseButtonsUp.left;
            case 1: return this.mouseButtonsUp.middle;
            case 2: return this.mouseButtonsUp.right;
            default: return false;
        }
    }

    /**
     * Get the current mouse position
     * @param {boolean} worldSpace - If true, returns position in world coordinates
     * @returns {Vector2} The mouse position
     */
    getMousePosition(worldSpace = false) {
        return worldSpace ? this.worldMousePosition.clone() : this.mousePosition.clone();
    }

    /**
     * Check if the mouse moved this frame
     * @returns {boolean} True if the mouse moved this frame
     */
    didMouseMove() {
        return this.mouseMoveThisFrame;
    }

    /**
     * Get the mouse wheel delta
     * @returns {number} The mouse wheel delta
     */
    getMouseWheelDelta() {
        return this.mouseWheel;
    }

    /**
     * Handle mouse move events
     * @private
     */
    _handleMouseMove(e) {
        if (!this.enabled) return;

        this.mousePosition.x = e.clientX;
        this.mousePosition.y = e.clientY;
        this.mouseMoveThisFrame = true;
    }

    /**
     * Handle mouse down events
     * @private
     */
    _handleMouseDown(e) {
        if (!this.enabled) return;

        //console.log('Mouse Down:' + e.button + ' at ' + e.clientX + ',' + e.clientY + ' World Position: ' + this.worldMousePosition.x + ',' + this.worldMousePosition.y);

        switch (e.button) {
            case 0: // Left
                this.mouseButtons.left = true;
                this.mouseButtonsDown.left = true;
                break;
            case 1: // Middle
                this.mouseButtons.middle = true;
                this.mouseButtonsDown.middle = true;
                break;
            case 2: // Right
                this.mouseButtons.right = true;
                this.mouseButtonsDown.right = true;
                break;
        }
    }

    /**
     * Handle mouse up events
     * @private
     */
    _handleMouseUp(e) {
        if (!this.enabled) return;

        switch (e.button) {
            case 0: // Left
                this.mouseButtons.left = false;
                this.mouseButtonsUp.left = true;
                break;
            case 1: // Middle
                this.mouseButtons.middle = false;
                this.mouseButtonsUp.middle = true;
                break;
            case 2: // Right
                this.mouseButtons.right = false;
                this.mouseButtonsUp.right = true;
                break;
        }
    }

    /**
     * Handle mouse wheel events
     * @private
     */
    _handleWheel(e) {
        if (!this.enabled) return;

        this.mouseWheel = Math.sign(e.deltaY); // 1 for scroll down, -1 for scroll up
    }

    // -------------------
    // Touch Input Methods
    // -------------------

    /**
     * Handle touch start events
     * @private
     */
    _handleTouchStart(e) {
        if (!this.enabled) return;

        // Prevent default to avoid scrolling and other touch behaviors
        e.preventDefault();

        for (let i = 0; i < e.changedTouches.length; i++) {
            const touch = e.changedTouches[i];
            const id = touch.identifier;

            // Get canvas-relative coordinates
            let x = touch.clientX;
            let y = touch.clientY;

            // Convert to canvas coordinates
            if (this.engine && this.engine.canvas) {
                const rect = this.engine.canvas.getBoundingClientRect();
                x = touch.clientX - rect.left;
                y = touch.clientY - rect.top;

                // Scale coordinates if canvas is scaled
                const scaleX = this.engine.canvas.width / rect.width;
                const scaleY = this.engine.canvas.height / rect.height;
                x *= scaleX;
                y *= scaleY;
            } else {
                // Fallback: try to find game canvas
                const gameCanvas = document.getElementById('gameCanvas');
                const editorCanvas = document.getElementById('editorCanvas');
                const canvas = gameCanvas || editorCanvas;

                if (canvas) {
                    const rect = canvas.getBoundingClientRect();
                    x = touch.clientX - rect.left;
                    y = touch.clientY - rect.top;

                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    x *= scaleX;
                    y *= scaleY;
                }
            }

            this.touches[id] = {
                id,
                position: new Vector2(x, y),
                startPosition: new Vector2(x, y),
                startTime: Date.now(),
                moved: false,
                totalDistance: 0
            };

            this.touchesStarted[id] = this.touches[id];

            // For single touch, simulate mouse events
            if (Object.keys(this.touches).length === 1) {
                this.mousePosition.x = touch.clientX;
                this.mousePosition.y = touch.clientY;
                this.mouseMoveThisFrame = true;
                this.mouseButtons.left = true;
                this.mouseButtonsDown.left = true;
            }
        }
    }

    /**
     * Handle touch move events
     * @private
     */
    _handleTouchMove(e) {
        if (!this.enabled) return;

        // Prevent default to avoid scrolling
        e.preventDefault();

        for (let i = 0; i < e.changedTouches.length; i++) {
            const touch = e.changedTouches[i];
            const id = touch.identifier;

            if (this.touches[id]) {
                // Get canvas-relative coordinates
                let x = touch.clientX;
                let y = touch.clientY;

                // Convert to canvas coordinates
                if (this.engine && this.engine.canvas) {
                    const rect = this.engine.canvas.getBoundingClientRect();
                    x = touch.clientX - rect.left;
                    y = touch.clientY - rect.top;

                    // Scale coordinates if canvas is scaled
                    const scaleX = this.engine.canvas.width / rect.width;
                    const scaleY = this.engine.canvas.height / rect.height;
                    x *= scaleX;
                    y *= scaleY;
                } else {
                    // Fallback: try to find game canvas
                    const gameCanvas = document.getElementById('gameCanvas');
                    const editorCanvas = document.getElementById('editorCanvas');
                    const canvas = gameCanvas || editorCanvas;

                    if (canvas) {
                        const rect = canvas.getBoundingClientRect();
                        x = touch.clientX - rect.left;
                        y = touch.clientY - rect.top;

                        const scaleX = canvas.width / rect.width;
                        const scaleY = canvas.height / rect.height;
                        x *= scaleX;
                        y *= scaleY;
                    }
                }

                // Calculate movement distance
                const deltaX = x - this.touches[id].position.x;
                const deltaY = y - this.touches[id].position.y;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                // Update touch data
                this.touches[id].position.x = x;
                this.touches[id].position.y = y;
                this.touches[id].moved = true;
                this.touches[id].totalDistance += distance;

                // For single touch, simulate mouse events
                if (Object.keys(this.touches).length === 1) {
                    this.mousePosition.x = touch.clientX;
                    this.mousePosition.y = touch.clientY;
                    this.mouseMoveThisFrame = true;
                }
            }
        }
    }

    /**
     * Handle touch end events
     * @private
     */
    _handleTouchEnd(e) {
        if (!this.enabled) return;

        // Prevent default to avoid ghost clicks
        e.preventDefault();

        for (let i = 0; i < e.changedTouches.length; i++) {
            const touch = e.changedTouches[i];
            const id = touch.identifier;

            if (this.touches[id]) {
                // Calculate final position
                let x = touch.clientX;
                let y = touch.clientY;

                // Convert to canvas coordinates
                if (this.engine && this.engine.canvas) {
                    const rect = this.engine.canvas.getBoundingClientRect();
                    x = touch.clientX - rect.left;
                    y = touch.clientY - rect.top;

                    // Scale coordinates if canvas is scaled
                    const scaleX = this.engine.canvas.width / rect.width;
                    const scaleY = this.engine.canvas.height / rect.height;
                    x *= scaleX;
                    y *= scaleY;
                } else {
                    // Fallback: try to find game canvas
                    const gameCanvas = document.getElementById('gameCanvas');
                    const editorCanvas = document.getElementById('editorCanvas');
                    const canvas = gameCanvas || editorCanvas;

                    if (canvas) {
                        const rect = canvas.getBoundingClientRect();
                        x = touch.clientX - rect.left;
                        y = touch.clientY - rect.top;

                        const scaleX = canvas.width / rect.width;
                        const scaleY = canvas.height / rect.height;
                        x *= scaleX;
                        y *= scaleY;
                    }
                }

                // Update final position
                this.touches[id].position.x = x;
                this.touches[id].position.y = y;

                // Store ended touch
                this.touchesEnded[id] = Object.assign({}, this.touches[id]);
                delete this.touches[id];

                // Update mouse buttons for single touch
                if (Object.keys(this.touches).length === 0) {
                    this.mouseButtons.left = false;
                    this.mouseButtonsUp.left = true;
                }
            }
        }
    }

    /**
     * Get active touch points
     * @returns {Object} Map of active touches
     */
    getTouches() {
        return this.touches;
    }

    /**
     * Get the count of active touches
     * @returns {number} Number of active touches
     */
    getTouchCount() {
        return Object.keys(this.touches).length;
    }

    /**
     * Check if a tap occurred this frame
     * @returns {boolean} True if a tap occurred
     */
    isTapped() {
        for (const id in this.touchesEnded) {
            const touch = this.touchesEnded[id];
            const duration = touch.startTime ? Date.now() - touch.startTime : 0;

            // Check if it's a short tap (less than 300ms)
            if (duration < 300) {
                // Check if finger didn't move too much
                const distance = touch.position.distanceTo(touch.startPosition);
                if (distance < 20) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Check if a long press occurred this frame
     * @returns {boolean} True if a long press occurred
     */
    isLongPressed() {
        for (const id in this.touchesEnded) {
            const touch = this.touchesEnded[id];
            const duration = touch.startTime ? Date.now() - touch.startTime : 0;

            // Check if it's a long press (more than 500ms) with minimal movement
            if (duration > 500) {
                const distance = touch.position.distanceTo(touch.startPosition);
                if (distance < 30) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Get pinch zoom data for two-finger gestures
     * @returns {Object|null} Pinch data or null if not pinching
     */
    getPinchData() {
        const touchIds = Object.keys(this.touches);
        if (touchIds.length !== 2) return null;

        const touch1 = this.touches[touchIds[0]];
        const touch2 = this.touches[touchIds[1]];

        const currentDistance = touch1.position.distanceTo(touch2.position);
        const startDistance = touch1.startPosition.distanceTo(touch2.startPosition);

        const centerX = (touch1.position.x + touch2.position.x) / 2;
        const centerY = (touch1.position.y + touch2.position.y) / 2;

        return {
            scale: currentDistance / startDistance,
            center: new Vector2(centerX, centerY),
            distance: currentDistance,
            startDistance: startDistance
        };
    }

    /**
     * Check if currently pinching (two fingers)
     * @returns {boolean} True if pinching
     */
    isPinching() {
        return Object.keys(this.touches).length === 2;
    }

    /**
     * Get swipe direction if a swipe occurred this frame
     * @returns {string|null} Direction ('up', 'down', 'left', 'right') or null
     */
    getSwipeDirection() {
        for (const id in this.touchesEnded) {
            const touch = this.touchesEnded[id];
            const duration = touch.startTime ? Date.now() - touch.startTime : 0;

            // Check if it's a quick swipe (less than 300ms) with significant movement
            if (duration < 300 && touch.totalDistance > 50) {
                const deltaX = touch.position.x - touch.startPosition.x;
                const deltaY = touch.position.y - touch.startPosition.y;

                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    return deltaX > 0 ? 'right' : 'left';
                } else {
                    return deltaY > 0 ? 'down' : 'up';
                }
            }
        }
        return null;
    }

    /**
     * Clean up and remove all event listeners
     */
    destroy() {
        window.removeEventListener('keydown', this._handleKeyDown);
        window.removeEventListener('keyup', this._handleKeyUp);

        this.targetElement.removeEventListener('mousemove', this._handleMouseMove);
        this.targetElement.removeEventListener('mousedown', this._handleMouseDown);
        this.targetElement.removeEventListener('mouseup', this._handleMouseUp);
        this.targetElement.removeEventListener('wheel', this._handleWheel);

        this.targetElement.removeEventListener('touchstart', this._handleTouchStart);
        this.targetElement.removeEventListener('touchmove', this._handleTouchMove);
        this.targetElement.removeEventListener('touchend', this._handleTouchEnd);
        this.targetElement.removeEventListener('touchcancel', this._handleTouchEnd);
    }

    /**
     * Enable input processing
     */
    enable() {
        this.enabled = true;
    }

    /**
     * Disable input processing
     */
    disable() {
        this.enabled = false;

        // Clear all input states
        this.keys = {};
        this.keysDown = {};
        this.keysUp = {};
        this.keysPressed = {};

        this.mouseButtons = { left: false, middle: false, right: false };
        this.mouseButtonsDown = { left: false, middle: false, right: false };
        this.mouseButtonsUp = { left: false, middle: false, right: false };

        this.touches = {};
        this.touchesStarted = {};
        this.touchesEnded = {};
    }

    // Prevent context menu from showing on right click
    preventContextMenu() {
        this.preventContextMenu = true;
    }

    // Allow context menu to show on right click
    allowContextMenu() {
        this.preventContextMenu = false;
    }

    /**
 * Enable debug logging for input events
 */
    enableDebugMode() {
        this.debugMode = true;

        // Add console logs to event handlers
        const originalHandleMouseDown = this._handleMouseDown;
        const originalHandleMouseUp = this._handleMouseUp;
        const originalHandleMouseMove = this._handleMouseMove;

        this._handleMouseDown = (e) => {
            if (this.debugMode) console.log('Mouse down:', e.button, 'at', e.clientX, e.clientY);
            originalHandleMouseDown.call(this, e);
        };

        this._handleMouseUp = (e) => {
            if (this.debugMode) console.log('Mouse up:', e.button, 'at', e.clientX, e.clientY);
            originalHandleMouseUp.call(this, e);
        };

        this._handleMouseMove = (e) => {
            if (this.debugMode && this.frameCount % 60 === 0) { // Log every 60th frame to avoid spam
                console.log('Mouse move:', e.clientX, e.clientY);
            }
            originalHandleMouseMove.call(this, e);
        };

        this.frameCount = 0;
    }

    /**
     * Test if event listeners are properly attached
     */
    testEventListeners() {
        console.log('Testing event listeners...');
        console.log('Target element:', this.targetElement);
        console.log('Canvas element:', this.engine?.canvas);

        // Test with a temporary click handler
        const testHandler = (e) => {
            console.log('TEST: Click detected on', e.target.tagName, 'at', e.clientX, e.clientY);
            document.removeEventListener('click', testHandler);
        };

        document.addEventListener('click', testHandler);
        console.log('Click anywhere to test event detection...');
    }

    /**
     * Switch to canvas-based event listeners
     */
    useCanvasTarget() {
        if (!this.engine || !this.engine.canvas) {
            console.warn('Cannot switch to canvas target: engine or canvas not available');
            return;
        }

        // Remove existing listeners
        this.targetElement.removeEventListener('mousemove', this._handleMouseMove);
        this.targetElement.removeEventListener('mousedown', this._handleMouseDown);
        this.targetElement.removeEventListener('mouseup', this._handleMouseUp);
        this.targetElement.removeEventListener('wheel', this._handleWheel);

        // Switch target to canvas
        this.targetElement = this.engine.canvas;

        // Make canvas focusable
        this.targetElement.tabIndex = 0;

        // Re-attach listeners to canvas
        this.targetElement.addEventListener('mousemove', this._handleMouseMove);
        this.targetElement.addEventListener('mousedown', this._handleMouseDown);
        this.targetElement.addEventListener('mouseup', this._handleMouseUp);
        this.targetElement.addEventListener('wheel', this._handleWheel);

        console.log('Switched to canvas-based event listeners');
    }

    /**
     * Get current input state for debugging
     */
    getDebugState() {
        return {
            mousePosition: this.mousePosition,
            worldMousePosition: this.worldMousePosition,
            mouseButtons: this.mouseButtons,
            mouseButtonsDown: this.mouseButtonsDown,
            mouseButtonsUp: this.mouseButtonsUp,
            enabled: this.enabled,
            targetElement: this.targetElement.tagName || 'document',
            touchCount: this.getTouchCount()
        };
    }

    // Add constants for key codes and mouse buttons like 'key.a', 'key.alt', 'key.space', 'mouse.left', etc.
    /**
     * Constants for key codes and mouse buttons for easier use
     */
    static get key() {
        return {
            // Letters
            a: 'a', b: 'b', c: 'c', d: 'd', e: 'e', f: 'f', g: 'g', h: 'h',
            i: 'i', j: 'j', k: 'k', l: 'l', m: 'm', n: 'n', o: 'o', p: 'p',
            q: 'q', r: 'r', s: 's', t: 't', u: 'u', v: 'v', w: 'w', x: 'x',
            y: 'y', z: 'z',

            // Numbers
            0: '0', 1: '1', 2: '2', 3: '3', 4: '4',
            5: '5', 6: '6', 7: '7', 8: '8', 9: '9',

            // Special keys
            backspace: 'backspace',
            tab: 'tab',
            enter: 'enter',
            shift: 'shift',
            control: 'control',
            ctrl: 'control',
            alt: 'alt',
            pause: 'pause',
            capslock: 'capslock',
            escape: 'escape',
            esc: 'escape',
            space: ' ',
            pageup: 'pageup',
            pagedown: 'pagedown',
            end: 'end',
            home: 'home',

            // Arrow keys
            left: 'arrowleft',
            up: 'arrowup',
            right: 'arrowright',
            down: 'arrowdown',
            arrowleft: 'arrowleft',
            arrowup: 'arrowup',
            arrowright: 'arrowright',
            arrowdown: 'arrowdown',

            // Special characters
            insert: 'insert',
            delete: 'delete',

            // Function keys
            f1: 'f1', f2: 'f2', f3: 'f3', f4: 'f4', f5: 'f5',
            f6: 'f6', f7: 'f7', f8: 'f8', f9: 'f9', f10: 'f10',
            f11: 'f11', f12: 'f12',

            // Number pad
            numlock: 'numlock',
            numpad0: '0', numpad1: '1', numpad2: '2', numpad3: '3', numpad4: '4',
            numpad5: '5', numpad6: '6', numpad7: '7', numpad8: '8', numpad9: '9',

            // Operators
            multiply: '*',
            add: '+',
            subtract: '-',
            decimal: '.',
            divide: '/',

            // Others
            semicolon: ';',
            equal: '=',
            comma: ',',
            dash: '-',
            period: '.',
            slash: '/',
            graveaccent: '`',
            openbracket: '[',
            backslash: '\\',
            closebracket: ']',
            quote: "'",

            // Meta keys
            meta: 'meta',
            cmd: 'meta',
            win: 'meta'
        };
    }

    /**
     * Constants for mouse buttons for easier use
     */
    static get mouse() {
        return {
            left: 'left',
            middle: 'middle',
            right: 'right',
            button1: 0,   // Left button
            button2: 2,   // Right button
            button3: 1,   // Middle button
            button4: 3,   // Browser back button
            button5: 4    // Browser forward button
        };
    }

    /**
     * Constants for gamepad buttons
     */
    static get gamepad() {
        return {
            a: 0,
            b: 1,
            x: 2,
            y: 3,
            leftbumper: 4,
            rightbumper: 5,
            lefttrigger: 6,
            righttrigger: 7,
            select: 8,
            start: 9,
            leftstick: 10,
            rightstick: 11,
            dpadup: 12,
            dpaddown: 13,
            dpadleft: 14,
            dpadright: 15,
            home: 16
        };
    }
}

// Create a global instance
window.input = new InputManager();
window.key = InputManager.key;
window.mouse = InputManager.mouse;
window.gamepad = InputManager.gamepad;

// src/core/Scene.js
class Scene {
    constructor(name = "New Scene") {
        this.name = name;
        this.path = null; // Store file path when saved
        this.gameObjects = [];
        this.settings = {
            viewportWidth: 1280,
            viewportHeight: 720,
            viewportX: 0,  
            viewportY: 0,
            backgroundColor: "#1e1e1e",
            gridEnabled: true,
            gridSize: 32,
            snapToGrid: false
        };
        this.dirty = false; // Track unsaved changes
    }

    markDirty() {
        this.dirty = true;
    }

    toJSON() {
        return {
            name: this.name,
            settings: {
                viewportWidth: this.settings.viewportWidth,
                viewportHeight: this.settings.viewportHeight,
                viewportX: this.settings.viewportX || 0,
                viewportY: this.settings.viewportY || 0,
                backgroundColor: this.settings.backgroundColor,
                gridEnabled: this.settings.gridEnabled,
                gridSize: this.settings.gridSize,
                snapToGrid: this.settings.snapToGrid,
                gravity: { x: 0, y: 1 },       // Physics gravity direction
                physicsEnabled: true,          // Whether physics is enabled
                physicsDebugDraw: false   
            },
            gameObjects: this.gameObjects.filter(obj => !obj.parent).map(obj => obj.toJSON())
        };
    }

    static fromJSON(json) {
        const scene = new Scene(json.name);
        scene.settings = json.settings || {};
        
        // Restore other scene properties
        scene.activeCamera = json.activeCamera;
        
        // Create gameObjects if we have GameObject reference
        if (typeof GameObject !== 'undefined' || window.GameObject) {
            // Use the appropriate GameObject reference
            const GameObjectRef = typeof GameObject !== 'undefined' ? GameObject : window.GameObject;
            
            // Create gameObjects
            scene.gameObjects = json.gameObjects.map(objJson => {
                return GameObjectRef.fromJSON(objJson);
            });
        } else {
            // If GameObject isn't available, store the JSON for later
            scene.gameObjectsJSON = json.gameObjects;
            scene.gameObjects = [];
            console.warn("GameObject class not available. Game objects will be loaded when GameObject class is available.");
        }
        
        return scene;
    }

    completeLoading() {
        if (this.gameObjectsJSON && (typeof GameObject !== 'undefined' || window.GameObject)) {
            const GameObjectRef = typeof GameObject !== 'undefined' ? GameObject : window.GameObject;
            this.gameObjects = this.gameObjectsJSON.map(objJson => {
                return GameObjectRef.fromJSON(objJson);
            });
            delete this.gameObjectsJSON;
            return true;
        }
        return false;
    }

    // Add engine integration methods
    attachToEngine(engine) {
        engine.scene = this;
        engine.gameObjects = this.gameObjects;
    }

    /**
     * Find a GameObject by name in the scene
     * @param {string} name - The name of the GameObject to find
     * @returns {GameObject|null} The found GameObject or null if not found
     */
    findGameObjectByName(name) {
        return this.findGameObjectByNameRecursive(this.gameObjects, name);
    }

    /**
     * Recursively search for a GameObject by name
     * @param {Array} objects - Array of GameObjects to search
     * @param {string} name - The name to search for
     * @returns {GameObject|null} The found GameObject or null if not found
     */
    findGameObjectByNameRecursive(objects, name) {
        for (const obj of objects) {
            if (obj.name === name) {
                return obj;
            }
            
            // Search in children if they exist
            if (obj.children && obj.children.length > 0) {
                const found = this.findGameObjectByNameRecursive(obj.children, name);
                if (found) {
                    return found;
                }
            }
        }
        return null;
    }

    /**
     * Alias for findGameObjectByName for consistency with documentation
     * @param {string} name - The name of the GameObject to find
     * @returns {GameObject|null} The found GameObject or null if not found
     */
    findGameObject(name) {
        return this.findGameObjectByName(name);
    }
}

// src/core/Engine.js
class Engine {
    constructor(canvas) {
        this.canvas = canvas;

        this.guiCanvas = document.createElement('canvas');
        this.guiCanvas.width = 800;
        this.guiCanvas.height = 600;
        this.guiCanvas.style.position = 'absolute';
        this.guiCanvas.style.left = '0px';
        this.guiCanvas.style.top = '0px';
        this.guiCanvas.style.pointerEvents = 'none';

        this.backgroundCanvas = document.createElement('canvas');
        this.backgroundCanvas.width = 800;
        this.backgroundCanvas.height = 600;
        this.backgroundCanvas.style.position = 'absolute';
        this.backgroundCanvas.style.left = '0px';
        this.backgroundCanvas.style.top = '0px';
        this.backgroundCanvas.style.pointerEvents = 'none';

        this.ctx = canvas.getContext('2d');
        this.scene = null;
        this.gameObjects = [];
        this.lastTime = 0;
        this.running = false;
        this.preloaded = false;

        this.usePixi = false; // Set to true to enable Pixi.js
        this.pixiRenderer = null;

        // Track viewport settings
        this.viewport = {
            width: 800,
            height: 600,
            x: 0,
            y: 0,
            zoom: 1,
            angle: 0,
            // Add bounds checking
            minZoom: 0.1,
            maxZoom: 10,
            // Track if viewport is dirty and needs updates
            dirty: true,
            // Add viewport shake for effects
            shake: { x: 0, y: 0, intensity: 0, duration: 0 }
        };

        this.viewportOriginalPosition = {
            width: 800,
            height: 600,
            x: 0,
            y: 0,
            zoom: 1,
            angle: 0 // Camera angle in degrees
        };

        this.renderConfig = {
            scaleMode: 'fit', // 'fit', 'stretch', 'pixel-perfect', 'nearest-neighbor'
            fullscreen: false,
            maintainAspectRatio: true,
            pixelPerfect: false,
            smoothing: true,
            // Add DPI awareness
            pixelRatio: window.devicePixelRatio || 1
        };

        // Add reference to the editor
        this.editor = null;

        // Track if canvas was resized
        this.canvasResized = true;

        // Add viewport change callbacks
        this.viewportCallbacks = [];

        // Set the input manager reference to this engine
        if (window.input) {
            window.input.setEngine(this);
            window.input.useCanvasTarget();
        }

        if (!window.viewport) {
            window.viewport = this.viewport;
        }

        window.engine = this; // Global reference for easy access

        // Set up resize observer to continuously monitor container size
        this.setupResizeObserver();

        // Also listen for window resize events
        window.addEventListener('resize', () => {
            this.resizeCanvas();
        });

        // Listen for panel resize events
        window.addEventListener('panel-resized', () => {
            this.resizeCanvas();
        });

        // Initialize viewport properly
        this.initializeViewport();

        // Track dynamically created objects for cleanup
        this.dynamicObjects = new Set();
        this.originalGameObjects = [];

        this.maxFPS = 60; // Default, will be updated from settings
        this._minFrameInterval = 1000 / this.maxFPS;
        this._lastFrameTime = 0;

        canvas.tabIndex = 0; // Makes canvas focusable
        canvas.focus(); // Give it focus
    }

    initializePixiRenderer() {
        if (this.usePixi && window.PixiRenderer) {
            this.pixiRenderer = new PixiRenderer(this.canvas, this.viewport.width, this.viewport.height, {
                backgroundColor: this.scene.settings.backgroundColor || 0x000000,
                antialias: true
            });

            this.pixiRenderer.Init().then(success => {
                if (success) {
                    console.log("PixiRenderer initialized");
                } else {
                    console.error("Failed to initialize PixiRenderer");
                    this.pixiRenderer = null;
                    this.usePixi = false;
                }
            });
        }
    }

    // Add viewport management methods
    initializeViewport() {
        // Ensure viewport is properly initialized
        this.viewport.dirty = true;
        this.updateViewport();
    }

    updateViewport() {
        // Add safety check for shake object
        if (!this.viewport.shake) {
            this.viewport.shake = { x: 0, y: 0, intensity: 0, duration: 0 };
        }

        // Clamp zoom within bounds
        this.viewport.zoom = Math.max(this.viewport.minZoom,
            Math.min(this.viewport.maxZoom, this.viewport.zoom));

        // Normalize angle to 0-360 range
        this.viewport.angle = ((this.viewport.angle % 360) + 360) % 360;

        // Update viewport shake
        if (this.viewport.shake.duration > 0) {
            this.viewport.shake.duration -= 16; // Assuming 60fps
            if (this.viewport.shake.duration <= 0) {
                this.viewport.shake.x = 0;
                this.viewport.shake.y = 0;
                this.viewport.shake.intensity = 0;
            } else {
                const intensity = this.viewport.shake.intensity * (this.viewport.shake.duration / 1000);
                this.viewport.shake.x = (Math.random() - 0.5) * intensity;
                this.viewport.shake.y = (Math.random() - 0.5) * intensity;
            }
        }

        // Mark as clean
        this.viewport.dirty = false;

        // Notify callbacks
        this.viewportCallbacks.forEach(callback => {
            try {
                callback(this.viewport);
            } catch (error) {
                console.error('Error in viewport callback:', error);
            }
        });
    }

    setupResizeObserver() {
        if (this.canvas && this.canvas.parentElement && window.ResizeObserver) {
            // Create a ResizeObserver to monitor container size changes
            this.resizeObserver = new ResizeObserver(entries => {
                // Resize the canvas whenever the container size changes
                this.resizeCanvas();
            });

            // Start observing the canvas container
            this.resizeObserver.observe(this.canvas.parentElement);
        } else {
            // Fallback for browsers without ResizeObserver
            setInterval(() => this.resizeCanvas(), 1000); // Check every second
        }
    }

    // Set the canvas context for different drawing modes
    getBackgroundCanvas() {
        return this.backgroundCanvas.getContext('2d');
    }

    getGuiCanvas() {
        return this.guiCanvas.getContext('2d');
    }

    getMainCanvas() {
        return this.canvas.getContext('2d');
    }

    updateRenderConfig(settings) {
        // Update settings
        Object.assign(this.renderConfig, settings);

        // Force canvas resize to apply new settings
        this.resizeCanvas();
    }

    getGameObjectByName(name) {
        // Use a simple recursive search to find the first matching game object by name
        const findInObjects = (objects) => {
            for (const obj of objects) {
                if (obj.name === name) {
                    return obj;
                }
                if (obj.children && obj.children.length > 0) {
                    const found = findInObjects(obj.children);
                    if (found) return found;
                }
            }
            return null;
        };
        return findInObjects(this.gameObjects);
    }

    getAllObjects(objects = this.gameObjects, visited = new Set()) {
        let result = [];
        objects.forEach(obj => {
            if (visited.has(obj)) return;
            visited.add(obj);
            result.push(obj);
            if (obj.children && obj.children.length) {
                result = result.concat(this.getAllObjects(obj.children, visited));
            }
        });
        return result;
    }

    /*
        Find the nearest object to x and y by name within a certain range
    */
    findNearestObjectByName(x, y, name, maxRange = Infinity) {
        let nearest = null;
        let nearestDist = maxRange;

        this.gameObjects.forEach(obj => {
            if (obj.name === name) {
                const dx = obj.position.x - x;
                const dy = obj.position.y - y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearest = obj;
                }
            }
        });

        return nearest;
    }

    async preload() {
        console.log("Preloading game objects...");
        const preloadPromises = [];

        // Traverse all game objects and collect preload promises
        this.traverseGameObjects(this.gameObjects, obj => {
            if (obj.preload) {
                preloadPromises.push(obj.preload());
            }
            if (obj.modules) {
                obj.modules.forEach(module => {
                    if (module.preload) {
                        preloadPromises.push(module.preload(obj));
                    }
                });
            }
            obj.engine = this; // Set engine reference for each object
        });

        // Wait for all resources to load
        await Promise.all(preloadPromises);
        this.preloaded = true;
        console.log("All resources preloaded.");
    }

    traverseGameObjects(objects, callback) {
        objects.forEach(obj => {
            callback(obj);
            if (obj.children && obj.children.length > 0) {
                this.traverseGameObjects(obj.children, callback);
            }
        });
    }

    setViewportPosition(x, y) {
        this.viewport.x = x;
        this.viewport.y = y;
        this.viewport.dirty = true;
    }

    moveViewport(deltaX, deltaY) {
        this.viewport.x += deltaX;
        this.viewport.y += deltaY;
        this.viewport.dirty = true;
    }

    setViewportZoom(zoom) {
        this.viewport.zoom = Math.max(this.viewport.minZoom,
            Math.min(this.viewport.maxZoom, zoom));
        this.viewport.dirty = true;
    }

    zoomViewport(factor) {
        this.setViewportZoom(this.viewport.zoom * factor);
    }

    setViewportAngle(angle) {
        this.viewport.angle = angle;
        this.viewport.dirty = true;
    }

    rotateViewport(deltaAngle) {
        this.viewport.angle += deltaAngle;
        this.viewport.dirty = true;
    }

    shakeViewport(intensity, duration) {
        this.viewport.shake.intensity = intensity;
        this.viewport.shake.duration = duration;
    }

    worldToScreen(worldX, worldY) {
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;

        // Apply viewport transformations in reverse order
        let screenX = worldX - this.viewport.x + this.viewport.shake.x;
        let screenY = worldY - this.viewport.y + this.viewport.shake.y;

        // Apply zoom
        screenX = (screenX - centerX) * this.viewport.zoom + centerX;
        screenY = (screenY - centerY) * this.viewport.zoom + centerY;

        // Apply rotation if needed
        if (this.viewport.angle !== 0) {
            const radians = this.viewport.angle * Math.PI / 180;
            const cos = Math.cos(radians);
            const sin = Math.sin(radians);

            const relX = screenX - centerX;
            const relY = screenY - centerY;

            screenX = centerX + (relX * cos - relY * sin);
            screenY = centerY + (relX * sin + relY * cos);
        }

        return { x: screenX, y: screenY };
    }

    screenToWorld(screenX, screenY) {
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;

        let worldX = screenX;
        let worldY = screenY;

        // Reverse rotation
        if (this.viewport.angle !== 0) {
            const radians = -this.viewport.angle * Math.PI / 180;
            const cos = Math.cos(radians);
            const sin = Math.sin(radians);

            const relX = worldX - centerX;
            const relY = worldY - centerY;

            worldX = centerX + (relX * cos - relY * sin);
            worldY = centerY + (relX * sin + relY * cos);
        }

        // Reverse zoom
        worldX = (worldX - centerX) / this.viewport.zoom + centerX;
        worldY = (worldY - centerY) / this.viewport.zoom + centerY;

        // Reverse position offset and shake
        worldX = worldX + this.viewport.x - this.viewport.shake.x;
        worldY = worldY + this.viewport.y - this.viewport.shake.y;

        return { x: worldX, y: worldY };
    }

    onViewportChange(callback) {
        this.viewportCallbacks.push(callback);
    }

    removeViewportCallback(callback) {
        const index = this.viewportCallbacks.indexOf(callback);
        if (index > -1) {
            this.viewportCallbacks.splice(index, 1);
        }
    }

    async start() {
        if (this.usePixi && !this.pixiRenderer) {
            this.initializePixiRenderer();
        }

        if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null; // Ensure no stale frame
        }
        
        if (!this.scene) {
            console.error('No scene loaded');
            return;
        }

        console.log("Starting game...");

        this.viewportOriginalPosition = {
            width: this.viewport.width,
            height: this.viewport.height,
            x: this.viewport.x,
            y: this.viewport.y,
            zoom: this.viewport.zoom,
            angle: this.viewport.angle
        };

        // Perform any pre-start setup
        this.refreshModules();

        if (!this.preloaded) {
            await this.preload();
        }

        // Call start on all game objects
        this.traverseGameObjects(this.gameObjects, obj => {
            if (obj.active) {
                // Call the object's start method
                if (obj.start) {
                    obj.start();
                }

                // Call each module's start method
                /*obj.modules.forEach(module => {
                    if (module.enabled && module.start) {
                        try {
                            module.start();
                        } catch (error) {
                            console.error(`Error starting module ${module.type || module.constructor.name}:`, error);
                        }
                    }
                });*/
            }
        });

        // Initialize touch controls
        this.initTouchControls();

        this.running = true;
        this.lastTime = performance.now();
        this.animationFrameId = requestAnimationFrame(this.gameLoop.bind(this));
    }

    pause() {
        if (this.running) {
            this.wasRunning = true;
            this.running = false;
            cancelAnimationFrame(this.animationFrameId);
            console.log("Game paused");
        }
    }

    resume() {
        if (this.wasRunning && !this.running) {
            this.running = true;
            this.wasRunning = false;
            this.lastFrameTime = performance.now();
            this.animationFrameId = requestAnimationFrame(this.gameLoop.bind(this));
            console.log("Game resumed");
        }
    }

    stop() {
        console.log("Stopping game...");
        this.running = false;
        this.wasRunning = false;
        if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null; // Ensure no stale frame
        }

        // Preserve shake object structure when resetting viewport
        this.viewport = {
            width: this.viewportOriginalPosition.width,
            height: this.viewportOriginalPosition.height,
            x: this.viewportOriginalPosition.x,
            y: this.viewportOriginalPosition.y,
            zoom: this.viewportOriginalPosition.zoom,
            angle: this.viewportOriginalPosition.angle,
            // Preserve all viewport properties
            minZoom: this.viewport.minZoom,
            maxZoom: this.viewport.maxZoom,
            dirty: this.viewport.dirty,
            shake: { x: 0, y: 0, intensity: 0, duration: 0 }
        };

        // Call onDestroy on all game objects
        this.traverseGameObjects(this.gameObjects, obj => {
            if (obj.modules) {
                obj.modules.forEach(module => {
                    if (module.onDestroy) {
                        try {
                            module.onDestroy();
                        } catch (error) {
                            console.error(`Error in onDestroy for module ${module.type || module.constructor.name}:`, error);
                        }
                    }
                });
            }
        });

        // Clean up dynamically created prefab instances
        this.cleanupDynamicObjects();

        // Reset physics after calling onDestroy to properly restore positions
        if (window.physicsManager) {
            window.physicsManager.reset();
        }

        // NEW: Restore the original objects to the editor and fix selection
        if (window.editor && window.editor.activeScene) {
            // Restore original objects to the scene
            window.editor.activeScene.gameObjects = [...this.originalGameObjects];
            window.editor.scene.gameObjects = [...this.originalGameObjects];

            // If there was a selected object, try to find its original counterpart
            if (window.editor.hierarchy && window.editor.hierarchy.selectedObject) {
                const selectedClone = window.editor.hierarchy.selectedObject;

                // Find the original object by matching name and position
                const originalObject = this.findOriginalObject(selectedClone, this.originalGameObjects);

                if (originalObject) {
                    // Deselect the clone
                    selectedClone.setSelected(false);

                    // Select the original object
                    originalObject.setSelected(true);
                    window.editor.hierarchy.selectedObject = originalObject;

                    // Update the inspector to show the original object
                    if (window.editor.inspector) {
                        window.editor.inspector.inspectObject(originalObject);
                    }

                    // Update hierarchy UI to show proper selection
                    window.editor.hierarchy.refreshHierarchy();

                    // Make sure the hierarchy item is selected
                    const hierarchyItem = document.querySelector(`.hierarchy-item[data-id="${originalObject.id}"]`);
                    if (hierarchyItem) {
                        // Remove selection from all items first
                        document.querySelectorAll('.hierarchy-item').forEach(item => {
                            item.classList.remove('selected');
                        });
                        // Add selection to the correct item
                        hierarchyItem.classList.add('selected');
                    }
                } else {
                    // If we can't find the original, just clear the selection
                    selectedClone.setSelected(false);
                    window.editor.hierarchy.selectedObject = null;

                    // Update hierarchy UI
                    document.querySelectorAll('.hierarchy-item').forEach(item => {
                        item.classList.remove('selected');
                    });

                    // Show "no object selected" in inspector
                    if (window.editor.inspector) {
                        window.editor.inspector.showNoObjectMessage();
                    }
                }
            }

            // Refresh the hierarchy to show original objects
            if (window.editor.hierarchy) {
                window.editor.hierarchy.refreshHierarchy();
            }

            // Refresh the editor canvas to show restored objects
            window.editor.refreshCanvas();
        }
    }

    /**
     * Find the original object that corresponds to a cloned object
     * @param {GameObject} clonedObject - The cloned object to find the original for
     * @param {Array} originalObjects - Array of original objects to search in
     * @returns {GameObject|null} - The original object or null if not found
     */
    findOriginalObject(clonedObject, originalObjects) {
        // Helper function to search recursively through objects and their children
        const searchInObjects = (objects) => {
            for (const obj of objects) {
                // Match by name and original position (before any runtime changes)
                if (obj.name === clonedObject.name &&
                    obj._originalPosition && clonedObject._originalPosition &&
                    Math.abs(obj._originalPosition.x - clonedObject._originalPosition.x) < 0.01 &&
                    Math.abs(obj._originalPosition.y - clonedObject._originalPosition.y) < 0.01) {
                    return obj;
                }

                // If no original position stored, fall back to ID matching if available
                if (!obj._originalPosition && obj.id === clonedObject.id) {
                    return obj;
                }

                // Search in children
                if (obj.children && obj.children.length > 0) {
                    const found = searchInObjects(obj.children);
                    if (found) return found;
                }
            }
            return null;
        };

        return searchInObjects(originalObjects);
    }

    /**
     * Remove a dynamically created object
     * @param {GameObject} gameObject - The object to remove
     */
    removeDynamicObject(gameObject) {
        if (!gameObject) return false;

        // Remove from dynamic objects tracking
        this.dynamicObjects.delete(gameObject);

        // Remove from game objects array
        const index = this.gameObjects.indexOf(gameObject);
        if (index > -1) {
            this.gameObjects.splice(index, 1);
        }

        // Also remove from parent if it has one
        if (gameObject.parent) {
            gameObject.parent.removeChild(gameObject);
        }

        // Remove from editor's scene if available
        if (window.editor && window.editor.activeScene) {
            const editorIndex = window.editor.activeScene.gameObjects.indexOf(gameObject);
            if (editorIndex > -1) {
                window.editor.activeScene.gameObjects.splice(editorIndex, 1);
            }

            // Also remove from editor's scene reference
            const sceneIndex = window.editor.scene.gameObjects.indexOf(gameObject);
            if (sceneIndex > -1) {
                window.editor.scene.gameObjects.splice(sceneIndex, 1);
            }
        }

        // Check if this object is currently selected in the editor
        if (window.editor && window.editor.hierarchy && window.editor.hierarchy.selectedObject === gameObject) {
            gameObject.setSelected(false);
            window.editor.hierarchy.selectedObject = null;

            // Update hierarchy UI
            document.querySelectorAll('.hierarchy-item').forEach(item => {
                item.classList.remove('selected');
            });

            // Show "no object selected" in inspector
            if (window.editor.inspector) {
                window.editor.inspector.showNoObjectMessage();
            }
        }

        // Call onDestroy on the object and its modules
        if (gameObject.modules) {
            gameObject.modules.forEach(module => {
                if (module.onDestroy) {
                    try {
                        module.onDestroy();
                    } catch (error) {
                        console.error(`Error in onDestroy for module ${module.type || module.constructor.name}:`, error);
                    }
                }
            });
        }

        console.log(`Removed dynamic object: ${gameObject.name || 'Unnamed'}`);
        return true;
    }

    /**
     * Clean up all dynamically created objects
     */
    cleanupDynamicObjects() {
        console.log(`Cleaning up ${this.dynamicObjects.size} dynamic objects...`);

        // Convert to array to avoid modification during iteration
        const objectsToRemove = Array.from(this.dynamicObjects);

        objectsToRemove.forEach(obj => {
            this.removeDynamicObject(obj);
        });

        // Restore original game objects
        this.gameObjects = [...this.originalGameObjects];
        this.dynamicObjects.clear();

        // Update the editor if available
        if (window.editor) {
            // Update the editor's scene gameObjects reference
            if (window.editor.activeScene) {
                window.editor.activeScene.gameObjects = [...this.originalGameObjects];
                window.editor.scene.gameObjects = [...this.originalGameObjects];
            }

            // Clear any selected object if it was dynamic
            if (window.editor.hierarchy && window.editor.hierarchy.selectedObject) {
                const selectedObj = window.editor.hierarchy.selectedObject;
                if (selectedObj._isDynamic) {
                    selectedObj.setSelected(false);
                    window.editor.hierarchy.selectedObject = null;

                    // Update hierarchy UI
                    document.querySelectorAll('.hierarchy-item').forEach(item => {
                        item.classList.remove('selected');
                    });

                    // Show "no object selected" in inspector
                    if (window.editor.inspector) {
                        window.editor.inspector.showNoObjectMessage();
                    }
                }
            }

            // Refresh the hierarchy to remove dynamic objects from the UI
            if (window.editor.hierarchy) {
                window.editor.hierarchy.refreshHierarchy();
            }

            // Refresh the editor canvas
            window.editor.refreshCanvas();
        }

        console.log('Dynamic object cleanup complete');
    }

    refreshModules() {
        if (!window.moduleReloader || !window.moduleRegistry) {
            console.warn("Cannot refresh modules: ModuleReloader or ModuleRegistry not available");
            return false;
        }

        console.log("Refreshing all module instances before game start...");

        let totalUpdated = 0;

        // Get all registered module types
        const moduleTypes = Array.from(window.moduleRegistry.modules.keys());

        // Update instances of each module type
        moduleTypes.forEach(className => {
            const updated = window.moduleReloader.updateModuleInstances(
                className,
                this.gameObjects
            );

            if (updated > 0) {
                totalUpdated += updated;
                console.log(`Updated ${updated} instances of ${className}`);
            }
        });

        console.log(`Total module instances refreshed: ${totalUpdated}`);
        return totalUpdated > 0;
    }

    updateFPSLimit(newMaxFPS) {
        this.maxFPS = newMaxFPS;
        this._minFrameInterval = this.maxFPS > 0 ? 1000 / this.maxFPS : 0;
    }

    gameLoop(timestamp) {
        if (!this.running) return;

        // FPS limiting logic
        if (this.maxFPS > 0) {
            if (timestamp - this._lastFrameTime < this._minFrameInterval) {
                this.animationFrameId = requestAnimationFrame(this.gameLoop.bind(this));
                return;
            }
        }
        this._lastFrameTime = timestamp;

        const deltaTime = Math.min((timestamp - this.lastTime) / 1000, 0.1);
        this.lastTime = timestamp;

        // Update input manager at the start of the frame
        if (window.input) {
            window.input.beginFrame();
        }

        // Update viewport if dirty
        if (this.viewport.dirty) {
            this.updateViewport();
        }

        this.update(deltaTime);
        this.draw();

        // Update input manager at the end of the frame
        if (window.input) {
            window.input.endFrame();
        }

        this.animationFrameId = requestAnimationFrame(this.gameLoop.bind(this));
    }

    update(deltaTime) {
        // Begin loop phase
        this.traverseGameObjects(this.gameObjects, obj => {
            if (obj.active) {
                // Call object's beginLoop method
                if (obj.beginLoop) obj.beginLoop(deltaTime);

                // Call modules' beginLoop methods
                /*obj.modules.forEach(module => {
                    if (module.enabled && module.beginLoop) {
                        try {
                            // Only pass deltaTime parameter, not the object reference
                            module.beginLoop(deltaTime);
                        } catch (error) {
                            console.error(`Error in beginLoop for module ${module.type || module.constructor.name}:`, error);
                        }
                    }
                });*/
            }
        });

        // Update collision system
        if (window.collisionSystem) {
            // Get all active objects
            const allObjects = this.getAllObjects(this.gameObjects).filter(obj => obj.active);

            // Update collision detection
            window.collisionSystem.update(allObjects);
        }

        // Main loop phase
        this.traverseGameObjects(this.gameObjects, obj => {
            if (obj.active) {
                // Call object's loop method
                if (obj.loop) obj.loop(deltaTime);

                // Call modules' loop methods
                /*obj.modules.forEach(module => {
                    if (module.enabled && module.loop) {
                        try {
                            // Only pass deltaTime parameter, not the object reference
                            module.loop(deltaTime);
                        } catch (error) {
                            console.error(`Error in loop for module ${module.type || module.constructor.name}:`, error);
                        }
                    }
                });*/
            }
        });

        // End loop phase
        this.traverseGameObjects(this.gameObjects, obj => {
            if (obj.active) {
                // Call object's endLoop method
                if (obj.endLoop) obj.endLoop(deltaTime);

                // Call modules' endLoop methods
                /*obj.modules.forEach(module => {
                    if (module.enabled && module.endLoop) {
                        try {
                            // Only pass deltaTime parameter, not the object reference
                            module.endLoop(deltaTime);
                        } catch (error) {
                            console.error(`Error in endLoop for module ${module.type || module.constructor.name}:`, error);
                        }
                    }
                });*/
            }
        });
    }

    draw() {
        if (!this.canvas || !this.ctx || !this.running) return;

        if (this.usePixi && this.pixiRenderer) {
            // Sync GameObjects to Pixi
            const allObjects = this.getAllObjects(this.gameObjects);
            allObjects.forEach(obj => {
                if (!obj.pixiDisplayObject) {
                    const pixiObj = obj.createPixiDisplayObject();
                    this.pixiRenderer.addDisplayObject(pixiObj);
                }
                obj.updatePixiDisplayObject();
            });

            // Draw each active and visible object using pixiRenderer as context
            allObjects
                .filter(obj => obj.active && obj.visible !== false)
                .sort((a, b) => b.depth - a.depth)
                .forEach(obj => {
                    try {
                        obj.draw(this.pixiRenderer); // Pass pixiRenderer as context
                    } catch (error) {
                        console.error(`Error drawing object ${obj.name}:`, error);
                    }
                });

            this.pixiRenderer.render();
            return;
        }

        // Clear canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // Fill with scene background color
        if (this.scene && this.scene.settings && this.scene.settings.backgroundColor) {
            this.ctx.fillStyle = this.scene.settings.backgroundColor;
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }

        // Apply viewport transformation
        this.ctx.save();

        // Apply any camera transformations
        this.applyViewportTransform();

        // Draw background canvas if available
        if (this.backgroundCanvas) {
            this.ctx.save();
            this.ctx.globalAlpha = 1.0;
            // Apply proper background positioning
            this.ctx.drawImage(this.backgroundCanvas, 0, 0);
            this.ctx.restore();
        }

        // Draw all game objects, sorted by depth
        const allObjects = this.getAllObjects(this.gameObjects);

        // Make sure we actually have objects to draw
        if (allObjects.length === 0) {
            // If no objects, draw a placeholder message
            this.ctx.fillStyle = "#ffffff";
            this.ctx.font = "20px Arial";
            this.ctx.textAlign = "center";
            this.ctx.fillText("No objects in scene... What is a game without objects?", this.canvas.width / 2, this.canvas.height / 2);
        } else {
            // Draw each active and visible object
            allObjects
                .filter(obj => obj.active && obj.visible !== false)
                .sort((a, b) => b.depth - a.depth)
                .forEach(obj => {
                    try {
                        obj.draw(this.ctx);
                    } catch (error) {
                        console.error(`Error drawing object ${obj.name}:`, error);
                    }
                });
        }

        this.ctx.restore();

        // Draw GUI canvas AFTER restoring transform (GUI should not be affected by viewport)
        if (this.guiCanvas) {
            this.ctx.save();
            this.ctx.globalAlpha = 1.0;
            this.ctx.drawImage(this.guiCanvas, 0, 0);
            this.ctx.restore();
        }
    }

    applyViewportTransform() {
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;

        // Apply viewport transformations in the correct order

        // 1. Translate to center for zoom and rotation
        this.ctx.translate(centerX, centerY);

        // 2. Apply rotation
        if (this.viewport.angle && this.viewport.angle !== 0) {
            const radians = this.viewport.angle * Math.PI / 180;
            this.ctx.rotate(radians);
        }

        // 3. Apply zoom
        if (this.viewport.zoom && this.viewport.zoom !== 1) {
            this.ctx.scale(this.viewport.zoom, this.viewport.zoom);
        }

        // 4. Translate back and apply position offset + shake
        this.ctx.translate(
            -centerX - this.viewport.x + this.viewport.shake.x,
            -centerY - this.viewport.y + this.viewport.shake.y
        );
    }

    loadScene(scene) {
        // Stop current scene if running
        if (this.running) {
            this.stop();
        } else if (window.physicsManager) {
            // Ensure physics is reset even if not currently running
            window.physicsManager.reset();
        }

        console.log(`Loading scene: ${scene.name}`);
        console.log(`Scene has ${scene.gameObjects.length} game objects`);

        // Clone the scene to avoid modifying the editor version
        this.scene = scene;

        // Copy viewport settings and validate them
        if (scene.settings) {
            this.viewport.width = Math.max(1, scene.settings.viewportWidth || 800);
            this.viewport.height = Math.max(1, scene.settings.viewportHeight || 600);
            this.viewport.x = scene.settings.viewportX || 0;
            this.viewport.y = scene.settings.viewportY || 0;
            this.viewport.zoom = Math.max(0.1, scene.settings.viewportZoom || 1);
            this.viewport.angle = scene.settings.viewportAngle || 0;
        }

        // Mark viewport as dirty to force update
        this.viewport.dirty = true;

        // Deep clone only in editor. In exported/runtime builds, use objects as-built
        // so embedded assets (like SpriteRenderer.imageData) are preserved.
        if (window.editor) {
            // Store original positions before cloning
            this.storeOriginalPositions(scene.gameObjects);
            this.gameObjects = this.cloneGameObjects(scene.gameObjects, false);
        } else {
            this.gameObjects = scene.gameObjects;
        }

        // Store original objects for cleanup purposes
        this.originalGameObjects = [...scene.gameObjects]; // Use the original scene objects
        this.dynamicObjects.clear();

        this.preloaded = false;
        this.canvasResized = true;

        // Force canvas resize with new viewport settings
        this.resizeCanvas();
    }

    /**
 * Load scene by index (useful for exported games)
 */
    loadSceneByIndex(scenes, index) {
        if (!scenes || !Array.isArray(scenes) || index < 0 || index >= scenes.length) {
            console.error('Invalid scene index or scenes array');
            return false;
        }

        const scene = scenes[index];
        this.loadScene(scene);
        return true;
    }

    /**
     * Enhanced prefab instantiation
     */
    async instantiatePrefab(prefabName, x = 0, y = 0) {
        console.log(`Attempting to instantiate prefab: ${prefabName}`);

        let instantiated = null;

        // Check if we're in the editor - use the hierarchy's prefab manager
        if (window.editor && window.editor.hierarchy && window.editor.hierarchy.prefabManager) {
            const position = new Vector2(x, y);
            instantiated = window.editor.hierarchy.prefabManager.instantiatePrefabByName(prefabName, position);

            if (instantiated) {
                // Add to the current scene's gameObjects if not already added
                if (!this.gameObjects.includes(instantiated)) {
                    this.gameObjects.push(instantiated);
                }
            }
        }

        // If the hierarchy prefab manager failed, try loading from file browser
        if (!instantiated && window.editor && window.editor.fileBrowser) {
            const variations = [
                `${prefabName}.prefab`,
                `Prefabs/${prefabName}.prefab`,
                `/Prefabs/${prefabName}.prefab`
            ];

            for (const variation of variations) {
                try {
                    const content = await window.editor.fileBrowser.readFile(variation);
                    if (content) {
                        const prefabData = JSON.parse(content);
                        instantiated = this.createGameObjectFromPrefab(prefabData, x, y);

                        if (instantiated) {
                            if (!this.gameObjects.includes(instantiated)) {
                                this.gameObjects.push(instantiated);
                            }
                            console.log(`Successfully instantiated prefab from file: ${variation}`);
                            break;
                        }
                    }
                } catch (error) {
                    console.warn(`Failed to load prefab from ${variation}:`, error);
                }
            }
        }

        // Check if we're in an exported game with embedded prefabs
        if (!instantiated && window.prefabManager) {
            console.log('Using global prefab manager for instantiation');

            // Use the prefab manager's instantiation method
            if (typeof window.prefabManager.instantiatePrefabByName === 'function') {
                const position = new Vector2(x, y);
                instantiated = window.prefabManager.instantiatePrefabByName(prefabName, position);

                if (instantiated) {
                    // Add to the current scene's gameObjects if not already added
                    if (!this.gameObjects.includes(instantiated)) {
                        this.gameObjects.push(instantiated);
                    }
                    console.log(`Successfully instantiated prefab: ${prefabName}`);
                }
            }

            // Fallback: try direct prefab data access
            if (!instantiated && typeof window.prefabManager.findPrefabByName === 'function') {
                const prefabData = window.prefabManager.findPrefabByName(prefabName);
                if (prefabData) {
                    console.log(`Found prefab data, creating instance: ${prefabName}`);
                    instantiated = this.createGameObjectFromPrefab(prefabData, x, y);

                    if (instantiated) {
                        if (!this.gameObjects.includes(instantiated)) {
                            this.gameObjects.push(instantiated);
                        }
                    }
                }
            }
        }

        // Track the instantiated object for cleanup
        if (instantiated) {
            this.dynamicObjects.add(instantiated);
            // Mark it as dynamically created for identification
            instantiated._isDynamic = true;
            console.log(`Tracked dynamic object: ${instantiated.name || 'Unnamed'}`);
        } else {
            console.error(`Prefab not found: ${prefabName}`);
            console.log('Available prefabs:', this.getAvailablePrefabs());
        }

        return instantiated;
    }

    /**
     * Create GameObject from prefab data
     */
    createGameObjectFromPrefab(prefabData, x = 0, y = 0) {
        if (!prefabData) return null;

        try {
            // Create GameObject
            const gameObject = new GameObject(prefabData.name || "PrefabInstance", this || null);

            // Set position
            gameObject.position.x = x;
            gameObject.position.y = y;

            // Apply prefab properties
            if (prefabData.position) {
                gameObject.position.x += prefabData.position.x || 0;
                gameObject.position.y += prefabData.position.y || 0;
            }

            if (prefabData.scale) {
                gameObject.scale.x = prefabData.scale.x || 1;
                gameObject.scale.y = prefabData.scale.y || 1;
            }

            if (prefabData.angle !== undefined) {
                gameObject.angle = prefabData.angle;
            }

            // Add modules
            if (prefabData.modules && Array.isArray(prefabData.modules)) {
                for (const moduleData of prefabData.modules) {
                    const ModuleClass = window[moduleData.type];
                    if (ModuleClass) {
                        const module = new ModuleClass();
                        if (module.fromJSON && moduleData.data) {
                            module.fromJSON(moduleData.data);
                        }
                        gameObject.addModule(module);
                    } else {
                        console.warn(`Module class not found: ${moduleData.type}`);
                    }
                }
            }

            console.log(`Successfully created GameObject from prefab`);
            return gameObject;

        } catch (error) {
            console.error(`Error creating GameObject from prefab:`, error);
            return null;
        }
    }

    /**
     * Check if a prefab exists by name
     * @param {string} prefabName - Name of the prefab to check
     * @returns {boolean} True if the prefab exists
     */
    hasPrefab(prefabName) {
        if (!prefabName) return false;

        // Check if we're in the editor - use the hierarchy's prefab manager
        if (window.editor && window.editor.hierarchy && window.editor.hierarchy.prefabManager) {
            return window.editor.hierarchy.prefabManager.hasPrefab(prefabName);
        }

        // Check if we're in an exported game with embedded prefabs
        if (window.prefabManager && typeof window.prefabManager.hasPrefab === 'function') {
            return window.prefabManager.hasPrefab(prefabName);
        }

        // Also check if prefabs are available through the file browser
        if (window.editor && window.editor.fileBrowser) {
            // Try to find a prefab file that matches
            const variations = [
                `${prefabName}.prefab`,
                `Prefabs/${prefabName}.prefab`,
                `/Prefabs/${prefabName}.prefab`
            ];

            for (const variation of variations) {
                if (window.editor.fileBrowser.exists && window.editor.fileBrowser.exists(variation)) {
                    return true;
                }
            }
        }

        return false;
    }

    /**
     * Get all available prefab names
     * @returns {Array<string>} Array of prefab names
     */
    getAvailablePrefabs() {
        // Check if we're in the editor
        if (window.editor && window.editor.hierarchy && window.editor.hierarchy.prefabManager) {
            return window.editor.hierarchy.prefabManager.getAvailablePrefabs();
        }

        // Check if we're in an exported game
        if (window.prefabManager && typeof window.prefabManager.getAllPrefabNames === 'function') {
            return window.prefabManager.getAllPrefabNames();
        }

        // Fallback to engine's prefab cache
        if (this.prefabs && this.prefabs.keys) {
            return Array.from(this.prefabs.keys());
        }

        return [];
    }

    findGameObjectByName(name) {
        // Use a simple recursive search to find the first matching game object by name
        const findInObjects = (objects) => {
            for (const obj of objects) {
                if (obj.name === name) {
                    return obj;
                }
                if (obj.children && obj.children.length > 0) {
                    const found = findInObjects(obj.children);
                    if (found) return found;
                }
            }
            return null;
        };
        return findInObjects(this.gameObjects);
    }

    /**
 * Store original positions on objects before cloning for runtime
 * @param {Array} gameObjects - Array of game objects to process
 */
    storeOriginalPositions(gameObjects) {
        const storeForObject = (obj) => {
            // Store the original position
            obj._originalPosition = { x: obj.position.x, y: obj.position.y };

            // Store for children too
            if (obj.children && obj.children.length > 0) {
                obj.children.forEach(storeForObject);
            }
        };

        gameObjects.forEach(storeForObject);
    }

    cloneGameObjects(objects, addNameCopySuffix = true) {
        return objects.map(obj => {
            // Use the GameObject's built-in clone method
            const clonedObj = obj.clone(addNameCopySuffix);

            // Copy the original position to the clone for tracking
            if (obj._originalPosition) {
                clonedObj._originalPosition = { x: obj._originalPosition.x, y: obj._originalPosition.y };
            }

            // Handle the cloning of children separately to maintain proper hierarchy
            if (obj.children && obj.children.length > 0) {
                // Remove any existing children that were cloned
                clonedObj.children = [];

                // Clone all children recursively and add them properly
                const clonedChildren = this.cloneGameObjects(obj.children, addNameCopySuffix);
                clonedChildren.forEach(child => {
                    clonedObj.addChild(child);
                });
            }

            return clonedObj;
        });
    }

    initTouchControls() {
        if (!this.canvas) return;

        // Prevent default touch actions on the canvas
        this.canvas.addEventListener('touchstart', (e) => {
            //e.preventDefault();

            // Convert touch to mouse events for simplicity
            if (window.input) {
                const touch = e.touches[0];
                const rect = this.canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                window.input.handleMouseDown({
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    button: 0, // Simulate left click
                    offsetX: x,
                    offsetY: y
                });
            }
        }, { passive: false });

        this.canvas.addEventListener('touchmove', (e) => {
            //e.preventDefault();

            // Convert touch to mouse events
            if (window.input) {
                const touch = e.touches[0];
                const rect = this.canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                window.input.handleMouseMove({
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    offsetX: x,
                    offsetY: y
                });
            }
        }, { passive: false });

        this.canvas.addEventListener('touchend', (e) => {
            //e.preventDefault();

            // Convert touch to mouse events
            if (window.input) {
                window.input.handleMouseUp({
                    button: 0 // Simulate left click
                });
            }
        }, { passive: false });
    }

    resizeCanvas() {
        if (!this.canvas) return;

        const container = this.canvas.parentElement;
        if (!container) return;

        // Get container dimensions - force a reflow to get the latest size
        container.offsetHeight; // Trigger reflow
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;

        // Ensure we have positive dimensions to work with
        if (containerWidth <= 0 || containerHeight <= 0) {
            return;
        }

        // Get the desired viewport dimensions from scene settings
        const viewportWidth = this.viewport.width || 800;
        const viewportHeight = this.viewport.height || 600;
        const aspectRatio = viewportWidth / viewportHeight;

        // Set physical dimensions based on scaling mode
        let physicalWidth, physicalHeight;

        if (this.renderConfig.fullscreen) {
            if (this.renderConfig.maintainAspectRatio) {
                // Calculate dimensions to maintain aspect ratio within the container
                const containerRatio = containerWidth / containerHeight;

                if (containerRatio > aspectRatio) {
                    // Container is wider than needed - height is the limiting factor
                    physicalHeight = containerHeight;
                    physicalWidth = containerHeight * aspectRatio;
                } else {
                    // Container is taller than needed - width is the limiting factor
                    physicalWidth = containerWidth;
                    physicalHeight = containerWidth / aspectRatio;
                }
            } else {
                // Stretch to fill container without maintaining aspect ratio
                physicalWidth = containerWidth;
                physicalHeight = containerHeight;
            }
        } else {
            // Fixed size mode - calculate scale to fit in container
            const scale = Math.min(
                containerWidth / viewportWidth,
                containerHeight / viewportHeight
            );

            physicalWidth = viewportWidth * scale;
            physicalHeight = viewportHeight * scale;
        }

        // Apply pixel ratio for high-DPI displays
        const pixelRatio = this.renderConfig.pixelRatio;

        // Ensure we don't have zero dimensions
        physicalWidth = Math.max(1, Math.floor(physicalWidth));
        physicalHeight = Math.max(1, Math.floor(physicalHeight));

        // Calculate centering position
        const left = Math.floor((containerWidth - physicalWidth) / 2);
        const top = Math.floor((containerHeight - physicalHeight) / 2);

        // Set canvas styles for proper display
        this.canvas.style.width = `${physicalWidth}px`;
        this.canvas.style.height = `${physicalHeight}px`;
        this.canvas.style.position = 'absolute';
        this.canvas.style.left = `${left}px`;
        this.canvas.style.top = `${top}px`;

        // Remove size constraints that might prevent proper scaling
        this.canvas.style.minWidth = '0';
        this.canvas.style.minHeight = '0';
        this.canvas.style.maxWidth = 'none';
        this.canvas.style.maxHeight = 'none';        

        // Set the drawing surface size (use viewport dimensions)
        this.canvas.width = viewportWidth * pixelRatio;
        this.canvas.height = viewportHeight * pixelRatio;

        // Reset transform before scaling
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        if (pixelRatio !== 1) {
            this.ctx.scale(pixelRatio, pixelRatio);
        }

        // Update GUI and background canvas sizes to match main canvas
        if (this.guiCanvas) {
            this.guiCanvas.width = this.canvas.width;
            this.guiCanvas.height = this.canvas.height;
            const guiCtx = this.guiCanvas.getContext('2d');
            if (pixelRatio !== 1) {
                guiCtx.scale(pixelRatio, pixelRatio);
            }
        }
        if (this.backgroundCanvas) {
            this.backgroundCanvas.width = this.canvas.width;
            this.backgroundCanvas.height = this.canvas.height;
            const bgCtx = this.backgroundCanvas.getContext('2d');
            if (pixelRatio !== 1) {
                bgCtx.scale(pixelRatio, pixelRatio);
            }
        }

        // Remove transform scaling which can cause positioning issues
        this.canvas.style.transform = 'none';

        // Configure image smoothing
        this.ctx.imageSmoothingEnabled = this.renderConfig.smoothing;

        // Apply appropriate CSS image rendering mode based on scale mode
        if (this.renderConfig.scaleMode === 'nearest-neighbor') {
            this.canvas.style.imageRendering = 'pixelated';
        } else {
            this.canvas.style.imageRendering = this.renderConfig.smoothing ? 'auto' : 'crisp-edges';
        }

        this.canvasResized = true;
        this.viewport.dirty = true; // Mark viewport as dirty after resize
    }

    cleanup() {
        // Clean up resources when engine is destroyed
        if (this.resizeObserver) {
            this.resizeObserver.disconnect();
        }

        this._resizeHandler = this.resizeCanvas.bind(this);
        window.addEventListener('resize', this._resizeHandler);
        window.addEventListener('panel-resized', this._resizeHandler);

        // Clear viewport callbacks
        this.viewportCallbacks = [];
    }
}

window.Engine = Engine; // Make available globally

// src/core/AssetManager.js
class AssetManager {
    constructor(fileBrowser = null) {
        this.fileBrowser = fileBrowser;
        this.cache = {};
        this.loadingPromises = {};
        this.modal = null;
        
        // Only initialize modal after DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => this.initModal());
        } else {
            this.initModal();
        }
    }

    initModal() {
        // Create modal container
        this.modal = document.createElement('div');
        this.modal.className = 'asset-modal';
        this.modal.innerHTML = `
            <div class="asset-modal-content">
                <div class="asset-modal-header">
                    <h2 class="asset-modal-title">Export Assets</h2>
                    <button class="asset-modal-close"><i class="fas fa-times"></i></button>
                </div>
                <div class="asset-modal-body">
                    <div class="asset-tree"></div>
                    <div class="asset-actions">
                        <button class="asset-button select-all">Select All</button>
                        <button class="asset-button export">Export Selected</button>
                    </div>
                </div>
            </div>
        `;

        document.body.appendChild(this.modal);
        this.setupEventListeners();
    }

    setupEventListeners() {
        // Close button
        this.modal.querySelector('.asset-modal-close').addEventListener('click', () => {
            this.hideModal();
        });

        // Select all button
        this.modal.querySelector('.select-all').addEventListener('click', () => {
            const checkboxes = this.modal.querySelectorAll('.asset-item input[type="checkbox"]');
            const allChecked = Array.from(checkboxes).every(cb => cb.checked);
            checkboxes.forEach(cb => cb.checked = !allChecked);
        });

        // Export button
        this.modal.querySelector('.export').addEventListener('click', () => {
            this.exportSelected();
        });
    }

    async showExportModal() {
        const files = await this.fileBrowser.getAllFiles();
        const tree = this.modal.querySelector('.asset-tree');
        tree.innerHTML = '';

        // Group files by directory
        const fileTree = this.buildFileTree(files);
        this.renderFileTree(fileTree, tree);

        this.modal.style.display = 'flex';
    }

    hideModal() {
        this.modal.style.display = 'none';
    }

    buildFileTree(files) {
        const tree = {};
        files.forEach(file => {
            const parts = file.path.split('/').filter(Boolean);
            let current = tree;
            parts.forEach((part, i) => {
                if (i === parts.length - 1) {
                    if (!current.files) current.files = [];
                    current.files.push(file);
                } else {
                    current.dirs = current.dirs || {};
                    current.dirs[part] = current.dirs[part] || {};
                    current = current.dirs[part];
                }
            });
        });
        return tree;
    }

    renderFileTree(tree, container, path = '') {
        // Render directories
        if (tree.dirs) {
            Object.entries(tree.dirs).forEach(([name, subTree]) => {
                const dirElement = document.createElement('div');
                dirElement.className = 'asset-directory';
                dirElement.innerHTML = `
                    <div class="asset-dir-header">
                        <input type="checkbox" data-path="${path}/${name}">
                        <i class="fas fa-folder"></i>
                        <span>${name}</span>
                    </div>
                    <div class="asset-dir-content"></div>
                `;
                container.appendChild(dirElement);

                // Handle directory checkbox
                const checkbox = dirElement.querySelector('input[type="checkbox"]');
                const content = dirElement.querySelector('.asset-dir-content');
                checkbox.addEventListener('change', () => {
                    const items = content.querySelectorAll('input[type="checkbox"]');
                    items.forEach(item => item.checked = checkbox.checked);
                });

                this.renderFileTree(subTree, content, `${path}/${name}`);
            });
        }

        // Render files
        if (tree.files) {
            tree.files.forEach(file => {
                const fileElement = document.createElement('div');
                fileElement.className = 'asset-item';
                fileElement.innerHTML = `
                    <input type="checkbox" data-path="${file.path}">
                    <i class="fas fa-file"></i>
                    <span>${file.name}</span>
                `;
                container.appendChild(fileElement);
            });
        }
    }

    async exportSelected() {
        const selected = this.modal.querySelectorAll('.asset-item input[type="checkbox"]:checked');
        const files = [];

        for (const checkbox of selected) {
            const path = checkbox.dataset.path;
            const file = await this.fileBrowser.getFile(path);
            if (file) {
                files.push({
                    path: file.path,
                    content: file.content,
                    type: file.type,
                    name: file.name
                });
            }
        }

        if (files.length === 0) {
            alert('No files selected for export');
            return;
        }

        // Prompt for package name
        const packageName = await this.fileBrowser.promptDialog(
            'Export Assets',
            'Enter name for asset package:',
            'assets'
        );

        if (!packageName) return;

        // Create asset package
        const assetPackage = {
            name: packageName,
            version: '1.0',
            timestamp: Date.now(),
            files: files
        };

        // Create and download file
        const blob = new Blob([JSON.stringify(assetPackage)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${packageName}.dmjs`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        this.hideModal();
    }

    async importAssets(file) {
        try {
            const content = await this.readFileContent(file);
            const assetPackage = JSON.parse(content);

            if (!assetPackage.version || !assetPackage.files) {
                throw new Error('Invalid asset package format');
            }

            // Create directory based on package name or file name
            const packageName = assetPackage.name || file.name.replace('.dmjs', '');
            const importPath = `/${packageName}`;

            // Ensure the directory exists
            await this.fileBrowser.createDirectory(importPath);

            // Import files with adjusted paths
            for (const fileEntry of assetPackage.files) {
                // Extract the file name and any subdirectories from the original path
                const pathParts = fileEntry.path.split('/').filter(Boolean);
                const newPath = `${importPath}/${pathParts.join('/')}`;

                // Ensure parent directories exist
                const parentPath = newPath.substring(0, newPath.lastIndexOf('/'));
                if (parentPath !== importPath) {
                    await this.fileBrowser.createDirectory(parentPath);
                }

                // Write the file
                await this.fileBrowser.writeFile(newPath, fileEntry.content, true);
            }

            this.fileBrowser.refreshFiles();
            this.fileBrowser.showNotification(
                `Assets imported successfully to /${packageName}`,
                'info'
            );

            // Navigate to the newly created directory
            await this.fileBrowser.navigateTo(importPath);

        } catch (error) {
            console.error('Error importing assets:', error);
            this.fileBrowser.showNotification('Error importing assets', 'error');
        }
    }

    readFileContent(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = e => resolve(e.target.result);
            reader.onerror = e => reject(e.target.error);
            reader.readAsText(file);
        });
    }

    normalizePath(path) {
        // Remove leading slashes and redundant slashes
        return path.replace(/^\/+/, '').replace(/\\/g, '/');
    }

    /**
 * Add embedded asset data for exported games
 * @param {Object} assetsData - Object containing all asset data
 */
    addEmbeddedAssets(assetsData) {
        console.log('Adding embedded assets:', Object.keys(assetsData));

        for (const [path, assetInfo] of Object.entries(assetsData)) {
            const normalizedPath = this.normalizePath(path);

            // Get all path variations
            const pathVariations = [
                path,
                normalizedPath,
                path.replace(/^[\/\\]+/, ''),
                normalizedPath.replace(/^[\/\\]+/, ''),
                '/' + path.replace(/^[\/\\]+/, ''),
                '/' + normalizedPath.replace(/^[\/\\]+/, ''),
                decodeURIComponent(path),
                decodeURIComponent(normalizedPath),
                path.split('/').pop(),
                normalizedPath.split('/').pop()
            ];

            // For images, load them as Image objects and cache both data URL and Image
            if (assetInfo.type && assetInfo.type.startsWith('image/')) {
                // First, cache the data URL immediately for fallback
                pathVariations.forEach(variation => {
                    if (variation && !this.cache[variation]) {
                        this.cache[variation + '_dataurl'] = assetInfo.content;
                    }
                });

                // Then load as HTMLImageElement asynchronously
                this.loadImage(assetInfo.content).then(img => {
                    pathVariations.forEach(variation => {
                        if (variation) {
                            this.cache[variation] = img;
                        }
                    });
                    console.log(`Cached image asset as HTMLImageElement: ${path} with ${pathVariations.length} path variations`);
                }).catch(error => {
                    console.error(`Failed to load embedded image ${path}:`, error);
                    // Fallback: keep the data URL in cache
                    pathVariations.forEach(variation => {
                        if (variation && !this.cache[variation]) {
                            this.cache[variation] = assetInfo.content;
                        }
                    });
                });
            } else {
                // Store the asset content directly in cache for non-images
                pathVariations.forEach(variation => {
                    if (variation) {
                        this.cache[variation] = assetInfo.content;
                    }
                });
                console.log(`Cached asset: ${path} with ${pathVariations.length} path variations`);
            }
        }
    }

    /**
     * Manually adds a pre-loaded asset (like a base64 data URL) to the cache.
     * This is used for standalone HTML exports.
     * @param {string} path - The asset's intended path (e.g., 'images/player.png').
     * @param {string} content - The asset content (e.g., a data URL).
     * @param {string} type - The MIME type of the asset (e.g., 'image/png').
     * @returns {Promise<any>} A promise that resolves when the asset is processed and cached.
     */
    addAssetToCache(path, content, type) {
        const normalizedPath = this.normalizePath(path);

        try {
            if (this.cache[normalizedPath]) {
                return Promise.resolve(this.cache[normalizedPath]);
            }

            // Store multiple path variations for better lookup
            const pathVariations = [
                path,                                           // Original path
                normalizedPath,                                // Normalized path
                path.replace(/^[\/\\]+/, ''),                  // Remove leading slashes
                normalizedPath.replace(/^[\/\\]+/, ''),        // Remove leading slashes from normalized
                '/' + path.replace(/^[\/\\]+/, ''),            // Add leading slash
                '/' + normalizedPath.replace(/^[\/\\]+/, ''),  // Add leading slash to normalized
                decodeURIComponent(path),                      // URL decoded
                decodeURIComponent(normalizedPath),            // URL decoded normalized
                path.split('/').pop(),                         // Just filename
                normalizedPath.split('/').pop()                // Just filename from normalized
            ];

            // Remove duplicates
            const uniquePaths = [...new Set(pathVariations.filter(p => p && p.length > 0))];

            let promise;
            if (type && type.startsWith('image/')) {
                // If content is not a data URL, construct one
                if (typeof content === 'string' && !content.startsWith('data:')) {
                    content = `data:${type};base64,${content}`;
                }
                promise = this.loadImage(content);
            } else if (type && type.startsWith('audio/')) {
                if (typeof content === 'string' && !content.startsWith('data:')) {
                    content = `data:${type};base64,${content}`;
                }
                promise = this.loadAudio(content);
            } else if (type && (type.startsWith('application/json') || path.endsWith('.json'))) {
                let jsonObject;
                if (typeof content === 'string') {
                    jsonObject = JSON.parse(content);
                } else {
                    jsonObject = content;
                }

                // Cache under all path variations
                uniquePaths.forEach(variation => {
                    this.cache[variation] = jsonObject;
                });

                return Promise.resolve(jsonObject);
            } else {
                // Cache text content under all path variations
                uniquePaths.forEach(variation => {
                    this.cache[variation] = content;
                });

                return Promise.resolve(content);
            }

            this.loadingPromises[normalizedPath] = promise;

            promise.then(asset => {
                // Cache under all path variations
                uniquePaths.forEach(variation => {
                    this.cache[variation] = asset;
                    console.log('Cached asset under path:', variation);
                });

                delete this.loadingPromises[normalizedPath];
                console.log('Successfully cached asset with', uniquePaths.length, 'path variations');
            }).catch(error => {
                console.error(`Error caching asset ${normalizedPath}:`, error);
                delete this.loadingPromises[normalizedPath];
            });

            return promise;
        } catch (error) {
            console.error(`Error adding asset to cache for path ${path}:`, error);
            return Promise.reject(error);
        }
    }

    /**
 * Load an asset
 * @param {string} path - Path to the asset
 * @returns {Promise<any>} The loaded asset
 */
    loadAsset(path) {
        const normalizedPath = this.normalizePath(path);

        // Check cache first with all possible path variations
        const pathVariations = [
            path,
            normalizedPath,
            path.replace(/^[\/\\]+/, ''),
            normalizedPath.replace(/^[\/\\]+/, ''),
            '/' + path.replace(/^[\/\\]+/, ''),
            '/' + normalizedPath.replace(/^[\/\\]+/, ''),
            decodeURIComponent(path),
            decodeURIComponent(normalizedPath),
            path.split('/').pop(),
            normalizedPath.split('/').pop()
        ];

        for (const variation of pathVariations) {
            if (this.cache[variation]) {
                console.log('Found asset in cache with path variation:', variation);
                const cachedAsset = this.cache[variation];

                // Check if it's already a proper HTMLImageElement
                if (cachedAsset instanceof HTMLImageElement) {
                    return Promise.resolve(cachedAsset);
                }

                // If it's a data URL string for an image, convert it to HTMLImageElement
                if (typeof cachedAsset === 'string' && cachedAsset.startsWith('data:image/')) {
                    console.log('Converting cached data URL to HTMLImageElement for:', variation);
                    return this.loadImage(cachedAsset).then(img => {
                        // Update cache with the HTMLImageElement
                        pathVariations.forEach(v => {
                            this.cache[v] = img;
                        });
                        return img;
                    });
                }

                // For non-image assets, return as-is
                return Promise.resolve(cachedAsset);
            }
        }

        // Check if already loading
        if (this.loadingPromises[normalizedPath]) {
            return this.loadingPromises[normalizedPath];
        }

        // If not in cache and not loading, try to load from file system or URL
        let promise;

        if (this.fileBrowser && typeof this.fileBrowser.readFile === 'function') {
            // Try to load from file browser first
            promise = this.loadFromFileBrowser(normalizedPath);
        } else {
            // Fallback to URL loading
            promise = this.loadFromUrl(normalizedPath);
        }

        this.loadingPromises[normalizedPath] = promise;

        promise.then(asset => {
            // Cache under all path variations
            pathVariations.forEach(variation => {
                this.cache[variation] = asset;
            });
            delete this.loadingPromises[normalizedPath];
        }).catch(error => {
            console.error(`Failed to load asset ${normalizedPath}:`, error);
            delete this.loadingPromises[normalizedPath];
        });

        return promise;
    }

    /**
     * Load asset from file browser
     * @param {string} path - Asset path
     * @returns {Promise<any>} The loaded asset
     */
    async loadFromFileBrowser(path) {
        try {
            const content = await this.fileBrowser.readFile(path);
            if (!content) {
                throw new Error(`Asset not found in file browser: ${path}`);
            }

            // Determine type and process accordingly
            const extension = path.split('.').pop().toLowerCase();

            if (['png', 'jpg', 'jpeg', 'gif', 'webp', 'svg'].includes(extension)) {
                return this.loadImage(content);
            } else if (['mp3', 'wav', 'ogg', 'aac', 'flac'].includes(extension)) {
                return this.loadAudio(content);
            } else if (extension === 'json') {
                return JSON.parse(content);
            } else {
                return content;
            }
        } catch (error) {
            throw new Error(`Failed to load asset from file browser: ${path} - ${error.message}`);
        }
    }

    /**
     * Load asset from URL (fallback method)
     * @param {string} path - Asset path
     * @returns {Promise<any>} The loaded asset
     */
    async loadFromUrl(path) {
        try {
            // Construct full URL
            const fullPath = this.basePath ? `${this.basePath}${path}` : path;

            const response = await fetch(fullPath);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const extension = path.split('.').pop().toLowerCase();

            if (['png', 'jpg', 'jpeg', 'gif', 'webp', 'svg'].includes(extension)) {
                const blob = await response.blob();
                const dataUrl = await this.blobToDataURL(blob);
                return this.loadImage(dataUrl);
            } else if (['mp3', 'wav', 'ogg', 'aac', 'flac'].includes(extension)) {
                const blob = await response.blob();
                const dataUrl = await this.blobToDataURL(blob);
                return this.loadAudio(dataUrl);
            } else if (extension === 'json') {
                return response.json();
            } else {
                return response.text();
            }
        } catch (error) {
            throw new Error(`Failed to load asset from URL: ${path} - ${error.message}`);
        }
    }

    /**
     * Convert Blob to data URL
     */
    async blobToDataURL(blob) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
        });
    }

    /**
     * Load an image
     * @param {string} src - Image source (URL or data URL)
     * @returns {Promise<Image>} The loaded image
     */
    loadImage(src) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = () => reject(new Error(`Failed to load image: ${src}`));
            img.src = src;
        });
    }

    /**
     * Load an audio file
     * @param {string} src - Audio source (URL or data URL)
     * @returns {Promise<Audio>} The loaded audio
     */
    loadAudio(src) {
        return new Promise((resolve, reject) => {
            const audio = new Audio();
            audio.oncanplaythrough = () => resolve(audio);
            audio.onerror = () => reject(new Error(`Failed to load audio: ${src}`));
            audio.src = src;
        });
    }

    /**
     * Serialize cache to a plain object (only serializable entries)
     */
    serializeCache() {
        const serializable = {};
        for (const [key, value] of Object.entries(this.cache)) {
            // Only serialize strings (e.g., data URLs, text, JSON)
            if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
                serializable[key] = value;
            } else if (typeof value === 'object' && value !== null && !(value instanceof HTMLImageElement) && !(value instanceof Audio)) {
                try {
                    serializable[key] = JSON.stringify(value);
                } catch {}
            }
            // Skip DOM objects (Image, Audio, etc.)
        }
        return serializable;
    }

    /**
     * Deserialize cache from a plain object
     */
    async deserializeCache(serializedCache) {
        for (const [key, value] of Object.entries(serializedCache)) {
            if (typeof value === 'string') {
                // If it's a data URL for image/audio, rehydrate
                if (value.startsWith('data:image/')) {
                    if (/^data:image\/[a-zA-Z]+;base64,/.test(value)) {
                        try {
                            this.cache[key] = await this.loadImage(value);
                        } catch {
                            this.cache[key] = value; // fallback
                        }
                    } else {
                        console.warn(`Skipped invalid image data URL for key: ${key}`);
                        this.cache[key] = value; // fallback
                    }
                } else if (value.startsWith('data:audio/')) {
                    if (/^data:audio\/[a-zA-Z]+;base64,/.test(value)) {
                        try {
                            this.cache[key] = await this.loadAudio(value);
                        } catch {
                            this.cache[key] = value; // fallback
                        }
                    } else {
                        console.warn(`Skipped invalid audio data URL for key: ${key}`);
                        this.cache[key] = value; // fallback
                    }
                } else {
                    // Try to parse JSON, else store as string
                    try {
                        this.cache[key] = JSON.parse(value);
                    } catch {
                        this.cache[key] = value;
                    }
                }
            } else {
                this.cache[key] = value;
            }
        }
    }
}

window.assetManager = new AssetManager(window.fileBrowser || null);

// src/core/AssetReference.js
/**
 * AssetReference - A class that represents a reference to an asset in the file browser
 * 
 * This class allows module properties to reference assets in the file system,
 * such as images, audio files, and scripts, with proper serialization support.
 */
class AssetReference {
    constructor(path = null, type = 'any') {
        this.path = path;
        this.type = type; // 'image', 'audio', 'script', 'any'
        this._cachedData = null;
        this._isLoading = false;
        this._loadPromise = null;
    }
    
    /**
     * Check if this reference has a valid path
     */
    isValid() {
        return !!this.path;
    }
    
    /**
     * Get the filename without path
     */
    getFilename() {
        if (!this.path) return null;
        return this.path.split('/').pop().split('\\').pop();
    }
    
    /**
     * Get the file extension
     */
    getExtension() {
        if (!this.path) return null;
        return this.path.split('.').pop().toLowerCase();
    }
    
    /**
     * Load the referenced asset
     * @returns {Promise<any>} The loaded asset data
     */
    async load() {
        // If already loaded, return cached data
        if (this._cachedData) {
            return this._cachedData;
        }
        
        // If already loading, return the existing promise
        if (this._isLoading && this._loadPromise) {
            return this._loadPromise;
        }
        
        // If no path, return null
        if (!this.path) {
            return null;
        }
        
        this._isLoading = true;

        // --- Support exported runtime asset loading ---
        this._loadPromise = new Promise(async (resolve, reject) => {
            try {
                // If running in exported game (no FileBrowser), load from assets folder or embedded data
                if (!window.fileBrowser) {
                    // Try to load from assets folder (ZIP export) or embedded data (standalone HTML)
                    const extension = this.getExtension();
                    let assetUrl = null;

                    // If path is already a data URL, use it directly
                    if (this.path.startsWith('data:image/') || this.path.startsWith('data:audio/')) {
                        assetUrl = this.path;
                    } else if (window.__ASSET_MAP && window.__ASSET_MAP[this.path]) {
                        // If a global asset map is present (for standalone HTML), use it
                        assetUrl = window.__ASSET_MAP[this.path];
                    } else {
                        // Otherwise, assume assets are in 'assets/' folder (ZIP export)
                        assetUrl = 'assets/' + this.getFilename();
                    }

                    if (['png', 'jpg', 'jpeg', 'gif', 'webp', 'svg'].includes(extension) || assetUrl.startsWith('data:image/')) {
                        // Image asset
                        const img = new Image();
                        const imgPromise = new Promise((imgResolve, imgReject) => {
                            img.onload = () => imgResolve(img);
                            img.onerror = (err) => imgReject(new Error(`Error loading image: ${err.message || 'Unknown error'}`));
                        });
                        img.src = assetUrl;
                        this._cachedData = await imgPromise;
                        resolve(this._cachedData);

                    } else if (['mp3', 'wav', 'ogg', 'aac'].includes(extension) || assetUrl.startsWith('data:audio/')) {
                        // Audio asset
                        const audio = new Audio();
                        const audioPromise = new Promise((audioResolve, audioReject) => {
                            audio.oncanplaythrough = () => audioResolve(audio);
                            audio.onerror = (err) => audioReject(new Error(`Error loading audio: ${err.message || 'Unknown error'}`));
                        });
                        audio.src = assetUrl;
                        this._cachedData = await audioPromise;
                        resolve(this._cachedData);

                    } else if (extension === 'js') {
                        // Script asset (fetch as text)
                        try {
                            const response = await fetch(assetUrl);
                            if (!response.ok) throw new Error(`Failed to fetch script: ${assetUrl}`);
                            const scriptContent = await response.text();
                            this._cachedData = scriptContent;
                            resolve(this._cachedData);
                        } catch (err) {
                            reject(err);
                        }

                    } else {
                        // Default: fetch as text or blob
                        try {
                            const response = await fetch(assetUrl);
                            if (!response.ok) throw new Error(`Failed to fetch asset: ${assetUrl}`);
                            const content = await response.text();
                            this._cachedData = content;
                            resolve(this._cachedData);
                        } catch (err) {
                            reject(err);
                        }
                    }
                    return;
                }

                // Editor mode: use FileBrowser
                const content = await window.fileBrowser.readFile(this.path);
                if (!content) {
                    throw new Error(`File not found: ${this.path}`);
                }
                const extension = this.getExtension();
                if (['png', 'jpg', 'jpeg', 'gif', 'webp', 'svg'].includes(extension) || content.startsWith('data:image/')) {
                    const img = new Image();
                    const imgPromise = new Promise((imgResolve, imgReject) => {
                        img.onload = () => imgResolve(img);
                        img.onerror = (err) => imgReject(new Error(`Error loading image: ${err.message || 'Unknown error'}`));
                    });
                    img.src = content;
                    this._cachedData = await imgPromise;
                    resolve(this._cachedData);
                } else if (['mp3', 'wav', 'ogg', 'aac'].includes(extension)) {
                    const audio = new Audio();
                    const audioPromise = new Promise((audioResolve, audioReject) => {
                        audio.oncanplaythrough = () => audioResolve(audio);
                        audio.onerror = (err) => audioReject(new Error(`Error loading audio: ${err.message || 'Unknown error'}`));
                    });
                    audio.src = content;
                    this._cachedData = await audioPromise;
                    resolve(this._cachedData);
                } else if (extension === 'js') {
                    this._cachedData = content;
                    resolve(this._cachedData);
                } else {
                    this._cachedData = content;
                    resolve(this._cachedData);
                }
            } catch (error) {
                console.error(`Error loading asset ${this.path}:`, error);
                this._cachedData = null;
                reject(error);
            } finally {
                this._isLoading = false;
            }
        });
        
        return this._loadPromise;
    }
    
    /**
     * Create a clone of this AssetReference
     */
    clone() {
        const clone = new AssetReference(this.path, this.type);
        clone._cachedData = this._cachedData;
        return clone;
    }
    
    /**
     * Convert to a simple object for serialization
     */
    toJSON() {
        return {
            path: this.path,
            type: this.type
        };
    }
    
    /**
     * Create an AssetReference from serialized data
     * @param {Object} json - Serialized data
     * @returns {AssetReference} The created AssetReference
     */
    static fromJSON(json) {
        if (!json) return new AssetReference();
        return new AssetReference(json.path, json.type || 'any');
    }
}

// Register globally
window.AssetReference = AssetReference;

// Game Modules
// src/core/Modules/Asteroids/DrawInfiniteStarFieldParallax.js
class DrawInfiniteStarFieldParallax extends Module {
    static namespace = "Asteroids";
    static description = "Infinite scrolling star field with parallax layers for top-down view";
    static allowMultiple = false;

    constructor() {
        super("DrawInfiniteStarFieldParallax");

        // Configuration properties
        this.layerCount = 4;
        this.starsPerGrid = 80;
        this.gridSize = 800; // Fixed grid size
        this.starColor = "#ffffff";
        this.minSize = 0.25;
        this.maxSize = 3.5;
        this.flickerRate = 1.83;
        this.parallaxStrength = 0.6;
        this.seed = 12345;
        this.baseDepth = 0.2;
        this.brightness = 1.0;
        this.viewportMargin = 200;

        // Internal state
        this.layers = [];
        this.gridCache = new Map();
        this.activeGrids = new Set();

        // Expose properties for inspector
        this.exposeProperty("layerCount", "number", 4, {
            description: "Number of parallax layers",
            onChange: (val) => {
                this.layerCount = Math.max(1, Math.floor(val));
                this.initializeLayers();
            }
        });

        this.exposeProperty("starsPerGrid", "number", 80, {
            description: "Stars per grid cell",
            onChange: (val) => {
                this.starsPerGrid = Math.max(5, Math.floor(val));
                this.clearCache();
            }
        });

        this.exposeProperty("gridSize", "number", 800, {
            description: "Size of each grid cell",
            onChange: (val) => {
                this.gridSize = Math.max(200, val);
                this.clearCache();
            }
        });

        this.exposeProperty("seed", "number", 12345, {
            description: "Seed for deterministic star generation",
            onChange: (val) => {
                this.seed = val;
                this.clearCache();
            }
        });

        this.exposeProperty("starColor", "color", "#ffffff", {
            description: "Base color of stars",
            onChange: (val) => {
                this.starColor = val;
            }
        });

        this.exposeProperty("minSize", "number", 0.5, {
            description: "Minimum star size",
            onChange: (val) => {
                this.minSize = Math.max(0.1, val);
            }
        });

        this.exposeProperty("maxSize", "number", 2.5, {
            description: "Maximum star size",
            onChange: (val) => {
                this.maxSize = Math.max(this.minSize, val);
            }
        });

        this.exposeProperty("flickerRate", "number", 0.83, {
            description: "Star flicker intensity (0-1)",
            onChange: (val) => {
                this.flickerRate = Math.max(0, Math.min(1, val));
            }
        });

        this.exposeProperty("parallaxStrength", "number", 0.6, {
            description: "Parallax effect strength",
            onChange: (val) => {
                this.parallaxStrength = Math.max(0, Math.min(1, val));
            }
        });

        this.exposeProperty("baseDepth", "number", 0.2, {
            description: "Base opacity for distant stars",
            onChange: (val) => {
                this.baseDepth = Math.max(0.1, Math.min(1, val));
            }
        });

        this.exposeProperty("brightness", "number", 1.0, {
            description: "Overall brightness multiplier",
            onChange: (val) => {
                this.brightness = Math.max(0.1, Math.min(3, val));
            }
        });

        this.exposeProperty("viewportMargin", "number", 200, {
            description: "Extra margin for star generation beyond viewport",
            onChange: (val) => {
                this.viewportMargin = Math.max(0, val);
            }
        });
    }

    start() {
        this.initializeLayers();

        // Position at viewport origin for top-down infinite scrolling
        this.gameObject.position.x = 0;
        this.gameObject.position.y = 0;
    }

    initializeLayers() {
        this.layers = [];

        for (let i = 0; i < this.layerCount; i++) {
            const layer = {
                depth: this.baseDepth + ((i + 1) / this.layerCount) * (1 - this.baseDepth),
                parallaxFactor: 1 - (i / this.layerCount) * this.parallaxStrength,
                starSizeMultiplier: 0.7 - (i / this.layerCount) * 0.4, // Reversed: closer layers (higher i) get bigger stars
                grids: new Map()
            };
            this.layers.push(layer);
        }

        this.clearCache();
    }

    clearCache() {
        this.gridCache.clear();
        this.activeGrids.clear();
        this.layers.forEach(layer => {
            if (layer.grids) layer.grids.clear();
        });
    }

    // Seeded random number generator
    seededRandom(seed) {
        let x = Math.sin(seed) * 10000;
        return x - Math.floor(x);
    }

    // Get grid coordinates for world position
    getGridCoords(worldX, worldY) {
        return {
            x: Math.floor(worldX / this.gridSize),
            y: Math.floor(worldY / this.gridSize)
        };
    }

    // Generate grid key
    getGridKey(gridX, gridY, layerIndex) {
        return `${gridX},${gridY},${layerIndex}`;
    }

    // Generate stars for a specific grid cell
    generateGrid(gridX, gridY, layerIndex) {
        const layer = this.layers[layerIndex];
        const gridKey = this.getGridKey(gridX, gridY, layerIndex);

        if (this.gridCache.has(gridKey)) {
            return this.gridCache.get(gridKey);
        }

        const stars = [];
        const gridWorldX = gridX * this.gridSize;
        const gridWorldY = gridY * this.gridSize;

        // Use a more robust seeding approach for large coordinates
        // Combine coordinates in a way that avoids precision issues
        const gridSeed = this.seed + 
            ((gridX & 0xFFFF) * 73856093) + 
            ((gridY & 0xFFFF) * 19349663) + 
            ((layerIndex & 0xFF) * 83492791);
        
        let seedCounter = 0;

        for (let i = 0; i < this.starsPerGrid; i++) {
            const baseSize = this.minSize + this.seededRandom(gridSeed + seedCounter++) * (this.maxSize - this.minSize);
            
            // Use layer depth instead of individual random depth
            const star = {
                x: gridWorldX + this.seededRandom(gridSeed + seedCounter++) * this.gridSize,
                y: gridWorldY + this.seededRandom(gridSeed + seedCounter++) * this.gridSize,
                size: baseSize * layer.starSizeMultiplier,
                brightness: 0.4 + this.seededRandom(gridSeed + seedCounter++) * 0.6,
                flickerPhase: this.seededRandom(gridSeed + seedCounter++) * Math.PI * 2,
                flickerSpeed: 0.3 + this.seededRandom(gridSeed + seedCounter++) * 1.5,
                depth: layer.depth,
                starType: this.seededRandom(gridSeed + seedCounter++) < 0.1 ? 'bright' : 'normal'
            };
            stars.push(star);
        }

        this.gridCache.set(gridKey, stars);
        return stars;
    }

    // Get viewport bounds like in DrawPlatformerHills
    getViewportBounds() {
        const viewportX = window.engine.viewport.x || 0;
        const viewportY = window.engine.viewport.y || 0;
        const viewportWidth = window.engine.viewport.width || 800;
        const viewportHeight = window.engine.viewport.height || 600;

        // viewport.x and viewport.y represent the world coordinates at the CENTER of the screen
        const halfWidth = viewportWidth / 2;
        const halfHeight = viewportHeight / 2;

        return {
            left: viewportX - halfWidth,
            right: viewportX + halfWidth,
            top: viewportY - halfHeight,
            bottom: viewportY + halfHeight
        };
    }

    // Get visible grids for current viewport (like DrawPlatformerHills)
    getVisibleGrids(viewportBounds) {
        const viewportX = window.engine.viewport.x || 0;
        const viewportY = window.engine.viewport.y || 0;

        // Calculate bounds for each layer and combine them
        const vpWidth = (viewportBounds.right - viewportBounds.left);
        const vpHeight = (viewportBounds.bottom - viewportBounds.top);
        const halfWidth = vpWidth / 2;
        const halfHeight = vpHeight / 2;
        const margin = this.viewportMargin;

        let minGridX = Infinity;
        let maxGridX = -Infinity;
        let minGridY = Infinity;
        let maxGridY = -Infinity;

        // Calculate grid bounds for each layer to ensure we cover all stars
        this.layers.forEach(layer => {
            const layerCameraX = viewportX * layer.parallaxFactor;
            const layerCameraY = viewportY * layer.parallaxFactor;

            const startGridX = Math.floor((layerCameraX - halfWidth - margin) / this.gridSize);
            const endGridX = Math.floor((layerCameraX + halfWidth + margin) / this.gridSize);
            const startGridY = Math.floor((layerCameraY - halfHeight - margin) / this.gridSize);
            const endGridY = Math.floor((layerCameraY + halfHeight + margin) / this.gridSize);

            minGridX = Math.min(minGridX, startGridX);
            maxGridX = Math.max(maxGridX, endGridX);
            minGridY = Math.min(minGridY, startGridY);
            maxGridY = Math.max(maxGridY, endGridY);
        });

        const visibleGrids = [];
        for (let x = minGridX; x <= maxGridX; x++) {
            for (let y = minGridY; y <= maxGridY; y++) {
                visibleGrids.push({ x, y });
            }
        }
        return visibleGrids;
    }

    // Get visible grids for a specific layer
    getVisibleGridsForLayer(viewportBounds, layer) {
        const viewportX = window.engine.viewport.x || 0;
        const viewportY = window.engine.viewport.y || 0;
        
        const vpWidth = (viewportBounds.right - viewportBounds.left);
        const vpHeight = (viewportBounds.bottom - viewportBounds.top);
        const halfWidth = vpWidth / 2;
        const halfHeight = vpHeight / 2;
        const margin = this.viewportMargin;

        // Calculate layer-specific camera position
        const layerCameraX = viewportX * layer.parallaxFactor;
        const layerCameraY = viewportY * layer.parallaxFactor;

        // Calculate grid bounds for this specific layer
        const startGridX = Math.floor((layerCameraX - halfWidth - margin) / this.gridSize);
        const endGridX = Math.floor((layerCameraX + halfWidth + margin) / this.gridSize);
        const startGridY = Math.floor((layerCameraY - halfHeight - margin) / this.gridSize);
        const endGridY = Math.floor((layerCameraY + halfHeight + margin) / this.gridSize);

        const visibleGrids = [];
        for (let x = startGridX; x <= endGridX; x++) {
            for (let y = startGridY; y <= endGridY; y++) {
                visibleGrids.push({ x, y });
            }
        }
        return visibleGrids;
    }

    loop(deltaTime) {
        const viewportBounds = this.getViewportBounds();

        // Keep game object at origin for infinite scrolling effect
        this.gameObject.position.x = window.engine.viewport.x || 0;
        this.gameObject.position.y = window.engine.viewport.y || 0;

        // Clear active grids set
        this.activeGrids.clear();

        // Update active grids for each layer separately
        this.layers.forEach((layer, layerIndex) => {
            // Clear old grids from layer
            layer.grids.clear();

            // Get visible grids for this specific layer
            const visibleGrids = this.getVisibleGridsForLayer(viewportBounds, layer);

            // Load visible grids for this layer
            visibleGrids.forEach(grid => {
                const gridKey = this.getGridKey(grid.x, grid.y, layerIndex);
                const stars = this.generateGrid(grid.x, grid.y, layerIndex);
                layer.grids.set(gridKey, {
                    stars: stars,
                    gridX: grid.x,
                    gridY: grid.y
                });
                this.activeGrids.add(gridKey);
            });
        });

        // Update star flicker phases
        this.layers.forEach(layer => {
            layer.grids.forEach(grid => {
                grid.stars.forEach(star => {
                    star.flickerPhase += star.flickerSpeed * deltaTime;
                });
            });
        });
    }

    draw(ctx) {
        const viewportBounds = this.getViewportBounds();

        // Draw each layer from back to front (distant to close)
        this.layers.forEach(layer => {
            this.drawLayer(ctx, layer, viewportBounds);
        });
    }

    drawLayer(ctx, layer, viewportBounds) {
        ctx.save();

        const viewportX = window.engine.viewport.x || 0;
        const viewportY = window.engine.viewport.y || 0;

        const vpWidth = (viewportBounds.right - viewportBounds.left);
        const vpHeight = (viewportBounds.bottom - viewportBounds.top);
        const halfWidth = vpWidth / 2;
        const halfHeight = vpHeight / 2;

        // Use layer's parallax factor consistently
        const layerCameraX = viewportX * layer.parallaxFactor;
        const layerCameraY = viewportY * layer.parallaxFactor;

        layer.grids.forEach(grid => {
            grid.stars.forEach(star => {
                // Screen position relative to layer's parallax
                const screenX = (star.x - layerCameraX) + halfWidth;
                const screenY = (star.y - layerCameraY) + halfHeight;

                const margin = star.size * 2;

                if (screenX >= -margin && screenX <= vpWidth + margin &&
                    screenY >= -margin && screenY <= vpHeight + margin) {

                    // Flicker
                    const flicker = this.flickerRate > 0 ? Math.sin(star.flickerPhase) * this.flickerRate : 0;
                    let alpha = Math.max(0.1, star.brightness + flicker);

                    // Depth and global brightness
                    alpha *= star.depth * this.brightness;

                    if (star.starType === 'bright') alpha *= 1.5;

                    // Soft glow
                    ctx.globalAlpha = alpha * 0.3;
                    ctx.fillStyle = this.starColor;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, star.size * 2, 0, Math.PI * 2);
                    ctx.fill();

                    // Core
                    ctx.globalAlpha = alpha;
                    ctx.beginPath();
                    ctx.arc(screenX, screenY, star.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
        });

        ctx.restore();
    }

    drawGizmos(ctx) {
        if (window.engine.debug) {
            const viewportBounds = this.getViewportBounds();

            ctx.fillStyle = "yellow";
            ctx.font = "12px Arial";
            ctx.fillText(`Star Layers: ${this.layers.length}`, 10, 20);
            ctx.fillText(`Grid Size: ${this.gridSize}`, 10, 35);
            ctx.fillText(`Cache Size: ${this.gridCache.size}`, 10, 50);
            ctx.fillText(`Active Grids: ${this.activeGrids.size}`, 10, 65);

            const viewport = window.engine.viewport;
            ctx.fillText(`Viewport: ${Math.round(viewport.x)}, ${Math.round(viewport.y)}`, 10, 80);

            // Draw grid boundaries for debugging (first layer as reference)
            if (this.layers.length > 0) {
                const layer = this.layers[0];
                const viewportX = viewport.x || 0;
                const viewportY = viewport.y || 0;

                const layerCameraX = viewportX * layer.parallaxFactor;
                const layerCameraY = viewportY * layer.parallaxFactor;

                const vpWidth = viewportBounds.right - viewportBounds.left;
                const vpHeight = viewportBounds.bottom - viewportBounds.top;
                const halfWidth = vpWidth / 2;
                const halfHeight = vpHeight / 2;

                // Current grid in layer space
                const currentGridX = Math.floor(layerCameraX / this.gridSize);
                const currentGridY = Math.floor(layerCameraY / this.gridSize);
                const gridWorldX = currentGridX * this.gridSize;
                const gridWorldY = currentGridY * this.gridSize;

                ctx.strokeStyle = "rgba(255, 255, 0, 0.3)";
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);

                // Vertical lines
                for (let i = -1; i <= 2; i++) {
                    const worldX = gridWorldX + (i * this.gridSize);
                    const screenX = (worldX - layerCameraX) + halfWidth;
                    ctx.beginPath();
                    ctx.moveTo(screenX, 0);
                    ctx.lineTo(screenX, vpHeight);
                    ctx.stroke();
                }

                // Horizontal lines
                for (let i = -1; i <= 2; i++) {
                    const worldY = gridWorldY + (i * this.gridSize);
                    const screenY = (worldY - layerCameraY) + halfHeight;
                    ctx.beginPath();
                    ctx.moveTo(0, screenY);
                    ctx.lineTo(vpWidth, screenY);
                    ctx.stroke();
                }

                ctx.setLineDash([]);
            }
        }
    }

    toJSON() {
        return {
            layerCount: this.layerCount,
            starsPerGrid: this.starsPerGrid,
            gridSize: this.gridSize,
            seed: this.seed,
            starColor: this.starColor,
            minSize: this.minSize,
            maxSize: this.maxSize,
            flickerRate: this.flickerRate,
            parallaxStrength: this.parallaxStrength,
            baseDepth: this.baseDepth,
            brightness: this.brightness,
            viewportMargin: this.viewportMargin
        };
    }

    fromJSON(data) {
        this.layerCount = data.layerCount || 4;
        this.starsPerGrid = data.starsPerGrid || 80;
        this.gridSize = data.gridSize || 800;
        this.seed = data.seed || 12345;
        this.starColor = data.starColor || "#ffffff";
        this.minSize = data.minSize || 0.5;
        this.maxSize = data.maxSize || 2.5;
        this.flickerRate = data.flickerRate || 0.03;
        this.parallaxStrength = data.parallaxStrength || 0.6;
        this.baseDepth = data.baseDepth || 0.2;
        this.brightness = data.brightness || 1.0;
        this.viewportMargin = data.viewportMargin || 200;

        this.initializeLayers();
    }
}

window.DrawInfiniteStarFieldParallax = DrawInfiniteStarFieldParallax;

// src/core/Modules/Drawing/DrawGrid.js
class DrawGrid extends Module {
    static namespace = "Drawing";
    static description = "Draws an infinite, scalable grid optimized for viewport rendering";
    static allowMultiple = true;
    static iconClass = "fas fa-th";
    static iconColor = "#a200ffff";

    constructor() {
        super("DrawGrid");

        this.x = 0;
        this.y = 0;
        this.cellWidth = 50;
        this.cellHeight = 50;
        this.lineColor = "#cccccc";
        this.lineThickness = 1;
        this.showVertical = true;
        this.showHorizontal = true;
        this.glow = false;
        this.glowColor = "#00ffff";
        this.glowBlur = 8;
        this.infinite = true;
        this.width = 800;  // Used when infinite is false
        this.height = 600; // Used when infinite is false

        this.exposeProperty("x", "number", this.x, {
            description: "Grid X offset position",
            onChange: val => { this.x = val; }
        });
        this.exposeProperty("y", "number", this.y, {
            description: "Grid Y offset position",
            onChange: val => { this.y = val; }
        });
        this.exposeProperty("cellWidth", "number", this.cellWidth, {
            description: "Cell width",
            onChange: val => { this.cellWidth = Math.max(1, val); }
        });
        this.exposeProperty("cellHeight", "number", this.cellHeight, {
            description: "Cell height",
            onChange: val => { this.cellHeight = Math.max(1, val); }
        });
        this.exposeProperty("lineColor", "color", this.lineColor, {
            description: "Grid line color",
            onChange: val => { this.lineColor = val; }
        });
        this.exposeProperty("lineThickness", "number", this.lineThickness, {
            description: "Line thickness",
            onChange: val => { this.lineThickness = Math.max(0.1, val); }
        });
        this.exposeProperty("showVertical", "boolean", this.showVertical, {
            description: "Show vertical lines",
            onChange: val => { this.showVertical = val; }
        });
        this.exposeProperty("showHorizontal", "boolean", this.showHorizontal, {
            description: "Show horizontal lines",
            onChange: val => { this.showHorizontal = val; }
        });
        this.exposeProperty("glow", "boolean", this.glow, {
            description: "Enable glow effect",
            onChange: val => { this.glow = val; }
        });
        this.exposeProperty("glowColor", "color", this.glowColor, {
            description: "Glow color",
            onChange: val => { this.glowColor = val; }
        });
        this.exposeProperty("glowBlur", "number", this.glowBlur, {
            description: "Glow blur amount",
            onChange: val => { this.glowBlur = val; }
        });
        this.exposeProperty("infinite", "boolean", this.infinite, {
            description: "Enable infinite grid generation",
            onChange: val => { this.infinite = val; }
        });
        this.exposeProperty("width", "number", this.width, {
            description: "Grid width (when not infinite)",
            onChange: val => { this.width = val; }
        });
        this.exposeProperty("height", "number", this.height, {
            description: "Grid height (when not infinite)",
            onChange: val => { this.height = val; }
        });
    }

    style(style) {
        style.startGroup("Grid Position", false, {
            backgroundColor: 'rgba(200,200,255,0.1)',
            borderRadius: '6px',
            padding: '8px'
        });
        style.exposeProperty("x", "number", this.x, { min: -10000, max: 10000 });
        style.exposeProperty("y", "number", this.y, { min: -10000, max: 10000 });
        style.exposeProperty("infinite", "boolean", this.infinite);
        if (!this.infinite) {
            style.exposeProperty("width", "number", this.width, { min: 1, max: 10000 });
            style.exposeProperty("height", "number", this.height, { min: 1, max: 10000 });
        }
        style.endGroup();

        style.startGroup("Cells", false, {
            backgroundColor: 'rgba(150,255,200,0.1)',
            borderRadius: '6px',
            padding: '8px'
        });
        style.exposeProperty("cellWidth", "number", this.cellWidth, { min: 1, max: 1000 });
        style.exposeProperty("cellHeight", "number", this.cellHeight, { min: 1, max: 1000 });
        style.endGroup();

        style.startGroup("Lines", false, {
            backgroundColor: 'rgba(200,255,200,0.1)',
            borderRadius: '6px',
            padding: '8px'
        });
        style.exposeProperty("lineColor", "color", this.lineColor);
        style.exposeProperty("lineThickness", "number", this.lineThickness, { min: 0.1, max: 20 });
        style.exposeProperty("showVertical", "boolean", this.showVertical);
        style.exposeProperty("showHorizontal", "boolean", this.showHorizontal);
        style.endGroup();

        style.startGroup("Glow", false, {
            backgroundColor: 'rgba(0,255,255,0.1)',
            borderRadius: '6px',
            padding: '8px'
        });
        style.exposeProperty("glow", "boolean", this.glow);
        style.exposeProperty("glowColor", "color", this.glowColor);
        style.exposeProperty("glowBlur", "number", this.glowBlur, { min: 0, max: 50 });
        style.endGroup();
    }

    draw(ctx) {
        // Get viewport with fallback
        const vp = window.engine?.viewport || { 
            x: 0, 
            y: 0, 
            width: ctx.canvas.width, 
            height: ctx.canvas.height 
        };

        this.gameObject.position.x = 0;
        this.gameObject.position.y = 0;

        // Early exit if no lines to show
        if (!this.showVertical && !this.showHorizontal) return;

        ctx.save();
        ctx.strokeStyle = this.lineColor;
        ctx.lineWidth = this.lineThickness;
        
        // Apply glow effect
        if (this.glow) {
            ctx.shadowColor = this.glowColor;
            ctx.shadowBlur = this.glowBlur;
        }

        // Determine grid bounds
        let minX, maxX, minY, maxY;
        
        if (this.infinite) {
            // For infinite grid, use viewport bounds with some padding
            const padding = Math.max(this.cellWidth, this.cellHeight);
            minX = vp.x - padding;
            maxX = vp.x + vp.width + padding;
            minY = vp.y - padding;
            maxY = vp.y + vp.height + padding;
        } else {
            // For bounded grid, use grid bounds intersected with viewport
            minX = Math.max(this.x, vp.x);
            maxX = Math.min(this.x + this.width, vp.x + vp.width);
            minY = Math.max(this.y, vp.y);
            maxY = Math.min(this.y + this.height, vp.y + vp.height);
            
            // Early exit if grid is completely outside viewport
            if (minX >= maxX || minY >= maxY) {
                ctx.restore();
                return;
            }
        }

        // Draw vertical lines
        if (this.showVertical && this.cellWidth > 0) {
            // Calculate first vertical line position
            const firstVertical = this.infinite 
                ? Math.floor((minX - this.x) / this.cellWidth) * this.cellWidth + this.x
                : this.x;
            
            const verticalEnd = this.infinite ? maxX : Math.min(this.x + this.width, maxX);
            const verticalTop = this.infinite ? minY : Math.max(this.y, minY);
            const verticalBottom = this.infinite ? maxY : Math.min(this.y + this.height, maxY);
            
            for (let gx = firstVertical; gx <= verticalEnd; gx += this.cellWidth) {
                if (gx < minX) continue;
                if (!this.infinite && (gx < this.x || gx > this.x + this.width)) continue;
                
                ctx.beginPath();
                ctx.moveTo(gx, verticalTop);
                ctx.lineTo(gx, verticalBottom);
                ctx.stroke();
            }
        }

        // Draw horizontal lines  
        if (this.showHorizontal && this.cellHeight > 0) {
            // Calculate first horizontal line position
            const firstHorizontal = this.infinite
                ? Math.floor((minY - this.y) / this.cellHeight) * this.cellHeight + this.y
                : this.y;
                
            const horizontalEnd = this.infinite ? maxY : Math.min(this.y + this.height, maxY);
            const horizontalLeft = this.infinite ? minX : Math.max(this.x, minX);
            const horizontalRight = this.infinite ? maxX : Math.min(this.x + this.width, maxX);
            
            for (let gy = firstHorizontal; gy <= horizontalEnd; gy += this.cellHeight) {
                if (gy < minY) continue;
                if (!this.infinite && (gy < this.y || gy > this.y + this.height)) continue;
                
                ctx.beginPath();
                ctx.moveTo(horizontalLeft, gy);
                ctx.lineTo(horizontalRight, gy);
                ctx.stroke();
            }
        }

        ctx.restore();
    }

    toJSON() {
        return {
            ...super.toJSON(),
            x: this.x,
            y: this.y,
            width: this.width,
            height: this.height,
            cellWidth: this.cellWidth,
            cellHeight: this.cellHeight,
            lineColor: this.lineColor,
            lineThickness: this.lineThickness,
            showVertical: this.showVertical,
            showHorizontal: this.showHorizontal,
            glow: this.glow,
            glowColor: this.glowColor,
            glowBlur: this.glowBlur,
            infinite: this.infinite
        };
    }

    fromJSON(data) {
        super.fromJSON(data);
        if (!data) return;
        this.x = data.x || 0;
        this.y = data.y || 0;
        this.width = data.width || 800;
        this.height = data.height || 600;
        this.cellWidth = data.cellWidth || 50;
        this.cellHeight = data.cellHeight || 50;
        this.lineColor = data.lineColor || "#cccccc";
        this.lineThickness = data.lineThickness || 1;
        this.showVertical = data.showVertical !== undefined ? data.showVertical : true;
        this.showHorizontal = data.showHorizontal !== undefined ? data.showHorizontal : true;
        this.glow = data.glow || false;
        this.glowColor = data.glowColor || "#00ffff";
        this.glowBlur = data.glowBlur || 8;
        this.infinite = data.infinite !== undefined ? data.infinite : true;
    }
}

window.DrawGrid = DrawGrid;

// src/core/Modules/Car1.js
// Could not load src/core/Modules/Car1.js: Failed to load src/core/Modules/Car1.js: 404

// src/core/Modules/Controllers/CameraController.js
/**
 * CameraController - Controls the game's camera view
 * 
 * This module provides smooth camera movement and zoom capabilities.
 * When attached to a GameObject, the camera automatically follows that object.
 */
class CameraController extends Module {
    static allowMultiple = false;
    static namespace = "Camera";
    static description = "Control the viewport camera for the game scene. ";
    static iconClass = "fas fa-video";

    constructor() {
        super("CameraController");

        // Camera position (in world coordinates)
        this.position = new Vector2(0, 0);

        // Camera settings
        this.followSpeed = 5.0;
        this.zoomSpeed = 2.0;
        this.zoom = 1.0;
        this.targetZoom = 1.0;
        this.bounds = null; // Optional camera bounds {x, y, width, height}

        // Offset from attached object (useful for looking ahead)
        this.offset = new Vector2(0, 0);

        // Damping (smoothness) values
        this.positionDamping = 0.85;
        this.zoomDamping = 0.85;

        // Dynamic zoom properties
        this.dynamicZoomEnabled = false;
        this.maxZoomOut = 0.2;
        this.zoomSmoothness = 0.85;
        this.zoomIntensityMultiplier = 0.001;

        // Shake effect properties
        this.shakeIntensity = 0;
        this.shakeDuration = 0;
        this.shakeTimer = 0;
        this.shakeDecay = 1;

        // Auto-follow settings
        this.followOwner = true;
        this.followOwnerAngle = false; // Angle to follow the owner at
        this.followAngleOffset = 0; // Angle offset when following owner
        this.currentAngle = 0; // Current camera angle for smooth lerping
        this.targetAngle = 0; // Target angle for smooth lerping

        // Expose properties
        this.exposeProperty("followOwner", "boolean", true, {
            description: "Whether camera follows this GameObject",
            onChange: (val) => { this.followOwner = val; }
        });

        /*this.exposeProperty("followOwnerAngle", "boolean", false, {
            description: "Whether camera follows the owner's angle",
            onChange: (val) => { this.followOwnerAngle = val; }
        });*/

        /*this.exposeProperty("followAngleOffset", "number", 0, {
            description: "Angle offset when following owner",
            min: -Math.PI,
            max: Math.PI,
            step: 0.01,
            onChange: (val) => { this.followAngleOffset = val; }
        });*/

        this.exposeProperty("followSpeed", "number", 5.0, {
            description: "How quickly the camera follows its target",
            min: 0.1,
            max: 20,
            step: 0.1,
            onChange: (val) => { this.followSpeed = val; }
        });

        this.exposeProperty("zoom", "number", 1.0, {
            description: "Camera zoom level (1.0 = 100%)",
            min: 0.1,
            max: 10,
            step: 0.1,
            onChange: (val) => { this.zoom = val; }
        });

        this.exposeProperty("targetZoom", "number", 1.0, {
            description: "Target zoom level (base zoom level)",
            min: 0.1,
            max: 10,
            step: 0.1,
            onChange: (val) => { this.targetZoom = val; }
        });

        this.exposeProperty("positionDamping", "number", 0.85, {
            description: "Smoothness of camera movement (0-1)",
            min: 0,
            max: 0.99,
            step: 0.01,
            onChange: (val) => { this.positionDamping = val; }
        });

        this.exposeProperty("zoomDamping", "number", 0.85, {
            description: "Smoothness of camera zoom (0-1)",
            min: 0,
            max: 0.99,
            step: 0.01,
            onChange: (val) => { this.zoomDamping = val; }
        });

        this.exposeProperty("dynamicZoomEnabled", "boolean", false, {
            description: "Enable dynamic zoom based on GameObject speed",
            onChange: (val) => { this.dynamicZoomEnabled = val; }
        });

        this.exposeProperty("maxZoomOut", "number", 0.5, {
            description: "Maximum zoom out level",
            min: 0.1,
            max: 10,
            step: 0.1,
            onChange: (val) => { this.maxZoomOut = val; }
        });

        this.exposeProperty("zoomSmoothness", "number", 0.85, {
            description: "Smoothness of dynamic zoom (0-1)",
            min: 0,
            max: 0.99,
            step: 0.01,
            onChange: (val) => { this.zoomSmoothness = val; }
        });

        this.exposeProperty("zoomIntensityMultiplier", "number", 0.01, {
            description: "Multiplier for zoom intensity based on speed",
            min: 0.001,
            max: 1,
            step: 0.001,
            onChange: (val) => { this.zoomIntensityMultiplier = val; }
        });

        this.exposeProperty("shakeIntensity", "number", 0, {
            description: "Intensity of camera shake effect",
            min: 0,
            max: 100,
            step: 1,
            onChange: (val) => { this.shakeIntensity = val; }
        });

        this.exposeProperty("shakeTimer", "number", 0, {
            description: "Internal timer for shake effect",
            readOnly: true,
            onChange: (val) => { this.shakeTimer = val; }
        });

        this.exposeProperty("offset", "vector2", this.offset, {
            description: "Camera offset from this GameObject",
            onChange: (val) => {
                this.offset = new Vector2(val.x, val.y);
                //this.updateSceneViewport(); // Update immediately
            }
        });
    }

    /**
 * Optional method for enhanced inspector UI using the Style helper
 * This will be called by the Inspector if it exists
 * @param {Style} style - Styling helper
 */
    style(style) {
        style.startGroup("Camera Follow", false, {
            backgroundColor: 'rgba(100,150,255,0.08)',
            borderRadius: '6px',
            padding: '8px'
        });
        style.exposeProperty("followOwner", "boolean", this.followOwner, { label: "Follow GameObject" });
        style.exposeProperty("followSpeed", "number", this.followSpeed, { label: "Follow Speed" });
        style.exposeProperty("offset", "vector2", this.offset, { label: "Camera Offset" });
        style.endGroup();

        style.addDivider();

        style.startGroup("Zoom & Dynamics", false, {
            backgroundColor: 'rgba(150,255,150,0.08)',
            borderRadius: '6px',
            padding: '8px'
        });
        style.exposeProperty("zoom", "number", this.zoom, { label: "Zoom" });
        style.exposeProperty("targetZoom", "number", this.targetZoom, { label: "Target Zoom" });
        style.exposeProperty("zoomDamping", "number", this.zoomDamping, { label: "Zoom Damping" });
        style.exposeProperty("dynamicZoomEnabled", "boolean", this.dynamicZoomEnabled, { label: "Dynamic Zoom" });
        style.exposeProperty("maxZoomOut", "number", this.maxZoomOut, { label: "Max Zoom Out" });
        style.exposeProperty("zoomSmoothness", "number", this.zoomSmoothness, { label: "Zoom Smoothness" });
        style.exposeProperty("zoomIntensityMultiplier", "number", this.zoomIntensityMultiplier, { label: "Zoom Intensity Multiplier" });
        style.endGroup();

        style.addDivider();

        style.startGroup("Shake & Misc", false, {
            backgroundColor: 'rgba(255,150,150,0.08)',
            borderRadius: '6px',
            padding: '8px'
        });
        style.exposeProperty("shakeIntensity", "number", this.shakeIntensity, { label: "Shake Intensity" });
        style.exposeProperty("shakeTimer", "number", this.shakeTimer, { label: "Shake Timer" });
        style.exposeProperty("positionDamping", "number", this.positionDamping, { label: "Position Damping" });
        style.endGroup();
    }

    /**
     * Called when the module is first attached
     */
    onAttach(gameObject) {
        // Initialize camera position to the GameObject's position
        const pos = gameObject.getWorldPosition();
        this.position = new Vector2(pos.x, pos.y);

        // Initialize the scene viewport immediately to prevent black screen
        this.updateSceneViewport();
    }

    /**
     * Get the target position (including offset)
     */
    getTargetPosition() {
        if (!this.gameObject || !this.followOwner) return this.position.clone();

        const targetPos = this.gameObject.getWorldPosition();
        return new Vector2(
            targetPos.x + this.offset.x,
            targetPos.y + this.offset.y
        );
    }

    /**
     * Immediately move the camera to the target without smoothing
     */
    jumpToTarget() {
        this.position = this.getTargetPosition();
        //this.applyBounds();
        this.updateSceneViewport();
    }

    /**
     * Move camera to specific world position with optional smoothing
     * @param {Vector2} position - World position to move to
     * @param {boolean} immediate - If true, jump immediately without smoothing
     */
    moveTo(position, immediate = false) {
        // Temporarily disable following while moving to a specific point
        const wasFollowing = this.followOwner;
        this.followOwner = false;

        if (immediate) {
            this.position = position.clone();
            //this.applyBounds();
            this.updateSceneViewport();
        } else {
            this._targetPosition = position.clone();
        }

        // After 1 second, restore original following state
        if (wasFollowing) {
            setTimeout(() => {
                this.followOwner = wasFollowing;
            }, 1000);
        }
    }

    /**
     * Set camera zoom level
     * @param {number} zoomLevel - New zoom level
     * @param {boolean} immediate - If true, apply immediately without smoothing
     */
    setZoom(zoomLevel, immediate = false) {
        this.targetZoom = Math.max(0.1, zoomLevel);

        if (immediate) {
            this.zoom = this.targetZoom;
            this.updateSceneViewport();
        }
    }

    /**
     * Apply a camera shake effect
     * @param {number} intensity - Shake intensity
     * @param {number} duration - Shake duration in seconds
     */
    shake(intensity = 10, duration = 0.5) {
        this.shakeIntensity = intensity;
        this.shakeDuration = duration;
        this.shakeTimer = duration;
    }

    /**
     * Constrain camera to bounds if set
     */
    applyBounds() {
        if (!this.bounds) return;

        // Get half-viewport dimensions
        const engine = window.engine;
        if (!engine || !engine.scene) return;

        const settings = engine.scene.settings || {};
        const viewportWidth = settings.viewportWidth || 800;
        const viewportHeight = settings.viewportHeight || 600;
        const halfWidth = (viewportWidth / 2) / this.zoom;
        const halfHeight = (viewportHeight / 2) / this.zoom;

        // Constrain to bounds with viewport consideration
        if (this.bounds) {
            this.position.x = Math.max(
                this.bounds.x + halfWidth,
                Math.min(this.bounds.x + this.bounds.width - halfWidth, this.position.x)
            );
            this.position.y = Math.max(
                this.bounds.y + halfHeight,
                Math.min(this.bounds.y + this.bounds.height - halfHeight, this.position.y)
            );
        }
    }

    /**
     * Update the scene's viewport settings based on camera position/zoom
     */
    updateSceneViewport() {
        const engine = window.engine;
        if (!engine) {
            console.warn("CameraController: Engine not available, cannot update viewport.");
            return;
        }

        const viewportWidth = engine.viewport.width ? engine.viewport.width : 800;
        const viewportHeight = engine.viewport.height ? engine.viewport.height : 600;

        let centerX = this.position.x;
        let centerY = this.position.y;

        // Apply shake effect if active
        let shakeOffsetX = 0;
        let shakeOffsetY = 0;

        let halfWidth = viewportWidth / 2 / this.zoom;
        let halfHeight = viewportHeight / 2 / this.zoom;

        // Use the smoothly lerped angle
        engine.viewport.angle = this.currentAngle;

        if (this.shakeTimer > 0) {
            shakeOffsetX = (Math.random() * 2 - 1) * this.shakeIntensity;
            shakeOffsetY = (Math.random() * 2 - 1) * this.shakeIntensity;
        }

        // Camera position is always the center, so subtract half the viewport size divided by zoom
        engine.viewport.x = centerX - (viewportWidth / 2) + shakeOffsetX;
        engine.viewport.y = centerY - (viewportHeight / 2) + shakeOffsetY;

        engine.viewport.width = viewportWidth;
        engine.viewport.height = viewportHeight;
        engine.viewport.zoom = this.zoom;

        if (engine.resizeCanvas) {
            engine.resizeCanvas();
        }
    }

    /**
     * Main update loop
     * @param {number} deltaTime - Time since last frame in seconds
     */
    loop(deltaTime) {
        // Always follow owner if dynamic zoom is enabled
        if (this.dynamicZoomEnabled) {
            this.followOwner = true;
            this._targetPosition = undefined;
        }

        // Handle following with smooth lerp
        const targetPos = this.followOwner ? this.getTargetPosition() : (this._targetPosition || this.position);

        // Update target angle if following owner angle
        if (this.followOwnerAngle && this.gameObject) {
            // Get the owner's angle directly - it should already be in the correct format
            this.targetAngle = this.gameObject.angle + this.followAngleOffset;
        } else {
            this.targetAngle = 0;
        }

        // Smoothly move towards target position
        if (!this.position.equals(targetPos)) {
            // Calculate how far to move this frame using follow speed
            const lerpFactor = 1.0 - Math.pow(this.positionDamping, deltaTime * this.followSpeed);

            this.position.x = this.position.x + (targetPos.x - this.position.x) * lerpFactor;
            this.position.y = this.position.y + (targetPos.y - this.position.y) * lerpFactor;
        }

        // Smooth angle changes when following owner angle
        if (this.followOwnerAngle && this.gameObject) {
            // Use the same lerp factor as position for consistent feel
            const angleLerpFactor = 1.0 - Math.pow(this.positionDamping, deltaTime * this.followSpeed);

            // Handle angle wrapping for shortest rotation path
            let angleDiff = this.targetAngle - this.currentAngle;

            // Normalize angle difference to [-, ] for shortest rotation
            while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
            while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

            this.currentAngle += angleDiff * angleLerpFactor;
        } else if (!this.followOwnerAngle) {
            // Reset to 0 when not following angle
            if (Math.abs(this.currentAngle) > 0.001) {
                const angleLerpFactor = 1.0 - Math.pow(this.positionDamping, deltaTime * this.followSpeed);

                let angleDiff = -this.currentAngle;
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

                this.currentAngle += angleDiff * angleLerpFactor;

                if (Math.abs(this.currentAngle) < 0.001) {
                    this.currentAngle = 0;
                }
            }
        }

        // Smooth zoom changes
        if (this.zoom !== this.targetZoom) {
            const zoomLerpFactor = 1.0 - Math.pow(this.zoomDamping, deltaTime * this.zoomSpeed);
            this.zoom += (this.targetZoom - this.zoom) * zoomLerpFactor;

            // Snap to target when close enough
            if (Math.abs(this.zoom - this.targetZoom) < 0.001) {
                this.zoom = this.targetZoom;
            }
        }

        // Dynamic zoom based on GameObject speed
        if (this.dynamicZoomEnabled && this.gameObject && this.gameObject.previousPosition) {
            const prev = this.gameObject.previousPosition;
            const curr = this.gameObject.position;
            const speed = Math.sqrt(
                Math.pow(curr.x - prev.x, 2) + Math.pow(curr.y - prev.y, 2)
            ) / (deltaTime || 1);

            // Calculate target zoom based on speed
            // At speed=0, zoom=1.0; at high speed, zoom approaches maxZoomOut
            let desiredZoom = 1.0 - speed * this.zoomIntensityMultiplier;
            desiredZoom = Math.max(this.maxZoomOut, Math.min(1.0, desiredZoom));
            this.targetZoom = desiredZoom;

            // Smooth zoom changes
            const zoomLerpFactor = 1.0 - Math.pow(this.zoomSmoothness, deltaTime * this.zoomSpeed);
            this.zoom += (this.targetZoom - this.zoom) * zoomLerpFactor;
            if (Math.abs(this.zoom - this.targetZoom) < 0.001) {
                this.zoom = this.targetZoom;
            }
        }

        // Update shake effect
        if (this.shakeTimer > 0) {
            this.shakeTimer -= deltaTime;
            if (this.shakeTimer <= 0) {
                this.shakeTimer = 0;
                this.shakeIntensity = 0;
            } else {
                // Gradually reduce intensity over time
                this.shakeIntensity *= this.shakeDecay;
            }
        }

        if (this.zoom <= 0.1) {
            this.zoom = 0.1; // Prevent zooming out too far
            this.targetZoom = 0.1; // Ensure target zoom is also clamped
        }

        // Ensure camera stays within bounds
        //this.applyBounds();

        // Update the actual viewport in the scene
        this.updateSceneViewport();
    }

    /**
     * Set camera bounds
     * @param {number} x - Left boundary
     * @param {number} y - Top boundary
     * @param {number} width - Boundary width
     * @param {number} height - Boundary height
     */
    setBounds(x, y, width, height) {
        this.bounds = { x, y, width, height };
        //this.applyBounds(); // Apply immediately
    }

    /**
     * Clear camera bounds
     */
    clearBounds() {
        this.bounds = null;
    }

    /**
     * Pan the camera by a given amount (in world units)
     * @param {number} dx - Amount to move in X
     * @param {number} dy - Amount to move in Y
     * @param {boolean} immediate - If true, move instantly
     */
    pan(dx, dy, immediate = false) {
        this.followOwner = false; // Disable auto-follow when panning manually
        const newPos = new Vector2(this.position.x + dx, this.position.y + dy);
        this.moveTo(newPos, immediate);
    }

    /**
     * Center camera on a specific world position
     * @param {number} x
     * @param {number} y
     * @param {boolean} immediate
     */
    centerOn(x, y, immediate = false) {
        this.followOwner = false;
        this.moveTo(new Vector2(x, y), immediate);
    }

    /**
     * Called when the module is enabled 
     */
    onEnable() {
        // Make sure viewport is updated when module is enabled
        if (this.gameObject) {
            const pos = this.gameObject.getWorldPosition();
            this.position = new Vector2(pos.x, pos.y);
            this.updateSceneViewport();
        }
    }

    /**
     * Called when the module is first attached
     */
    onAttach(gameObject) {
        // Initialize camera position to the GameObject's position
        const pos = gameObject.getWorldPosition();
        this.position = new Vector2(pos.x, pos.y);

        // Initialize the scene viewport immediately to prevent black screen
        setTimeout(() => {
            // Using setTimeout ensures the engine is fully initialized
            this.jumpToTarget();
        }, 0);
    }

    /**
     * Override to handle serialization
     */
    toJSON() {
        const json = super.toJSON() || {};

        // Store camera properties
        json.position = { x: this.position.x, y: this.position.y };
        json.zoom = this.zoom;
        json.targetZoom = this.targetZoom;
        json.followOwner = this.followOwner;
        json.followSpeed = this.followSpeed;
        json.zoomSpeed = this.zoomSpeed;
        json.positionDamping = this.positionDamping;
        json.zoomDamping = this.zoomDamping;
        json.offset = { x: this.offset.x, y: this.offset.y };
        json.followOwnerAngle = this.followOwnerAngle;
        json.followAngleOffset = this.followAngleOffset;
        json.currentAngle = this.currentAngle;
        json.targetAngle = this.targetAngle;

        // Store bounds if set
        if (this.bounds) {
            json.bounds = { ...this.bounds };
        }

        return json;
    }

    /**
     * Override to handle deserialization
     */
    fromJSON(json) {
        super.fromJSON(json);

        if (!json) return;

        // Restore camera properties
        if (json.position) {
            this.position = new Vector2(json.position.x, json.position.y);
        }

        if (json.zoom !== undefined) this.zoom = json.zoom;
        if (json.targetZoom !== undefined) this.targetZoom = json.targetZoom;
        if (json.followOwner !== undefined) this.followOwner = json.followOwner;
        if (json.followSpeed !== undefined) this.followSpeed = json.followSpeed;
        if (json.zoomSpeed !== undefined) this.zoomSpeed = json.zoomSpeed;
        if (json.positionDamping !== undefined) this.positionDamping = json.positionDamping;
        if (json.zoomDamping !== undefined) this.zoomDamping = json.zoomDamping;
        if (json.followOwnerAngle !== undefined) this.followOwnerAngle = json.followOwnerAngle;
        if (json.followAngleOffset !== undefined) this.followAngleOffset = json.followAngleOffset;
        if (json.currentAngle !== undefined) this.currentAngle = json.currentAngle;
        if (json.targetAngle !== undefined) this.targetAngle = json.targetAngle;

        if (json.offset) {
            this.offset = new Vector2(json.offset.x, json.offset.y);
        }

        // Restore bounds if set
        if (json.bounds) {
            this.bounds = { ...json.bounds };
        }

        // Initialize viewport right away to prevent black screen
        this.updateSceneViewport();
    }
}

// Register module globally
window.CameraController = CameraController;

// src/core/Modules/Matter-js/RigidBody.js
/**
 * RigidBody - Physics component that adds a physical body to a GameObject
 */
class RigidBody extends Module {
    static allowMultiple = false; // Only one RigidBody per GameObject
    static namespace = "Matter.js";
    static description = "Physics component that adds a physical body to a GameObject for Matter.js";

    constructor() {
        super("RigidBody");

        // Physics body reference
        this.body = null;

        // Body properties
        this.bodyType = "dynamic";  // "dynamic", "static", "kinematic"
        this.density = 1;           // Density (mass = density * area)
        this.friction = 0.8;        // Friction coefficient
        this.restitution = 0.1;     // Bounciness (0 to 1)
        this.linearDamping = 0.01;  // Air resistance to linear movement
        this.angularDamping = 0.01; // Air resistance to rotation
        this.isSensor = false;      // Is this a trigger/sensor?
        this.collisionFilter = {    // Collision filtering
            category: 0x0001,       // What category this body belongs to
            mask: 0xFFFFFFFF,       // What categories this body collides with
            group: 0                // Collision groups
        };

        this.useGravity = true; // New property: reacts to gravity
        this.frictionAir = 0.01; // Air resistance (linear damping)
        this.sleepingAllowed = true; // Can the body sleep?
        this.label = ""; // Custom label

        // Shape options
        this.shape = "rectangle";   // "rectangle", "circle", "polygon"
        this.width = 50;           // Used for rectangle
        this.height = 50;          // Used for rectangle
        this.radius = 25;           // Used for circle
        this.vertices = [];         // Used for polygon

        // Constraint options
        this.fixedRotation = false; // Prevent rotation

        // Collision tracking
        this.inCollision = new Set();  // Set of bodies currently in contact
        this.bodyNeedsUpdate = false;  // Flag to update static bodies when moved

        this._skipRebuild = true; // Internal flag to skip rebuilds during bulk updates

        // Expose properties to the inspector
        this.exposeProperty("bodyType", "enum", this.bodyType, {
            options: ["dynamic", "static", "kinematic"],
            onChange: (val) => { this.bodyType = val; if (!this._skipRebuild) this.rebuildBody(); }
        });

        this.exposeProperty("shape", "enum", this.shape, {
            options: ["rectangle", "circle", "polygon"],
            onChange: (val) => { this.shape = val; if (!this._skipRebuild) this.rebuildBody(); }
        });

        this.exposeProperty("width", "number", this.width, {
            min: 1,
            onChange: (val) => { this.width = val; if (!this._skipRebuild) this.rebuildBody(); }
        });

        this.exposeProperty("height", "number", this.height, {
            min: 1,
            onChange: (val) => { this.height = val; if (!this._skipRebuild) this.rebuildBody(); }
        });

        this.exposeProperty("radius", "number", this.radius, {
            min: 1,
            onChange: (val) => { this.radius = val; if (!this._skipRebuild) this.rebuildBody(); }
        });

        this.exposeProperty("density", "number", this.density, {
            min: 0.001,
            max: 100,
            onChange: (val) => { this.density = val; if (this.body) Matter.Body.setDensity(this.body, val); }
        });

        this.exposeProperty("friction", "number", this.friction, {
            min: 0,
            max: 1,
            onChange: (val) => { this.friction = val; if (this.body) this.body.friction = val; }
        });

        this.exposeProperty("restitution", "number", this.restitution, {
            min: 0,
            max: 1,
            onChange: (val) => { this.restitution = val; if (this.body) this.body.restitution = val; }
        });

        this.exposeProperty("useGravity", "boolean", this.useGravity, {
            onChange: (val) => { 
                this.useGravity = val; 
                if (this.body) this.body.ignoreGravity = !val; // Custom flag, see below
            }
        });

        this.exposeProperty("frictionAir", "number", this.frictionAir, {
            min: 0,
            max: 1,
            onChange: (val) => { 
                this.frictionAir = val; 
                if (this.body) this.body.frictionAir = val; 
            }
        });

        this.exposeProperty("sleepingAllowed", "boolean", this.sleepingAllowed, {
            onChange: (val) => { 
                this.sleepingAllowed = val; 
                if (this.body) this.body.sleepThreshold = val ? 60 : -1; // Matter.js default is 60
            }
        });

        this.exposeProperty("label", "string", this.label, {
            onChange: (val) => { 
                this.label = val; 
                if (this.body) this.body.label = val; 
            }
        });

        this.exposeProperty("fixedRotation", "boolean", false, {
            onChange: (value) => {
                this.fixedRotation = value;
                if (this.body) {
                    // Fix: Use correct method to set inertia for fixed rotation
                    if (value) {
                        this.body.inertia = Infinity;
                        this.body.inverseInertia = 0;
                    } else {
                        // Calculate proper inertia based on the body shape
                        if (this.shape === "circle") {
                            // For circle: I = m * r^2
                            const mass = this.body.mass;
                            const radius = this.radius;
                            this.body.inertia = mass * radius * radius;
                        } else {
                            // For rectangles and other shapes, use Matter.js built-in calculation
                            // We need to recalculate based on vertices
                            const mass = this.body.mass;
                            let inertia = 0;
                            const vertices = this.body.vertices;

                            // Simple approximation for non-circular shapes
                            // Based on Matter.js internal calculations
                            const centre = this.body.position;
                            for (let i = 0; i < vertices.length; i++) {
                                const vertex = vertices[i];
                                const dx = vertex.x - centre.x;
                                const dy = vertex.y - centre.y;
                                const distSq = dx * dx + dy * dy;
                                inertia += distSq;
                            }

                            this.body.inertia = mass * (inertia / vertices.length);
                        }

                        // Make sure to update inverseInertia as well
                        this.body.inverseInertia = 1 / this.body.inertia;
                    }
                }
            }
        });

        this.exposeProperty("isSensor", "boolean", this.isSensor, {
            onChange: (val) => { this.isSensor = val; if (this.body) this.body.isSensor = val; }
        });

        this.boundOnCollisionStart = this.onCollisionStart.bind(this);
        this.boundOnCollisionEnd = this.onCollisionEnd.bind(this);

        // Store initial position for reset
        if (this.gameObject) {
            const pos = this.gameObject.getWorldPosition();
            this.initialPosition = { x: pos.x, y: pos.y };
            this.initialAngle = this.gameObject.angle;
        } else {
            this.initialPosition = null;
            this.initialAngle = null;
        }
    }

    /**
     * Create the physics body when the component starts
     */
    start() {
        if (!window.physicsManager) {
            console.error("Physics manager not found. Make sure it's initialized before using RigidBody.");
            return;
        }

        // Store initial position and angle
        if (this.gameObject) {
            const pos = this.gameObject.getWorldPosition();
            this.initialPosition = { x: pos.x, y: pos.y };
            this.initialAngle = this.gameObject.angle;
        }

        this.onStart();

        // Set up collision handlers
        Matter.Events.on(window.physicsManager.engine, 'collisionStart', this.boundOnCollisionStart);
        Matter.Events.on(window.physicsManager.engine, 'collisionEnd', this.boundOnCollisionEnd);
    }

    /**
     * Create the physics body based on current settings
     */
    createBody() {
        if (!this.gameObject) return;

        this.removeBody();

        if (!window.physicsManager) {
            console.error("PhysicsManager not found or not initialized");
            return null;
        }

        // Use collider data from GameObject
        let body;

        let pos = this.gameObject.getWorldPosition();

        // If position is (0,0) and we have an initialPosition, use that instead
        /*if ((pos.x === 0 && pos.y === 0) && this.initialPosition && (this.initialPosition.x !== 0 || this.initialPosition.y !== 0)) {
            pos = { ...this.initialPosition };
        }*/

        const angle = this.gameObject.angle * (Math.PI / 180);

        // Use collider size from GameObject
        const colliderWidth = this.gameObject.size?.x * this.gameObject.scale.x || this.width;
        const colliderHeight = this.gameObject.size?.y * this.gameObject.scale.y || this.height;
        const colliderRadius = (this.gameObject.size?.x * this.gameObject.scale.x || this.radius) / 2;

        const options = {
            friction: this.friction,
            frictionAir: this.frictionAir,
            restitution: this.restitution,
            density: this.density,
            isSensor: this.isSensor,
            isStatic: this.bodyType === "static",
            angle: angle,
            label: this.label || this.gameObject.name || "Body",
            collisionFilter: this.collisionFilter,
            sleepThreshold: this.sleepingAllowed ? 60 : -1
        };

        try {
            switch (this.shape) {
                case "rectangle":
                    body = Matter.Bodies.rectangle(pos.x, pos.y, colliderWidth, colliderHeight, options);
                    break;
                case "circle":
                    body = Matter.Bodies.circle(pos.x, pos.y, colliderRadius, options);
                    break;
                case "polygon":
                    // Use polygon points from GameObject if available
                    let vertices = this.gameObject.polygonPoints?.length ? this.gameObject.polygonPoints.map(pt => ({ x: pt.x, y: pt.y })) : this.vertices;
                    if (vertices && vertices.length >= 3) {
                        body = Matter.Bodies.fromVertices(pos.x, pos.y, vertices, options);
                    } else {
                        // Fallback to triangle
                        body = Matter.Bodies.polygon(pos.x, pos.y, 3, colliderRadius, options);
                    }
                    break;
                default:
                    body = Matter.Bodies.rectangle(pos.x, pos.y, colliderWidth, colliderHeight, options);
            }
        } catch (error) {
            console.error("Error creating physics body:", error);
            return null;
        }

        // Now that we have a valid body, continue with the rest of the method

        // Ensure static bodies are really static
        if (this.bodyType === "static") {
            //body.isStatic = true;
            body.inertia = Infinity;
            body.inverseInertia = 0;
            body.inverseMass = 0;
            body.mass = Infinity;
            body.velocity.x = 0;
            body.velocity.y = 0;
            body.angularVelocity = 0;

            //Matter.Body.setStatic(body, true);
        }
        else if (this.bodyType === "kinematic") {
            //body.isStatic = false;
            body.inertia = Infinity;
            body.inverseInertia = 0;
            body.mass = Infinity;
            body.inverseMass = 0;
        }
        else {
            //body.isStatic = false;
            body.mass = (this.density * body.area) || 1;
        }

        // Apply fixed rotation constraint
        if (this.fixedRotation) {
            body.inertia = Infinity;
            body.inverseInertia = 0;
        }

        // Gravity control (custom implementation)
        if (body) {
            body.ignoreGravity = !this.useGravity; // Custom flag, must be handled in your physicsManager update
        }

        // Register with physics manager - ensure this properly adds to the world
        try {
            // Register with physics manager
            if (window.physicsManager && body) {
                window.physicsManager.registerBody(body, this.gameObject);

                const isInWorld = window.physicsManager.engine.world.bodies.includes(body);
                if (!isInWorld) {
                    console.warn(`Body for ${options.label} was not properly added to the physics world`);
                    Matter.World.add(window.physicsManager.engine.world, body);
                }
            }
        } catch (error) {
            console.error("Error registering physics body:", error);
        }

        // Store reference to this module in the body
        if (body) {
            this.body = body;
            this.body.module = this;
        }

        return body;
    }

    updateMass(weight = 1) {
        if (this.body && this.bodyType === "dynamic") {
            const area = this.body.area || 1;
            const newMass = this.density * area * weight;
            Matter.Body.setMass(this.body, newMass);
        }
    }

    /**
     * Called when body should be created during game startup
     */
    onStart() {
        if (this.pendingBodyCreation && !this.body) {
            console.log("Creating pending RigidBody for:", this.gameObject?.name);
            this.createBody();
            this.pendingBodyCreation = false;
        }
    }

    /**
     * Reset the physics body and GameObject to their initial position and angle
     */
    resetPosition() {
        if (this.initialPosition && this.gameObject) {
            this.gameObject.setWorldPosition(this.initialPosition.x, this.initialPosition.y);
            this.gameObject.angle = this.initialAngle || 0;
            if (this.body) {
                Matter.Body.setPosition(this.body, { x: this.initialPosition.x, y: this.initialPosition.y });
                Matter.Body.setAngle(this.body, (this.initialAngle || 0) * (Math.PI / 180));
            }
        }
    }

    /**
     * Remove the body from the physics world
     */
    removeBody() {
        if (this.body && window.physicsManager) {
            window.physicsManager.removeBody(this.body);
            this.body = null;
        }
    }

    /**
     * Rebuild the body when properties change
     */
    rebuildBody() {
        if (this.gameObject && window.physicsManager) {
            // Update initial position and angle before rebuilding
            const pos = this.gameObject.getWorldPosition();
            this.initialPosition = { x: pos.x, y: pos.y };
            this.initialAngle = this.gameObject.angle;
            this.createBody();
        }
    }

    /**
     * Apply a force to the center of the body
     * @param {Vector2} force - The force to apply
     */
    applyForce(force) {
        if (this.body) {
            Matter.Body.applyForce(this.body, this.body.position, { x: force.x, y: force.y });
        }
    }

    /**
     * Apply an impulse to the center of the body
     * @param {Vector2} impulse - The impulse to apply
     */
    applyImpulse(impulse) {
        if (this.body) {
            const position = this.body.position;
            Matter.Body.applyForce(this.body, position, {
                x: impulse.x / this.body.mass,
                y: impulse.y / this.body.mass
            });
        }
    }

    /**
     * Apply a torque (rotational force) to the body
     * @param {number} torque - The torque to apply
     */
    applyTorque(torque) {
        if (this.body) {
            Matter.Body.setAngularVelocity(this.body, this.body.angularVelocity + torque);
        }
    }

    setAngularVelocity(angularVelocity) {
        if (this.body) {
            // Convert from degrees/sec to radians/sec
            const radians = angularVelocity * (Math.PI / 180);
            Matter.Body.setAngularVelocity(this.body, radians);
        }
    }

    /**
     * Set the linear velocity of the body
     * @param {Vector2} velocity - The velocity to set
     */
    setVelocity(velocity) {
        if (this.body) {
            Matter.Body.setVelocity(this.body, { x: velocity.x, y: velocity.y });
        }
    }

    /**
     * Get the current linear velocity of the body
     * @returns {Vector2} The current velocity
     */
    getVelocity() {
        if (this.body) {
            return new Vector2(this.body.velocity.x, this.body.velocity.y);
        }
        return new Vector2(0, 0);
    }

    /**
     * Set the angular velocity of the body
     * @param {number} angularVelocity - The angular velocity in degrees/second
     */
    setAngularVelocity(angularVelocity) {
        if (this.body) {
            // Convert from degrees/sec to radians/sec
            const radians = angularVelocity * (Math.PI / 180);
            Matter.Body.setAngularVelocity(this.body, radians);
        }
    }

    /**
     * Get the current angular velocity of the body
     * @returns {number} The angular velocity in degrees/second
     */
    getAngularVelocity() {
        if (this.body) {
            // Convert from radians/sec to degrees/sec
            return this.body.angularVelocity * (180 / Math.PI);
        }
        return 0;
    }

    /**
     * Handle collision start events
     */
    onCollisionStart(event) {
        const pairs = event.pairs;

        for (let i = 0; i < pairs.length; i++) {
            const pair = pairs[i];

            if (pair.bodyA === this.body) {
                // Add the colliding body to our contacts
                this.inCollision.add(pair.bodyB);

                // Find the other game object
                const otherObject = window.physicsManager.bodies.get(pair.bodyB);
                if (otherObject) {
                    // Call the onCollisionEnter method if it exists
                    if (this.gameObject && this.gameObject.onCollisionEnter) {
                        this.gameObject.onCollisionEnter(otherObject);
                    }
                }
            }
            else if (pair.bodyB === this.body) {
                // Add the colliding body to our contacts
                this.inCollision.add(pair.bodyA);

                // Find the other game object
                const otherObject = window.physicsManager.bodies.get(pair.bodyA);
                if (otherObject) {
                    // Call the onCollisionEnter method if it exists
                    if (this.gameObject && this.gameObject.onCollisionEnter) {
                        this.gameObject.onCollisionEnter(otherObject);
                    }
                }
            }
        }
    }

    /**
     * Handle collision end events
     */
    onCollisionEnd(event) {
        const pairs = event.pairs;

        for (let i = 0; i < pairs.length; i++) {
            const pair = pairs[i];

            if (pair.bodyA === this.body) {
                // Remove the body from our contacts
                this.inCollision.delete(pair.bodyB);

                // Find the other game object
                const otherObject = window.physicsManager.bodies.get(pair.bodyB);
                if (otherObject) {
                    // Call the onCollisionExit method if it exists
                    if (this.gameObject && this.gameObject.onCollisionExit) {
                        this.gameObject.onCollisionExit(otherObject);
                    }
                }
            }
            else if (pair.bodyB === this.body) {
                // Remove the body from our contacts
                this.inCollision.delete(pair.bodyA);

                // Find the other game object
                const otherObject = window.physicsManager.bodies.get(pair.bodyA);
                if (otherObject) {
                    // Call the onCollisionExit method if it exists
                    if (this.gameObject && this.gameObject.onCollisionExit) {
                        this.gameObject.onCollisionExit(otherObject);
                    }
                }
            }
        }
    }

    /**
     * Called before rendering to update static bodies if needed
     */
    beginLoop() {
        // If the game object has moved, we need to update static bodies
        if (this.body && this.bodyType === 'static' && this.gameObject) {
            const pos = this.gameObject.getWorldPosition();
            const angle = this.gameObject.angle * (Math.PI / 180);
            Matter.Body.setPosition(this.body, { x: pos.x, y: pos.y });
            Matter.Body.setAngle(this.body, angle);
        }
    }

    /**
     * Override onEnable to handle pending body creation
     */
    onEnable() {
        if (this.pendingBodyCreation && !this.body && window.physicsManager) {
            this.createBody();
            this.pendingBodyCreation = false;
        }
    }

    /**
     * Called when the module is destroyed
     */
    onDestroy() {
        // Remove event listeners
        if (window.physicsManager && window.physicsManager.engine) {
            Matter.Events.off(window.physicsManager.engine, 'collisionStart', this.boundOnCollisionStart);
            Matter.Events.off(window.physicsManager.engine, 'collisionEnd', this.boundOnCollisionEnd);
        }

        // Remove body from physics world
        this.removeBody();
    }

    toJSON() {
        return {
            ...super.toJSON(),
            bodyType: this.bodyType,
            shape: this.shape,
            width: this.width,
            height: this.height,
            radius: this.radius,
            density: this.density,
            friction: this.friction,
            frictionAir: this.frictionAir,
            restitution: this.restitution,
            fixedRotation: this.fixedRotation,
            isSensor: this.isSensor,
            useGravity: this.useGravity,
            sleepingAllowed: this.sleepingAllowed,
            label: this.label,
            collisionFilter: { ...this.collisionFilter },
            vertices: this.vertices
        };
    }

    /**
     * Override from Module to handle deserialization
     * @param {Object} data - The serialized data
     */
    fromJSON(data) {
        super.fromJSON(data);
        this.bodyType = data.bodyType ?? this.bodyType;
        this.shape = data.shape ?? this.shape;
        this.width = data.width ?? this.width;
        this.height = data.height ?? this.height;
        this.radius = data.radius ?? this.radius;
        this.density = data.density ?? this.density;
        this.friction = data.friction ?? this.friction;
        this.frictionAir = data.frictionAir ?? this.frictionAir;
        this.restitution = data.restitution ?? this.restitution;
        this.fixedRotation = data.fixedRotation ?? false;
        this.isSensor = data.isSensor ?? false;
        this.useGravity = data.useGravity ?? true;
        this.sleepingAllowed = data.sleepingAllowed ?? true;
        this.label = data.label ?? "";
        this.collisionFilter = { ...this.collisionFilter, ...data.collisionFilter };
        this.vertices = data.vertices ?? [];

        // Update initial position and angle after deserialization
        if (this.gameObject) {
            const pos = this.gameObject.getWorldPosition();
            this.initialPosition = { x: pos.x, y: pos.y };
            this.initialAngle = this.gameObject.angle;
            //this.createBody();
        }

        this.pendingBodyCreation = true; // Delay body creation until onEnable or start
    }
}

// Register the module
window.RigidBody = RigidBody;

// src/core/Modules/Matter-js/VehiclePhysics.js
/**
 * VehiclePhysics - Realistic top-down vehicle physics module with drift system
 * Requires RigidBody module on the same GameObject
 */
class VehiclePhysics extends Module {
    static allowMultiple = false;
    static namespace = "Matter.js";
    static description = "Realistic top-down vehicle physics with steering, acceleration, and drift mechanics for Matter.js";
    static iconClass = "fas fa-car";

    constructor() {
        super("VehiclePhysics");

        // Control settings
        this.playerControlled = true;           // Can be controlled with arrow keys
        this.upKey = "arrowup";                 // Accelerate key
        this.downKey = "arrowdown";             // Brake/reverse key
        this.leftKey = "arrowleft";             // Turn left key
        this.rightKey = "arrowright";           // Turn right key
        this.handbrakeKey = " ";            // Handbrake/drift key

        // Vehicle physics properties
        this.weight = 1000;                  // Vehicle weight in kg
        this.maxSpeed = 1000;                   // Maximum speed in pixels/second
        this.acceleration = 300;               // Acceleration force
        this.brakeForce = 250;                 // Braking force
        this.decelerationRate = 0.05;          // Natural deceleration when not accelerating
        this.reverseMaxSpeed = 250;            // Max reverse speed

        // Steering system
        this.maxTurnAngle = 45;                // Maximum wheel turn angle in degrees
        this.wheelTurnSpeed = 90;             // Degrees per second wheel turn rate
        this.wheelReturnSpeed = 90;           // Speed wheels return to center when not turning        
        this.turnMultiplier = 20.0;             // Multiplies steering effect based on speed

        this.dragCoefficient = 0.95;           // Natural drag (0-1, closer to 1 = less drag)
        this.lateralGrip = 0.85;               // Base side friction for normal driving (0-1)
        this.minTurnSpeed = 50;                // Minimum speed to turn effectively

        // Advanced physics
        this.wheelBase = 60;                   // Distance between front and rear axles
        this.frontWheelDrive = false;           // Front or rear wheel drive
        this.differentialStrength = 0.6;       // How much wheels stick together (0-1)
        this.antiRoll = 0.3;                   // Prevents excessive body roll

        // NEW: Drift and traction system
        this.handbrakeForce = 6;             // How much handbrake reduces rear grip (0-1)
        this.driftThreshold = 0.8;             // Speed threshold for drift to begin (0-1 of max speed)
        this.tractionLoss = 0.4;               // How much traction is lost under hard acceleration (0-1)
        this.powerOversteerStrength = 1.2;     // Multiplier for rear-wheel drive oversteer
        this.frontGripAdvantage = 0.15;        // Extra grip for front-wheel drive in turns
        this.driftRecoveryRate = 1.2;          // How quickly traction recovers when not drifting
        this.velocityDriftFactor = 0.7;        // How much velocity direction affects drift angle

        // Traction control simulation
        this.tractionControlEnabled = true;    // Simulates modern traction control
        this.tractionControlStrength = 0.6;    // How much TC reduces power loss (0-1)
        this.absEnabled = true;                // Anti-lock braking simulation
        this.absStrength = 0.8;               // ABS effectiveness (0-1)

        // Internal state
        this.currentSpeed = 0;                 // Current speed magnitude
        this.currentWheelAngle = 0;            // Current wheel angle in degrees (-maxTurnAngle to +maxTurnAngle)
        this.throttleInput = 0;                // Current throttle/brake input (-1 to 1)
        this.targetThrottleInput = 0;          // Target throttle input from controls
        this.steeringInput = 0;                // Current steering input (-1 to 1)
        this.targetSteeringInput = 0;          // Target steering from controls

        this.isAccelerating = false;
        this.isBraking = false;
        this.isTurning = false;
        this.isHandbraking = false;            // NEW: Handbrake state
        this.isDrifting = false;               // NEW: Whether vehicle is currently drifting
        this.driftAngle = 0;                   // NEW: Current drift angle in degrees
        this.currentTraction = 1.0;            // NEW: Current traction level (0-1)
        this.wheelSpinAmount = 0;              // NEW: Amount of wheel spin/loss of traction

        this.rigidBody = null;                 // Reference to RigidBody component

        // Debug options
        this.showDebugInfo = false;            // Show speed/steering debug
        this.showWheelDirection = true;        // Show wheel direction indicators
        this.showDriftInfo = true;             // NEW: Show drift-related debug info

        this.require("RigidBody");

        // Expose properties to inspector
        this.exposeProperty("weight", "number", this.weight, {
            description: "Vehicle weight in kg",
            min: 1,
            max: 5000,
            step: 10,
            onChange: (val) => { this.weight = val; }
        });

        this.exposeProperty("playerControlled", "boolean", this.playerControlled, {
            description: "Can be controlled with arrow keys",
            onChange: (val) => { this.playerControlled = val; }
        });

        this.exposeProperty("maxSpeed", "number", this.maxSpeed, {
            description: "Maximum forward speed",
            min: 1,
            max: 500,
            onChange: (val) => { this.maxSpeed = val; }
        });

        this.exposeProperty("acceleration", "number", this.acceleration, {
            description: "Acceleration force",
            min: 0.1,
            max: 100,
            onChange: (val) => { this.acceleration = val; }
        });

        this.exposeProperty("brakeForce", "number", this.brakeForce, {
            description: "Braking force",
            min: 0.1,
            max: 1000,
            onChange: (val) => { this.brakeForce = val; }
        });

        this.exposeProperty("frontWheelDrive", "boolean", this.frontWheelDrive, {
            description: "Front wheel drive vs rear wheel drive",
            onChange: (val) => { this.frontWheelDrive = val; }
        });

        this.exposeProperty("handbrakeForce", "number", this.handbrakeForce, {
            description: "Handbrake drift strength",
            min: 0.1,
            max: 1.0,
            step: 0.1,
            onChange: (val) => { this.handbrakeForce = val; }
        });

        this.exposeProperty("tractionLoss", "number", this.tractionLoss, {
            description: "Traction loss under hard acceleration",
            min: 0.0,
            max: 1.0,
            step: 0.1,
            onChange: (val) => { this.tractionLoss = val; }
        });

        this.exposeProperty("showDebugInfo", "boolean", this.showDebugInfo, {
            description: "Show speed and steering debug info",
            onChange: (val) => { this.showDebugInfo = val; }
        });

        this.exposeProperty("showDriftInfo", "boolean", this.showDriftInfo, {
            description: "Show drift debug information",
            onChange: (val) => { this.showDriftInfo = val; }
        });
    }

    style(style) {
        style.startGroup("Vehicle Controls", false, {
            backgroundColor: 'rgba(100, 200, 100, 0.1)',
            borderRadius: '6px',
            padding: '8px'
        });

        style.exposeProperty("playerControlled", "boolean", this.playerControlled, {
            description: "Enable arrow key controls",
            style: { label: "Player Controlled" }
        });

        style.exposeProperty("handbrakeKey", "string", this.handbrakeKey, {
            description: "Key for handbrake/drift",
            style: { label: "Handbrake Key" }
        });

        style.endGroup();

        style.startGroup("Performance", false, {
            backgroundColor: 'rgba(255, 150, 100, 0.1)',
            borderRadius: '6px',
            padding: '8px'
        });

        style.exposeProperty("weight", "number", this.weight, {
            description: "Vehicle weight in kg",
            min: 1,
            max: 5000,
            step: 10
        });

        style.exposeProperty("maxSpeed", "number", this.maxSpeed, {
            description: "Top speed in pixels per second",
            min: 50,
            max: 1000,
            step: 25,
            style: { label: "Max Speed", slider: true }
        });

        style.exposeProperty("acceleration", "number", this.acceleration, {
            description: "How quickly the vehicle accelerates",
            min: 100,
            max: 2000,
            step: 50,
            style: { label: "Acceleration", slider: true }
        });

        style.exposeProperty("brakeForce", "number", this.brakeForce, {
            description: "Braking strength",
            min: 200,
            max: 2000,
            step: 50,
            style: { label: "Brake Force", slider: true }
        });

        style.exposeProperty("decelerationRate", "number", this.decelerationRate, {
            description: "Natural slowdown when coasting",
            min: 0.05,
            max: 0.5,
            step: 0.05,
            style: { label: "Deceleration", slider: true }
        });

        style.endGroup();

        style.startGroup("Drive Type & Traction", false, {
            backgroundColor: 'rgba(255, 200, 100, 0.1)',
            borderRadius: '6px',
            padding: '8px'
        });

        style.exposeProperty("frontWheelDrive", "boolean", this.frontWheelDrive, {
            description: "FWD vs RWD affects handling and drift characteristics",
            style: { label: "Front Wheel Drive" }
        });

        style.exposeProperty("tractionLoss", "number", this.tractionLoss, {
            description: "Traction loss under hard acceleration",
            min: 0.0,
            max: 1.0,
            step: 0.1,
            style: { label: "Power Traction Loss", slider: true }
        });

        style.exposeProperty("powerOversteerStrength", "number", this.powerOversteerStrength, {
            description: "RWD oversteer multiplier",
            min: 0.5,
            max: 3.0,
            step: 0.1,
            style: { label: "RWD Oversteer", slider: true }
        });

        style.exposeProperty("frontGripAdvantage", "number", this.frontGripAdvantage, {
            description: "FWD cornering grip advantage",
            min: 0.0,
            max: 0.5,
            step: 0.05,
            style: { label: "FWD Grip Bonus", slider: true }
        });

        style.endGroup();

        style.startGroup("Drift System", false, {
            backgroundColor: 'rgba(200, 100, 255, 0.1)',
            borderRadius: '6px',
            padding: '8px'
        });

        style.exposeProperty("handbrakeForce", "number", this.handbrakeForce, {
            description: "Handbrake drift strength (higher = more sliding)",
            min: 0.1,
            max: 1.0,
            step: 0.1,
            style: { label: "Handbrake Strength", slider: true }
        });

        style.exposeProperty("driftThreshold", "number", this.driftThreshold, {
            description: "Speed threshold for drift initiation",
            min: 0.3,
            max: 1.0,
            step: 0.1,
            style: { label: "Drift Speed Threshold", slider: true }
        });

        style.exposeProperty("driftRecoveryRate", "number", this.driftRecoveryRate, {
            description: "How quickly traction recovers",
            min: 1.0,
            max: 10.0,
            step: 0.5,
            style: { label: "Traction Recovery", slider: true }
        });

        style.exposeProperty("velocityDriftFactor", "number", this.velocityDriftFactor, {
            description: "How much velocity affects drift angle",
            min: 0.1,
            max: 2.0,
            step: 0.1,
            style: { label: "Velocity Drift Factor", slider: true }
        });

        style.endGroup();

        style.startGroup("Steering", false, {
            backgroundColor: 'rgba(150, 150, 255, 0.1)',
            borderRadius: '6px',
            padding: '8px'
        });

        style.exposeProperty("turnMultiplier", "number", this.turnMultiplier, {
            description: "Steering strength multiplier",
            min: 0.1,
            max: 5,
            step: 0.1,
            style: { label: "Turn Multiplier", slider: true }
        });

        style.exposeProperty("maxTurnAngle", "number", this.maxTurnAngle, {
            description: "Maximum wheel turn angle",
            min: 15,
            max: 90,
            step: 5,
            style: { label: "Max Turn Angle", slider: true }
        });

        style.exposeProperty("lateralGrip", "number", this.lateralGrip, {
            description: "Base tire grip for cornering",
            min: 0.1,
            max: 1,
            step: 0.05,
            style: { label: "Base Tire Grip", slider: true }
        });

        style.endGroup();

        style.startGroup("Driver Assists", true, {
            backgroundColor: 'rgba(100, 255, 200, 0.1)',
            borderRadius: '6px',
            padding: '8px'
        });

        style.exposeProperty("tractionControlEnabled", "boolean", this.tractionControlEnabled, {
            description: "Simulates traction control system",
            style: { label: "Traction Control" }
        });

        style.exposeProperty("tractionControlStrength", "number", this.tractionControlStrength, {
            description: "TC effectiveness",
            min: 0.0,
            max: 1.0,
            step: 0.1,
            style: { label: "TC Strength", slider: true }
        });

        style.exposeProperty("absEnabled", "boolean", this.absEnabled, {
            description: "Anti-lock braking system",
            style: { label: "ABS" }
        });

        style.endGroup();

        style.startGroup("Debug", true, {
            backgroundColor: 'rgba(200, 200, 200, 0.1)',
            borderRadius: '6px',
            padding: '8px'
        });

        style.exposeProperty("showDebugInfo", "boolean", this.showDebugInfo, {
            description: "Display basic vehicle debug information",
            style: { label: "Debug Info" }
        });

        style.exposeProperty("showDriftInfo", "boolean", this.showDriftInfo, {
            description: "Display drift-specific debug information",
            style: { label: "Drift Debug" }
        });

        style.exposeProperty("showWheelDirection", "boolean", this.showWheelDirection, {
            description: "Show wheel and velocity vectors",
            style: { label: "Wheel Vectors" }
        });

        style.endGroup();

        style.addDivider();
        style.addHelpText("Enhanced physics with realistic drift mechanics. Use handbrake + steering to initiate drifts. RWD vehicles have more oversteer, FWD have better traction.");
    }

    start() {
        // Get the RigidBody component
        this.rigidBody = this.gameObject.getModule("RigidBody");

        if (!this.rigidBody) {
            console.error("VehiclePhysics requires a RigidBody component on the same GameObject!");
            return;
        }

        // Configure RigidBody for vehicle physics
        this.rigidBody.useGravity = false;      // Disable gravity for top-down
        this.rigidBody.bodyType = "dynamic";    // Must be dynamic
        this.rigidBody.friction = 0.1;          // Low friction, we'll handle it
        this.rigidBody.frictionAir = 0.02;      // Minimal air resistance
        this.rigidBody.density = 1.5;           // Moderate density for realistic mass

        // Set up collision filter if needed
        if (this.rigidBody.body) {
            this.rigidBody.body.ignoreGravity = true;
        }

        this.rigidBody.updateMass(this.weight);

        console.log(this.playerControlled ? "Player-controlled vehicle initialized." : "AI-controlled vehicle initialized.");
    }

    loop(deltaTime) {
        if (!this.rigidBody || !this.rigidBody.body) return;

        // Reset input flags
        this.isAccelerating = false;
        this.isBraking = false;
        this.isTurning = false;
        this.isHandbraking = false;

        // Get target input values
        this.targetThrottleInput = 0;
        this.targetSteeringInput = 0;

        if (this.playerControlled) {
            if (window.input.keyDown(this.upKey)) {
                this.targetThrottleInput = 1;
                this.isAccelerating = true;
            }
            if (window.input.keyDown(this.downKey)) {
                this.targetThrottleInput = -1;
                this.isBraking = true;
            }
            if (window.input.keyDown(this.leftKey)) {
                this.targetSteeringInput = -1;
                this.isTurning = true;
            }
            if (window.input.keyDown(this.rightKey)) {
                this.targetSteeringInput = 1;
                this.isTurning = true;
            }
            if (window.input.keyDown(this.handbrakeKey)) {
                this.isHandbraking = true;
            }
        }

        // Update physics systems
        this.updateInputs(deltaTime);
        this.updateWheelSteering(deltaTime);
        this.updateTractionSystem(deltaTime);
        this.updateVehiclePhysics(deltaTime);
        this.updateDriftPhysics(deltaTime);
    }

    updateInputs(deltaTime) {
        // Smooth throttle input transitions
        if (this.targetThrottleInput !== 0) {
            // Accelerating or braking - use acceleration/brake rates
            let lerpRate = this.targetThrottleInput > 0 ? this.acceleration * 0.01 : this.brakeForce * 0.01;
            this.throttleInput = this.lerp(this.throttleInput, this.targetThrottleInput, lerpRate * deltaTime);
        } else {
            // Coasting - use deceleration rate
            this.throttleInput = this.lerp(this.throttleInput, 0, this.decelerationRate * deltaTime * 60);
        }

        // Smooth steering input transitions
        if (this.targetSteeringInput !== 0) {
            this.steeringInput = this.lerp(this.steeringInput, this.targetSteeringInput, 8 * deltaTime);
        } else {
            this.steeringInput = this.lerp(this.steeringInput, 0, 6 * deltaTime);
        }
    }

    updateWheelSteering(deltaTime) {
        // Calculate target wheel angle based on steering input
        let targetWheelAngle = this.steeringInput * this.maxTurnAngle;

        // Determine wheel turn speed
        let turnSpeed = this.wheelTurnSpeed;
        if (this.targetSteeringInput === 0 && this.isMoving()) {
            // Use return speed when wheels should return to center while moving
            turnSpeed = this.wheelReturnSpeed;
        }

        // Smooth wheel angle transitions
        let angleDiff = targetWheelAngle - this.currentWheelAngle;
        let maxAngleChange = turnSpeed * deltaTime;

        if (Math.abs(angleDiff) <= maxAngleChange) {
            this.currentWheelAngle = targetWheelAngle;
        } else {
            this.currentWheelAngle += Math.sign(angleDiff) * maxAngleChange;
        }
    }

    updateTractionSystem(deltaTime) {
        const speedRatio = this.currentSpeed / this.maxSpeed;
        const throttleAmount = Math.abs(this.throttleInput);

        // Calculate wheel spin based on acceleration and drive type
        this.wheelSpinAmount = 0;

        if (this.isAccelerating && throttleAmount > 0.7) {
            // Hard acceleration causes wheel spin
            let baseSpin = throttleAmount * this.tractionLoss;

            // RWD loses more traction under power, especially when turning
            if (!this.frontWheelDrive) {
                baseSpin *= (1 + Math.abs(this.steeringInput) * this.powerOversteerStrength);
            }

            // Higher speeds make it easier to break traction
            baseSpin *= (0.5 + speedRatio * 0.5);

            this.wheelSpinAmount = baseSpin;
        }

        // Calculate current effective traction
        let targetTraction = 1.0;

        // Reduce traction based on wheel spin
        if (this.wheelSpinAmount > 0) {
            targetTraction = Math.max(0.2, 1.0 - this.wheelSpinAmount);

            // Traction control helps recover traction
            if (this.tractionControlEnabled) {
                targetTraction = this.lerp(targetTraction, 1.0, this.tractionControlStrength);
            }
        }

        // Handbrake reduces rear traction significantly
        if (this.isHandbraking) {
            // Handbrake mainly affects rear wheels
            let handbrakeEffect = this.handbrakeForce;
            if (this.frontWheelDrive) {
                // FWD can still steer somewhat with handbrake
                targetTraction = Math.max(0.3, targetTraction - handbrakeEffect * 0.7);
            } else {
                // RWD loses more control with handbrake
                targetTraction = Math.max(0.1, targetTraction - handbrakeEffect);
            }
        }

        // FWD gets grip advantage in normal conditions
        if (this.frontWheelDrive && !this.isHandbraking && this.wheelSpinAmount < 0.3) {
            targetTraction = Math.min(1.0, targetTraction + this.frontGripAdvantage);
        }

        // Smooth traction transitions
        this.currentTraction = this.lerp(this.currentTraction, targetTraction, this.driftRecoveryRate * deltaTime);
    }

    updateVehiclePhysics(deltaTime) {
        const body = this.rigidBody.body;
        const velocity = this.rigidBody.getVelocity();

        // Calculate current speed and direction
        this.currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
        const currentAngle = this.gameObject.angle * (Math.PI / 180);

        // Forward direction vector (vehicle body direction)
        const forwardX = Math.cos(currentAngle);
        const forwardY = Math.sin(currentAngle);

        // Right direction vector (for lateral forces)
        const rightX = -Math.sin(currentAngle);
        const rightY = Math.cos(currentAngle);

        // Calculate forward and lateral velocity components
        const forwardVel = velocity.x * forwardX + velocity.y * forwardY;
        const rightVel = velocity.x * rightX + velocity.y * rightY;

        // Apply throttle forces with traction consideration
        if (Math.abs(this.throttleInput) > 0.01) {
            let targetSpeed = this.throttleInput > 0 ? this.maxSpeed : -this.reverseMaxSpeed;
            let force = Math.abs(this.throttleInput > 0 ? this.acceleration : this.brakeForce);

            // ABS simulation for braking
            if (this.throttleInput < 0 && this.absEnabled) {
                force *= (0.3 + this.currentTraction * 0.7 * this.absStrength);
            }

            // Reduce force as we approach max speed
            let speedRatio = Math.abs(forwardVel) / Math.abs(targetSpeed);
            if (speedRatio > 0.8) {
                force *= Math.max(0.1, 1 - speedRatio);
            }

            // Apply traction to driving force
            let effectiveForce = force * this.throttleInput * this.currentTraction * deltaTime * 60;

            // Wheel spin causes reduced forward motion but can help initiate drifts
            if (this.wheelSpinAmount > 0.5 && Math.abs(this.steeringInput) > 0.3) {
                effectiveForce *= 0.7; // Reduce forward motion when spinning wheels while turning
            }

            this.rigidBody.applyForce({
                x: forwardX * effectiveForce,
                y: forwardY * effectiveForce
            });
        }

        // --- Add roll force in wheel direction when not accelerating ---
        if (!this.isAccelerating && this.isMoving()) {
            // Calculate wheel direction vector
            const wheelAngleRad = (this.currentWheelAngle * Math.PI / 180);
            const wheelDirection = currentAngle + wheelAngleRad;
            const wheelDirX = Math.cos(wheelDirection);
            const wheelDirY = Math.sin(wheelDirection);

            // Project velocity onto wheel direction
            const velDotWheel = velocity.x * wheelDirX + velocity.y * wheelDirY;

            // Calculate desired velocity in wheel direction
            const desiredVelX = wheelDirX * velDotWheel;
            const desiredVelY = wheelDirY * velDotWheel;

            // Blend factor increases as speed drops (stronger at low speed)
            const speedRatio = Math.min(1, this.currentSpeed / this.maxSpeed);
            // At low speed, blend is high (0.25), at high speed, blend is low (0.05)
            const rollBlend = 0.05 + (1 - speedRatio) * 0.2;

            // Further increase blend if traction is low
            const tractionBlend = rollBlend * (1 - this.currentTraction);

            // Final blend factor
            const blend = Math.max(rollBlend, tractionBlend);

            // Apply roll force
            const rollForceX = (desiredVelX - velocity.x) * blend;
            const rollForceY = (desiredVelY - velocity.y) * blend;

            this.rigidBody.applyForce({
                x: rollForceX,
                y: rollForceY
            });
        }

        // Apply wheel-based steering with traction consideration
        if (Math.abs(this.currentWheelAngle) > 1 && this.isMoving()) {
            const wheelAngleRad = (this.currentWheelAngle * Math.PI / 180);
            const wheelDirection = currentAngle + wheelAngleRad;

            const wheelForwardX = Math.cos(wheelDirection);
            const wheelForwardY = Math.sin(wheelDirection);

            // Calculate steering force with traction
            let steerForce = this.currentSpeed * Math.sin(wheelAngleRad) * this.currentTraction;

            // Apply drive type effects to steering
            if (!this.frontWheelDrive && this.wheelSpinAmount > 0.3) {
                steerForce *= (1.5 + Math.abs(this.throttleInput) * 0.5);
            }

            this.rigidBody.applyForce({
                x: wheelForwardX * steerForce * 0.5,
                y: wheelForwardY * steerForce * 0.5
            });

            // Calculate turn radius and apply angular velocity
            let wheelbase = this.wheelBase;
            let turnRadius = wheelbase / Math.tan(Math.abs(wheelAngleRad));
            let angularVel = (forwardVel / turnRadius) * (this.currentWheelAngle / Math.abs(this.currentWheelAngle)) * this.turnMultiplier;

            // Modify angular velocity based on traction
            angularVel *= this.currentTraction;

            // RWD oversteer effect
            if (!this.frontWheelDrive && this.isAccelerating && this.wheelSpinAmount > 0.3) {
                angularVel *= 1.3;
            }

            // Limit angular velocity for stability  
            angularVel = Math.max(-5, Math.min(5, angularVel));
            this.rigidBody.setAngularVelocity(angularVel);
        }

        // Apply drag forces
        if (this.currentSpeed > 0) {
            // Forward/backward drag
            const dragForce = forwardVel * forwardVel * (1 - this.dragCoefficient) * 0.01;
            this.rigidBody.applyForce({
                x: -forwardX * dragForce * Math.sign(forwardVel),
                y: -forwardY * dragForce * Math.sign(forwardVel)
            });

            // Lateral drag (tire friction) modified by current traction
            let effectiveLateralGrip = this.lateralGrip * this.currentTraction;
            const lateralDragForce = Math.abs(rightVel) * rightVel * effectiveLateralGrip * 0.5;

            this.rigidBody.applyForce({
                x: -rightX * lateralDragForce,
                y: -rightY * lateralDragForce
            });
        }

        // Apply angular damping
        if (body.angularVelocity !== 0) {
            const angularDrag = body.angularVelocity * 0.8 * this.currentTraction;
            body.angularVelocity -= angularDrag * deltaTime;
        }
    }

    updateDriftPhysics(deltaTime) {
        if (!this.rigidBody || !this.rigidBody.body) return;

        const velocity = this.rigidBody.getVelocity();
        const currentAngle = this.gameObject.angle * (Math.PI / 180);

        // Calculate velocity angle
        const velocityAngle = Math.atan2(velocity.y, velocity.x);

        // Calculate drift angle (difference between car direction and velocity direction)
        let rawDriftAngle = (velocityAngle - currentAngle) * (180 / Math.PI);

        // Normalize angle to -180 to 180
        while (rawDriftAngle > 180) rawDriftAngle -= 360;
        while (rawDriftAngle < -180) rawDriftAngle += 360;

        // Apply velocity factor to drift angle calculation
        this.driftAngle = rawDriftAngle * this.velocityDriftFactor;

        // Determine if we're drifting (symmetrical for left/right)
        const speedRatio = this.currentSpeed / this.maxSpeed;
        const driftThreshold = this.driftThreshold;

        this.isDrifting = (
            speedRatio > driftThreshold &&
            (Math.abs(this.driftAngle) > 15 || this.isHandbraking || this.currentTraction < 0.8)
        );

        // Enhanced drift effects when handbraking
        if (this.isHandbraking && speedRatio > 0.2 && Math.abs(this.steeringInput) > 0.01) {
            // Calculate sideways (perpendicular) direction to car's forward
            const rightX = -Math.sin(currentAngle);
            const rightY = Math.cos(currentAngle);

            // Drift force is perpendicular to car direction, scaled by steering direction
            // But should move opposite to current velocity for initial slide
            // So, apply force opposite to velocity, plus a sideways force for turning
            // 1. Opposite to velocity (to break traction)
            const slideForce = -1 * this.handbrakeForce * this.currentSpeed;
            this.rigidBody.applyForce({
                x: velocity.x * slideForce * deltaTime,
                y: velocity.y * slideForce * deltaTime
            });

            // 2. Sideways force (perpendicular to forward, scaled by steering)
            const driftSideForce = this.currentSpeed * this.handbrakeForce * Math.sign(this.steeringInput);
            this.rigidBody.applyForce({
                x: rightX * driftSideForce * deltaTime,
                y: rightY * driftSideForce * deltaTime
            });

            // 3. Stronger damping to prevent speed accumulation
            const dampingForce = 0.8; // Increased damping
            this.rigidBody.applyForce({
                x: -velocity.x * dampingForce * deltaTime,
                y: -velocity.y * dampingForce * deltaTime
            });
        }
    }

    // Utility function for smooth interpolation
    lerp(start, end, factor) {
        factor = Math.max(0, Math.min(1, factor));
        return start + (end - start) * factor;
    }

    draw(ctx) {
        if (!this.showDebugInfo && !this.showWheelDirection && !this.showDriftInfo) return;

        const pos = this.gameObject.getWorldPosition();
        const angle = 0;//this.gameObject.angle * (Math.PI / 180);

        ctx.save();

        if (this.showDebugInfo) {
            // Draw basic debug info
            ctx.fillStyle = "white";
            ctx.font = "12px Arial";
            ctx.textAlign = "center";

            const speed = Math.round(this.currentSpeed);
            const angle_deg = Math.round(this.gameObject.angle % 360);
            const wheelAngle = Math.round(this.currentWheelAngle);
            const throttle = Math.round(this.throttleInput * 100);

            ctx.fillText(`Speed: ${speed}px/s`, 0, -70);
            ctx.fillText(`Angle: ${angle_deg}`, 0, -58);
            ctx.fillText(`Wheels: ${wheelAngle}`, 0, -46);
            ctx.fillText(`Throttle: ${throttle}%`, 0, -34);

            if (this.isAccelerating) ctx.fillText("ACCEL", 0, -22);
            if (this.isBraking) ctx.fillText("BRAKE", 0, -22);
            if (this.isTurning) ctx.fillText("TURN", 0, -10);
            if (this.isHandbraking) ctx.fillText("HANDBRAKE", 0, 2);
        }

        if (this.showDriftInfo) {
            // Draw drift-specific debug info
            ctx.fillStyle = this.isDrifting ? "orange" : "lightblue";
            ctx.font = "11px Arial";
            ctx.textAlign = "center";

            const traction = Math.round(this.currentTraction * 100);
            const driftAngle = Math.round(this.driftAngle);
            const wheelSpin = Math.round(this.wheelSpinAmount * 100);

            let yOffset = this.showDebugInfo ? 14 : -58;

            ctx.fillText(`Traction: ${traction}%`, 0, yOffset);
            ctx.fillText(`Drift: ${driftAngle}`, 0, yOffset + 12);
            ctx.fillText(`Wheel Spin: ${wheelSpin}%`, 0, yOffset + 24);

            if (this.isDrifting) {
                ctx.fillStyle = "orange";
                ctx.fillText("DRIFTING!", 0, yOffset + 36);
            }

            // Drive type indicator
            ctx.fillStyle = "yellow";
            ctx.fillText(this.frontWheelDrive ? "FWD" : "RWD", 0, yOffset + 48);

            // Traction control indicators
            if (this.tractionControlEnabled || this.absEnabled) {
                ctx.fillStyle = "lime";
                let assists = [];
                if (this.tractionControlEnabled) assists.push("TC");
                if (this.absEnabled) assists.push("ABS");
                ctx.fillText(assists.join(" "), 0, yOffset + 60);
            }
        }

        if (this.showWheelDirection) {
            // Draw velocity vector
            try {
                const velocity = this.rigidBody.getVelocity();
                if (!velocity) return;

                if (this.currentSpeed > 10) {
                    // Color code velocity vector based on drift state
                    ctx.strokeStyle = this.isDrifting ? "orange" : "lime";
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(velocity.x * 0.5, velocity.y * 0.5);
                    ctx.stroke();
                }
            } catch (e) {
                //console.warn("VehiclePhysics: Unable to draw velocity vector", e);
            }

            // Draw forward direction (red)
            ctx.strokeStyle = "red";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(Math.cos(angle) * 30, Math.sin(angle) * 30);
            ctx.stroke();

            // Draw wheel direction (yellow)
            if (Math.abs(this.currentWheelAngle) > 1) {
                const wheelAngleRad = (this.currentWheelAngle * Math.PI / 180);
                const wheelDirection = angle + wheelAngleRad;
                ctx.strokeStyle = "lime";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(wheelDirection) * 25, Math.sin(wheelDirection) * 25);
                ctx.stroke();
            }

            // Draw traction indicator
            const tractionRadius = 15 + (this.currentTraction * 10);
            ctx.strokeStyle = `hsl(${this.currentTraction * 120}, 100%, 50%)`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, tractionRadius, 0, Math.PI * 2);
            ctx.stroke();

            // Draw wheel spin indicator
            if (this.wheelSpinAmount > 0.1) {
                ctx.strokeStyle = "red";
                ctx.lineWidth = 1;
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const radius = 35 + Math.sin(Date.now() * 0.01 + i) * this.wheelSpinAmount * 5;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
                    ctx.stroke();
                }
            }
        }

        ctx.restore();
    }

    drawGizmos(ctx) {
        // Draw wheel positions and angles
        if (!this.showWheelDirection) return;

        const pos = this.gameObject.getWorldPosition();
        const angle = this.gameObject.angle * (Math.PI / 180);

        ctx.save();

        // Draw simplified wheel positions with current steering angle
        const wheelOffset = this.wheelBase * 0.3;
        const wheelAngleRad = (this.currentWheelAngle * Math.PI / 180);

        // Front wheels (steered) - color based on traction
        ctx.save();
        ctx.translate(0, -wheelOffset);
        ctx.rotate(wheelAngleRad);

        // Color wheels based on traction and drive type
        if (this.frontWheelDrive) {
            ctx.fillStyle = `hsla(${this.currentTraction * 120}, 100%, 50%, 0.8)`;
        } else {
            ctx.fillStyle = "rgba(255, 255, 0, 0.7)";
        }

        ctx.fillRect(-8, -4, 16, 8);

        // Show wheel spin on drive wheels
        if (this.frontWheelDrive && this.wheelSpinAmount > 0.2) {
            ctx.strokeStyle = "red";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(0, 0, 6, 0, Math.PI * 2);
            ctx.stroke();
        }

        ctx.restore();

        // Rear wheels (fixed)
        ctx.save();
        ctx.translate(0, wheelOffset);

        if (!this.frontWheelDrive) {
            // RWD - color based on traction
            ctx.fillStyle = `hsla(${this.currentTraction * 120}, 100%, 50%, 0.8)`;
        } else {
            ctx.fillStyle = "rgba(255, 255, 0, 0.5)";
        }

        ctx.fillRect(-8, -4, 16, 8);

        // Show wheel spin on drive wheels
        if (!this.frontWheelDrive && this.wheelSpinAmount > 0.2) {
            ctx.strokeStyle = "red";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(0, 0, 6, 0, Math.PI * 2);
            ctx.stroke();
        }

        // Show handbrake effect on rear wheels
        if (this.isHandbraking) {
            ctx.strokeStyle = "orange";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, Math.PI * 2);
            ctx.stroke();
        }

        ctx.restore();

        ctx.restore();
    }

    // Public methods for external control
    accelerate(force = 1) {
        this.targetThrottleInput = Math.max(0, Math.min(1, force));
        this.isAccelerating = true;
    }

    brake(force = 1) {
        this.targetThrottleInput = -Math.max(0, Math.min(1, force));
        this.isBraking = true;
    }

    steer(direction = 1) {
        this.targetSteeringInput = Math.max(-1, Math.min(1, direction));
        this.isTurning = true;
    }

    handbrake(enabled = true) {
        this.isHandbraking = enabled;
    }

    getCurrentSpeed() {
        return this.currentSpeed;
    }

    isMoving() {
        return this.currentSpeed !== 0;
    }

    getCurrentWheelAngle() {
        return this.currentWheelAngle;
    }

    getThrottleInput() {
        return this.throttleInput;
    }

    getDriftAngle() {
        return this.driftAngle;
    }

    getTraction() {
        return this.currentTraction;
    }

    getWheelSpinAmount() {
        return this.wheelSpinAmount;
    }

    toJSON() {
        return {
            ...super.toJSON(),
            playerControlled: this.playerControlled,
            maxSpeed: this.maxSpeed,
            acceleration: this.acceleration,
            brakeForce: this.brakeForce,
            decelerationRate: this.decelerationRate,
            reverseMaxSpeed: this.reverseMaxSpeed,
            maxTurnAngle: this.maxTurnAngle,
            turnMultiplier: this.turnMultiplier,
            wheelTurnSpeed: this.wheelTurnSpeed,
            wheelReturnSpeed: this.wheelReturnSpeed,
            dragCoefficient: this.dragCoefficient,
            lateralGrip: this.lateralGrip,
            minTurnSpeed: this.minTurnSpeed,
            wheelBase: this.wheelBase,
            frontWheelDrive: this.frontWheelDrive,
            differentialStrength: this.differentialStrength,
            antiRoll: this.antiRoll,
            handbrakeForce: this.handbrakeForce,
            driftThreshold: this.driftThreshold,
            tractionLoss: this.tractionLoss,
            powerOversteerStrength: this.powerOversteerStrength,
            frontGripAdvantage: this.frontGripAdvantage,
            driftRecoveryRate: this.driftRecoveryRate,
            velocityDriftFactor: this.velocityDriftFactor,
            tractionControlEnabled: this.tractionControlEnabled,
            tractionControlStrength: this.tractionControlStrength,
            absEnabled: this.absEnabled,
            absStrength: this.absStrength,
            showDebugInfo: this.showDebugInfo,
            showWheelDirection: this.showWheelDirection,
            showDriftInfo: this.showDriftInfo,
            upKey: this.upKey,
            downKey: this.downKey,
            leftKey: this.leftKey,
            rightKey: this.rightKey,
            handbrakeKey: this.handbrakeKey
        };
    }

    fromJSON(data) {
        super.fromJSON(data);

        if (!data) return;

        this.playerControlled = data.playerControlled !== undefined ? data.playerControlled : true;
        this.maxSpeed = data.maxSpeed || 300;
        this.acceleration = data.acceleration || 600;
        this.brakeForce = data.brakeForce || 800;
        this.decelerationRate = data.decelerationRate || 0.15;
        this.reverseMaxSpeed = data.reverseMaxSpeed || 150;
        this.maxTurnAngle = data.maxTurnAngle || 45;
        this.turnMultiplier = data.turnMultiplier || 1.0;
        this.wheelTurnSpeed = data.wheelTurnSpeed || 180;
        this.wheelReturnSpeed = data.wheelReturnSpeed || 120;
        this.dragCoefficient = data.dragCoefficient || 0.95;
        this.lateralGrip = data.lateralGrip || 0.85;
        this.minTurnSpeed = data.minTurnSpeed || 50;
        this.wheelBase = data.wheelBase || 60;
        this.frontWheelDrive = data.frontWheelDrive !== undefined ? data.frontWheelDrive : true;
        this.differentialStrength = data.differentialStrength || 0.8;
        this.antiRoll = data.antiRoll || 0.3;
        this.handbrakeForce = data.handbrakeForce || 0.3;
        this.driftThreshold = data.driftThreshold || 0.8;
        this.tractionLoss = data.tractionLoss || 0.4;
        this.powerOversteerStrength = data.powerOversteerStrength || 1.2;
        this.frontGripAdvantage = data.frontGripAdvantage || 0.15;
        this.driftRecoveryRate = data.driftRecoveryRate || 3.0;
        this.velocityDriftFactor = data.velocityDriftFactor || 0.7;
        this.tractionControlEnabled = data.tractionControlEnabled !== undefined ? data.tractionControlEnabled : true;
        this.tractionControlStrength = data.tractionControlStrength || 0.6;
        this.absEnabled = data.absEnabled !== undefined ? data.absEnabled : true;
        this.absStrength = data.absStrength || 0.8;
        this.showDebugInfo = data.showDebugInfo || false;
        this.showWheelDirection = data.showWheelDirection !== undefined ? data.showWheelDirection : true;
        this.showDriftInfo = data.showDriftInfo !== undefined ? data.showDriftInfo : true;
        this.upKey = data.upKey || "arrowup";
        this.downKey = data.downKey || "arrowdown";
        this.leftKey = data.leftKey || "arrowleft";
        this.rightKey = data.rightKey || "arrowright";
        this.handbrakeKey = data.handbrakeKey || " ";
    }
}

// Register the module
window.VehiclePhysics = VehiclePhysics;

// src/core/Modules/RoadCone.js
// Could not load src/core/Modules/RoadCone.js: Failed to load src/core/Modules/RoadCone.js: 404

// Car1.js
class Car1 extends Module {
    static namespace = "Drawing";
    static description = "Custom generated drawing module";
    static allowMultiple = false;
    static iconClass = "fas fa-paint-brush";
    static iconColor = "#64B5F6";

    constructor() {
        super("Car1");

        // Visual properties
        this.scale = 1;
        this.offsetX = 0;
        this.offsetY = 0;
        this.flipped = false;

        this.animationRanges = [
        {
                "name": "idle",
                "start": 0,
                "end": 4
        }
];
        this.currentAnimation = "idle";
        
        // Animation properties
        this.isAnimated = false;
        this.currentFrame = 0;
        this.animationSpeed = 1;
        this.isPlaying = true;
        this.frameTimer = 0;
        this.pingPong = false;
        this.playDirection = 1;
        this.totalFrames = 1;
        this.enableTweening = false;
        this.tweenType = "linear";

        this.preGenerateImage = false;
        this.generatedImage = null;
        this.imageGenerated = false;
        
        // Frame data
        this.frames = [
        [
                {
                        "type": "rectangle",
                        "startX": 224,
                        "startY": 208,
                        "endX": 576,
                        "endY": 384,
                        "fillColor": "#3b82f6",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 176,
                                "y": 208
                        },
                        "worldPosition": {
                                "x": 176,
                                "y": 208
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                },
                {
                        "type": "rectangle",
                        "startX": 304,
                        "startY": 240,
                        "endX": 496,
                        "endY": 352,
                        "fillColor": "#81abee",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": false,
                                "start": "#c8d9f3",
                                "end": "#ffffff",
                                "type": "linear",
                                "angle": 0
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 304,
                                "y": 240
                        },
                        "worldPosition": {
                                "x": 304,
                                "y": 240
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                },
                {
                        "type": "rectangle",
                        "startX": 496,
                        "startY": 240,
                        "endX": 528,
                        "endY": 352,
                        "fillColor": "#81abee",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#c8d9f3",
                                "end": "#ffffff",
                                "type": "linear",
                                "angle": 0
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 496,
                                "y": 240
                        },
                        "worldPosition": {
                                "x": 496,
                                "y": 240
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                },
                {
                        "type": "rectangle",
                        "startX": 256,
                        "startY": 240,
                        "endX": 304,
                        "endY": 352,
                        "fillColor": "#81abee",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#c8d9f3",
                                "end": "#ffffff",
                                "type": "linear",
                                "angle": 0
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 256,
                                "y": 240
                        },
                        "worldPosition": {
                                "x": 256,
                                "y": 240
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                },
                {
                        "type": "rectangle",
                        "startX": 560,
                        "startY": 224,
                        "endX": 576,
                        "endY": 256,
                        "fillColor": "#ebe9cb",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 560,
                                "y": 224
                        },
                        "worldPosition": {
                                "x": 560,
                                "y": 224
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                },
                {
                        "type": "rectangle",
                        "startX": 560,
                        "startY": 368,
                        "endX": 576,
                        "endY": 336,
                        "fillColor": "#ebe9cb",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 560,
                                "y": 368
                        },
                        "worldPosition": {
                                "x": 560,
                                "y": 368
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                },
                {
                        "type": "rectangle",
                        "startX": 224,
                        "startY": 224,
                        "endX": 240,
                        "endY": 256,
                        "fillColor": "#c08c8c",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 224,
                                "y": 224
                        },
                        "worldPosition": {
                                "x": 224,
                                "y": 224
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                },
                {
                        "type": "rectangle",
                        "startX": 224,
                        "startY": 336,
                        "endX": 240,
                        "endY": 368,
                        "fillColor": "#c08c8c",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 224,
                                "y": 336
                        },
                        "worldPosition": {
                                "x": 224,
                                "y": 336
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                }
        ]
];
        
        // Initialize current animation range
        this.currentAnimationRange = this.getCurrentAnimationRange();
        
        this.exposeProperties();
    }

    getCurrentAnimationRange() {
        return this.animationRanges.find(r => r.name === this.currentAnimation) || 
               { name: "default", start: 0, end: this.totalFrames - 1 };
    }

    exposeProperties() {
        this.exposeProperty("scale", "number", this.scale, {
            description: "Scale factor",
            onChange: (val) => { this.scale = val; }
        });
        
        this.exposeProperty("offsetX", "number", this.offsetX, {
            description: "X offset",
            onChange: (val) => { this.offsetX = val; }
        });
        
        this.exposeProperty("offsetY", "number", this.offsetY, {
            description: "Y offset", 
            onChange: (val) => { this.offsetY = val; }
        });
        
        this.exposeProperty("flipped", "boolean", this.flipped, {
            description: "Flip horizontally",
            onChange: (val) => { this.flipped = val; }
        });

        this.exposeProperty("preGenerateImage", "boolean", this.preGenerateImage, {
            description: "Pre-generate image for better performance",
            onChange: (val) => { 
                this.preGenerateImage = val; 
                if (val) {
                    this.generateImage();
                } else {
                    this.generatedImage = null;
                    this.imageGenerated = false;
                }
            }
        });

        if (this.isAnimated) {
            this.exposeProperty("currentAnimation", "enum", this.currentAnimation, {
                options: this.animationRanges.map(r => r.name),
                description: "Current animation",
                onChange: (val) => {
                    this.setAnimation(val);
                }
            });

            this.exposeProperty("animationSpeed", "number", this.animationSpeed, {
                description: "Animation speed",
                onChange: (val) => { this.animationSpeed = val; }
            });
            
            this.exposeProperty("enableTweening", "boolean", this.enableTweening, {
                description: "Enable tweening for smooth transitions",
                onChange: (val) => { this.enableTweening = val; }
            });

            this.exposeProperty("tweenType", "enum", this.tweenType, {
                options: ["linear", "ease-in", "ease-out", "ease-in-out"],
                description: "Tweening type",
                onChange: (val) => { this.tweenType = val; }
            });
            
            this.exposeProperty("isPlaying", "boolean", this.isPlaying, {
                description: "Is playing animation",
                onChange: (val) => { this.isPlaying = val }
            });
        }
    }

    style(style) {
        style.startGroup("Car1 Appearance", false, { 
            backgroundColor: 'rgba(59,130,246,0.1)',
            borderRadius: '6px',
            padding: '8px'
        });
        
        style.exposeProperty("scale", "number", this.scale, {
            min: 0.1,
            max: 5,
            step: 0.1,
            style: { label: "Scale", slider: true }
        });
        
        style.exposeProperty("offsetX", "number", this.offsetX, {
            min: -200,
            max: 200,
            style: { label: "Offset X", slider: true }
        });
        
        style.exposeProperty("offsetY", "number", this.offsetY, {
            min: -200,
            max: 200,
            style: { label: "Offset Y", slider: true }
        });
        
        style.exposeProperty("flipped", "boolean", this.flipped, {
            style: { label: "Flip Horizontally" }
        });

        style.exposeProperty("preGenerateImage", "boolean", this.preGenerateImage, {
            style: { label: "Pre-generate Image" }
        });
        
        if (this.isAnimated) {
            style.startGroup("Animation Controls", true);

            style.exposeProperty("currentAnimation", "enum", this.currentAnimation, {
                options: this.animationRanges.map(r => r.name),
                style: { label: "Animation" }
            });
            
            style.exposeProperty("animationSpeed", "number", this.animationSpeed, {
                min: 0.1,
                max: 5,
                step: 0.1,
                style: { label: "Speed", slider: true }
            });

            style.exposeProperty("enableTweening", "boolean", this.enableTweening, {
                style: { label: "Enable Tweening" }
            });

            style.exposeProperty("tweenType", "enum", this.tweenType, {
                options: ["linear", "ease-in", "ease-out", "ease-in-out"],
                style: { label: "Tween Type" }
            });
            
            style.exposeProperty("isPlaying", "boolean", this.isPlaying, {
                style: { label: "Playing" }
            });
            
            style.endGroup();
        }
        
        style.endGroup();
        style.addHelpText("Generated drawing module with animation support");
        style.addHelpText(`Animation List: 
${this.animationRanges.map(r => `${r.name} (frames ${r.start}-${r.end})`).join(", ")}`);
    }

    // Public API Methods
    playAnimation(name) {
        const range = this.animationRanges.find(r => r.name === name);
        if (range) {
            this.currentAnimation = name;
            this.currentAnimationRange = range;
            this.currentFrame = range.start;
            this.isPlaying = true;
            this.frameTimer = 0;
            this.playDirection = 1;
        }
    }

    setAnimation(name) {
        const range = this.animationRanges.find(r => r.name === name);
        if (range) {
            this.currentAnimation = name;
            this.currentAnimationRange = range;
            this.currentFrame = range.start;
            this.isPlaying = false;
            this.frameTimer = 0;
            this.playDirection = 1;
        }
    }

    play() {
        this.isPlaying = true;
    }

    pause() {
        this.isPlaying = false;
    }

    stop() {
        this.isPlaying = false;
        const range = this.getCurrentAnimationRange();
        this.currentFrame = range.start;
        this.frameTimer = 0;
        this.playDirection = 1;
    }

    setFrame(frameIndex) {
        const range = this.getCurrentAnimationRange();
        if (frameIndex >= range.start && frameIndex <= range.end) {
            this.currentFrame = frameIndex;
        }
    }

    setSpeed(speed) {
        this.animationSpeed = Math.max(0.1, speed);
        return this;
    }

    getCurrentFrame() {
        return this.currentFrame;
    }

    getTotalFrames() {
        return this.totalFrames;
    }

    getAnimationFrameCount() {
        const range = this.getCurrentAnimationRange();
        return range.end - range.start + 1;
    }

    start() {
        if (this.preGenerateImage) {
            this.generateImage();
        }
        // Initialize to first frame of current animation
        const range = this.getCurrentAnimationRange();
        this.currentFrame = range.start;
    }

    loop(deltaTime) {
        if (!this.isAnimated || !this.isPlaying) return;

        const range = this.getCurrentAnimationRange();
        const frameCount = range.end - range.start + 1;

        // If only one frame in range, nothing to animate
        if (frameCount <= 1) {
            this.currentFrame = range.start;
            return;
        }

        this.frameTimer += deltaTime * this.animationSpeed;

        // Use frame duration of 0.1 seconds (10 FPS)
        const frameDuration = 0.1;
        
        if (this.frameTimer >= frameDuration) {
            this.frameTimer = 0;

            if (this.pingPong) {
                // Ping pong animation within the range
                this.currentFrame += this.playDirection;
                
                if (this.currentFrame >= range.end) {
                    this.playDirection = -1;
                    this.currentFrame = range.end;
                } else if (this.currentFrame <= range.start) {
                    this.playDirection = 1;
                    this.currentFrame = range.start;
                }
            } else {
                // Linear loop animation within the range
                this.currentFrame++;
                if (this.currentFrame > range.end) {
                    this.currentFrame = range.start;
                }
            }
        }
    }

    draw(ctx) {
        if (this.preGenerateImage && this.generatedImage && this.imageGenerated) {
            ctx.save();
            ctx.scale(this.scale, this.scale);
            if (this.flipped) {
                ctx.scale(-1, 1);
            }
            ctx.translate(this.offsetX, this.offsetY);
            
            ctx.drawImage(this.generatedImage, -this.generatedImage.width/2, -this.generatedImage.height/2);
            ctx.restore();
            return;
        }

        ctx.save();
        
        // Apply transformations
        ctx.scale(this.scale, this.scale);
        if (this.flipped) {
            ctx.scale(-1, 1);
        }
        ctx.translate(this.offsetX, this.offsetY);

        // Calculate the center point of all shapes to use as origin
        const shapeCenter = this.calculateShapesCenterPoint();
        
        // Translate so shapes center around 0,0
        ctx.translate(-shapeCenter.centerX, -shapeCenter.centerY);

        // Get current frame shapes
        let shapes;
        if (this.enableTweening && this.totalFrames > 1 && this.isPlaying) {
            shapes = this.getTweenedShapes();
        } else {
            const frameIndex = Math.floor(this.currentFrame);
            shapes = this.frames[frameIndex] || [];
        }
        shapes = shapes.filter(shape => shape && shape.visible !== false);

        shapes.forEach((shape, index) => {
            this.drawShape(ctx, shape);
        });

        ctx.restore();
    }

    getTweenedShapes() {
        const range = this.getCurrentAnimationRange();
        
        // Ensure current frame is within animation range for tweening
        let currentFrame = Math.floor(this.currentFrame);
        let nextFrame = currentFrame + 1;
        
        // Handle range boundaries
        if (nextFrame > range.end) {
            if (this.pingPong && this.playDirection === -1) {
                nextFrame = currentFrame - 1;
            } else {
                nextFrame = range.start; // Loop back to start
            }
        }
        
        // Ensure frames are valid
        currentFrame = Math.max(range.start, Math.min(range.end, currentFrame));
        nextFrame = Math.max(range.start, Math.min(range.end, nextFrame));
        
        const t = this.currentFrame - Math.floor(this.currentFrame);

        const currentShapes = this.frames[currentFrame] || [];
        const nextShapes = this.frames[nextFrame] || [];

        return this.interpolateShapes(currentShapes, nextShapes, t);
    }

    interpolateShapes(shapes1, shapes2, t) {
        const result = [];
        const maxLength = Math.max(shapes1.length, shapes2.length);

        for (let i = 0; i < maxLength; i++) {
            const shape1 = shapes1[i];
            const shape2 = shapes2[i];

            if (shape1 && shape2 && shape1.type === shape2.type) {
                result.push(this.interpolateShape(shape1, shape2, t));
            } else if (shape1) {
                result.push({ ...shape1 });
            } else if (shape2) {
                result.push({ ...shape2 });
            }
        }

        return result;
    }

    interpolateShape(shape1, shape2, t) {
        const eased = this.applyEasing(t, this.tweenType);
        const interpolated = { ...shape1 };

        // Interpolate basic properties
        if (shape1.type === 'spline') {
            interpolated.points = [];
            const maxPoints = Math.max(shape1.points.length, shape2.points.length);
            
            for (let i = 0; i < maxPoints; i++) {
                const p1 = shape1.points[i] || shape1.points[shape1.points.length - 1];
                const p2 = shape2.points[i] || shape2.points[shape2.points.length - 1];
                
                interpolated.points.push({
                    x: p1.x + (p2.x - p1.x) * eased,
                    y: p1.y + (p2.y - p1.y) * eased
                });
            }
        } else {
            interpolated.startX = shape1.startX + (shape2.startX - shape1.startX) * eased;
            interpolated.startY = shape1.startY + (shape2.startY - shape1.startY) * eased;
            interpolated.endX = shape1.endX + (shape2.endX - shape1.endX) * eased;
            interpolated.endY = shape1.endY + (shape2.endY - shape1.endY) * eased;
        }

        // Interpolate transform properties
        interpolated.rotation = (shape1.rotation || 0) + ((shape2.rotation || 0) - (shape1.rotation || 0)) * eased;
        interpolated.scaleX = (shape1.scaleX || 1) + ((shape2.scaleX || 1) - (shape1.scaleX || 1)) * eased;
        interpolated.scaleY = (shape1.scaleY || 1) + ((shape2.scaleY || 1) - (shape1.scaleY || 1)) * eased;

        return interpolated;
    }

    applyEasing(t, type) {
        switch (type) {
            case 'ease-in': return t * t;
            case 'ease-out': return 1 - (1 - t) * (1 - t);
            case 'ease-in-out': return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
            case 'bounce': return this.bounceEase(t);
            default: return t; // linear
        }
    }

    bounceEase(t) {
        const n1 = 7.5625;
        const d1 = 2.75;

        if (t < 1 / d1) {
            return n1 * t * t;
        } else if (t < 2 / d1) {
            return n1 * (t -= 1.5 / d1) * t + 0.75;
        } else if (t < 2.5 / d1) {
            return n1 * (t -= 2.25 / d1) * t + 0.9375;
        } else {
            return n1 * (t -= 2.625 / d1) * t + 0.984375;
        }
    }

    generateImage() {
        const canvas = document.createElement('canvas');
        canvas.width = 800;
        canvas.height = 600;
        const ctx = canvas.getContext('2d');
        
        // Calculate center point and translate
        const shapeCenter = this.calculateShapesCenterPoint();
        ctx.translate(canvas.width/2 - shapeCenter.centerX, canvas.height/2 - shapeCenter.centerY);
        
        // Draw all frames composited (or just frame 0 for static)
        const shapes = this.frames[0] || [];
        shapes.forEach((shape) => {
            this.drawShape(ctx, shape);
        });
        
        this.generatedImage = new Image();
        this.generatedImage.src = canvas.toDataURL();
        this.imageGenerated = true;
    }

    calculateShapesCenterPoint() {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        let hasShapes = false;

        this.frames.forEach(frame => {
            if (!frame) return;
            frame.forEach(shape => {
                hasShapes = true;
                if (shape.type === 'spline') {
                    shape.points.forEach(point => {
                        minX = Math.min(minX, point.x);
                        minY = Math.min(minY, point.y);
                        maxX = Math.max(maxX, point.x);
                        maxY = Math.max(maxY, point.y);
                    });
                } else if (shape.type === 'circle') {
                    const radius = Math.sqrt((shape.endX - shape.startX) ** 2 + (shape.endY - shape.startY) ** 2);
                    minX = Math.min(minX, shape.startX - radius);
                    minY = Math.min(minY, shape.startY - radius);
                    maxX = Math.max(maxX, shape.startX + radius);
                    maxY = Math.max(maxY, shape.startY + radius);
                } else {
                    minX = Math.min(minX, shape.startX, shape.endX);
                    minY = Math.min(minY, shape.startY, shape.endY);
                    maxX = Math.max(maxX, shape.startX, shape.endX);
                    maxY = Math.max(maxY, shape.startY, shape.endY);
                }
            });
        });

        if (!hasShapes) return { centerX: 0, centerY: 0 };
        
        return {
            centerX: (minX + maxX) / 2,
            centerY: (minY + maxY) / 2
        };
    }

    createGradient(shape, ctx) {
        if (!shape.gradient || !shape.gradient.enabled) return shape.fillColor;
        
        let gradient;
        const bounds = this.getShapeBounds(shape);
        
        if (shape.gradient.type === 'radial') {
            const centerX = bounds.x + bounds.width / 2;
            const centerY = bounds.y + bounds.height / 2;
            const radius = Math.max(bounds.width, bounds.height) / 2;
            gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
        } else {
            // Linear gradient
            const angle = (shape.gradient.angle || 0) * Math.PI / 180;
            const x1 = bounds.x + bounds.width / 2 - Math.cos(angle) * bounds.width / 2;
            const y1 = bounds.y + bounds.height / 2 - Math.sin(angle) * bounds.height / 2;
            const x2 = bounds.x + bounds.width / 2 + Math.cos(angle) * bounds.width / 2;
            const y2 = bounds.y + bounds.height / 2 + Math.sin(angle) * bounds.height / 2;
            gradient = ctx.createLinearGradient(x1, y1, x2, y2);
        }
        
        gradient.addColorStop(0, shape.gradient.start);
        gradient.addColorStop(1, shape.gradient.end);
        
        return gradient;
    }

    getShapeBounds(shape) {
        if (shape.type === 'spline') {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            shape.points.forEach(pt => {
                minX = Math.min(minX, pt.x);
                minY = Math.min(minY, pt.y);
                maxX = Math.max(maxX, pt.x);
                maxY = Math.max(maxY, pt.y);
            });
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        } else if (shape.type === 'circle') {
            const radius = Math.sqrt((shape.endX - shape.startX) ** 2 + (shape.endY - shape.startY) ** 2);
            return {
                x: shape.startX - radius,
                y: shape.startY - radius,
                width: radius * 2,
                height: radius * 2
            };
        } else {
            const minX = Math.min(shape.startX, shape.endX);
            const minY = Math.min(shape.startY, shape.endY);
            const maxX = Math.max(shape.startX, shape.endX);
            const maxY = Math.max(shape.startY, shape.endY);
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }
    }

    drawShape(ctx, shape) {
        if (!shape.visible) return;
        
        ctx.save();
        
        // Apply transformations
        if (shape.rotation || shape.scaleX !== 1 || shape.scaleY !== 1) {
            const bounds = this.getShapeBounds(shape);
            const centerX = bounds.x + bounds.width / 2;
            const centerY = bounds.y + bounds.height / 2;
            
            ctx.translate(centerX, centerY);
            ctx.rotate((shape.rotation || 0) * Math.PI / 180);
            ctx.scale(shape.scaleX || 1, shape.scaleY || 1);
            ctx.translate(-centerX, -centerY);
        }
        
        // Set up colors/gradients
        ctx.fillStyle = shape.gradient ? this.createGradient(shape, ctx) : shape.fillColor;
        ctx.strokeStyle = shape.strokeColor;
        ctx.lineWidth = shape.strokeWidth;
        ctx.setLineDash([]);

        switch (shape.type) {
            case 'rectangle':
                this.drawRectangle(ctx, shape);
                break;
            case 'circle':
                this.drawCircle(ctx, shape);
                break;
            case 'triangle':
                this.drawTriangle(ctx, shape);
                break;
            case 'line':
                this.drawLine(ctx, shape);
                break;
            case 'spline':
                this.drawSpline(ctx, shape);
                break;
        }

        ctx.restore();
    }

    drawRectangle(ctx, shape) {
        const width = shape.endX - shape.startX;
        const height = shape.endY - shape.startY;
        if (shape.fill) ctx.fillRect(shape.startX, shape.startY, width, height);
        if (shape.stroke) ctx.strokeRect(shape.startX, shape.startY, width, height);
    }

    drawCircle(ctx, shape) {
        const radius = Math.sqrt((shape.endX - shape.startX) ** 2 + (shape.endY - shape.startY) ** 2);
        ctx.beginPath();
        ctx.arc(shape.startX, shape.startY, radius, 0, Math.PI * 2);
        if (shape.fill) ctx.fill();
        if (shape.stroke) ctx.stroke();
    }

    drawTriangle(ctx, shape) {
        const midX = (shape.startX + shape.endX) / 2;
        ctx.beginPath();
        ctx.moveTo(midX, shape.startY);
        ctx.lineTo(shape.startX, shape.endY);
        ctx.lineTo(shape.endX, shape.endY);
        ctx.closePath();
        if (shape.fill) ctx.fill();
        if (shape.stroke) ctx.stroke();
    }

    drawLine(ctx, shape) {
        ctx.beginPath();
        ctx.moveTo(shape.startX, shape.startY);
        ctx.lineTo(shape.endX, shape.endY);
        ctx.stroke();
    }

    drawSpline(ctx, shape) {
        if (shape.points.length < 2) return;
        ctx.beginPath();
        if (shape.points.length === 2) {
            ctx.moveTo(shape.points[0].x, shape.points[0].y);
            ctx.lineTo(shape.points[1].x, shape.points[1].y);
        } else {
            // Use the original points without offset
            this.drawSmoothSpline(shape.points, shape.curveIntensity, shape.closed, ctx);
        }
        if (shape.closed) ctx.closePath();
        if (shape.fill && shape.closed) ctx.fill();
        if (shape.stroke) ctx.stroke();
    }

    // Update drawSmoothSpline to accept ctx
    drawSmoothSpline(points, intensity, closed, ctx = this.ctx) {
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            const prev = points[i - 1];
            const curr = points[i];
            const next = points[(i + 1) % points.length];
            const cp1x = prev.x + (curr.x - prev.x) * intensity;
            const cp1y = prev.y + (curr.y - prev.y) * intensity;
            const cp2x = curr.x - (next.x - prev.x) * intensity * 0.2;
            const cp2y = curr.y - (next.y - prev.y) * intensity * 0.2;
            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, curr.x, curr.y);
        }
    }

    toJSON() {
        return {
            ...super.toJSON(),
            scale: this.scale,
            offsetX: this.offsetX,
            offsetY: this.offsetY,
            flipped: this.flipped,
            animationSpeed: this.animationSpeed,
            isPlaying: this.isPlaying,
            currentFrame: this.currentFrame,
            currentAnimation: this.currentAnimation
        };
    }

    fromJSON(data) {
        super.fromJSON(data);
        if (!data) return;

        this.scale = data.scale || 1;
        this.offsetX = data.offsetX || 0;
        this.offsetY = data.offsetY || 0;
        this.flipped = data.flipped || false;
        this.animationSpeed = data.animationSpeed || 1;
        this.isPlaying = data.isPlaying || false;
        this.currentFrame = data.currentFrame || 0;
        this.currentAnimation = data.currentAnimation || "idle";
        
        // Update animation range after loading
        this.currentAnimationRange = this.getCurrentAnimationRange();
    }
}

window.Car1 = Car1;

// RoadCone.js
class RoadCone extends Module {
    static namespace = "Drawing";
    static description = "Custom generated drawing module";
    static allowMultiple = false;
    static iconClass = "fas fa-paint-brush";
    static iconColor = "#64B5F6";

    constructor() {
        super("RoadCone");

        // Visual properties
        this.scale = 1;
        this.offsetX = 0;
        this.offsetY = 0;
        this.flipped = false;

        this.animationRanges = [
        {
                "name": "idle",
                "start": 0,
                "end": 4
        }
];
        this.currentAnimation = "idle";
        
        // Animation properties
        this.isAnimated = false;
        this.currentFrame = 0;
        this.animationSpeed = 1;
        this.isPlaying = true;
        this.frameTimer = 0;
        this.pingPong = false;
        this.playDirection = 1;
        this.totalFrames = 1;
        this.enableTweening = false;
        this.tweenType = "linear";

        this.preGenerateImage = false;
        this.generatedImage = null;
        this.imageGenerated = false;
        
        // Frame data
        this.frames = [
        [
                {
                        "type": "rectangle",
                        "startX": 272,
                        "startY": 176,
                        "endX": 528,
                        "endY": 432,
                        "fillColor": "#3b82f6",
                        "strokeColor": "#000000",
                        "strokeWidth": 4,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#b4590e",
                                "end": "#9f4204",
                                "type": "linear",
                                "angle": 0
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 272,
                                "y": 176
                        },
                        "worldPosition": {
                                "x": 272,
                                "y": 176
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                },
                {
                        "type": "circle",
                        "startX": 400,
                        "startY": 304,
                        "endX": 448,
                        "endY": 400,
                        "fillColor": "#3b82f6",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#e37316",
                                "end": "#b55608",
                                "type": "linear",
                                "angle": 0
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 400,
                                "y": 304
                        },
                        "worldPosition": {
                                "x": 400,
                                "y": 304
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                },
                {
                        "type": "circle",
                        "startX": 400,
                        "startY": 304,
                        "endX": 448,
                        "endY": 352,
                        "fillColor": "#3b82f6",
                        "strokeColor": "#ffffff",
                        "strokeWidth": 5,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#ef7715",
                                "end": "#df5a01",
                                "type": "linear",
                                "angle": 0
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 400,
                                "y": 304
                        },
                        "worldPosition": {
                                "x": 400,
                                "y": 304
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                },
                {
                        "type": "circle",
                        "startX": 400,
                        "startY": 304,
                        "endX": 416,
                        "endY": 320,
                        "fillColor": "#3b82f6",
                        "strokeColor": "#ffffff",
                        "strokeWidth": 5,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#ea8634",
                                "end": "#f3ad35",
                                "type": "linear",
                                "angle": 0
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 400,
                                "y": 304
                        },
                        "worldPosition": {
                                "x": 400,
                                "y": 304
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                }
        ]
];
        
        // Initialize current animation range
        this.currentAnimationRange = this.getCurrentAnimationRange();
        
        this.exposeProperties();
    }

    getCurrentAnimationRange() {
        return this.animationRanges.find(r => r.name === this.currentAnimation) || 
               { name: "default", start: 0, end: this.totalFrames - 1 };
    }

    exposeProperties() {
        this.exposeProperty("scale", "number", this.scale, {
            description: "Scale factor",
            onChange: (val) => { this.scale = val; }
        });
        
        this.exposeProperty("offsetX", "number", this.offsetX, {
            description: "X offset",
            onChange: (val) => { this.offsetX = val; }
        });
        
        this.exposeProperty("offsetY", "number", this.offsetY, {
            description: "Y offset", 
            onChange: (val) => { this.offsetY = val; }
        });
        
        this.exposeProperty("flipped", "boolean", this.flipped, {
            description: "Flip horizontally",
            onChange: (val) => { this.flipped = val; }
        });

        this.exposeProperty("preGenerateImage", "boolean", this.preGenerateImage, {
            description: "Pre-generate image for better performance",
            onChange: (val) => { 
                this.preGenerateImage = val; 
                if (val) {
                    this.generateImage();
                } else {
                    this.generatedImage = null;
                    this.imageGenerated = false;
                }
            }
        });

        if (this.isAnimated) {
            this.exposeProperty("currentAnimation", "enum", this.currentAnimation, {
                options: this.animationRanges.map(r => r.name),
                description: "Current animation",
                onChange: (val) => {
                    this.setAnimation(val);
                }
            });

            this.exposeProperty("animationSpeed", "number", this.animationSpeed, {
                description: "Animation speed",
                onChange: (val) => { this.animationSpeed = val; }
            });
            
            this.exposeProperty("enableTweening", "boolean", this.enableTweening, {
                description: "Enable tweening for smooth transitions",
                onChange: (val) => { this.enableTweening = val; }
            });

            this.exposeProperty("tweenType", "enum", this.tweenType, {
                options: ["linear", "ease-in", "ease-out", "ease-in-out"],
                description: "Tweening type",
                onChange: (val) => { this.tweenType = val; }
            });
            
            this.exposeProperty("isPlaying", "boolean", this.isPlaying, {
                description: "Is playing animation",
                onChange: (val) => { this.isPlaying = val }
            });
        }
    }

    style(style) {
        style.startGroup("RoadCone Appearance", false, { 
            backgroundColor: 'rgba(59,130,246,0.1)',
            borderRadius: '6px',
            padding: '8px'
        });
        
        style.exposeProperty("scale", "number", this.scale, {
            min: 0.1,
            max: 5,
            step: 0.1,
            style: { label: "Scale", slider: true }
        });
        
        style.exposeProperty("offsetX", "number", this.offsetX, {
            min: -200,
            max: 200,
            style: { label: "Offset X", slider: true }
        });
        
        style.exposeProperty("offsetY", "number", this.offsetY, {
            min: -200,
            max: 200,
            style: { label: "Offset Y", slider: true }
        });
        
        style.exposeProperty("flipped", "boolean", this.flipped, {
            style: { label: "Flip Horizontally" }
        });

        style.exposeProperty("preGenerateImage", "boolean", this.preGenerateImage, {
            style: { label: "Pre-generate Image" }
        });
        
        if (this.isAnimated) {
            style.startGroup("Animation Controls", true);

            style.exposeProperty("currentAnimation", "enum", this.currentAnimation, {
                options: this.animationRanges.map(r => r.name),
                style: { label: "Animation" }
            });
            
            style.exposeProperty("animationSpeed", "number", this.animationSpeed, {
                min: 0.1,
                max: 5,
                step: 0.1,
                style: { label: "Speed", slider: true }
            });

            style.exposeProperty("enableTweening", "boolean", this.enableTweening, {
                style: { label: "Enable Tweening" }
            });

            style.exposeProperty("tweenType", "enum", this.tweenType, {
                options: ["linear", "ease-in", "ease-out", "ease-in-out"],
                style: { label: "Tween Type" }
            });
            
            style.exposeProperty("isPlaying", "boolean", this.isPlaying, {
                style: { label: "Playing" }
            });
            
            style.endGroup();
        }
        
        style.endGroup();
        style.addHelpText("Generated drawing module with animation support");
        style.addHelpText(`Animation List: 
${this.animationRanges.map(r => `${r.name} (frames ${r.start}-${r.end})`).join(", ")}`);
    }

    // Public API Methods
    playAnimation(name) {
        const range = this.animationRanges.find(r => r.name === name);
        if (range) {
            this.currentAnimation = name;
            this.currentAnimationRange = range;
            this.currentFrame = range.start;
            this.isPlaying = true;
            this.frameTimer = 0;
            this.playDirection = 1;
        }
    }

    setAnimation(name) {
        const range = this.animationRanges.find(r => r.name === name);
        if (range) {
            this.currentAnimation = name;
            this.currentAnimationRange = range;
            this.currentFrame = range.start;
            this.isPlaying = false;
            this.frameTimer = 0;
            this.playDirection = 1;
        }
    }

    play() {
        this.isPlaying = true;
    }

    pause() {
        this.isPlaying = false;
    }

    stop() {
        this.isPlaying = false;
        const range = this.getCurrentAnimationRange();
        this.currentFrame = range.start;
        this.frameTimer = 0;
        this.playDirection = 1;
    }

    setFrame(frameIndex) {
        const range = this.getCurrentAnimationRange();
        if (frameIndex >= range.start && frameIndex <= range.end) {
            this.currentFrame = frameIndex;
        }
    }

    setSpeed(speed) {
        this.animationSpeed = Math.max(0.1, speed);
        return this;
    }

    getCurrentFrame() {
        return this.currentFrame;
    }

    getTotalFrames() {
        return this.totalFrames;
    }

    getAnimationFrameCount() {
        const range = this.getCurrentAnimationRange();
        return range.end - range.start + 1;
    }

    start() {
        if (this.preGenerateImage) {
            this.generateImage();
        }
        // Initialize to first frame of current animation
        const range = this.getCurrentAnimationRange();
        this.currentFrame = range.start;
    }

    loop(deltaTime) {
        if (!this.isAnimated || !this.isPlaying) return;

        const range = this.getCurrentAnimationRange();
        const frameCount = range.end - range.start + 1;

        // If only one frame in range, nothing to animate
        if (frameCount <= 1) {
            this.currentFrame = range.start;
            return;
        }

        this.frameTimer += deltaTime * this.animationSpeed;

        // Use frame duration of 0.1 seconds (10 FPS)
        const frameDuration = 0.1;
        
        if (this.frameTimer >= frameDuration) {
            this.frameTimer = 0;

            if (this.pingPong) {
                // Ping pong animation within the range
                this.currentFrame += this.playDirection;
                
                if (this.currentFrame >= range.end) {
                    this.playDirection = -1;
                    this.currentFrame = range.end;
                } else if (this.currentFrame <= range.start) {
                    this.playDirection = 1;
                    this.currentFrame = range.start;
                }
            } else {
                // Linear loop animation within the range
                this.currentFrame++;
                if (this.currentFrame > range.end) {
                    this.currentFrame = range.start;
                }
            }
        }
    }

    draw(ctx) {
        if (this.preGenerateImage && this.generatedImage && this.imageGenerated) {
            ctx.save();
            ctx.scale(this.scale, this.scale);
            if (this.flipped) {
                ctx.scale(-1, 1);
            }
            ctx.translate(this.offsetX, this.offsetY);
            
            ctx.drawImage(this.generatedImage, -this.generatedImage.width/2, -this.generatedImage.height/2);
            ctx.restore();
            return;
        }

        ctx.save();
        
        // Apply transformations
        ctx.scale(this.scale, this.scale);
        if (this.flipped) {
            ctx.scale(-1, 1);
        }
        ctx.translate(this.offsetX, this.offsetY);

        // Calculate the center point of all shapes to use as origin
        const shapeCenter = this.calculateShapesCenterPoint();
        
        // Translate so shapes center around 0,0
        ctx.translate(-shapeCenter.centerX, -shapeCenter.centerY);

        // Get current frame shapes
        let shapes;
        if (this.enableTweening && this.totalFrames > 1 && this.isPlaying) {
            shapes = this.getTweenedShapes();
        } else {
            const frameIndex = Math.floor(this.currentFrame);
            shapes = this.frames[frameIndex] || [];
        }
        shapes = shapes.filter(shape => shape && shape.visible !== false);

        shapes.forEach((shape, index) => {
            this.drawShape(ctx, shape);
        });

        ctx.restore();
    }

    getTweenedShapes() {
        const range = this.getCurrentAnimationRange();
        
        // Ensure current frame is within animation range for tweening
        let currentFrame = Math.floor(this.currentFrame);
        let nextFrame = currentFrame + 1;
        
        // Handle range boundaries
        if (nextFrame > range.end) {
            if (this.pingPong && this.playDirection === -1) {
                nextFrame = currentFrame - 1;
            } else {
                nextFrame = range.start; // Loop back to start
            }
        }
        
        // Ensure frames are valid
        currentFrame = Math.max(range.start, Math.min(range.end, currentFrame));
        nextFrame = Math.max(range.start, Math.min(range.end, nextFrame));
        
        const t = this.currentFrame - Math.floor(this.currentFrame);

        const currentShapes = this.frames[currentFrame] || [];
        const nextShapes = this.frames[nextFrame] || [];

        return this.interpolateShapes(currentShapes, nextShapes, t);
    }

    interpolateShapes(shapes1, shapes2, t) {
        const result = [];
        const maxLength = Math.max(shapes1.length, shapes2.length);

        for (let i = 0; i < maxLength; i++) {
            const shape1 = shapes1[i];
            const shape2 = shapes2[i];

            if (shape1 && shape2 && shape1.type === shape2.type) {
                result.push(this.interpolateShape(shape1, shape2, t));
            } else if (shape1) {
                result.push({ ...shape1 });
            } else if (shape2) {
                result.push({ ...shape2 });
            }
        }

        return result;
    }

    interpolateShape(shape1, shape2, t) {
        const eased = this.applyEasing(t, this.tweenType);
        const interpolated = { ...shape1 };

        // Interpolate basic properties
        if (shape1.type === 'spline') {
            interpolated.points = [];
            const maxPoints = Math.max(shape1.points.length, shape2.points.length);
            
            for (let i = 0; i < maxPoints; i++) {
                const p1 = shape1.points[i] || shape1.points[shape1.points.length - 1];
                const p2 = shape2.points[i] || shape2.points[shape2.points.length - 1];
                
                interpolated.points.push({
                    x: p1.x + (p2.x - p1.x) * eased,
                    y: p1.y + (p2.y - p1.y) * eased
                });
            }
        } else {
            interpolated.startX = shape1.startX + (shape2.startX - shape1.startX) * eased;
            interpolated.startY = shape1.startY + (shape2.startY - shape1.startY) * eased;
            interpolated.endX = shape1.endX + (shape2.endX - shape1.endX) * eased;
            interpolated.endY = shape1.endY + (shape2.endY - shape1.endY) * eased;
        }

        // Interpolate transform properties
        interpolated.rotation = (shape1.rotation || 0) + ((shape2.rotation || 0) - (shape1.rotation || 0)) * eased;
        interpolated.scaleX = (shape1.scaleX || 1) + ((shape2.scaleX || 1) - (shape1.scaleX || 1)) * eased;
        interpolated.scaleY = (shape1.scaleY || 1) + ((shape2.scaleY || 1) - (shape1.scaleY || 1)) * eased;

        return interpolated;
    }

    applyEasing(t, type) {
        switch (type) {
            case 'ease-in': return t * t;
            case 'ease-out': return 1 - (1 - t) * (1 - t);
            case 'ease-in-out': return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
            case 'bounce': return this.bounceEase(t);
            default: return t; // linear
        }
    }

    bounceEase(t) {
        const n1 = 7.5625;
        const d1 = 2.75;

        if (t < 1 / d1) {
            return n1 * t * t;
        } else if (t < 2 / d1) {
            return n1 * (t -= 1.5 / d1) * t + 0.75;
        } else if (t < 2.5 / d1) {
            return n1 * (t -= 2.25 / d1) * t + 0.9375;
        } else {
            return n1 * (t -= 2.625 / d1) * t + 0.984375;
        }
    }

    generateImage() {
        const canvas = document.createElement('canvas');
        canvas.width = 800;
        canvas.height = 600;
        const ctx = canvas.getContext('2d');
        
        // Calculate center point and translate
        const shapeCenter = this.calculateShapesCenterPoint();
        ctx.translate(canvas.width/2 - shapeCenter.centerX, canvas.height/2 - shapeCenter.centerY);
        
        // Draw all frames composited (or just frame 0 for static)
        const shapes = this.frames[0] || [];
        shapes.forEach((shape) => {
            this.drawShape(ctx, shape);
        });
        
        this.generatedImage = new Image();
        this.generatedImage.src = canvas.toDataURL();
        this.imageGenerated = true;
    }

    calculateShapesCenterPoint() {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        let hasShapes = false;

        this.frames.forEach(frame => {
            if (!frame) return;
            frame.forEach(shape => {
                hasShapes = true;
                if (shape.type === 'spline') {
                    shape.points.forEach(point => {
                        minX = Math.min(minX, point.x);
                        minY = Math.min(minY, point.y);
                        maxX = Math.max(maxX, point.x);
                        maxY = Math.max(maxY, point.y);
                    });
                } else if (shape.type === 'circle') {
                    const radius = Math.sqrt((shape.endX - shape.startX) ** 2 + (shape.endY - shape.startY) ** 2);
                    minX = Math.min(minX, shape.startX - radius);
                    minY = Math.min(minY, shape.startY - radius);
                    maxX = Math.max(maxX, shape.startX + radius);
                    maxY = Math.max(maxY, shape.startY + radius);
                } else {
                    minX = Math.min(minX, shape.startX, shape.endX);
                    minY = Math.min(minY, shape.startY, shape.endY);
                    maxX = Math.max(maxX, shape.startX, shape.endX);
                    maxY = Math.max(maxY, shape.startY, shape.endY);
                }
            });
        });

        if (!hasShapes) return { centerX: 0, centerY: 0 };
        
        return {
            centerX: (minX + maxX) / 2,
            centerY: (minY + maxY) / 2
        };
    }

    createGradient(shape, ctx) {
        if (!shape.gradient || !shape.gradient.enabled) return shape.fillColor;
        
        let gradient;
        const bounds = this.getShapeBounds(shape);
        
        if (shape.gradient.type === 'radial') {
            const centerX = bounds.x + bounds.width / 2;
            const centerY = bounds.y + bounds.height / 2;
            const radius = Math.max(bounds.width, bounds.height) / 2;
            gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
        } else {
            // Linear gradient
            const angle = (shape.gradient.angle || 0) * Math.PI / 180;
            const x1 = bounds.x + bounds.width / 2 - Math.cos(angle) * bounds.width / 2;
            const y1 = bounds.y + bounds.height / 2 - Math.sin(angle) * bounds.height / 2;
            const x2 = bounds.x + bounds.width / 2 + Math.cos(angle) * bounds.width / 2;
            const y2 = bounds.y + bounds.height / 2 + Math.sin(angle) * bounds.height / 2;
            gradient = ctx.createLinearGradient(x1, y1, x2, y2);
        }
        
        gradient.addColorStop(0, shape.gradient.start);
        gradient.addColorStop(1, shape.gradient.end);
        
        return gradient;
    }

    getShapeBounds(shape) {
        if (shape.type === 'spline') {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            shape.points.forEach(pt => {
                minX = Math.min(minX, pt.x);
                minY = Math.min(minY, pt.y);
                maxX = Math.max(maxX, pt.x);
                maxY = Math.max(maxY, pt.y);
            });
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        } else if (shape.type === 'circle') {
            const radius = Math.sqrt((shape.endX - shape.startX) ** 2 + (shape.endY - shape.startY) ** 2);
            return {
                x: shape.startX - radius,
                y: shape.startY - radius,
                width: radius * 2,
                height: radius * 2
            };
        } else {
            const minX = Math.min(shape.startX, shape.endX);
            const minY = Math.min(shape.startY, shape.endY);
            const maxX = Math.max(shape.startX, shape.endX);
            const maxY = Math.max(shape.startY, shape.endY);
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }
    }

    drawShape(ctx, shape) {
        if (!shape.visible) return;
        
        ctx.save();
        
        // Apply transformations
        if (shape.rotation || shape.scaleX !== 1 || shape.scaleY !== 1) {
            const bounds = this.getShapeBounds(shape);
            const centerX = bounds.x + bounds.width / 2;
            const centerY = bounds.y + bounds.height / 2;
            
            ctx.translate(centerX, centerY);
            ctx.rotate((shape.rotation || 0) * Math.PI / 180);
            ctx.scale(shape.scaleX || 1, shape.scaleY || 1);
            ctx.translate(-centerX, -centerY);
        }
        
        // Set up colors/gradients
        ctx.fillStyle = shape.gradient ? this.createGradient(shape, ctx) : shape.fillColor;
        ctx.strokeStyle = shape.strokeColor;
        ctx.lineWidth = shape.strokeWidth;
        ctx.setLineDash([]);

        switch (shape.type) {
            case 'rectangle':
                this.drawRectangle(ctx, shape);
                break;
            case 'circle':
                this.drawCircle(ctx, shape);
                break;
            case 'triangle':
                this.drawTriangle(ctx, shape);
                break;
            case 'line':
                this.drawLine(ctx, shape);
                break;
            case 'spline':
                this.drawSpline(ctx, shape);
                break;
        }

        ctx.restore();
    }

    drawRectangle(ctx, shape) {
        const width = shape.endX - shape.startX;
        const height = shape.endY - shape.startY;
        if (shape.fill) ctx.fillRect(shape.startX, shape.startY, width, height);
        if (shape.stroke) ctx.strokeRect(shape.startX, shape.startY, width, height);
    }

    drawCircle(ctx, shape) {
        const radius = Math.sqrt((shape.endX - shape.startX) ** 2 + (shape.endY - shape.startY) ** 2);
        ctx.beginPath();
        ctx.arc(shape.startX, shape.startY, radius, 0, Math.PI * 2);
        if (shape.fill) ctx.fill();
        if (shape.stroke) ctx.stroke();
    }

    drawTriangle(ctx, shape) {
        const midX = (shape.startX + shape.endX) / 2;
        ctx.beginPath();
        ctx.moveTo(midX, shape.startY);
        ctx.lineTo(shape.startX, shape.endY);
        ctx.lineTo(shape.endX, shape.endY);
        ctx.closePath();
        if (shape.fill) ctx.fill();
        if (shape.stroke) ctx.stroke();
    }

    drawLine(ctx, shape) {
        ctx.beginPath();
        ctx.moveTo(shape.startX, shape.startY);
        ctx.lineTo(shape.endX, shape.endY);
        ctx.stroke();
    }

    drawSpline(ctx, shape) {
        if (shape.points.length < 2) return;
        ctx.beginPath();
        if (shape.points.length === 2) {
            ctx.moveTo(shape.points[0].x, shape.points[0].y);
            ctx.lineTo(shape.points[1].x, shape.points[1].y);
        } else {
            // Use the original points without offset
            this.drawSmoothSpline(shape.points, shape.curveIntensity, shape.closed, ctx);
        }
        if (shape.closed) ctx.closePath();
        if (shape.fill && shape.closed) ctx.fill();
        if (shape.stroke) ctx.stroke();
    }

    // Update drawSmoothSpline to accept ctx
    drawSmoothSpline(points, intensity, closed, ctx = this.ctx) {
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            const prev = points[i - 1];
            const curr = points[i];
            const next = points[(i + 1) % points.length];
            const cp1x = prev.x + (curr.x - prev.x) * intensity;
            const cp1y = prev.y + (curr.y - prev.y) * intensity;
            const cp2x = curr.x - (next.x - prev.x) * intensity * 0.2;
            const cp2y = curr.y - (next.y - prev.y) * intensity * 0.2;
            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, curr.x, curr.y);
        }
    }

    toJSON() {
        return {
            ...super.toJSON(),
            scale: this.scale,
            offsetX: this.offsetX,
            offsetY: this.offsetY,
            flipped: this.flipped,
            animationSpeed: this.animationSpeed,
            isPlaying: this.isPlaying,
            currentFrame: this.currentFrame,
            currentAnimation: this.currentAnimation
        };
    }

    fromJSON(data) {
        super.fromJSON(data);
        if (!data) return;

        this.scale = data.scale || 1;
        this.offsetX = data.offsetX || 0;
        this.offsetY = data.offsetY || 0;
        this.flipped = data.flipped || false;
        this.animationSpeed = data.animationSpeed || 1;
        this.isPlaying = data.isPlaying || false;
        this.currentFrame = data.currentFrame || 0;
        this.currentAnimation = data.currentAnimation || "idle";
        
        // Update animation range after loading
        this.currentAnimationRange = this.getCurrentAnimationRange();
    }
}

window.RoadCone = RoadCone;


// Game Initialization - Fixed for Physics
let gameInitialized = false;

async function initializeGame() {
    if (gameInitialized) return;
    gameInitialized = true;
    
    console.log('Initializing exported game...');
    
    // Prevent scrolling with keyboard
    document.addEventListener('keydown', (e) => {
        if ([32, 33, 34, 35, 36, 37, 38, 39, 40].includes(e.keyCode)) {
            e.preventDefault();
        }
    }, { passive: false });
    
    // Prevent context menu and drag/drop
    document.addEventListener('contextmenu', (e) => e.preventDefault());
    document.addEventListener('dragover', (e) => e.preventDefault());
    document.addEventListener('drop', (e) => e.preventDefault());
    
    const loadingScreen = document.getElementById('loading-screen');
    
    // Wait for Matter.js to be available
    if (typeof Matter === 'undefined') {
        console.log('Waiting for Matter.js to load...');
        return; // Will be called again when matter-loaded event fires
    }
    
    console.log('Matter.js is available, proceeding with initialization...');
    
    // Initialize physics manager FIRST
    window.physicsManager = new PhysicsManager();
    
    // Initialize module registry
    if (!window.moduleRegistry) {
        window.moduleRegistry = new ModuleRegistry();
    }
    
    // Register all available modules
    console.log('Registering modules...');
    
    if (typeof DrawInfiniteStarFieldParallax !== 'undefined') {
        window.moduleRegistry.register(DrawInfiniteStarFieldParallax);
        console.log('Registered module: DrawInfiniteStarFieldParallax');
    } else {
        console.error('Module class not found: DrawInfiniteStarFieldParallax');
    }
    if (typeof DrawGrid !== 'undefined') {
        window.moduleRegistry.register(DrawGrid);
        console.log('Registered module: DrawGrid');
    } else {
        console.error('Module class not found: DrawGrid');
    }
    if (typeof Car1 !== 'undefined') {
        window.moduleRegistry.register(Car1);
        console.log('Registered module: Car1');
    } else {
        console.error('Module class not found: Car1');
    }
    if (typeof CameraController !== 'undefined') {
        window.moduleRegistry.register(CameraController);
        console.log('Registered module: CameraController');
    } else {
        console.error('Module class not found: CameraController');
    }
    if (typeof RigidBody !== 'undefined') {
        window.moduleRegistry.register(RigidBody);
        console.log('Registered module: RigidBody');
    } else {
        console.error('Module class not found: RigidBody');
    }
    if (typeof VehiclePhysics !== 'undefined') {
        window.moduleRegistry.register(VehiclePhysics);
        console.log('Registered module: VehiclePhysics');
    } else {
        console.error('Module class not found: VehiclePhysics');
    }
    if (typeof RoadCone !== 'undefined') {
        window.moduleRegistry.register(RoadCone);
        console.log('Registered module: RoadCone');
    } else {
        console.error('Module class not found: RoadCone');
    }
    
    console.log('Total registered modules:', window.moduleRegistry.modules.size);
    
    // Initialize input manager
    if (!window.input) {
        window.input = new InputManager();
    }

    // Initialize AssetManager with proper export mode handling
    if (!window.assetManager) {
        window.assetManager = new AssetManager(null);
    }

    // Enhanced path normalization function
    window.assetManager.normalizePath = function(path) {
        if (!path) return '';
        let normalized = path.replace(/^[/\\]+/, '').replace(/\\/g, '/');
        try {
            normalized = decodeURIComponent(normalized);
        } catch (e) {
            // If decoding fails, use the original normalized path
        }
        return normalized;
    };

    // Standalone mode - override asset loading to use embedded assets
        window.assetManager.originalLoadAsset = window.assetManager.loadAsset;
        window.assetManager.loadAsset = function(path) {
            const normalizedPath = this.normalizePath(path);
            
            const pathVariations = [
                path,
                normalizedPath,
                path.replace(/^[/\\]+/, ''),
                normalizedPath.replace(/^[/\\]+/, ''),
                '/' + path.replace(/^[/\\]+/, ''),
                '/' + normalizedPath.replace(/^[/\\]+/, ''),
                decodeURIComponent(path),
                decodeURIComponent(normalizedPath),
                path.split('/').pop(),
                normalizedPath.split('/').pop()
            ];
            
            for (const variation of pathVariations) {
                if (this.cache[variation]) {
                    console.log('Found asset in cache with path variation:', variation);
                    return Promise.resolve(this.cache[variation]);
                }
            }
            
            console.warn('Asset not found in cache:', path, 'Tried variations:', pathVariations);
            return Promise.reject(new Error('Asset not found: ' + path));
        };

        // Override loadImage and loadAudio methods...
        window.assetManager.originalLoadImage = window.assetManager.loadImage;
        window.assetManager.loadImage = function(src) {
            if (src.startsWith('data:') || src.startsWith('blob:')) {
                return this.originalLoadImage(src);
            }
            
            const normalizedSrc = this.normalizePath(src);
            const pathVariations = [
                src, normalizedSrc, src.replace(/^[/\\]+/, ''),
                normalizedSrc.replace(/^[/\\]+/, ''), '/' + src.replace(/^[/\\]+/, ''),
                '/' + normalizedSrc.replace(/^[/\\]+/, ''), decodeURIComponent(src),
                decodeURIComponent(normalizedSrc), src.split('/').pop(), normalizedSrc.split('/').pop()
            ];
            
            for (const variation of pathVariations) {
                if (this.cache[variation]) {
                    return Promise.resolve(this.cache[variation]);
                }
            }
            
            return this.originalLoadImage(src);
        };

        window.assetManager.originalLoadAudio = window.assetManager.loadAudio;
        window.assetManager.loadAudio = function(src) {
            if (src.startsWith('data:') || src.startsWith('blob:')) {
                return this.originalLoadAudio(src);
            }
            
            const normalizedSrc = this.normalizePath(src);
            const pathVariations = [
                src, normalizedSrc, src.replace(/^[/\\]+/, ''),
                normalizedSrc.replace(/^[/\\]+/, ''), '/' + src.replace(/^[/\\]+/, ''),
                '/' + normalizedSrc.replace(/^[/\\]+/, ''), decodeURIComponent(src),
                decodeURIComponent(normalizedSrc), src.split('/').pop(), normalizedSrc.split('/').pop()
            ];
            
            for (const variation of pathVariations) {
                if (this.cache[variation]) {
                    return Promise.resolve(this.cache[variation]);
                }
            }
            
            return this.originalLoadAudio(src);
        };
    
    // Initialize Global Prefab Manager
    window.prefabManager = {
        prefabs: new Map(),
        
        loadPrefabs: function(prefabsData) {
            if (!prefabsData) return;
            
            for (const [name, prefabData] of Object.entries(prefabsData)) {
                this.prefabs.set(name, prefabData);
                console.log('Loaded prefab:', name);
            }
            
            console.log('Total prefabs loaded:', this.prefabs.size);
        },
        
        findPrefabByName: function(name) {
            if (!name) return null;
            
            if (this.prefabs.has(name)) {
                return this.prefabs.get(name);
            }
            
            const lowerName = name.toLowerCase();
            for (const [key, value] of this.prefabs) {
                if (key.toLowerCase() === lowerName) {
                    return value;
                }
            }
            
            return null;
        },
        
        hasPrefab: function(name) {
            return this.findPrefabByName(name) !== null;
        },
        
        getAllPrefabNames: function() {
            return Array.from(this.prefabs.keys());
        },
        
        instantiatePrefabByName: function(name, position = null, parent = null) {
            const prefabData = this.findPrefabByName(name);
            if (!prefabData) {
                console.error('Prefab not found:', name);
                return null;
            }
            
            return this.instantiatePrefab(prefabData, position, parent);
        },
        
        instantiatePrefab: function(prefabData, position = null, parent = null) {
            try {
                const gameObject = new GameObject(prefabData.name);
                
                if (position) {
                    gameObject.position.x = position.x;
                    gameObject.position.y = position.y;
                } else {
                    gameObject.position.x = prefabData.position.x;
                    gameObject.position.y = prefabData.position.y;
                }

                gameObject.angle = prefabData.angle || 0;
                gameObject.scale.x = prefabData.scale?.x || 1;
                gameObject.scale.y = prefabData.scale?.y || 1;
                gameObject.active = prefabData.active !== false;

                if (prefabData.modules && prefabData.modules.length > 0) {
                    prefabData.modules.forEach(moduleData => {
                        try {
                            const ModuleClass = window.moduleRegistry.getModuleClass(moduleData.className);
                            if (!ModuleClass) {
                                console.warn('Module class not found:', moduleData.className);
                                return;
                            }

                            const moduleInstance = new ModuleClass();
                            
                            if (moduleData.properties) {
                                Object.keys(moduleData.properties).forEach(propName => {
                                    if (moduleInstance.hasOwnProperty(propName)) {
                                        moduleInstance[propName] = moduleData.properties[propName];
                                    }
                                });
                            }

                            gameObject.addModule(moduleInstance);
                            
                        } catch (error) {
                            console.error('Error adding module ' + moduleData.className + ':', error);
                        }
                    });
                }

                if (prefabData.children && prefabData.children.length > 0) {
                    prefabData.children.forEach(childData => {
                        const childGameObject = this.instantiatePrefab(childData, null, gameObject);
                        gameObject.addChild(childGameObject);
                    });
                }

                if (parent) {
                    parent.addChild(gameObject);
                } else if (window.engine && window.engine.gameObjects) {
                    window.engine.gameObjects.push(gameObject);
                }

                return gameObject;

            } catch (error) {
                console.error('Error instantiating prefab:', error);
                throw error;
            }
        }
    };
    
    // Load game data safely
    let gameData;
    try {
        gameData = {
            scenes: [{"name":"Main Scene","settings":{"viewportWidth":1280,"viewportHeight":720,"viewportX":0,"viewportY":0,"backgroundColor":"#1e1e1e","gridEnabled":true,"gridSize":32,"snapToGrid":false,"gravity":{"x":0,"y":1},"physicsEnabled":true,"physicsDebugDraw":false},"gameObjects":[{"id":"4274746e-ff0c-4797-8bce-728572446f56","name":"New GameObject","position":{"x":352.4879466240232,"y":146.98171969363474},"angle":0,"scale":{"x":1,"y":1},"size":{"width":50,"height":50},"active":true,"visible":true,"depth":0,"modules":[{"type":"DrawInfiniteStarFieldParallax","id":"ee22f7e1-50ba-4cf9-b87e-7700eed417bd","enabled":true,"data":{"layerCount":4,"starsPerGrid":80,"gridSize":800,"seed":12345,"starColor":"#ffffff","minSize":0.25,"maxSize":3.5,"flickerRate":1.83,"parallaxStrength":0.6,"baseDepth":0.2,"brightness":1,"viewportMargin":200}}]},{"id":"5b254eb1-f9b4-474e-ae39-24374d015891","name":"Grid","position":{"x":0,"y":0},"angle":0,"scale":{"x":1,"y":1},"size":{"width":50,"height":50},"active":true,"visible":true,"depth":0,"modules":[{"type":"DrawGrid","id":"449e768a-be52-41e2-946d-535ad6a7c75b","enabled":true,"data":{"name":"DrawGrid","type":"DrawGrid","enabled":true,"requirements":[],"properties":{},"exposedValues":{"x":0,"y":0,"cellWidth":200,"cellHeight":200,"lineColor":"#9efdff","lineThickness":4,"showVertical":true,"showHorizontal":true,"glow":true,"glowColor":"#00fffb","glowBlur":24,"infinite":true,"width":800,"height":600},"x":0,"y":0,"width":800,"height":600,"cellWidth":200,"cellHeight":200,"lineColor":"#9efdff","lineThickness":4,"showVertical":true,"showHorizontal":true,"glow":true,"glowColor":"#00fffb","glowBlur":24,"infinite":true}}]},{"id":"89d3ec18-b5a5-47db-8e38-d55c5cc4b319","name":"Car","position":{"x":442.3342641972063,"y":308.8571028510898},"angle":-12.832989044567789,"scale":{"x":1,"y":1},"size":{"width":100,"height":50},"active":true,"visible":true,"depth":0,"modules":[{"type":"Car1","id":"60bd9d6d-bf0c-444a-8bf2-01d6d7fa24d9","enabled":true,"data":{"name":"Car1","type":"Car1","enabled":true,"requirements":[],"properties":{},"exposedValues":{"scale":0.29,"offsetX":0,"offsetY":0,"flipped":false,"preGenerateImage":false},"scale":0.29,"offsetX":0,"offsetY":0,"flipped":false,"animationSpeed":1,"isPlaying":true,"currentFrame":0,"currentAnimation":"idle"}},{"type":"CameraController","id":"8f3dfb4e-47ba-45d0-8c15-02d2b0726080","enabled":true,"data":{"name":"CameraController","type":"CameraController","enabled":true,"requirements":[],"properties":{},"exposedValues":{"followOwner":true,"followSpeed":50,"zoom":1,"targetZoom":1,"positionDamping":0.85,"zoomDamping":0.85,"dynamicZoomEnabled":true,"maxZoomOut":0.2,"zoomSmoothness":0.85,"zoomIntensityMultiplier":0.001,"shakeIntensity":0,"shakeTimer":0,"offset":{"x":0,"y":0}},"position":{"x":442.33,"y":308.86},"zoom":1,"targetZoom":1,"followOwner":true,"followSpeed":50,"zoomSpeed":2,"positionDamping":0.85,"zoomDamping":0.85,"offset":{"x":0,"y":0},"followOwnerAngle":false,"followAngleOffset":0,"currentAngle":0,"targetAngle":0}},{"type":"RigidBody","id":"6938230a-f6b6-4a88-bdfc-81de9035b642","enabled":true,"data":{"name":"RigidBody","type":"RigidBody","enabled":true,"requirements":[],"properties":{},"exposedValues":{"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"restitution":0.4,"useGravity":true,"frictionAir":0.03,"sleepingAllowed":true,"label":"","fixedRotation":false,"isSensor":false},"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"frictionAir":0.03,"restitution":0.4,"fixedRotation":false,"isSensor":false,"useGravity":true,"sleepingAllowed":true,"label":"","collisionFilter":{"category":1,"mask":4294967295,"group":0},"vertices":[]}},{"type":"VehiclePhysics","id":"49e97dd7-c99a-40c2-b79f-f77283f15c81","enabled":true,"data":{"name":"VehiclePhysics","type":"VehiclePhysics","enabled":true,"requirements":["RigidBody"],"properties":{},"exposedValues":{"weight":100,"playerControlled":true,"maxSpeed":5000,"acceleration":2000,"brakeForce":1000,"frontWheelDrive":false,"handbrakeForce":6,"tractionLoss":0.4,"showDebugInfo":false,"showDriftInfo":false},"playerControlled":true,"maxSpeed":5000,"acceleration":2000,"brakeForce":1000,"decelerationRate":0.05,"reverseMaxSpeed":250,"maxTurnAngle":45,"turnMultiplier":20,"wheelTurnSpeed":90,"wheelReturnSpeed":90,"dragCoefficient":0.95,"lateralGrip":0.85,"minTurnSpeed":50,"wheelBase":60,"frontWheelDrive":false,"differentialStrength":0.6,"antiRoll":0.3,"handbrakeForce":6,"driftThreshold":0.8,"tractionLoss":0.4,"powerOversteerStrength":1.2,"frontGripAdvantage":0.15,"driftRecoveryRate":1.2,"velocityDriftFactor":0.7,"tractionControlEnabled":false,"tractionControlStrength":0.6,"absEnabled":false,"absStrength":0.8,"showDebugInfo":false,"showWheelDirection":false,"showDriftInfo":false,"upKey":"arrowup","downKey":"arrowdown","leftKey":"arrowleft","rightKey":"arrowright","handbrakeKey":" "}}]},{"id":"7feb6105-2ac8-4482-b2ed-a52c5a08e27b","name":"Car (Copy)","position":{"x":699.2142612306092,"y":252.81055804380193},"angle":-56.21808824634486,"scale":{"x":1,"y":1},"size":{"width":100,"height":50},"active":true,"visible":true,"depth":0,"modules":[{"type":"Car1","id":"7c65807d-8e4c-4f92-b10d-8c42546c3c53","enabled":true,"data":{"name":"Car1","type":"Car1","enabled":true,"requirements":[],"properties":{},"exposedValues":{"scale":0.29,"offsetX":0,"offsetY":0,"flipped":false,"preGenerateImage":false},"scale":0.29,"offsetX":0,"offsetY":0,"flipped":false,"animationSpeed":1,"isPlaying":true,"currentFrame":0,"currentAnimation":"idle"}},{"type":"RigidBody","id":"d0a00c1f-fd95-4a6c-bbc3-4bf2ba859bd3","enabled":true,"data":{"name":"RigidBody","type":"RigidBody","enabled":true,"requirements":[],"properties":{},"exposedValues":{"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"restitution":0.4,"useGravity":true,"frictionAir":0.02,"sleepingAllowed":true,"label":"","fixedRotation":false,"isSensor":false},"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"frictionAir":0.02,"restitution":0.4,"fixedRotation":false,"isSensor":false,"useGravity":true,"sleepingAllowed":true,"label":"","collisionFilter":{"category":1,"mask":4294967295,"group":0},"vertices":[]}},{"type":"VehiclePhysics","id":"69e7e5c5-0827-40b1-b905-09a4fcdb3986","enabled":true,"data":{"name":"VehiclePhysics","type":"VehiclePhysics","enabled":true,"requirements":["RigidBody"],"properties":{},"exposedValues":{"weight":100,"playerControlled":false,"maxSpeed":3000,"acceleration":1000,"brakeForce":250,"frontWheelDrive":false,"handbrakeForce":6,"tractionLoss":0.4,"showDebugInfo":false,"showDriftInfo":false},"playerControlled":false,"maxSpeed":3000,"acceleration":1000,"brakeForce":250,"decelerationRate":0.05,"reverseMaxSpeed":250,"maxTurnAngle":45,"turnMultiplier":20,"wheelTurnSpeed":90,"wheelReturnSpeed":90,"dragCoefficient":0.95,"lateralGrip":0.85,"minTurnSpeed":50,"wheelBase":60,"frontWheelDrive":false,"differentialStrength":0.6,"antiRoll":0.3,"handbrakeForce":6,"driftThreshold":0.8,"tractionLoss":0.4,"powerOversteerStrength":1.2,"frontGripAdvantage":0.15,"driftRecoveryRate":1.2,"velocityDriftFactor":0.7,"tractionControlEnabled":false,"tractionControlStrength":0.6,"absEnabled":false,"absStrength":0.8,"showDebugInfo":false,"showWheelDirection":false,"showDriftInfo":false,"upKey":"arrowup","downKey":"arrowdown","leftKey":"arrowleft","rightKey":"arrowright","handbrakeKey":" "}}]},{"id":"2d5e5ddd-2650-4bf4-be44-45a5250b77c9","name":"Car (Copy)","position":{"x":926.5141373934989,"y":277.72013351370765},"angle":-112.00241851806867,"scale":{"x":1,"y":1},"size":{"width":100,"height":50},"active":true,"visible":true,"depth":0,"modules":[{"type":"Car1","id":"010778e6-5522-4e80-be52-4504459b6171","enabled":true,"data":{"name":"Car1","type":"Car1","enabled":true,"requirements":[],"properties":{},"exposedValues":{"scale":0.29,"offsetX":0,"offsetY":0,"flipped":false,"preGenerateImage":false},"scale":0.29,"offsetX":0,"offsetY":0,"flipped":false,"animationSpeed":1,"isPlaying":true,"currentFrame":0,"currentAnimation":"idle"}},{"type":"RigidBody","id":"17d87909-428c-4af7-9543-138e0a48c2d6","enabled":true,"data":{"name":"RigidBody","type":"RigidBody","enabled":true,"requirements":[],"properties":{},"exposedValues":{"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"restitution":0.4,"useGravity":true,"frictionAir":0.05,"sleepingAllowed":true,"label":"","fixedRotation":false,"isSensor":false},"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"frictionAir":0.05,"restitution":0.4,"fixedRotation":false,"isSensor":false,"useGravity":true,"sleepingAllowed":true,"label":"","collisionFilter":{"category":1,"mask":4294967295,"group":0},"vertices":[]}},{"type":"VehiclePhysics","id":"fe4c1309-578b-4964-bb59-62cc738c42a3","enabled":true,"data":{"name":"VehiclePhysics","type":"VehiclePhysics","enabled":true,"requirements":["RigidBody"],"properties":{},"exposedValues":{"weight":100,"playerControlled":false,"maxSpeed":3000,"acceleration":1000,"brakeForce":250,"frontWheelDrive":false,"handbrakeForce":6,"tractionLoss":0.4,"showDebugInfo":false,"showDriftInfo":false},"playerControlled":false,"maxSpeed":3000,"acceleration":1000,"brakeForce":250,"decelerationRate":0.05,"reverseMaxSpeed":250,"maxTurnAngle":45,"turnMultiplier":20,"wheelTurnSpeed":90,"wheelReturnSpeed":90,"dragCoefficient":0.95,"lateralGrip":0.85,"minTurnSpeed":50,"wheelBase":60,"frontWheelDrive":false,"differentialStrength":0.6,"antiRoll":0.3,"handbrakeForce":6,"driftThreshold":0.8,"tractionLoss":0.4,"powerOversteerStrength":1.2,"frontGripAdvantage":0.15,"driftRecoveryRate":1.2,"velocityDriftFactor":0.7,"tractionControlEnabled":false,"tractionControlStrength":0.6,"absEnabled":false,"absStrength":0.8,"showDebugInfo":false,"showWheelDirection":false,"showDriftInfo":false,"upKey":"arrowup","downKey":"arrowdown","leftKey":"arrowleft","rightKey":"arrowright","handbrakeKey":" "}}]},{"id":"3a1831ba-a29f-43f0-8b45-c030577498c2","name":"Car (Copy)","position":{"x":811.3073508451849,"y":287.0612243149223},"angle":-85.10448085386933,"scale":{"x":1,"y":1},"size":{"width":100,"height":50},"active":true,"visible":true,"depth":0,"modules":[{"type":"Car1","id":"e9da7002-8961-4154-99d0-5973ad7d9008","enabled":true,"data":{"name":"Car1","type":"Car1","enabled":true,"requirements":[],"properties":{},"exposedValues":{"scale":0.29,"offsetX":0,"offsetY":0,"flipped":false,"preGenerateImage":false},"scale":0.29,"offsetX":0,"offsetY":0,"flipped":false,"animationSpeed":1,"isPlaying":true,"currentFrame":0,"currentAnimation":"idle"}},{"type":"RigidBody","id":"ed8cfad6-56a0-4945-9894-eff133e4d6b8","enabled":true,"data":{"name":"RigidBody","type":"RigidBody","enabled":true,"requirements":[],"properties":{},"exposedValues":{"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"restitution":0.4,"useGravity":true,"frictionAir":0.02,"sleepingAllowed":true,"label":"","fixedRotation":false,"isSensor":false},"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"frictionAir":0.02,"restitution":0.4,"fixedRotation":false,"isSensor":false,"useGravity":true,"sleepingAllowed":true,"label":"","collisionFilter":{"category":1,"mask":4294967295,"group":0},"vertices":[]}},{"type":"VehiclePhysics","id":"a4830238-73e5-444e-a363-7df62bcd067d","enabled":true,"data":{"name":"VehiclePhysics","type":"VehiclePhysics","enabled":true,"requirements":["RigidBody"],"properties":{},"exposedValues":{"weight":100,"playerControlled":false,"maxSpeed":3000,"acceleration":1000,"brakeForce":250,"frontWheelDrive":false,"handbrakeForce":6,"tractionLoss":0.4,"showDebugInfo":false,"showDriftInfo":false},"playerControlled":false,"maxSpeed":3000,"acceleration":1000,"brakeForce":250,"decelerationRate":0.05,"reverseMaxSpeed":250,"maxTurnAngle":45,"turnMultiplier":20,"wheelTurnSpeed":90,"wheelReturnSpeed":90,"dragCoefficient":0.95,"lateralGrip":0.85,"minTurnSpeed":50,"wheelBase":60,"frontWheelDrive":false,"differentialStrength":0.6,"antiRoll":0.3,"handbrakeForce":6,"driftThreshold":0.8,"tractionLoss":0.4,"powerOversteerStrength":1.2,"frontGripAdvantage":0.15,"driftRecoveryRate":1.2,"velocityDriftFactor":0.7,"tractionControlEnabled":false,"tractionControlStrength":0.6,"absEnabled":false,"absStrength":0.8,"showDebugInfo":false,"showWheelDirection":false,"showDriftInfo":false,"upKey":"arrowup","downKey":"arrowdown","leftKey":"arrowleft","rightKey":"arrowright","handbrakeKey":" "}}]},{"id":"8188760f-1c0e-4b5f-97db-2060844df92f","name":"RoadCone","position":{"x":517.6499865462918,"y":121.90597739114615},"angle":0,"scale":{"x":1,"y":1},"size":{"width":25,"height":25},"active":true,"visible":true,"depth":0,"modules":[{"type":"RoadCone","id":"60fd029d-4c21-46c7-93e3-05a5092ee970","enabled":true,"data":{"name":"RoadCone","type":"RoadCone","enabled":true,"requirements":[],"properties":{},"exposedValues":{"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"preGenerateImage":false},"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"animationSpeed":1,"isPlaying":true,"currentFrame":0,"currentAnimation":"idle"}},{"type":"RigidBody","id":"e3801719-ca3e-414f-b33c-8d83d4db9613","enabled":true,"data":{"name":"RigidBody","type":"RigidBody","enabled":true,"requirements":[],"properties":{},"exposedValues":{"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"restitution":0.1,"useGravity":false,"frictionAir":0.04,"sleepingAllowed":true,"label":"","fixedRotation":false,"isSensor":false},"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"frictionAir":0.04,"restitution":0.1,"fixedRotation":false,"isSensor":false,"useGravity":false,"sleepingAllowed":true,"label":"","collisionFilter":{"category":1,"mask":4294967295,"group":0},"vertices":[]}}]},{"id":"c35ac5c4-c739-487f-aa36-1ddfebd18a07","name":"RoadCone","position":{"x":402.45614532510234,"y":239.2991373398105},"angle":-93.86534000648997,"scale":{"x":1,"y":1},"size":{"width":25,"height":25},"active":true,"visible":true,"depth":0,"modules":[{"type":"RoadCone","id":"639aa287-43fd-4025-beca-b408cd6c0df5","enabled":true,"data":{"name":"RoadCone","type":"RoadCone","enabled":true,"requirements":[],"properties":{},"exposedValues":{"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"preGenerateImage":false},"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"animationSpeed":1,"isPlaying":true,"currentFrame":0,"currentAnimation":"idle"}},{"type":"RigidBody","id":"498baa24-eac2-4186-bf20-56bd096bc2ff","enabled":true,"data":{"name":"RigidBody","type":"RigidBody","enabled":true,"requirements":[],"properties":{},"exposedValues":{"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"restitution":0.1,"useGravity":false,"frictionAir":0.01,"sleepingAllowed":true,"label":"","fixedRotation":false,"isSensor":false},"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"frictionAir":0.01,"restitution":0.1,"fixedRotation":false,"isSensor":false,"useGravity":false,"sleepingAllowed":true,"label":"","collisionFilter":{"category":1,"mask":4294967295,"group":0},"vertices":[]}}]},{"id":"6f1d5b6c-f316-4d55-8796-7eaee2cc32a3","name":"RoadCone (Copy)","position":{"x":477.3293342138085,"y":124.61994929508339},"angle":-13.122990630654327,"scale":{"x":1,"y":1},"size":{"width":25,"height":25},"active":true,"visible":true,"depth":0,"modules":[{"type":"RoadCone","id":"2ce49416-2506-4569-86e3-a8f63a4af167","enabled":true,"data":{"name":"RoadCone","type":"RoadCone","enabled":true,"requirements":[],"properties":{},"exposedValues":{"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"preGenerateImage":false},"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"animationSpeed":1,"isPlaying":true,"currentFrame":0,"currentAnimation":"idle"}},{"type":"RigidBody","id":"acc83d3a-f66e-468f-a742-7ff18cb88973","enabled":true,"data":{"name":"RigidBody","type":"RigidBody","enabled":true,"requirements":[],"properties":{},"exposedValues":{"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"restitution":0.1,"useGravity":false,"frictionAir":0.01,"sleepingAllowed":true,"label":"","fixedRotation":false,"isSensor":false},"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"frictionAir":0.01,"restitution":0.1,"fixedRotation":false,"isSensor":false,"useGravity":false,"sleepingAllowed":true,"label":"","collisionFilter":{"category":1,"mask":4294967295,"group":0},"vertices":[]}}]},{"id":"d0047250-65b1-4234-9d6a-f331c9a0ba7f","name":"RoadCone (Copy)","position":{"x":443.2099063657905,"y":140.73190133442523},"angle":-35.97803188394044,"scale":{"x":1,"y":1},"size":{"width":25,"height":25},"active":true,"visible":true,"depth":0,"modules":[{"type":"RoadCone","id":"0b40b69f-8982-46c6-8f74-d81b4d641d94","enabled":true,"data":{"name":"RoadCone","type":"RoadCone","enabled":true,"requirements":[],"properties":{},"exposedValues":{"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"preGenerateImage":false},"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"animationSpeed":1,"isPlaying":true,"currentFrame":0,"currentAnimation":"idle"}},{"type":"RigidBody","id":"b6ee6f5a-77a3-4229-b238-28aba896e57f","enabled":true,"data":{"name":"RigidBody","type":"RigidBody","enabled":true,"requirements":[],"properties":{},"exposedValues":{"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"restitution":0.1,"useGravity":false,"frictionAir":0.01,"sleepingAllowed":true,"label":"","fixedRotation":false,"isSensor":false},"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"frictionAir":0.01,"restitution":0.1,"fixedRotation":false,"isSensor":false,"useGravity":false,"sleepingAllowed":true,"label":"","collisionFilter":{"category":1,"mask":4294967295,"group":0},"vertices":[]}}]},{"id":"47b014cf-7f5e-4dda-bb08-72aec4357763","name":"RoadCone (Copy)","position":{"x":414.7770498257755,"y":167.26923410510588},"angle":-54.560187331127906,"scale":{"x":1,"y":1},"size":{"width":25,"height":25},"active":true,"visible":true,"depth":0,"modules":[{"type":"RoadCone","id":"44034b5b-bacd-4d0b-a7d5-bc2acc525fe3","enabled":true,"data":{"name":"RoadCone","type":"RoadCone","enabled":true,"requirements":[],"properties":{},"exposedValues":{"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"preGenerateImage":false},"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"animationSpeed":1,"isPlaying":true,"currentFrame":0,"currentAnimation":"idle"}},{"type":"RigidBody","id":"7d05352a-16dd-4fda-9845-fa1fec1f5f79","enabled":true,"data":{"name":"RigidBody","type":"RigidBody","enabled":true,"requirements":[],"properties":{},"exposedValues":{"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"restitution":0.1,"useGravity":false,"frictionAir":0.01,"sleepingAllowed":true,"label":"","fixedRotation":false,"isSensor":false},"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"frictionAir":0.01,"restitution":0.1,"fixedRotation":false,"isSensor":false,"useGravity":false,"sleepingAllowed":true,"label":"","collisionFilter":{"category":1,"mask":4294967295,"group":0},"vertices":[]}}]},{"id":"fab27594-9598-461e-a0f5-add91f562466","name":"RoadCone (Copy)","position":{"x":404.3516690944367,"y":203.28418572245818},"angle":-78.24504070806893,"scale":{"x":1,"y":1},"size":{"width":25,"height":25},"active":true,"visible":true,"depth":0,"modules":[{"type":"RoadCone","id":"399eb324-0e44-4807-b0df-e9a58a4fb0a5","enabled":true,"data":{"name":"RoadCone","type":"RoadCone","enabled":true,"requirements":[],"properties":{},"exposedValues":{"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"preGenerateImage":false},"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"animationSpeed":1,"isPlaying":true,"currentFrame":0,"currentAnimation":"idle"}},{"type":"RigidBody","id":"c6eb6eea-71de-4b6a-8787-d58f732daeee","enabled":true,"data":{"name":"RigidBody","type":"RigidBody","enabled":true,"requirements":[],"properties":{},"exposedValues":{"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"restitution":0.1,"useGravity":false,"frictionAir":0.01,"sleepingAllowed":true,"label":"","fixedRotation":false,"isSensor":false},"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"frictionAir":0.01,"restitution":0.1,"fixedRotation":false,"isSensor":false,"useGravity":false,"sleepingAllowed":true,"label":"","collisionFilter":{"category":1,"mask":4294967295,"group":0},"vertices":[]}}]}]}],
            assets: {"SpriteCode Projects/RoadCone.spritecode":{"content":"{\n  \"frames\": [\n    [\n      {\n        \"type\": \"rectangle\",\n        \"startX\": 272,\n        \"startY\": 176,\n        \"endX\": 528,\n        \"endY\": 432,\n        \"fillColor\": \"#3b82f6\",\n        \"strokeColor\": \"#000000\",\n        \"strokeWidth\": 4,\n        \"fill\": true,\n        \"stroke\": true,\n        \"visible\": true,\n        \"rotation\": 0,\n        \"scaleX\": 1,\n        \"scaleY\": 1,\n        \"gradient\": {\n          \"enabled\": true,\n          \"start\": \"#b4590e\",\n          \"end\": \"#9f4204\",\n          \"type\": \"linear\",\n          \"angle\": 0\n        },\n        \"parentGroup\": null,\n        \"children\": [],\n        \"localRotation\": 0,\n        \"worldRotation\": 0,\n        \"localPosition\": {\n          \"x\": 272,\n          \"y\": 176\n        },\n        \"worldPosition\": {\n          \"x\": 272,\n          \"y\": 176\n        },\n        \"rotationHotspot\": {\n          \"x\": 0,\n          \"y\": 0\n        }\n      },\n      {\n        \"type\": \"circle\",\n        \"startX\": 400,\n        \"startY\": 304,\n        \"endX\": 448,\n        \"endY\": 400,\n        \"fillColor\": \"#3b82f6\",\n        \"strokeColor\": \"#000000\",\n        \"strokeWidth\": 2,\n        \"fill\": true,\n        \"stroke\": true,\n        \"visible\": true,\n        \"rotation\": 0,\n        \"scaleX\": 1,\n        \"scaleY\": 1,\n        \"gradient\": {\n          \"enabled\": true,\n          \"start\": \"#e37316\",\n          \"end\": \"#b55608\",\n          \"type\": \"linear\",\n          \"angle\": 0\n        },\n        \"parentGroup\": null,\n        \"children\": [],\n        \"localRotation\": 0,\n        \"worldRotation\": 0,\n        \"localPosition\": {\n          \"x\": 400,\n          \"y\": 304\n        },\n        \"worldPosition\": {\n          \"x\": 400,\n          \"y\": 304\n        },\n        \"rotationHotspot\": {\n          \"x\": 0,\n          \"y\": 0\n        }\n      },\n      {\n        \"type\": \"circle\",\n        \"startX\": 400,\n        \"startY\": 304,\n        \"endX\": 448,\n        \"endY\": 352,\n        \"fillColor\": \"#3b82f6\",\n        \"strokeColor\": \"#ffffff\",\n        \"strokeWidth\": 5,\n        \"fill\": true,\n        \"stroke\": true,\n        \"visible\": true,\n        \"rotation\": 0,\n        \"scaleX\": 1,\n        \"scaleY\": 1,\n        \"gradient\": {\n          \"enabled\": true,\n          \"start\": \"#ef7715\",\n          \"end\": \"#df5a01\",\n          \"type\": \"linear\",\n          \"angle\": 0\n        },\n        \"parentGroup\": null,\n        \"children\": [],\n        \"localRotation\": 0,\n        \"worldRotation\": 0,\n        \"localPosition\": {\n          \"x\": 400,\n          \"y\": 304\n        },\n        \"worldPosition\": {\n          \"x\": 400,\n          \"y\": 304\n        },\n        \"rotationHotspot\": {\n          \"x\": 0,\n          \"y\": 0\n        }\n      },\n      {\n        \"type\": \"circle\",\n        \"startX\": 400,\n        \"startY\": 304,\n        \"endX\": 416,\n        \"endY\": 320,\n        \"fillColor\": \"#3b82f6\",\n        \"strokeColor\": \"#ffffff\",\n        \"strokeWidth\": 5,\n        \"fill\": true,\n        \"stroke\": true,\n        \"visible\": true,\n        \"rotation\": 0,\n        \"scaleX\": 1,\n        \"scaleY\": 1,\n        \"gradient\": {\n          \"enabled\": true,\n          \"start\": \"#ea8634\",\n          \"end\": \"#f3ad35\",\n          \"type\": \"linear\",\n          \"angle\": 0\n        },\n        \"parentGroup\": null,\n        \"children\": [],\n        \"localRotation\": 0,\n        \"worldRotation\": 0,\n        \"localPosition\": {\n          \"x\": 400,\n          \"y\": 304\n        },\n        \"worldPosition\": {\n          \"x\": 400,\n          \"y\": 304\n        },\n        \"rotationHotspot\": {\n          \"x\": 0,\n          \"y\": 0\n        }\n      }\n    ]\n  ],\n  \"animationRanges\": [\n    {\n      \"name\": \"idle\",\n      \"start\": 0,\n      \"end\": 4\n    }\n  ],\n  \"animationSettings\": {\n    \"enableTweening\": false,\n    \"animSpeed\": 1,\n    \"tweenType\": \"linear\",\n    \"pingPong\": false\n  }\n}","type":"file","binary":false},"SpriteCode Projects/car.spritecode":{"content":"{\n  \"frames\": [\n    [\n      {\n        \"type\": \"rectangle\",\n        \"startX\": 224,\n        \"startY\": 208,\n        \"endX\": 576,\n        \"endY\": 384,\n        \"fillColor\": \"#3b82f6\",\n        \"strokeColor\": \"#000000\",\n        \"strokeWidth\": 2,\n        \"fill\": true,\n        \"stroke\": true,\n        \"visible\": true,\n        \"rotation\": 0,\n        \"scaleX\": 1,\n        \"scaleY\": 1,\n        \"gradient\": null,\n        \"parentGroup\": null,\n        \"children\": [],\n        \"localRotation\": 0,\n        \"worldRotation\": 0,\n        \"localPosition\": {\n          \"x\": 176,\n          \"y\": 208\n        },\n        \"worldPosition\": {\n          \"x\": 176,\n          \"y\": 208\n        },\n        \"rotationHotspot\": {\n          \"x\": 0,\n          \"y\": 0\n        }\n      },\n      {\n        \"type\": \"rectangle\",\n        \"startX\": 304,\n        \"startY\": 240,\n        \"endX\": 496,\n        \"endY\": 352,\n        \"fillColor\": \"#81abee\",\n        \"strokeColor\": \"#000000\",\n        \"strokeWidth\": 2,\n        \"fill\": true,\n        \"stroke\": true,\n        \"visible\": true,\n        \"rotation\": 0,\n        \"scaleX\": 1,\n        \"scaleY\": 1,\n        \"gradient\": {\n          \"enabled\": false,\n          \"start\": \"#c8d9f3\",\n          \"end\": \"#ffffff\",\n          \"type\": \"linear\",\n          \"angle\": 0\n        },\n        \"parentGroup\": null,\n        \"children\": [],\n        \"localRotation\": 0,\n        \"worldRotation\": 0,\n        \"localPosition\": {\n          \"x\": 304,\n          \"y\": 240\n        },\n        \"worldPosition\": {\n          \"x\": 304,\n          \"y\": 240\n        },\n        \"rotationHotspot\": {\n          \"x\": 0,\n          \"y\": 0\n        }\n      },\n      {\n        \"type\": \"rectangle\",\n        \"startX\": 496,\n        \"startY\": 240,\n        \"endX\": 528,\n        \"endY\": 352,\n        \"fillColor\": \"#81abee\",\n        \"strokeColor\": \"#000000\",\n        \"strokeWidth\": 2,\n        \"fill\": true,\n        \"stroke\": true,\n        \"visible\": true,\n        \"rotation\": 0,\n        \"scaleX\": 1,\n        \"scaleY\": 1,\n        \"gradient\": {\n          \"enabled\": true,\n          \"start\": \"#c8d9f3\",\n          \"end\": \"#ffffff\",\n          \"type\": \"linear\",\n          \"angle\": 0\n        },\n        \"parentGroup\": null,\n        \"children\": [],\n        \"localRotation\": 0,\n        \"worldRotation\": 0,\n        \"localPosition\": {\n          \"x\": 496,\n          \"y\": 240\n        },\n        \"worldPosition\": {\n          \"x\": 496,\n          \"y\": 240\n        },\n        \"rotationHotspot\": {\n          \"x\": 0,\n          \"y\": 0\n        }\n      },\n      {\n        \"type\": \"rectangle\",\n        \"startX\": 256,\n        \"startY\": 240,\n        \"endX\": 304,\n        \"endY\": 352,\n        \"fillColor\": \"#81abee\",\n        \"strokeColor\": \"#000000\",\n        \"strokeWidth\": 2,\n        \"fill\": true,\n        \"stroke\": true,\n        \"visible\": true,\n        \"rotation\": 0,\n        \"scaleX\": 1,\n        \"scaleY\": 1,\n        \"gradient\": {\n          \"enabled\": true,\n          \"start\": \"#c8d9f3\",\n          \"end\": \"#ffffff\",\n          \"type\": \"linear\",\n          \"angle\": 0\n        },\n        \"parentGroup\": null,\n        \"children\": [],\n        \"localRotation\": 0,\n        \"worldRotation\": 0,\n        \"localPosition\": {\n          \"x\": 256,\n          \"y\": 240\n        },\n        \"worldPosition\": {\n          \"x\": 256,\n          \"y\": 240\n        },\n        \"rotationHotspot\": {\n          \"x\": 0,\n          \"y\": 0\n        }\n      },\n      {\n        \"type\": \"rectangle\",\n        \"startX\": 560,\n        \"startY\": 224,\n        \"endX\": 576,\n        \"endY\": 256,\n        \"fillColor\": \"#ebe9cb\",\n        \"strokeColor\": \"#000000\",\n        \"strokeWidth\": 2,\n        \"fill\": true,\n        \"stroke\": true,\n        \"visible\": true,\n        \"rotation\": 0,\n        \"scaleX\": 1,\n        \"scaleY\": 1,\n        \"gradient\": null,\n        \"parentGroup\": null,\n        \"children\": [],\n        \"localRotation\": 0,\n        \"worldRotation\": 0,\n        \"localPosition\": {\n          \"x\": 560,\n          \"y\": 224\n        },\n        \"worldPosition\": {\n          \"x\": 560,\n          \"y\": 224\n        },\n        \"rotationHotspot\": {\n          \"x\": 0,\n          \"y\": 0\n        }\n      },\n      {\n        \"type\": \"rectangle\",\n        \"startX\": 560,\n        \"startY\": 368,\n        \"endX\": 576,\n        \"endY\": 336,\n        \"fillColor\": \"#ebe9cb\",\n        \"strokeColor\": \"#000000\",\n        \"strokeWidth\": 2,\n        \"fill\": true,\n        \"stroke\": true,\n        \"visible\": true,\n        \"rotation\": 0,\n        \"scaleX\": 1,\n        \"scaleY\": 1,\n        \"gradient\": null,\n        \"parentGroup\": null,\n        \"children\": [],\n        \"localRotation\": 0,\n        \"worldRotation\": 0,\n        \"localPosition\": {\n          \"x\": 560,\n          \"y\": 368\n        },\n        \"worldPosition\": {\n          \"x\": 560,\n          \"y\": 368\n        },\n        \"rotationHotspot\": {\n          \"x\": 0,\n          \"y\": 0\n        }\n      },\n      {\n        \"type\": \"rectangle\",\n        \"startX\": 224,\n        \"startY\": 224,\n        \"endX\": 240,\n        \"endY\": 256,\n        \"fillColor\": \"#c08c8c\",\n        \"strokeColor\": \"#000000\",\n        \"strokeWidth\": 2,\n        \"fill\": true,\n        \"stroke\": true,\n        \"visible\": true,\n        \"rotation\": 0,\n        \"scaleX\": 1,\n        \"scaleY\": 1,\n        \"gradient\": null,\n        \"parentGroup\": null,\n        \"children\": [],\n        \"localRotation\": 0,\n        \"worldRotation\": 0,\n        \"localPosition\": {\n          \"x\": 224,\n          \"y\": 224\n        },\n        \"worldPosition\": {\n          \"x\": 224,\n          \"y\": 224\n        },\n        \"rotationHotspot\": {\n          \"x\": 0,\n          \"y\": 0\n        }\n      },\n      {\n        \"type\": \"rectangle\",\n        \"startX\": 224,\n        \"startY\": 336,\n        \"endX\": 240,\n        \"endY\": 368,\n        \"fillColor\": \"#c08c8c\",\n        \"strokeColor\": \"#000000\",\n        \"strokeWidth\": 2,\n        \"fill\": true,\n        \"stroke\": true,\n        \"visible\": true,\n        \"rotation\": 0,\n        \"scaleX\": 1,\n        \"scaleY\": 1,\n        \"gradient\": null,\n        \"parentGroup\": null,\n        \"children\": [],\n        \"localRotation\": 0,\n        \"worldRotation\": 0,\n        \"localPosition\": {\n          \"x\": 224,\n          \"y\": 336\n        },\n        \"worldPosition\": {\n          \"x\": 224,\n          \"y\": 336\n        },\n        \"rotationHotspot\": {\n          \"x\": 0,\n          \"y\": 0\n        }\n      }\n    ]\n  ],\n  \"animationRanges\": [\n    {\n      \"name\": \"idle\",\n      \"start\": 0,\n      \"end\": 4\n    }\n  ],\n  \"animationSettings\": {\n    \"enableTweening\": false,\n    \"animSpeed\": 1,\n    \"tweenType\": \"linear\",\n    \"pingPong\": false\n  }\n}","type":"file","binary":false}},
            prefabs: {"RoadCone":{"metadata":{"name":"RoadCone","created":1756690887401,"version":"1.0.0"},"gameObject":{"name":"RoadCone","position":{"x":517.6499865462918,"y":121.90597739114615},"scale":{"x":1,"y":1},"active":true,"editorColor":"hsl(66, 70%, 60%)","modules":[{"type":"RoadCone","properties":{}},{"type":"RigidBody","properties":{}}],"children":[]}}}
        };
    } catch (error) {
        console.error('Error parsing game data:', error);
        loadingScreen.innerHTML = '<div>Error loading game data: ' + error.message + '</div>';
        return;
    }
    
    // Load prefabs into the global prefab manager
    if (gameData.prefabs) {
        window.prefabManager.loadPrefabs(gameData.prefabs);
        console.log('Loaded prefabs:', Object.keys(gameData.prefabs));
    }
    
    // Pre-load assets for standalone mode
    
    if (gameData.assets) {
        console.log('Pre-caching embedded assets...');
        console.log('Assets to cache:', Object.keys(gameData.assets));
        
        window.assetManager.addEmbeddedAssets(gameData.assets);
        
        console.log('Asset caching completed.');
        console.log('Final asset cache keys:', Object.keys(window.assetManager.cache));
    }
    
    // Initialize engine
    const canvas = document.getElementById('gameCanvas');
    const engine = new Engine(canvas);
    engine.updateFPSLimit(120);
    
    this.ctx = canvas.ctx;
    
    // Make engine globally available for prefab instantiation
    window.engine = engine;
    
    // CRITICAL: Connect physics to engine properly
    if (window.physicsManager) {
        console.log('Connecting physics to engine...');
        
        // Store original methods
        const originalEngineUpdate = engine.update.bind(engine);
        const originalEngineDraw = engine.draw.bind(engine);
        
        // Override engine update to include physics
        engine.update = function(deltaTime) {
            // Update physics first
            if (window.physicsManager && window.physicsManager.update) {
                window.physicsManager.update(deltaTime);
            }
            
            // Then update game objects
            originalEngineUpdate(deltaTime);
        };
        
        // Override engine draw to include physics debug
        engine.draw = function() {
            // Draw game objects
            originalEngineDraw();
            
            // Draw physics debug if enabled
            if (window.physicsManager && window.physicsManager.drawDebug && this.ctx) {
                window.physicsManager.drawDebug(this.ctx);
            }
        };
        
        console.log('Matter Physics connected to engine successfully');
    } else {
        console.error('Physics manager not found during engine setup');
    }
    
    // Setup canvas scaling
    function resizeCanvas() {
        const container = document.getElementById('game-container');
        const canvas = document.getElementById('gameCanvas');
        
        if (!canvas || !container) return;
        
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;
        const originalWidth = 800;
        const originalHeight = 600;
        
        const scaleX = containerWidth / originalWidth;
        const scaleY = containerHeight / originalHeight;
        const scale = Math.min(scaleX, scaleY);
        
        const scaledWidth = originalWidth * scale;
        const scaledHeight = originalHeight * scale;
        
        canvas.style.width = scaledWidth + 'px';
        canvas.style.height = scaledHeight + 'px';
        canvas.style.position = 'absolute';
        canvas.style.left = '50%';
        canvas.style.top = '50%';
        canvas.style.transform = 'translate(-50%, -50%)';
    }
    
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // Load scenes
    const scenes = gameData.scenes || [];
    const loadedScenes = [];
    
    scenes.forEach(sceneData => {
        const scene = new Scene(sceneData.name);
        scene.settings = sceneData.settings;
        
        sceneData.gameObjects.forEach(objData => {
            const gameObject = createGameObjectFromData(objData);
            scene.gameObjects.push(gameObject);
        });
        
        loadedScenes.push(scene);
    });
    
    // Function to create game object from serialized data
    function createGameObjectFromData(data) {
        console.log('Creating game object:', data.name, 'with', data.modules?.length || 0, 'modules');
        
        const obj = new GameObject(data.name);
        if (data.id) obj.id = data.id;

        obj.position = new Vector2(data.position.x, data.position.y);
        obj.angle = (typeof data.angle === 'number') ? data.angle : 0;
        obj.depth = data.depth;
        obj.useCollisions = data.useCollisions || false;
        obj.size = data.size ? new Vector2(data.size.width, data.size.height) : new Vector2(50, 50);

        // Restore scale if available
        if (data.scale) obj.scale = new Vector2(data.scale.x, data.scale.y);
        obj.editorColor = data.editorColor || obj.generateRandomColor();

        if (data.polygonPointCount !== undefined) {
            obj.polygonPointCount = data.polygonPointCount;
        }
        if (data.polygonPoints && Array.isArray(data.polygonPoints)) {
            obj.polygonPoints = data.polygonPoints.map(pt => new Vector2(pt.x, pt.y));
            // Pass parent, position, ...points
            obj.polygon = new Polygon(obj, obj.position.clone(), ...obj.polygonPoints.map(pt => pt.clone()));
        }

        if (data.usePolygonCollision !== undefined) {
            obj.usePolygonCollision = data.usePolygonCollision;
        }

        obj.active = data.active;
        if (data.visible !== undefined) obj.visible = data.visible;
        obj.tags = Array.isArray(data.tags) ? [...data.tags] : [];

        if (data.collisionEnabled !== undefined) obj.collisionEnabled = data.collisionEnabled;
        if (data.collisionLayer !== undefined) obj.collisionLayer = data.collisionLayer;
        if (data.collisionMask !== undefined) obj.collisionMask = data.collisionMask;

        // Add modules
        if (data.modules && data.modules.length > 0) {
            data.modules.forEach(moduleData => {
                console.log('Adding module:', moduleData.type, 'to', data.name);
                
                const ModuleClass = window.moduleRegistry.getModuleClass(moduleData.type);
                if (ModuleClass) {
                    const module = new ModuleClass();
                    module.enabled = moduleData.enabled;
                    module.id = moduleData.id;
                    
                    // CRITICAL: Skip body creation during deserialization for RigidBody
                    //if (module.constructor.name === 'RigidBody') {
                    //    module._skipRebuild = false;
                    //}
                    
                    // Restore module data
                    if (moduleData.data) {
                        if (typeof module.fromJSON === 'function') {
                            try {
                                module.fromJSON(moduleData.data);
                                console.log('Module data restored via fromJSON for:', moduleData.type);
                            } catch (error) {
                                console.error('Error restoring module data via fromJSON:', error);
                                if (moduleData.data.properties) {
                                    Object.keys(moduleData.data.properties).forEach(key => {
                                        if (key in module) {
                                            module[key] = moduleData.data.properties[key];
                                        }
                                    });
                                }
                            }
                        } else {
                            const sourceData = moduleData.data.properties || moduleData.data;
                            Object.keys(sourceData).forEach(key => {
                                if (key in module) {
                                    module[key] = sourceData[key];
                                }
                            });
                        }
                    }
                    
                    // Re-enable body creation after data restoration
                    //if (module.constructor.name === 'RigidBody') {
                    //    module._skipRebuild = false;
                        // Ensure pending creation is set for later initialization
                    //    module.pendingBodyCreation = true;
                    //}
                    
                    obj.addModule(module);
                    console.log('Successfully added module:', moduleData.type);
                }
            });
        }
        
        // Add children
        if (data.children) {
            data.children.forEach(childData => {
                const child = createGameObjectFromData(childData);
                obj.addChild(child);
            });
        }
        
        return obj;
    }
    
    // Start the game with the selected starting scene
    if (loadedScenes.length > 0) {
        try {
            const startingSceneIndex = 0;
            const sceneToLoad = loadedScenes[startingSceneIndex] || loadedScenes[0];
            console.log('Loading starting scene:', sceneToLoad.name, 'at index:', startingSceneIndex);
            
            engine.loadScene(sceneToLoad);
            await engine.start();
            loadingScreen.style.display = 'none';
            console.log('Game started successfully with scene:', sceneToLoad.name);
        } catch (error) {
            console.error('Failed to start game:', error);
            loadingScreen.innerHTML = '<div>Error loading game: ' + error.message + '</div>';
        }
    } else {
        loadingScreen.innerHTML = '<div>No scenes found</div>';
    }
}

// Wait for both DOM and Matter.js to be ready
document.addEventListener('DOMContentLoaded', initializeGame);
window.addEventListener('matter-loaded', initializeGame);
</script>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="loading-screen" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; color: #fff; display: flex; align-items: center; justify-content: center; font-family: Arial, sans-serif;">
            <div>Loading...</div>
        </div>
    </div>
</body>
</html>