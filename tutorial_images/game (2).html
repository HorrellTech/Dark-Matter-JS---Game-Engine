<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Dark Matter Game</title>
    <meta name="description" content="A game created with Dark Matter JS Engine">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const canvas = document.getElementById('gameCanvas');
            if (canvas) {
                const updateCanvasSize = () => {
                    const width = window.innerWidth;
                    const height = window.innerHeight;
                    canvas.width = width;
                    canvas.height = height;
                    canvas.style.width = width + 'px';
                    canvas.style.height = height + 'px';
                    if (window.engine && typeof window.engine.handleResize === 'function') {
                        window.engine.handleResize(width, height);
                    }
                };
                updateCanvasSize();
                window.addEventListener('resize', updateCanvasSize);
                window.addEventListener('orientationchange', () => {
                    setTimeout(updateCanvasSize, 100);
                });
            }
            if (typeof Matter === 'undefined') {
                console.log('Loading Matter.js from CDN as fallback...');
                const script = document.createElement('script');
                script.src = 'https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js';
                script.onload = function() {
                    console.log('Matter.js loaded from CDN');
                    window.dispatchEvent(new Event('matter-loaded'));
                };
                document.head.appendChild(script);
            } else {
                window.dispatchEvent(new Event('matter-loaded'));
            }
        });

        document.addEventListener('DOMContentLoaded', function() {
            const startBtn = document.getElementById('start-game-btn');
            if (startBtn) {
                startBtn.addEventListener('click', function() {
                    startBtn.style.display = 'none';
                    const loadingScreen = document.getElementById('loading-screen');
                    if (loadingScreen) loadingScreen.style.display = 'none';
                    if (window.melodicode && window.melodicode.audioEngine && window.melodicode.audioEngine.context) {
                        window.melodicode.audioEngine.context.resume();
                    }
                    if (typeof initializeGame === 'function') {
                        initializeGame();
                    }
                });
            }

            // Load Game Button Logic
            const loadBtn = document.getElementById('load-game-btn');
            if (loadBtn) {
                loadBtn.addEventListener('click', function() {
                    showLoadGameDialog();
                });
            }
        });

        // Load Game Dialog
        function showLoadGameDialog() {
            const modal = document.createElement('div');
            modal.id = 'load-game-modal';
            modal.style.position = 'fixed';
            modal.style.top = '0'; modal.style.left = '0';
            modal.style.width = '100vw'; modal.style.height = '100vh';
            modal.style.background = 'rgba(0,0,0,0.85)';
            modal.style.display = 'flex'; modal.style.alignItems = 'center'; modal.style.justifyContent = 'center';
            modal.style.zIndex = '2000';

            // List local saves
            let saves = [];
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key.startsWith('dmjs_save_')) {
                    saves.push(key.replace('dmjs_save_', ''));
                }
            }

            // Build options string
            let optionsHtml = '';
            if (saves.length) {
                optionsHtml = saves.map(s => `<option value="${s}">${s}</option>`).join('');
            } else {
                optionsHtml = '<option>No saves found</option>';
            }

            modal.innerHTML = `
                <div style="background:#222;padding:32px;border-radius:16px;min-width:320px;max-width:90vw;">
                    <h2 style="color:#fff;">Load Game</h2>
                    <div>
                        <label style="color:#fff;">Local Saves:</label>
                        <select id="local-save-list" style="width:100%;margin-bottom:12px;">
                            ${optionsHtml}
                        </select>
                        <button id="load-local-btn" style="margin-right:8px;">Load Selected</button>
                        <button id="delete-local-btn" style="margin-right:8px;">Delete Selected</button>
                    </div>
                    <hr style="margin:16px 0;">
                    <div>
                        <label style="color:#fff;">Import Save File:</label>
                        <input type="file" id="import-save-file" accept=".json,.dmjs-save.json" style="margin-bottom:8px;">
                        <button id="import-file-btn">Import & Load</button>
                    </div>
                    <hr style="margin:16px 0;">
                    <button id="back-btn" style="margin-top:8px;">Back</button>
                </div>
            `;
            document.body.appendChild(modal);

            // Load local
            modal.querySelector('#load-local-btn').onclick = async () => {
                const sel = modal.querySelector('#local-save-list').value;
                if (window.engine && sel) {
                    await window.engine.loadGame(sel);
                    modal.remove();
                    document.getElementById('loading-screen').style.display = 'none';
                }
            };
            // Delete local
            modal.querySelector('#delete-local-btn').onclick = () => {
                const sel = modal.querySelector('#local-save-list').value;
                if (sel && confirm('Delete save "' + sel + '"?')) {
                    localStorage.removeItem('dmjs_save_' + sel);
                    modal.remove();
                    showLoadGameDialog();
                }
            };
            // Import file
            modal.querySelector('#import-file-btn').onclick = async () => {
                const fileInput = modal.querySelector('#import-save-file');
                if (fileInput.files.length) {
                    const file = fileInput.files[0];
                    if (window.engine) {
                        await window.engine.loadGame(file);
                        modal.remove();
                        document.getElementById('loading-screen').style.display = 'none';
                    }
                }
            };
            // Back button
            modal.querySelector('#back-btn').onclick = () => {
                modal.remove();
            };
        }
    </script>
    
    <style id="game-styles">
/* Full viewport coverage */
html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #000;
    font-family: Arial, sans-serif;
    overscroll-behavior: none;
}

/* Game container fills entire viewport */
#game-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
    background: #000;
    margin: 0;
    padding: 0;
}

/* Canvas fills the game container while maintaining aspect ratio */
#gameCanvas {
    display: block;
    background: #000;
    width: 100%;
    height: 100%;
    /* Remove fixed dimensions and let it fill container */
    max-width: 100vw;
    max-height: 100vh;
    /* Maintain aspect ratio */
    object-fit: contain;
    /* Center the canvas */
    margin: 0;
    /* Smooth scaling */
    image-rendering: auto;
}

/* For pixel-perfect games, use pixelated rendering */


/* Loading screen covers entire viewport */
#loading-screen {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: #000;
    color: #fff;
    display: flex;
    align-items: center;
    justify-content: center;
    font-family: Arial, sans-serif;
    z-index: 1000;
}

/* Prevent context menu and selection */
#gameCanvas {
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    -khtml-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;
    outline: none;
}

/* Mobile optimizations */
@media (max-width: 768px) {
    body {
        position: fixed;
        overflow: hidden;
        -webkit-overflow-scrolling: touch;
    }
    
    #gameCanvas {
        width: 100vw !important;
        height: 100vh !important;
    }
}

/* Orientation change handling */
@media screen and (orientation: portrait) {
    #game-container {
        flex-direction: column;
    }
}

@media screen and (orientation: landscape) {
    #game-container {
        flex-direction: row;
    }
}

/* Prevent scrolling */
body:focus {
    outline: none;
}

::-webkit-scrollbar {
    display: none;
}

html {
    -ms-overflow-style: none;
    scrollbar-width: none;
}

/* Enhanced loading screen */
#loading-screen {
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    background: #000000;
    color: #fff;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    font-family: Arial, sans-serif;
}
.loading-content {
    display: flex;
    flex-direction: column;
    align-items: center;
}
.loading-spinner {
    width: 48px;
    height: 48px;
    border: 6px solid transparent;
    border-top: 6px solid #922e99;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 16px;
}
@keyframes spin {
    0% { transform: rotate(0deg);}
    100% { transform: rotate(360deg);}
}
.loading-text {
    font-size: 1.2em;
    margin-bottom: 12px;
    letter-spacing: 1px;
}
.loading-progress-bar {
    width: 200px;
    height: 8px;
    background: #222;
    border-radius: 4px;
    overflow: hidden;
    margin-top: 8px;
}
.loading-progress {
    width: 0%;
    height: 100%;
    background: linear-gradient(90deg, #09f 0%, #0ff 100%);
    transition: width 0.3s;
}

/* Make the logo much larger and centered */
.loading-logo {
    display: block;
    margin: 0 auto 32px auto;
    max-width: 60vw;
    max-height: 60vh;
    width: auto;
    height: auto;
    object-fit: contain;
}

/* Stack loading text and spinner horizontally */
.loading-row {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 16px;
    gap: 24px;
}

/* Loading text styling */
.loading-text {
    font-size: 2em;
    margin: 0;
    letter-spacing: 1px;
    color: #fff;
}

/* Spinner next to text, not inside logo */
.loading-spinner {
    width: 48px;
    height: 48px;
    border: 6px solid transparent;
    border-top: 6px solid #922e99;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0;
}

#load-game-modal {
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    background: rgba(0,0,0,0.85);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 2000;
    font-family: 'Segoe UI', Arial, sans-serif;
}

#load-game-modal > div {
    background: #222;
    padding: 32px 40px;
    border-radius: 18px;
    min-width: 340px;
    max-width: 95vw;
    box-shadow: 0 8px 32px #000a;
    color: #fff;
}

#load-game-modal h2 {
    margin-top: 0;
    margin-bottom: 18px;
    font-size: 2em;
    font-weight: 700;
    letter-spacing: 1px;
    color:  #922e99;
}

#load-game-modal label {
    font-weight: 500;
    margin-bottom: 6px;
    display: block;
    color: #eee;
}

#load-game-modal select,
#load-game-modal input[type="file"] {
    width: 100%;
    padding: 8px 10px;
    border-radius: 8px;
    border: none;
    background: #333;
    color: #fff;
    margin-bottom: 10px;
    font-size: 1em;
}

#load-game-modal button {
    padding: 10px 24px;
    border-radius: 8px;
    border: none;
    background: #922e99;
    color: #fff;
    font-weight: 600;
    font-size: 1em;
    margin: 6px 4px 0 0;
    cursor: pointer;
    box-shadow: 0 2px 8px #4F8EF744;
    transition: background 0.2s, box-shadow 0.2s;
}

#load-game-modal button#back-btn {
    background: #444;
}

#load-game-modal button:hover {
    background: #922e99;
}

#load-game-modal hr {
    border: none;
    border-top: 1px solid #444;
    margin: 18px 0;
}

* Style the file input for the load game modal */
#load-game-modal input[type="file"] {
    background: #2d3e5c; /* Slightly darker than spinner color */
    color: #fff;
    border: none;
    border-radius: 8px;
    padding: 8px 10px;
    font-size: 1em;
    margin-bottom: 10px;
    box-shadow: 0 2px 8px #4F8EF744;
    transition: background 0.2s, box-shadow 0.2s;
}

#load-game-modal input[type="file"]:hover,
#load-game-modal input[type="file"]:focus {
    background: #22304a; /* Even darker on hover/focus */
    outline: none;
}

@media (max-width: 600px) {
    #load-game-modal > div {
        padding: 18px 8px;
        min-width: 90vw;
    }
    #load-game-modal h2 {
        font-size: 1.3em;
    }
}
</style>
    <script id="game-script">// Dark Matter JS Engine
// src/core/Math/Vector2.js
class Vector2 {
    constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
    }

    add(other) {
        return new Vector2(this.x + other.x, this.y + other.y);
    }

    subtract(other) {
        return new Vector2(this.x - other.x, this.y - other.y);
    }

    multiply(scalar) {
        return new Vector2(this.x * scalar, this.y * scalar);
    }

    magnitude() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }

    normalize() {
        const mag = this.magnitude();
        return mag === 0 ? new Vector2() : new Vector2(this.x / mag, this.y / mag);
    }

    distanceTo(other) {
        return Math.sqrt((this.x - other.x) ** 2 + (this.y - other.y) ** 2);
    }

    // Static constructors
    static zero() { return new Vector2(0, 0); }
    static one() { return new Vector2(1, 1); }
    static up() { return new Vector2(0, 1); }
    static down() { return new Vector2(0, -1); }
    static left() { return new Vector2(-1, 0); }
    static right() { return new Vector2(1, 0); }
    static fromAngle(angle) {
        return new Vector2(Math.cos(angle), Math.sin(angle));
    }

    static random() {
        return new Vector2(Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();
    }

    // Basic operations
    add(other) {
        return new Vector2(this.x + other.x, this.y + other.y);
    }

    subtract(other) {
        return new Vector2(this.x - other.x, this.y - other.y);
    }

    sub(other) {
        return new Vector2(this.x - other.x, this.y - other.y);
    }

    multiply(scalar) {
        return new Vector2(this.x * scalar, this.y * scalar);
    }

    divide(scalar) {
        if (scalar === 0) throw new Error("Division by zero");
        return new Vector2(this.x / scalar, this.y / scalar);
    }

    // Vector operations
    dot(other) {
        return this.x * other.x + this.y * other.y;
    }

    cross(other) {
        return this.x * other.y - this.y * other.x;
    }

    magnitude() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }

    magnitudeSquared() {
        return this.x * this.x + this.y * this.y;
    }

    normalize() {
        const mag = this.magnitude();
        return mag === 0 ? Vector2.zero() : this.divide(mag);
    }

    // Angle operations
    angle() {
        return Math.atan2(this.y, this.x);
    }

    rotate(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        return new Vector2(
            this.x * cos - this.y * sin,
            this.x * sin + this.y * cos
        );
    }

    // Utility methods
    distance(other) {
        return this.subtract(other).magnitude();
    }

    distanceSquared(other) {
        return this.subtract(other).magnitudeSquared();
    }

    lerp(other, t) {
        return new Vector2(
            this.x + (other.x - this.x) * t,
            this.y + (other.y - this.y) * t
        );
    }

    clamp(min, max) {
        return new Vector2(
            Math.min(Math.max(this.x, min.x), max.x),
            Math.min(Math.max(this.y, min.y), max.y)
        );
    }

    reflect(normal) {
        const dot = this.dot(normal);
        return this.subtract(normal.multiply(2 * dot));
    }

    project(other) {
        const normalized = other.normalize();
        return normalized.multiply(this.dot(normalized));
    }

    perpendicular() {
        return new Vector2(-this.y, this.x);
    }

    // Comparison methods
    equals(other, epsilon = 0.000001) {
        return Math.abs(this.x - other.x) < epsilon && 
               Math.abs(this.y - other.y) < epsilon;
    }

    // Conversion methods
    toString() {
        return `Vector2(${this.x}, ${this.y})`;
    }

    toArray() {
        return [this.x, this.y];
    }

    clone() {
        return new Vector2(this.x, this.y);
    }

    toJSON() {
        return { x: this.x, y: this.y };
    }

    // Public API methods
    static up() { return new Vector2(0, 1); }
    static down() { return new Vector2(0, -1); }
    static left() { return new Vector2(-1, 0); }
    static right() { return new Vector2(1, 0); }

    static zero() { return new Vector2(0, 0); }
    static one() { return new Vector2(1, 1); }
    
    static fromAngle(angle) {
        return new Vector2(Math.cos(angle), Math.sin(angle));
    }

    static forward() { return Vector2.up(); }
    static back() { return Vector2.down(); }

    static fromJSON(data) {
        if (!data) return Vector2.zero();
        return new Vector2(data.x ?? 0, data.y ?? 0);
    }
}

window.Vector2 = Vector2;

// src/core/Math/Vector3.js
/**
 * Vector3 - A 3D vector implementation for the Dark Matter JS engine
 */
class Vector3 {
    /**
     * Create a new Vector3
     * @param {number} x - X component
     * @param {number} y - Y component
     * @param {number} z - Z component
     */
    constructor(x = 0, y = 0, z = 0) {
        this.x = x;
        this.y = y;
        this.z = z;
    }

    /**
     * Clone this vector
     * @returns {Vector3} A new vector with the same values
     */
    clone() {
        return new Vector3(this.x, this.y, this.z);
    }

    /**
     * Add a vector to this one
     * @param {Vector3} v - Vector to add
     * @returns {Vector3} New vector with the result
     */
    add(v) {
        return new Vector3(this.x + v.x, this.y + v.y, this.z + v.z);
    }

    /**
     * Subtract a vector from this one
     * @param {Vector3} v - Vector to subtract
     * @returns {Vector3} New vector with the result
     */
    subtract(v) {
        return new Vector3(this.x - v.x, this.y - v.y, this.z - v.z);
    }

    /**
     * Multiply this vector by a scalar value
     * @param {number} scalar - Value to multiply by
     * @returns {Vector3} New vector with the result
     */
    multiply(scalar) {
        return new Vector3(this.x * scalar, this.y * scalar, this.z * scalar);
    }

    /**
     * Calculate the dot product of this vector and another
     * @param {Vector3} v - The other vector
     * @returns {number} The dot product
     */
    dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
    }

    /**
     * Calculate the cross product of this vector and another
     * @param {Vector3} v - The other vector
     * @returns {Vector3} New vector with the result
     */
    cross(v) {
        return new Vector3(
            this.y * v.z - this.z * v.y,
            this.z * v.x - this.x * v.z,
            this.x * v.y - this.y * v.x
        );
    }

    /**
     * Calculate the magnitude (length) of this vector
     * @returns {number} The magnitude
     */
    magnitude() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
    }

    /**
     * Normalize this vector (make it unit length)
     * @returns {Vector3} A new normalized vector
     */
    normalize() {
        const mag = this.magnitude();
        if (mag === 0) return this.clone();
        return new Vector3(this.x / mag, this.y / mag, this.z / mag);
    }

    /**
     * Convert this vector to a 2D vector by projecting onto XY plane
     * @returns {Vector2} 2D projection of this vector
     */
    toVector2() {
        return new Vector2(this.x, this.y);
    }

    /**
     * Create a Vector3 from a Vector2 by setting Z to 0
     * @param {Vector2} v2 - The 2D vector
     * @returns {Vector3} A new 3D vector
     */
    static fromVector2(v2, z = 0) {
        return new Vector3(v2.x, v2.y, z);
    }

    /**
     * Calculate the distance between this vector and another
     * @param {Vector3} v - The other vector
     * @returns {number} The distance
     */
    distance(v) {
        const dx = this.x - v.x;
        const dy = this.y - v.y;
        const dz = this.z - v.z;
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }

    /**
     * Rotate this vector around the X axis
     * @param {number} angle - Rotation angle in radians
     * @returns {Vector3} The rotated vector
     */
    rotateX(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const y = this.y * cos - this.z * sin;
        const z = this.y * sin + this.z * cos;
        return new Vector3(this.x, y, z);
    }

    /**
     * Rotate this vector around the Y axis
     * @param {number} angle - Rotation angle in radians
     * @returns {Vector3} The rotated vector
     */
    rotateY(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const x = this.x * cos + this.z * sin;
        const z = -this.x * sin + this.z * cos;
        return new Vector3(x, this.y, z);
    }

    /**
     * Rotate this vector around the Z axis
     * @param {number} angle - Rotation angle in radians
     * @returns {Vector3} The rotated vector
     */
    rotateZ(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const x = this.x * cos - this.y * sin;
        const y = this.x * sin + this.y * cos;
        return new Vector3(x, y, this.z);
    }

    /**
     * Convert to a string representation
     * @returns {string} String representation of the vector
     */
    toString() {
        return `(${this.x}, ${this.y}, ${this.z})`;
    }
}

// Make the Vector3 class available globally
window.Vector3 = Vector3;

// src/core/Math/CollisionSystem.js
/**
 * CollisionSystem - Handles collision detection between GameObjects
 */
class CollisionSystem {
    constructor() {
        // Store collisions from last frame for collision events
        this.lastFrameCollisions = new Set();
        this.currentFrameCollisions = new Set();
    }
    
    /**
     * Check if two bounding boxes are colliding
     * @param {Object} box1 - First bounding box {x, y, width, height, rotation}
     * @param {Object} box2 - Second bounding box {x, y, width, height, rotation}
     * @returns {boolean} True if the boxes are colliding
     */
    checkCollision(box1, box2) {
        // Handle axis-aligned bounding boxes (no rotation)
        if ((box1.rotation === 0 || box1.rotation === undefined) && 
            (box2.rotation === 0 || box2.rotation === undefined)) {
            return this.checkAABBCollision(box1, box2);
        }
        
        // Handle oriented bounding boxes (with rotation)
        return this.checkOBBCollision(box1, box2);
    }
    
    /**
     * Check collision between two axis-aligned bounding boxes
     * @param {Object} box1 - First AABB {x, y, width, height}
     * @param {Object} box2 - Second AABB {x, y, width, height}
     * @returns {boolean} True if colliding
     */
    checkAABBCollision(box1, box2) {
        // Calculate bounds for box1 (centered bounding box)
        const box1Left = box1.x - box1.width / 2;
        const box1Right = box1.x + box1.width / 2;
        const box1Top = box1.y - box1.height / 2;
        const box1Bottom = box1.y + box1.height / 2;
        
        // Calculate bounds for box2 (centered bounding box)
        const box2Left = box2.x - box2.width / 2;
        const box2Right = box2.x + box2.width / 2;
        const box2Top = box2.y - box2.height / 2;
        const box2Bottom = box2.y + box2.height / 2;
        
        // Check for overlap
        if (box1Right < box2Left || box1Left > box2Right ||
            box1Bottom < box2Top || box1Top > box2Bottom) {
            return false; // No overlap
        }
        
        return true; // Overlap exists
    }
    
    /**
     * Check collision between two oriented bounding boxes
     * @param {Object} box1 - First OBB {x, y, width, height, rotation}
     * @param {Object} box2 - Second OBB {x, y, width, height, rotation}
     * @returns {boolean} True if colliding
     */
    checkOBBCollision(box1, box2) {
        // Convert to polygon representation
        const polygon1 = this.boxToPolygon(box1);
        const polygon2 = this.boxToPolygon(box2);
        
        // Use Separating Axis Theorem (SAT) to check collision
        return this.checkSATCollision(polygon1, polygon2);
    }
    
    /**
     * Convert a bounding box to a polygon (array of vertices)
     * @param {Object} box - Bounding box {x, y, width, height, rotation}
     * @returns {Array} Array of vertices as Vector2 objects
     */
    boxToPolygon(box) {
        const halfWidth = box.width / 2;
        const halfHeight = box.height / 2;
        
        // Define corners relative to center
        const corners = [
            new Vector2(-halfWidth, -halfHeight),
            new Vector2(halfWidth, -halfHeight),
            new Vector2(halfWidth, halfHeight),
            new Vector2(-halfWidth, halfHeight)
        ];
        
        // Apply rotation and translation
        const rotationRad = (box.rotation || 0) * Math.PI / 180;
        return corners.map(corner => {
            return corner.rotate(rotationRad).add(new Vector2(box.x, box.y));
        });
    }
    
    /**
     * Check collision using Separating Axis Theorem
     * @param {Array} polygon1 - Array of Vector2 vertices
     * @param {Array} polygon2 - Array of Vector2 vertices
     * @returns {boolean} True if colliding
     */
    checkSATCollision(polygon1, polygon2) {
        // Get all axes to check
        const axes = this.getAxes(polygon1).concat(this.getAxes(polygon2));
        
        // Check projection overlap on each axis
        for (const axis of axes) {
            const projection1 = this.projectPolygon(polygon1, axis);
            const projection2 = this.projectPolygon(polygon2, axis);
            
            // If we found a separating axis, objects don't collide
            if (projection1.max < projection2.min || projection2.max < projection1.min) {
                return false;
            }
        }
        
        // No separating axis found, objects collide
        return true;
    }
    
    /**
     * Get all axes for Separating Axis Theorem check
     * @param {Array} polygon - Array of Vector2 vertices
     * @returns {Array} Array of Vector2 axes (normalized)
     */
    getAxes(polygon) {
        const axes = [];
        const vertexCount = polygon.length;
        
        for (let i = 0; i < vertexCount; i++) {
            // Get edge vector
            const p1 = polygon[i];
            const p2 = polygon[(i + 1) % vertexCount];
            const edge = p2.subtract(p1);
            
            // Get perpendicular axis (normal)
            const normal = new Vector2(-edge.y, edge.x).normalize();
            axes.push(normal);
        }
        
        return axes;
    }
    
    /**
     * Project a polygon onto an axis
     * @param {Array} polygon - Array of Vector2 vertices
     * @param {Vector2} axis - Axis to project onto
     * @returns {Object} Object with min and max projection values
     */
    projectPolygon(polygon, axis) {
        // Initialize with first vertex
        let min = polygon[0].dot(axis);
        let max = min;
        
        // Find min and max projections
        for (let i = 1; i < polygon.length; i++) {
            const projection = polygon[i].dot(axis);
            min = Math.min(min, projection);
            max = Math.max(max, projection);
        }
        
        return { min, max };
    }
    
    /**
     * Test collision between a ray and an object's bounding box
     * @param {Object} ray - Ray {origin: Vector2, direction: Vector2}
     * @param {Object} box - Bounding box {x, y, width, height, rotation}
     * @returns {Object|null} Hit information or null if no hit
     */
    raycast(ray, box) {
        if (box.rotation && box.rotation !== 0) {
            // Handle OBB (oriented bounding box)
            return this.raycastOBB(ray, box);
        } else {
            // Handle AABB (axis-aligned bounding box)
            return this.raycastAABB(ray, box);
        }
    }
    
    /**
     * Test collision between a ray and an axis-aligned bounding box
     * @param {Object} ray - Ray {origin: Vector2, direction: Vector2}
     * @param {Object} box - Box {x, y, width, height}
     * @returns {Object|null} Hit information or null if no hit
     */
    raycastAABB(ray, box) {
        // Calculate box bounds
        const minX = box.x - box.width / 2;
        const maxX = box.x + box.width / 2;
        const minY = box.y - box.height / 2;
        const maxY = box.y + box.height / 2;
        
        // Calculate ray parameters
        const rayOrigin = ray.origin;
        const rayDirection = ray.direction.normalize();
        
        // Calculate inverse direction to avoid division
        const invDirX = 1.0 / (rayDirection.x === 0 ? 0.00001 : rayDirection.x);
        const invDirY = 1.0 / (rayDirection.y === 0 ? 0.00001 : rayDirection.y);
        
        // Calculate intersection distances
        const t1 = (minX - rayOrigin.x) * invDirX;
        const t2 = (maxX - rayOrigin.x) * invDirX;
        const t3 = (minY - rayOrigin.y) * invDirY;
        const t4 = (maxY - rayOrigin.y) * invDirY;
        
        // Get min and max intersection distances
        const tMin = Math.max(Math.min(t1, t2), Math.min(t3, t4));
        const tMax = Math.min(Math.max(t1, t2), Math.max(t3, t4));
        
        // If tMax < 0, ray is intersecting box, but entire box is behind ray origin
        if (tMax < 0) {
            return null;
        }
        
        // If tMin > tMax, ray doesn't intersect box
        if (tMin > tMax) {
            return null;
        }
        
        // If tMin < 0, ray origin is inside the box
        const t = tMin < 0 ? tMax : tMin;
        
        // Calculate hit position and normal
        const hitPosition = rayOrigin.add(rayDirection.multiply(t));
        
        // Calculate hit normal based on which face was hit
        let normal;
        const epsilon = 0.001; // Small value for floating-point comparison
        
        if (Math.abs(hitPosition.x - minX) < epsilon) {
            normal = new Vector2(-1, 0); // Left face
        } else if (Math.abs(hitPosition.x - maxX) < epsilon) {
            normal = new Vector2(1, 0); // Right face
        } else if (Math.abs(hitPosition.y - minY) < epsilon) {
            normal = new Vector2(0, -1); // Top face
        } else {
            normal = new Vector2(0, 1); // Bottom face
        }
        
        return {
            distance: t,
            position: hitPosition,
            normal: normal
        };
    }
    
    /**
     * Test collision between a ray and an oriented bounding box
     * @param {Object} ray - Ray {origin: Vector2, direction: Vector2}
     * @param {Object} box - Box {x, y, width, height, rotation}
     * @returns {Object|null} Hit information or null if no hit
     */
    raycastOBB(ray, box) {
        // Convert to local space where OBB becomes AABB
        const rotationRad = -(box.rotation * Math.PI / 180);
        const boxCenter = new Vector2(box.x, box.y);
        
        // Transform ray to local space
        const localOrigin = ray.origin.subtract(boxCenter).rotate(rotationRad);
        const localDirection = ray.direction.rotate(rotationRad);
        
        // Create local space ray
        const localRay = {
            origin: localOrigin,
            direction: localDirection
        };
        
        // Create local space AABB
        const localBox = {
            x: 0,
            y: 0,
            width: box.width,
            height: box.height,
            rotation: 0
        };
        
        // Test against local space AABB
        const hit = this.raycastAABB(localRay, localBox);
        
        if (!hit) return null;
        
        // Transform hit back to world space
        const worldHitPos = hit.position.rotate(-rotationRad).add(boxCenter);
        const worldHitNormal = hit.normal.rotate(-rotationRad);
        
        return {
            distance: hit.distance,
            position: worldHitPos,
            normal: worldHitNormal
        };
    }
    
    /**
     * Update the collision system for the current frame
     * @param {Array} gameObjects - All active game objects
     */
    update(gameObjects) {
        // Store last frame's collisions
        this.lastFrameCollisions = new Set(this.currentFrameCollisions);
        this.currentFrameCollisions.clear();
        
        // Check collisions between all pairs of objects
        const objCount = gameObjects.length;
        
        for (let i = 0; i < objCount; i++) {
            const objA = gameObjects[i];
            
            if (!objA.active || !objA.collisionEnabled) continue;
            
            for (let j = i + 1; j < objCount; j++) {
                const objB = gameObjects[j];
                
                if (!objB.active || !objB.collisionEnabled) continue;
                
                // Skip collision check if they're on non-colliding layers
                if ((objA.collisionLayer & objB.collisionMask) === 0 && 
                    (objB.collisionLayer & objA.collisionMask) === 0) {
                    continue;
                }
                
                // Get bounding boxes
                const boxA = objA.getBoundingBox();
                const boxB = objB.getBoundingBox();
                
                // Check collision
                if (this.checkCollision(boxA, boxB)) {
                    // Create a unique identifier for this collision pair
                    const collisionId = `${objA.id}_${objB.id}`;
                    
                    // Store in current frame collisions
                    this.currentFrameCollisions.add(collisionId);
                    
                    // Check if this is a new collision (enter)
                    const isNewCollision = !this.lastFrameCollisions.has(collisionId);
                    
                    // Trigger collision events
                    if (isNewCollision) {
                        this.triggerCollisionEnter(objA, objB);
                    } else {
                        this.triggerCollisionStay(objA, objB);
                    }
                }
            }
        }
        
        // Check for collision exit events
        for (const collisionId of this.lastFrameCollisions) {
            if (!this.currentFrameCollisions.has(collisionId)) {
                // This collision was present last frame but not this frame
                const [idA, idB] = collisionId.split('_');
                
                // Find the objects by ID
                const objA = gameObjects.find(obj => obj.id === idA);
                const objB = gameObjects.find(obj => obj.id === idB);
                
                // Trigger exit event if objects still exist
                if (objA && objB) {
                    this.triggerCollisionExit(objA, objB);
                }
            }
        }
    }
    
    /**
     * Trigger collision enter event
     * @param {GameObject} objA - First object
     * @param {GameObject} objB - Second object
     */
    triggerCollisionEnter(objA, objB) {
        // Call event methods on both objects if they exist
        if (objA.onCollisionEnter) objA.onCollisionEnter(objB);
        if (objB.onCollisionEnter) objB.onCollisionEnter(objA);
        
        // Also trigger events on modules
        this.triggerModuleCollisionEvents(objA, objB, 'onCollisionEnter');
        this.triggerModuleCollisionEvents(objB, objA, 'onCollisionEnter');
    }
    
    /**
     * Trigger collision stay event
     * @param {GameObject} objA - First object
     * @param {GameObject} objB - Second object 
     */
    triggerCollisionStay(objA, objB) {
        if (objA.onCollisionStay) objA.onCollisionStay(objB);
        if (objB.onCollisionStay) objB.onCollisionStay(objA);
        
        this.triggerModuleCollisionEvents(objA, objB, 'onCollisionStay');
        this.triggerModuleCollisionEvents(objB, objA, 'onCollisionStay');
    }
    
    /**
     * Trigger collision exit event
     * @param {GameObject} objA - First object
     * @param {GameObject} objB - Second object
     */
    triggerCollisionExit(objA, objB) {
        if (objA.onCollisionExit) objA.onCollisionExit(objB);
        if (objB.onCollisionExit) objB.onCollisionExit(objA);
        
        this.triggerModuleCollisionEvents(objA, objB, 'onCollisionExit');
        this.triggerModuleCollisionEvents(objB, objA, 'onCollisionExit');
    }
    
    /**
     * Trigger collision events on modules
     * @param {GameObject} obj - Object with modules
     * @param {GameObject} other - Other colliding object
     * @param {string} eventName - Name of event to trigger
     */
    triggerModuleCollisionEvents(obj, other, eventName) {
        if (!obj.modules) return;
        
        obj.modules.forEach(module => {
            if (module.enabled && typeof module[eventName] === 'function') {
                try {
                    module[eventName](other);
                } catch (error) {
                    console.error(`Error in ${eventName} event for module ${module.type || module.constructor.name}:`, error);
                }
            }
        });
    }
}

// Create a global instance
window.collisionSystem = new CollisionSystem;

// src/core/Math/Raycast.js
/**
 * Raycast - Utility for raycasting in 2D space
 */
class Raycast {
    /**
     * Cast a ray against all objects in the scene
     * @param {Vector2} origin - Starting point of the ray
     * @param {Vector2} direction - Direction of the ray
     * @param {number} [maxDistance=Infinity] - Maximum distance to check
     * @param {Array} [gameObjects=[]] - GameObjects to check against
     * @param {number} [layerMask=0xFFFF] - Layer mask for filtering objects
     * @param {GameObject} [ignoreObject=null] - Object to ignore during raycast (usually the caller)
     * @returns {Object|null} Hit information or null if no hit
     */
    static cast(origin, direction, maxDistance = Infinity, gameObjects = window.engine.gameObjects ? window.engine.gameObjects : [], 
        layerMask = 0xFFFF, ignoreObject = null) {
        // Normalize the direction
        const normalizedDirection = direction.normalize();
        
        // Create the ray
        const ray = {
            origin: origin,
            direction: normalizedDirection
        };
        
        // Variables to track the closest hit
        let closestHit = null;
        let closestDistance = maxDistance;
        let hitObject = null;
        
        // Check all active game objects
        for (const obj of gameObjects) {
            if (!obj.active || !obj.collisionEnabled) {
                continue;
            }
            
            // Skip the ignored object (usually the caller)
            if (ignoreObject && obj === ignoreObject) {
                continue;
            }
            
            // Apply layer mask filtering
            if ((obj.collisionLayer & layerMask) === 0) {
                continue;
            }
            
            let hit = null;
            
            // Priority 1: Check Matter.js RigidBody collision if available
            const rigidbodyModule = obj.getModule('RigidBody');
            if (rigidbodyModule && rigidbodyModule.body && window.physicsManager) {
                // Additional check: if ignoreObject has a rigidbody, skip bodies that match
                if (ignoreObject) {
                    const ignoreRigidbody = ignoreObject.getModule('RigidBody');
                    if (ignoreRigidbody && ignoreRigidbody.body === rigidbodyModule.body) {
                        continue;
                    }
                }
                hit = this.raycastMatterBody(ray, rigidbodyModule.body, maxDistance);
            }
            
            // Priority 2: Check polygon collision if enabled and no Matter.js hit
            if (!hit && obj.usePolygonCollision && obj.polygon) {
                hit = this.raycastPolygon(ray, obj.polygon, maxDistance);
            }
            
            // Priority 3: Check rectangle collision if enabled and no previous hit
            if (!hit && obj.useCollisions) {
                const box = obj.getBoundingBox();
                hit = this.raycastRectangle(ray, box, maxDistance);
            }
            
            // If we hit something and it's closer than previous hits
            if (hit && hit.distance < closestDistance) {
                closestHit = hit;
                closestDistance = hit.distance;
                hitObject = obj;
            }
        }
        
        // Return null if no hit found
        if (!closestHit) {
            return null;
        }
        
        // Add the hit object to the result
        closestHit.object = hitObject;
        
        return closestHit;
    }
    
    /**
     * Cast a ray and return all objects that are hit
     * @param {Vector2} origin - Starting point of the ray
     * @param {Vector2} direction - Direction of the ray
     * @param {number} [maxDistance=Infinity] - Maximum distance to check
     * @param {Array} [gameObjects=[]] - GameObjects to check against
     * @param {number} [layerMask=0xFFFF] - Layer mask for filtering objects
     * @param {GameObject} [ignoreObject=null] - Object to ignore during raycast (usually the caller)
     * @returns {Array} Array of hit information
     */
    static castAll(origin, direction, maxDistance = Infinity, gameObjects = [], layerMask = 0xFFFF, ignoreObject = null) {
        // Normalize the direction
        const normalizedDirection = direction.normalize();
        
        // Create the ray
        const ray = {
            origin: origin,
            direction: normalizedDirection
        };
        
        // Array to store all hits
        const hits = [];
        
        // Check all active game objects
        for (const obj of gameObjects) {
            if (!obj.active || (!obj.useCollisions && !obj.usePolygonCollision) || obj !== this.gameObject) {
                continue;
            }
            
            // Skip the ignored object (usually the caller)
            if (ignoreObject && obj === ignoreObject) {
                continue;
            }
            
            // Apply layer mask filtering
            if ((obj.collisionLayer & layerMask) === 0) {
                continue;
            }
            
            let hit = null;
            
            // Priority 1: Check Matter.js RigidBody collision if available
            const rigidbodyModule = obj.getModule('RigidBody');
            if (rigidbodyModule && rigidbodyModule.body && window.physicsManager) {
                // Additional check: if ignoreObject has a rigidbody, skip bodies that match
                if (ignoreObject) {
                    const ignoreRigidbody = ignoreObject.getModule('RigidBody');
                    if (ignoreRigidbody && ignoreRigidbody.body === rigidbodyModule.body) {
                        continue;
                    }
                }
                hit = this.raycastMatterBody(ray, rigidbodyModule.body, maxDistance);
            }
            
            // Priority 2: Check polygon collision if enabled and no Matter.js hit
            if (!hit && obj.usePolygonCollision && obj.polygon) {
                hit = this.raycastPolygon(ray, obj.polygon, maxDistance);
            }
            
            // Priority 3: Check rectangle collision if enabled and no previous hit
            if (!hit && obj.useCollisions) {
                const box = obj.getBoundingBox();
                hit = this.raycastRectangle(ray, box, maxDistance);
            }
            
            // If we hit something within the max distance
            if (hit && hit.distance <= maxDistance) {
                // Add the hit object to the result
                hit.object = obj;
                hits.push(hit);
            }
        }
        
        // Sort hits by distance
        hits.sort((a, b) => a.distance - b.distance);
        
        return hits;
    }
    
    /**
     * Perform raycast against a Matter.js physics body
     * @param {Object} ray - Ray with origin and direction
     * @param {Matter.Body} body - Matter.js body to test against
     * @param {number} maxDistance - Maximum distance to check
     * @returns {Object|null} Hit information or null
     */
    static raycastMatterBody(ray, body, maxDistance) {
        // Create a very long line segment from the ray
        const endPoint = {
            x: ray.origin.x + ray.direction.x * maxDistance,
            y: ray.origin.y + ray.direction.y * maxDistance
        };
        
        // Test ray against body vertices
        const vertices = body.vertices;
        let closestHit = null;
        let closestDistance = maxDistance;
        
        // Check each edge of the body
        for (let i = 0; i < vertices.length; i++) {
            const v1 = vertices[i];
            const v2 = vertices[(i + 1) % vertices.length];
            
            const intersection = this.lineLineIntersection(
                ray.origin, endPoint,
                v1, v2
            );
            
            if (intersection) {
                const distance = Math.sqrt(
                    Math.pow(intersection.x - ray.origin.x, 2) +
                    Math.pow(intersection.y - ray.origin.y, 2)
                );
                
                if (distance < closestDistance && distance > 0.001) { // Small epsilon to avoid self-intersection
                    closestDistance = distance;
                    
                    // Calculate normal for this edge
                    const edgeVector = { x: v2.x - v1.x, y: v2.y - v1.y };
                    const normal = {
                        x: -edgeVector.y,
                        y: edgeVector.x
                    };
                    const normalLength = Math.sqrt(normal.x * normal.x + normal.y * normal.y);
                    normal.x /= normalLength;
                    normal.y /= normalLength;
                    
                    // Ensure normal points outward
                    const centerToHit = {
                        x: intersection.x - body.position.x,
                        y: intersection.y - body.position.y
                    };
                    if (normal.x * centerToHit.x + normal.y * centerToHit.y < 0) {
                        normal.x = -normal.x;
                        normal.y = -normal.y;
                    }
                    
                    closestHit = {
                        position: new Vector2(intersection.x, intersection.y),
                        normal: new Vector2(normal.x, normal.y),
                        distance: distance
                    };
                }
            }
        }
        
        return closestHit;
    }
    
    /**
     * Perform raycast against a polygon
     * @param {Object} ray - Ray with origin and direction
     * @param {Polygon} polygon - Polygon to test against
     * @param {number} maxDistance - Maximum distance to check
     * @returns {Object|null} Hit information or null
     */
    static raycastPolygon(ray, polygon, maxDistance) {
        if (!polygon || !polygon.points) return null;
        
        const endPoint = {
            x: ray.origin.x + ray.direction.x * maxDistance,
            y: ray.origin.y + ray.direction.y * maxDistance
        };
        
        let closestHit = null;
        let closestDistance = maxDistance;
        
        // Check each edge of the polygon
        for (let i = 0; i < polygon.points.length; i++) {
            const p1 = polygon.points[i];
            const p2 = polygon.points[(i + 1) % polygon.points.length];
            
            const intersection = this.lineLineIntersection(
                ray.origin, endPoint,
                p1, p2
            );
            
            if (intersection) {
                const distance = Math.sqrt(
                    Math.pow(intersection.x - ray.origin.x, 2) +
                    Math.pow(intersection.y - ray.origin.y, 2)
                );
                
                if (distance < closestDistance && distance > 0.001) {
                    closestDistance = distance;
                    
                    // Calculate normal for this edge
                    const edgeVector = { x: p2.x - p1.x, y: p2.y - p1.y };
                    const normal = {
                        x: -edgeVector.y,
                        y: edgeVector.x
                    };
                    const normalLength = Math.sqrt(normal.x * normal.x + normal.y * normal.y);
                    normal.x /= normalLength;
                    normal.y /= normalLength;
                    
                    // Ensure normal points outward (toward ray origin)
                    const centerToHit = {
                        x: intersection.x - polygon.position.x,
                        y: intersection.y - polygon.position.y
                    };
                    if (normal.x * centerToHit.x + normal.y * centerToHit.y < 0) {
                        normal.x = -normal.x;
                        normal.y = -normal.y;
                    }
                    
                    closestHit = {
                        position: new Vector2(intersection.x, intersection.y),
                        normal: new Vector2(normal.x, normal.y),
                        distance: distance
                    };
                }
            }
        }
        
        return closestHit;
    }
    
    /**
     * Perform raycast against a rectangle bounding box
     * @param {Object} ray - Ray with origin and direction
     * @param {Object} box - Bounding box with x, y, width, height, rotation
     * @param {number} maxDistance - Maximum distance to check
     * @returns {Object|null} Hit information or null
     */
    static raycastRectangle(ray, box, maxDistance) {
        // Create rectangle corners
        const halfWidth = box.width / 2;
        const halfHeight = box.height / 2;
        const centerX = box.x + halfWidth;
        const centerY = box.y + halfHeight;
        
        let corners = [
            { x: -halfWidth, y: -halfHeight },
            { x: halfWidth, y: -halfHeight },
            { x: halfWidth, y: halfHeight },
            { x: -halfWidth, y: halfHeight }
        ];
        
        // Apply rotation if present
        if (box.rotation && box.rotation !== 0) {
            const cos = Math.cos(box.rotation * Math.PI / 180);
            const sin = Math.sin(box.rotation * Math.PI / 180);
            
            corners = corners.map(corner => ({
                x: centerX + (corner.x * cos - corner.y * sin),
                y: centerY + (corner.x * sin + corner.y * cos)
            }));
        } else {
            corners = corners.map(corner => ({
                x: centerX + corner.x,
                y: centerY + corner.y
            }));
        }
        
        const endPoint = {
            x: ray.origin.x + ray.direction.x * maxDistance,
            y: ray.origin.y + ray.direction.y * maxDistance
        };
        
        let closestHit = null;
        let closestDistance = maxDistance;
        
        // Check each edge of the rectangle
        for (let i = 0; i < corners.length; i++) {
            const p1 = corners[i];
            const p2 = corners[(i + 1) % corners.length];
            
            const intersection = this.lineLineIntersection(
                ray.origin, endPoint,
                p1, p2
            );
            
            if (intersection) {
                const distance = Math.sqrt(
                    Math.pow(intersection.x - ray.origin.x, 2) +
                    Math.pow(intersection.y - ray.origin.y, 2)
                );
                
                if (distance < closestDistance && distance > 0.001) {
                    closestDistance = distance;
                    
                    // Calculate normal for this edge
                    const edgeVector = { x: p2.x - p1.x, y: p2.y - p1.y };
                    const normal = {
                        x: -edgeVector.y,
                        y: edgeVector.x
                    };
                    const normalLength = Math.sqrt(normal.x * normal.x + normal.y * normal.y);
                    normal.x /= normalLength;
                    normal.y /= normalLength;
                    
                    // Ensure normal points outward
                    const centerToHit = {
                        x: intersection.x - centerX,
                        y: intersection.y - centerY
                    };
                    if (normal.x * centerToHit.x + normal.y * centerToHit.y < 0) {
                        normal.x = -normal.x;
                        normal.y = -normal.y;
                    }
                    
                    closestHit = {
                        position: new Vector2(intersection.x, intersection.y),
                        normal: new Vector2(normal.x, normal.y),
                        distance: distance
                    };
                }
            }
        }
        
        return closestHit;
    }
    
    /**
     * Find intersection point between two line segments
     * @param {Object} line1Start - Start point of first line
     * @param {Object} line1End - End point of first line
     * @param {Object} line2Start - Start point of second line
     * @param {Object} line2End - End point of second line
     * @returns {Object|null} Intersection point or null
     */
    static lineLineIntersection(line1Start, line1End, line2Start, line2End) {
        const x1 = line1Start.x, y1 = line1Start.y;
        const x2 = line1End.x, y2 = line1End.y;
        const x3 = line2Start.x, y3 = line2Start.y;
        const x4 = line2End.x, y4 = line2End.y;
        
        const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        if (Math.abs(denom) < 1e-10) return null; // Lines are parallel
        
        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
        const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denom;
        
        // Check if intersection occurs within both line segments
        if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
            return {
                x: x1 + t * (x2 - x1),
                y: y1 + t * (y2 - y1)
            };
        }
        
        return null;
    }
    
    /**
     * Draw a ray in the scene for debugging
     * @param {CanvasRenderingContext2D} ctx - Canvas rendering context
     * @param {Vector2} origin - Starting point of the ray
     * @param {Vector2} direction - Direction of the ray
     * @param {number} [length=100] - Length of the ray to draw
     * @param {string} [color='#ff0000'] - Color of the ray
     * @param {boolean} [showHit=true] - Whether to show hit information
     * @param {Array} [gameObjects=[]] - GameObjects to check against
     * @param {GameObject} [ignoreObject=null] - Object to ignore during raycast
     */
    static drawRay(ctx, origin, direction, length = 100, color = '#ff0000', showHit = true, gameObjects = [], ignoreObject = null) {
        // Draw the ray line
        ctx.beginPath();
        ctx.moveTo(origin.x, origin.y);
        
        // If we want to show hit information and have objects to check against
        if (showHit && gameObjects.length > 0) {
            const hit = Raycast.cast(origin, direction, length, gameObjects, 0xFFFF, ignoreObject);
            
            if (hit) {
                // Draw line to hit point
                ctx.lineTo(hit.position.x, hit.position.y);
                ctx.strokeStyle = color;
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Draw hit point
                ctx.beginPath();
                ctx.arc(hit.position.x, hit.position.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = '#ffcc00';
                ctx.fill();
                
                // Draw normal vector
                ctx.beginPath();
                ctx.moveTo(hit.position.x, hit.position.y);
                ctx.lineTo(
                    hit.position.x + hit.normal.x * 10,
                    hit.position.y + hit.normal.y * 10
                );
                ctx.strokeStyle = '#00ccff';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                return;
            }
        }
        
        // If no hit, or not showing hit, draw the full ray
        const endPoint = origin.add(direction.normalize().multiply(length));
        ctx.lineTo(endPoint.x, endPoint.y);
        ctx.strokeStyle = color;
        ctx.lineWidth = 1;
        ctx.stroke();
    }
}

// Make Raycast available globally
window.Raycast = Raycast;

// src/core/Math/MatterMath.js
class MatterMath {
    constructor() {
        this.timescale = 1; // Timescale variable
    }

    /*
      Some basic and advanced math functions
    */
    //this.time = time();

    // We all know what pi() is
    pi() {
        return (Math.PI); // PI
    }

    pi2() {
        return (Math.PI * 2);
    }

    // Get the current time in a long number
    time() {
        return (new Date().getTime()); // Get the current time, can be good for random number functions
    }

    // Delta time. Set a floating number to change the rate at which delta time is calculated(0.1 is default)
    dt(rate = 0.1) {
        return ((1000 / 60) * this.timescale * rate);
    }

    setTimescale(timescale) {
        this.timescale = timescale;
    }

    getTimescale() {
        return (this.timescale);
    }

    ts() {
        return (this.timescale);
    }

    // ARRAY STUFF

    // Create a new list
    listCreate() {
        var arr = [];

        return (arr);
    }

    // Add to the list
    listAdd(id, value) {
        id.push(value);
    }

    // Set an item to a certain value in the list
    listSet(id, pos, value) {
        id[pos] = value;
    }

    // Get the value of an item in the list
    listGet(id, pos) {
        return (id[pos]);
    }

    // Create and initialize a 2d array
    array2dCreate(width, height, defaultValue) {
        var arr = [];

        for (var i = 0; i < width; i += 1) {
            for (var j = 0; j < height; j += 1) {
                arr.push([i, j]);
                arr[i][j] = defaultValue;
            }
        }

        return (arr);
    }

    // Set the value of the 2d array
    array2dSet(array, x, y, value) {
        array[x][y] = value;
    }

    // Get the value of the 2d array
    array2dGet(array, x, y) {
        return (array[x][y]);
    }

    // Create and initialize a 2d array
    array3dCreate(width, height, depth, defaultValue) {
        var arr = [];

        for (var i = 0; i < width; i += 1) {
            for (var j = 0; j < height; j += 1) {
                for (var f = 0; f < depth; f += 1) {
                    arr.push([i, j, f]);
                    arr[i][j][f] = defaultValue;
                }
            }
        }

        return (arr);
    }

    // Set the value of the 2d array
    array3dSet(array, x, y, z, value) {
        array[x][y][z] = value;
    }

    // Get the value of the 2d array
    array3dGet(array, x, y, z) {
        return (array[x][y][z]);
    }

    // Clear the array
    arrayClear(array) {
        array = [];

        return (array);
    }

    // MATH STUFF

    // Returns the cosine of a number from degrees to radians
    dcos(x) {
        return (Math.cos(this.degtorad(x)));
    }

    // Returns degrees to radians
    degtorad2 = function () {
        return ((this.pi() * 2) / -360);
    }

    // Returns degrees to radians
    degtorad(x) {
        return (x * this.pi() / 180);
    }

    // Returns radians to degrees
    radtodeg(x) {
        return (x * 180 / this.pi());
    }

    // Snap a position to a grid position. Position being for example, an x or y position
    snap(position, grid_size) {
        return (floor(position / grid_size) * grid_size);
    }

    // Return the distance between 2 points
    pointDistance(x1, y1, x2, y2) {
        var a = (x1) - (x2);
        var b = (y1) - (y2);
        return (Math.sqrt((a * a) + (b * b)));
    }

    // Return the direction from one point to another
    pointDirection(x1, y1, x2, y2) {
        var xdiff = (x2) - x1;
        var ydiff = (y2) - y1;

        return (-(Math.atan2(ydiff, xdiff) * 180.0 / Math.PI));
    }

    angleDifference(angle1, angle2) {
        // Normalize angles to the range [0, 360)
        const normalizedAngle1 = (angle1 % 360 + 360) % 360;
        const normalizedAngle2 = (angle2 % 360 + 360) % 360;

        // Calculate the absolute difference
        let diff = Math.abs(normalizedAngle1 - normalizedAngle2);

        // Ensure the result is within the range [0, 180)
        if (diff > 180) {
            diff = 360 - diff;
        }

        return diff;
    }

    // Returns the length and direction on the x axis
    lengthDirX(length, direction) {
        return (length * Math.cos(direction * this.degtorad2()));
    }

    // Returns the length and direction on the y axis
    lengthDirY(length, direction) {
        return (length * Math.sin(direction * this.degtorad2()));
    }

    // Lerp a value towards another value
    lerp(from, to, amount) {
        return (from + amount * (to - from));
    }

    // Returns a random floating point from 1 to max value
    random(max) {
        return ((Math.random() * max) + 1);
    }

    // Returns a random floating point from min to max value
    randomRange(min, max) {
        return (Math.random() * (max - min) + min);
    }

    // Returns a random integer from 1 to max value
    irandom(max) {
        return (Math.floor((Math.random() * max) + 1));
    }

    // Returns a random integer from min to max value
    irandomRange(min, max) {
        return (Math.floor(Math.random() * (max - min) + min));
    }

    // Returns either true or false
    randomBool() {
        return (Math.random() >= 0.5);
    }

    // Choose a random item out of a bunch of given items
    choose(...items) {
        if (items.length === 0) {
            throw new Error('No items provided to choose from.');
        }
        const randomIndex = Math.floor(Math.random() * items.length);

        return items[randomIndex];
    }

    // Replace every occurance of a string inside another string
    stringReplaceAll(str, find, replace) {
        return (str.replace(new RegExp(escapeRegExp(find), 'g'), replace));
    }

    // Returns a value to a string
    toString(val) {
        return (val.toString());
    }

    // Converts a string to an integer
    toInt(val) {
        return (parseInt(val));
    }

    // Returns a value pulsing at the rate of delay to a maximum number
    /*
        var red = pulse(10, 255);
    */
    sine(delay, max) {
        var time = this.time();
        var val = Math.sin(time / delay) * max;

        return (val);
    }

    // Returns a value pulsing at the rate of delay from 0 to a maximum number
    sinePositive(delay, max) {
        var val = Math.sin(this.time() / delay) * max;
        return (keepPositive(val));
    }

    // Returns a value pulsing at the rate of delay from 0 to a maximum number
    sineNegative(delay, max) {
        var val = Math.sin(this.time() / delay) * max;
        return (keepNegative(val));
    }

    // Linear interpolation function
    interpolate(start, end, t) {
        return start + (end - start) * t;
    }

    // Smoothstep interpolation function
    smoothstep(t) {
        return t * t * (3 - 2 * t);
    }

    // Sine interpolation function
    sineInterpolation(t) {
        return 0.5 - 0.5 * Math.cos(Math.PI * t);
    }

    // Clamp a value to a max and min value
    clamp(value, min, max) {
        if (value > max) { value = max; }
        if (value < min) { value = min; }

        return (value);
    }

    // Return a number that is always positive
    keepPositive(x) {
        if (x < 0) {
            x *= -1;
        }

        return (x);
    }

    // Return a number that is always negative
    keepNegative(x) {
        if (x > 0) {
            x *= -1;
        }

        return (x);
    }

    // Rotate an angle smoothly towards another angle
    rotateSmooth(direction, targetDirection, speed) {
        let delta = targetDirection - direction;

        delta = ((delta + 360) % 360 - 180);

        const rotateDirection = delta > 0 ? 1 : -1;

        let rotationAmount = rotateDirection * Math.min(Math.abs(delta), speed);

        direction = ((direction + (rotationAmount + 360)) % 360);
        //console.log(direction);

        return (direction);
    }

    // Execute javascript code from a string
    executeString(string) {
        try {
            eval(string);
        } catch (error) {
            console.error("Error executing string:", error);
        }
    }

    // Get color from rgb color values
    rgb(r, g, b) {
        r = Math.floor(r);
        g = Math.floor(g);
        b = Math.floor(b);
        return ["rgb(", r, ",", g, ",", b, ")"].join("");
    }

    hsl(h, s, l) {
        r = Math.floor(h);
        g = Math.floor(s) * 100;
        b = Math.floor(l) * 100;
        return ["hsl(", r, ",", g, "%,", b, "%)"].join("");
    }
}

window.MatterMath = new MatterMath(); // Make available globally
window.matterMath = new MatterMath(); // Make available globally

// src/core/Math/Polygon.js
class Polygon {
  constructor(parent, position, ...vectors) {
    this.vertices = vectors.map(v => v.sub(position)); // Local coordinates of vertices
    this.position = position; // Position of the parent object
    this.rotation = 0; // Rotation angle in radians

    this.math = new MatterMath();

    this.parent = parent; // Parent object

    this.originalVertices = this.vertices;
  }

  projectOntoAxis(axis) {
    let min = Infinity;
    let max = -Infinity;

    this.vertices.forEach(vertex => {
      const globalVertex = vertex.add(this.position);
      const projection = vertex.x * axis.x + vertex.y * axis.y;
      min = Math.min(min, projection);
      max = Math.max(max, projection);
    });

    return ({ min, max });
  }

  collidesWith(otherPolygon) {
    if (this === otherPolygon) {
      return false;
    }

    const axes = this.getAxes().concat(otherPolygon.getAxes());

    for (let axis of axes) {
      const projection1 = this.projectOntoAxis(axis);
      const projection2 = otherPolygon.projectOntoAxis(axis);

      if (projection1.max < projection2.min || projection2.max < projection1.min) {
        // No collision
        return false;
      }
    }


    // Collision detected
    return true;
  }

  // Check if a point is within this polygon
  collisionPoint(x, y) {
    const polygon = this;
    let inside = false;

    for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
      const xi = polygon[i][0];
      const yi = polygon[i][1];
      const xj = polygon[j][0];
      const yj = polygon[j][1];

      const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
      if (intersect) {
        inside = !inside;
      }
    }

    return inside;
  }

  // Snaps the parent objects position back to the edge of the other polygon
  snapPositionBack(otherPolygon) {
    const mtv = this.calculateMTV(otherPolygon);
    if (mtv) {
      // Move the parent object by the negative of the MTV
      this.parent.x -= mtv.x;
      this.parent.y -= mtv.y;
    }
  }

  easePositionBack(otherPolygon, steps = 10) {
    const mtv = this.calculateMTV(otherPolygon);
    const stepSize = { x: mtv.x / steps, y: mtv.y / steps };

    for (let i = 0; i < steps; i++) {
      this.parent.x -= stepSize.x;
      this.parent.y -= stepSize.y;
      // Update the game/rendering logic here
    }
  }

  calculateMTV(otherPolygon) {
    let minOverlap = Infinity;
    let mtv = { x: 0, y: 0 };

    // Iterate over all edges (axes) of both polygons
    const axes = this.getAxes().concat(otherPolygon.getAxes());
    for (const axis of axes) {
      const projection1 = this.projectOntoAxis(axis);
      const projection2 = otherPolygon.projectOntoAxis(axis);

      // Check for overlap (collision)
      const overlap = Math.min(projection1.max, projection2.max) - Math.max(projection1.min, projection2.min);
      if (overlap < 0) {
        // No overlap on this axis, no collision
        return null;
      }

      // Keep track of the smallest overlap (MTV)
      if (overlap < minOverlap) {
        minOverlap = overlap;
        mtv = { x: axis.x * overlap, y: axis.y * overlap }; // Create a new vector
      }
    }

    return mtv;
  }

  // Check for a collision between a line and this polygon
  collisionLine(x1, y1, x2, y2) {
    const polygon = this;

    // Check if both line endpoints are inside the polygon
    if (this.collisionPoint(x1, y1) || this.collisionLine(x2, y2)) {
      return true;
    }

    // Check if the line intersects any polygon edge
    for (let i = 0; i < polygon.length; i++) {
      const x3 = polygon[i][0];
      const y3 = polygon[i][1];
      const x4 = polygon[(i + 1) % polygon.length][0];
      const y4 = polygon[(i + 1) % polygon.length][1];

      if (this.collisionLineLine(x1, y1, x2, y2, x3, y3, x4, y4)) {
        return true;
      }
    }

    return false;
  }

  // Check for a collision between a line and this polygon
  collisionLineLine(x1, y1, x2, y2, x3, y3, x4, y4) {
    const polygon = this;

    // Calculate the direction vectors of the lines
    const dx1 = x2 - x1;
    const dy1 = y2 - y1;
    const dx2 = x4 - x3;
    const dy2 = y4 - y3;

    // Calculate determinants
    const det = dx1 * dy2 - dx2 * dy1;
    const detInv = 1 / det;

    // Check if lines are parallel (det === 0)
    if (Math.abs(det) < 1e-6) {
      return false;
    }

    // Calculate intersection point
    const t1 = (x3 - x1) * dy2 - (y3 - y1) * dx2;
    const t2 = (x3 - x1) * dy1 - (y3 - y1) * dx1;
    const tIntersect1 = t1 * detInv;
    const tIntersect2 = t2 * detInv;

    // Check if intersection point lies within both line segments
    if (tIntersect1 >= 0 && tIntersect1 <= 1 && tIntersect2 >= 0 && tIntersect2 <= 1) {
      return true;
    }

    return false;
  }

  getAxes() {
    const axes = [];
    for (let i = 0; i < this.vertices.length; i++) {
      const p1 = this.vertices[i];
      const p2 = this.vertices[i + 1 === this.vertices.length ? 0 : i + 1];
      const edge = (new Vector2(p2.x - p1.x, p2.y - p1.y));
      const normal = (new Vector2(-edge.y, edge.x));
      const length = Math.sqrt(normal.x * normal.x + normal.y * normal.y);
      const norm = new Vector2(normal.x / length, normal.y / length);
      axes.push(norm);
    }
    return axes;
  }

  update(position, rotation) {
    this.position = position;
    const r = rotation % 360;
    this.rotation = this.math.degtorad(r);

    const cos = Math.cos(this.rotation);
    const sin = Math.sin(this.rotation);

    this.vertices = this.originalVertices.map(vertex => {
      const rotatedX = cos * vertex.x - sin * vertex.y;
      const rotatedY = sin * vertex.x + cos * vertex.y;

      // console.log(rotatedX);

      return (new Vector2(rotatedX + this.position.x, rotatedY + this.position.y));
    });
  }

  // Preset shapes
  static rectangle(position, width, height, parent) {
    return (new Polygon(parent, position, new Vector2(position.x - (width), position.y - (height)),
      new Vector2(position.x + (width), position.y - (height)),
      new Vector2(position.x + (width), position.y + (height)),
      new Vector2(position.x - (width), position.y + (height))
    ));
  }

  // A rounded shape with resolution as the number of points, at a position for the center point and a radius size
  static round(position, resolution, radius, parent) {
    const vertices = [];
    for (let i = 0; i < resolution; i++) {
      const angle = (i / resolution) * 2 * Math.PI;

      const x = position.x + radius * Math.cos(angle);
      const y = position.y + radius * Math.sin(angle);

      vertices.push(new Vector2(x, y));
    }

    return (new Polygon(parent, position, ...vertices));
  }

  draw(ctx, color) {
    ctx.save();
    ctx.strokeStyle = color || "white";
    ctx.beginPath();
    for (let i = 0; i < this.vertices.length; i++) {
      const v = this.vertices[i];
      const to = this.vertices[(i + 1) % this.vertices.length];
      if (i === 0) {
        ctx.moveTo(v.x, v.y);
      }
      ctx.lineTo(to.x, to.y);
    }
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
  }

  toJSON() {
    return {
      x: this.position.x,
      y: this.position.y,
      position: { x: this.position.x, y: this.position.y },
      rotation: this.rotation,
      vertices: this.vertices.map(v => ({ x: v.x, y: v.y }))
    };
  }
}

window.Polygon = Polygon;

// src/webgl-canvas.js
/**
 * WebGLCanvas - A WebGL-powered canvas with HTML5 Canvas-like API
 * Easy to use, GPU-accelerated 2D graphics library with optimized batching
 */
class WebGLCanvas {
    constructor(canvas, options = {}, useWebGL = true) {
        this.canvas = canvas;
        this.useWebGL = useWebGL;

        // Handle pixel scaling options
        this.options = {
            enableFullscreen: options.enableFullscreen || false,
            pixelWidth: options.pixelWidth || canvas.width,
            pixelHeight: options.pixelHeight || canvas.height,
            pixelScale: options.pixelScale || 1,
            batchSize: Math.min(options.batchSize || 8000, 8000), // Max objects per batch
            // VSync options
            vsync: options.vsync !== false, // Default to true
            targetFPS: options.targetFPS || 60,
            adaptiveSync: options.adaptiveSync || false,
            frameTimingBuffer: options.frameTimingBuffer || 30,
            ...options
        };

        // VSync and frame timing state
        this.frameTime = {
            enabled: this.options.vsync,
            targetFPS: this.options.targetFPS,
            targetFrameTime: 1000 / this.options.targetFPS,
            lastFrameTime: 0,
            frameCount: 0,
            actualFPS: 0,
            frameBuffer: [],
            bufferSize: this.options.frameTimingBuffer,
            adaptiveSync: this.options.adaptiveSync,

            // Frame timing statistics
            minFrameTime: Infinity,
            maxFrameTime: 0,
            avgFrameTime: 0,
            frameTimeVariance: 0,

            // Adaptive sync state
            adaptiveTargetFPS: this.options.targetFPS,
            performanceScore: 1.0,
            adaptiveUpdateCounter: 0,

            // Animation frame management
            animationId: null,
            isAnimating: false,
            renderCallback: null
        };

        // Set up pixel scaling
        this.setupPixelScaling();

        this.width = this.canvas.width;
        this.height = this.canvas.height;

        // Context lost state
        this.contextLost = false;
        this.contextRestoreCallbacks = [];

        // Context stability tracking
        this.contextLossCount = 0;
        this.timers = new Set();

        if (!this.useWebGL) {
            // 2D context
            this.ctx = canvas.getContext('2d');
            if (!this.ctx) {
                throw new Error('2D context not supported');
            }
        } else {
            // WebGL context with better stability settings
            this.gl = canvas.getContext('webgl', {
                preserveDrawingBuffer: true,
                antialias: true,
                alpha: true,
                premultipliedAlpha: true,
                failIfMajorPerformanceCaveat: false,
                powerPreference: 'default'
            }) || canvas.getContext('experimental-webgl', {
                preserveDrawingBuffer: true,
                antialias: false,
                alpha: true,
                premultipliedAlpha: true,
                failIfMajorPerformanceCaveat: false,
                powerPreference: 'default'
            });

            if (!this.gl) {
                throw new Error('WebGL not supported');
            }

            // Set up context loss handlers immediately
            this.setupContextLossHandling();
        }

        // State management
        this.state = {
            fillStyle: [1, 1, 1, 1], // white
            strokeStyle: [0, 0, 0, 1], // black
            lineWidth: 1,
            lineCap: 'butt',
            lineJoin: 'miter',
            miterLimit: 10,
            lineDashOffset: 0,
            lineDash: [],
            globalAlpha: 1,
            globalCompositeOperation: 'source-over',
            textAlign: 'start',
            textBaseline: 'alphabetic',
            font: '10px sans-serif',
            shadowColor: [0, 0, 0, 0],
            shadowBlur: 0,
            shadowOffsetX: 0,
            shadowOffsetY: 0,
            imageSmoothingEnabled: true,
            transform: this.createIdentityMatrix(),

            // Image color properties
            imageHue: 0,            // -180 to 180 degrees
            imageSaturation: 1,     // 0 to 2+ (1 = normal)
            imageLightness: 0,      // -1 to 1 (0 = normal)
            imageBrightness: 0,     // -1 to 1 (0 = normal)
            imageContrast: 1,       // 0 to 2+ (1 = normal)
            imageOpacity: 1,        // 0 to 1 (1 = opaque)
            imageColorTint: [0, 0, 0, 0], // RGBA tint color
            imageColorMode: 0,      // 0=normal, 1=grayscale, 2=sepia, 3=invert, 4=blackwhite
            imageColorMultiply: [1, 1, 1, 1], // RGBA multiply
            imageColorAdd: [0, 0, 0, 0],      // RGBA add
            imageGamma: 1,          // 0.1 to 3 (1 = normal)
            imageExposure: 0        // -3 to 3 (0 = normal)
        };
        this.stateStack = [];

        // Path state
        this.currentPath = [];
        this.pathStartX = 0;
        this.pathStartY = 0;
        this.currentX = 0;
        this.currentY = 0;

        // Fullscreen state
        this.isFullscreen = false;
        this.originalStyle = {};
        this.originalDimensions = {};
        this.fullscreenButton = null;

        // Batching system
        this.batches = {
            rectangles: new Map(),
            circles: new Map(),
            ellipses: new Map(),
            lines: new Map(),
            images: new Map(),
            text: new Map()
        };
        this.batchBuffers = {};

        // Texture cache for images
        this.textureCache = new Map();
        this.fontCache = new Map();

        this.currentImageBatch = null;
        this.imageBatchTexture = null;

        if (this.useWebGL) {
            // Initialize WebGL
            this.init();

            // Create built-in shaders
            this.shaders = {};
            this.createBuiltInShaders();

            // Create post-processing system
            this.postProcessing = {
                enabled: false,
                effects: [],
                framebuffers: [],
                currentEffect: 0,
                tempTextures: []
            };
            this.createPostProcessingSystem();

            // Create batch buffers
            this.createBatchBuffers();

            // Create optimized image batch system
            this.createImageBatchSystem();

            // Set initial viewport
            this.gl.viewport(0, 0, this.width, this.height);
            this.gl.enable(this.gl.BLEND);
            this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        }

        // Setup fullscreen if enabled
        if (this.options.enableFullscreen) {
            this.setupFullscreen();
        }
    }

    /*
     * Setup pixel scaling for pixel art games
     * Configures canvas internal resolution vs display size
     */
    setupPixelScaling() {
        // Set canvas internal resolution
        this.canvas.width = this.options.pixelWidth;
        this.canvas.height = this.options.pixelHeight;

        // Set display size (CSS size)
        const displayWidth = this.options.pixelWidth * this.options.pixelScale;
        const displayHeight = this.options.pixelHeight * this.options.pixelScale;

        this.canvas.style.width = `${displayWidth}px`;
        this.canvas.style.height = `${displayHeight}px`;

        // Ensure pixel-perfect scaling
        this.canvas.style.imageRendering = 'pixelated';
        this.canvas.style.imageRendering = '-moz-crisp-edges';
        this.canvas.style.imageRendering = 'crisp-edges';

        // Store display dimensions
        this.displayWidth = displayWidth;
        this.displayHeight = displayHeight;
    }

    /*
     * Create optimized batch buffers for different shape types
     */
    createBatchBuffers() {
        const gl = this.gl;
        const batchSize = this.options.batchSize;

        // Rectangle batch buffer (4 vertices per rectangle)
        this.batchBuffers.rectangles = {
            vertices: gl.createBuffer(),
            colors: gl.createBuffer(),
            indices: gl.createBuffer(),
            maxVertices: batchSize * 4,
            maxIndices: batchSize * 6,
            currentVertices: 0,
            currentIndices: 0,
            vertexData: new Float32Array(batchSize * 4 * 2), // x, y for each vertex
            colorData: new Float32Array(batchSize * 4 * 4),  // r, g, b, a for each vertex
            indexData: new Uint16Array(batchSize * 6)        // 6 indices per rectangle
        };

        // Circle batch buffer (4 vertices per circle quad)
        this.batchBuffers.circles = {
            vertices: gl.createBuffer(),
            colors: gl.createBuffer(),
            centers: gl.createBuffer(),
            radii: gl.createBuffer(),
            indices: gl.createBuffer(),
            maxVertices: batchSize * 4,
            maxIndices: batchSize * 6,
            currentVertices: 0,
            currentIndices: 0,
            vertexData: new Float32Array(batchSize * 4 * 2), // x, y for each vertex
            colorData: new Float32Array(batchSize * 4 * 4),  // r, g, b, a for each vertex
            centerData: new Float32Array(batchSize * 4 * 2), // center x, y for each vertex
            radiusData: new Float32Array(batchSize * 4),     // radius for each vertex
            indexData: new Uint16Array(batchSize * 6)        // 6 indices per circle
        };

        // Ellipse batch buffer
        this.batchBuffers.ellipses = {
            vertices: gl.createBuffer(),
            colors: gl.createBuffer(),
            centers: gl.createBuffer(),
            radii: gl.createBuffer(),
            indices: gl.createBuffer(),
            maxVertices: batchSize * 4,
            maxIndices: batchSize * 6,
            currentVertices: 0,
            currentIndices: 0,
            vertexData: new Float32Array(batchSize * 4 * 2),
            colorData: new Float32Array(batchSize * 4 * 4),
            centerData: new Float32Array(batchSize * 4 * 2),
            radiusData: new Float32Array(batchSize * 4 * 2), // radiusX, radiusY
            indexData: new Uint16Array(batchSize * 6)
        };

        // Line batch buffer
        this.batchBuffers.lines = {
            vertices: gl.createBuffer(),
            colors: gl.createBuffer(),
            maxVertices: batchSize * 2,
            currentVertices: 0,
            vertexData: new Float32Array(batchSize * 2 * 2), // x, y for each vertex
            colorData: new Float32Array(batchSize * 2 * 4)   // r, g, b, a for each vertex
        };

        // Image batch buffer
        this.batchBuffers.images = {
            vertices: gl.createBuffer(),
            texCoords: gl.createBuffer(),
            indices: gl.createBuffer(),
            maxQuads: batchSize,
            maxVertices: batchSize * 4,
            maxIndices: batchSize * 6,
            currentQuads: 0,
            currentVertices: 0,
            currentIndices: 0,
            vertexData: new Float32Array(batchSize * 4 * 2),
            texCoordData: new Float32Array(batchSize * 4 * 2),
            indexData: new Uint16Array(batchSize * 6),
            currentTexture: null
        };
    }

    /*
        * Initialize WebGL settings
        * Set clear color to transparent
    */
    init() {
        const gl = this.gl;
        gl.clearColor(0, 0, 0, 0); // Transparent background
    }

    /*
        * Create an identity matrix
        * Used for initial transformations
    */
    createIdentityMatrix() {
        return [
            1, 0, 0,
            0, 1, 0,
            0, 0, 1
        ];
    }

    /*        
        * Multiply two 3x3 matrices
        * Used for combining transformations
        * @param {Array} a - First matrix (3x3)
        * @param {Array} b - Second matrix (3x3)
        * @return {Array} - Resulting matrix (3x3)
    */
    multiplyMatrix(a, b) {
        const result = new Array(9);
        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                result[i * 3 + j] = 0;
                for (let k = 0; k < 3; k++) {
                    result[i * 3 + j] += a[i * 3 + k] * b[k * 3 + j];
                }
            }
        }
        return result;
    }

    /*
     * Transform a point using the current transformation matrix
     */
    transformPoint(x, y) {
        const m = this.state.transform;
        return [
            m[0] * x + m[1] * y + m[2],
            m[3] * x + m[4] * y + m[5]
        ];
    }

    /*
        * Create a shader program from vertex and fragment shader sources
        * Compiles shaders and links them into a program
        * @param {string} vertexShaderSource - GLSL source code for the vertex shader
        * @param {string} fragmentShaderSource - GLSL source code for the fragment shader
        * @return {WebGLProgram} - Compiled and linked shader program
    */
    createShaderProgram(vertexShaderSource, fragmentShaderSource) {
        const gl = this.gl;

        const vertexShader = this.createShader(gl.VERTEX_SHADER, vertexShaderSource);
        const fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fragmentShaderSource);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);

        // Log any warnings or info even if linking succeeds
        const log = gl.getProgramInfoLog(program);
        if (log) {
            // console.warn('Shader program link log:', log);
        }

        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            throw new Error('Shader program failed to link: ' + gl.getProgramInfoLog(program));
        }

        return program;
    }

    /*
    * Create a shader of a specific type (vertex or fragment)
    * Compiles the shader source code
    * @param {number} type - Shader type (gl.VERTEX_SHADER or gl.FRAGMENT_SHADER)
    * @param {string} source - GLSL source code for the shader
    * @return {WebGLShader} - Compiled shader
    */
    createShader(type, source) {
        const gl = this.gl;
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);

        // Always check compilation status and log errors
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            const error = gl.getShaderInfoLog(shader);
            const shaderType = type === gl.VERTEX_SHADER ? 'vertex' : 'fragment';
            // console.error(`${shaderType} shader compilation error:`, error);
            // console.error('Shader source:', source);
            gl.deleteShader(shader);
            throw new Error(`${shaderType} shader compilation error: ${error}`);
        }

        // Log warnings even if compilation succeeds
        const log = gl.getShaderInfoLog(shader);
        if (log && log.trim()) {
            const shaderType = type === gl.VERTEX_SHADER ? 'vertex' : 'fragment';
            // console.warn(`${shaderType} shader compile log:`, log);
        }

        return shader;
    }

    /*
     * Create post-processing system with framebuffers and built-in effects
     */
    createPostProcessingSystem() {
        this.createPostProcessingFramebuffers();
        this.createPostProcessingShaders();
        this.createFullscreenQuad();
    }

    /*
     * Create framebuffers for post-processing pipeline
     */
    createPostProcessingFramebuffers() {
        const gl = this.gl;

        // Create two framebuffers for ping-ponging between effects
        for (let i = 0; i < 2; i++) {
            const framebuffer = gl.createFramebuffer();
            const texture = gl.createTexture();

            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

            if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
                // console.error('Framebuffer is not complete');
            }

            this.postProcessing.framebuffers.push(framebuffer);
            this.postProcessing.tempTextures.push(texture);
        }

        // Unbind framebuffer
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    /*
     * Create fullscreen quad for post-processing
     */
    createFullscreenQuad() {
        const gl = this.gl;

        // Create vertex buffer for fullscreen quad
        const vertices = new Float32Array([
            -1, -1, 0, 0,  // Bottom-left
            1, -1, 1, 0,  // Bottom-right
            -1, 1, 0, 1,  // Top-left
            1, 1, 1, 1   // Top-right
        ]);

        this.postProcessing.quadBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.postProcessing.quadBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        // Create index buffer
        const indices = new Uint16Array([0, 1, 2, 1, 2, 3]);
        this.postProcessing.quadIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.postProcessing.quadIndexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
    }

    /*
     * Create built-in post-processing shaders
     */
    createPostProcessingShaders() {
        // Base vertex shader for all post-processing effects
        const postVertexShader = `
        precision mediump float;
        attribute vec2 a_position;
        attribute vec2 a_texCoord;
        varying vec2 v_texCoord;
        
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
            v_texCoord = a_texCoord;
        }
    `;

        // Pass-through fragment shader (no effect)
        const passthroughFragmentShader = `
        precision mediump float;
        uniform sampler2D u_texture;
        varying vec2 v_texCoord;
        
        void main() {
            gl_FragColor = texture2D(u_texture, v_texCoord);
        }
    `;

        // Improved Gaussian blur fragment shader
        const blurFragmentShader = `
        precision mediump float;
        uniform sampler2D u_texture;
        uniform vec2 u_resolution;
        uniform vec2 u_direction;
        uniform float u_blurRadius;
        varying vec2 v_texCoord;
        
        void main() {
            vec2 texelSize = 1.0 / u_resolution;
            vec4 color = vec4(0.0);
            
            // 5-tap blur for better performance
            float weights[5];
            weights[0] = 0.227027;
            weights[1] = 0.1945946;
            weights[2] = 0.1216216;
            weights[3] = 0.054054;
            weights[4] = 0.016216;
            
            // Sample center
            color += texture2D(u_texture, v_texCoord) * weights[0];
            
            // Sample in both directions
            for(int i = 1; i < 5; i++) {
                vec2 offset = u_direction * texelSize * float(i) * u_blurRadius;
                color += texture2D(u_texture, v_texCoord + offset) * weights[i];
                color += texture2D(u_texture, v_texCoord - offset) * weights[i];
            }
            
            gl_FragColor = color;
        }
    `;

        // Fixed bloom extract shader with better threshold handling
        const bloomExtractFragmentShader = `
    precision mediump float;
    uniform sampler2D u_texture;
    uniform float u_bloomThreshold;
    varying vec2 v_texCoord;
    
    void main() {
        vec4 color = texture2D(u_texture, v_texCoord);
        float brightness = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));
        
        // Only output bright areas above threshold
        if(brightness > u_bloomThreshold) {
            // Scale the color by how much it exceeds the threshold
            float excess = brightness - u_bloomThreshold;
            gl_FragColor = vec4(color.rgb * excess / brightness, color.a);
        } else {
            gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
    }
`;

        // Fixed bloom combine shader
        const bloomCombineFragmentShader = `
    precision mediump float;
    uniform sampler2D u_texture;
    uniform sampler2D u_bloomTexture;
    uniform float u_bloomStrength;
    varying vec2 v_texCoord;
    
    void main() {
        vec3 original = texture2D(u_texture, v_texCoord).rgb;
        vec3 bloom = texture2D(u_bloomTexture, v_texCoord).rgb;
        
        // Add bloom to original with strength multiplier
        vec3 result = original + bloom * u_bloomStrength;
        gl_FragColor = vec4(result, 1.0);
    }
`;

        // FXAA antialiasing fragment shader (simplified)
        const fxaaFragmentShader = `
        precision mediump float;
        uniform sampler2D u_texture;
        uniform vec2 u_resolution;
        varying vec2 v_texCoord;
        
        void main() {
            vec2 texelSize = 1.0 / u_resolution;
            
            vec3 rgbNW = texture2D(u_texture, v_texCoord + vec2(-1.0, -1.0) * texelSize).rgb;
            vec3 rgbNE = texture2D(u_texture, v_texCoord + vec2(1.0, -1.0) * texelSize).rgb;
            vec3 rgbSW = texture2D(u_texture, v_texCoord + vec2(-1.0, 1.0) * texelSize).rgb;
            vec3 rgbSE = texture2D(u_texture, v_texCoord + vec2(1.0, 1.0) * texelSize).rgb;
            vec3 rgbM  = texture2D(u_texture, v_texCoord).rgb;
            
            vec3 luma = vec3(0.299, 0.587, 0.114);
            float lumaNW = dot(rgbNW, luma);
            float lumaNE = dot(rgbNE, luma);
            float lumaSW = dot(rgbSW, luma);
            float lumaSE = dot(rgbSE, luma);
            float lumaM  = dot(rgbM,  luma);
            
            float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
            float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));
            
            if(lumaMax - lumaMin < 0.1) {
                gl_FragColor = vec4(rgbM, 1.0);
                return;
            }
            
            vec2 dir = vec2(
                -((lumaNW + lumaNE) - (lumaSW + lumaSE)),
                ((lumaNW + lumaSW) - (lumaNE + lumaSE))
            );
            
            float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * 0.03125, 0.0078125);
            float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
            dir = min(vec2(8.0), max(vec2(-8.0), dir * rcpDirMin)) * texelSize;
            
            vec3 rgbA = 0.5 * (
                texture2D(u_texture, v_texCoord + dir * -0.166667).rgb +
                texture2D(u_texture, v_texCoord + dir * 0.166667).rgb);
            vec3 rgbB = rgbA * 0.5 + 0.25 * (
                texture2D(u_texture, v_texCoord + dir * -0.5).rgb +
                texture2D(u_texture, v_texCoord + dir * 0.5).rgb);
            
            float lumaB = dot(rgbB, luma);
            
            if((lumaB < lumaMin) || (lumaB > lumaMax)) {
                gl_FragColor = vec4(rgbA, 1.0);
            } else {
                gl_FragColor = vec4(rgbB, 1.0);
            }
        }
    `;

        // Chromatic aberration fragment shader
        const chromaticAberrationFragmentShader = `
        precision mediump float;
        uniform sampler2D u_texture;
        uniform float u_aberrationStrength;
        varying vec2 v_texCoord;
        
        void main() {
            vec2 center = vec2(0.5);
            vec2 offset = (v_texCoord - center) * u_aberrationStrength;
            
            float r = texture2D(u_texture, v_texCoord - offset).r;
            float g = texture2D(u_texture, v_texCoord).g;
            float b = texture2D(u_texture, v_texCoord + offset).b;
            float a = texture2D(u_texture, v_texCoord).a;
            
            gl_FragColor = vec4(r, g, b, a);
        }
    `;

        // Vignette fragment shader
        const vignetteFragmentShader = `
        precision mediump float;
        uniform sampler2D u_texture;
        uniform float u_vignetteStrength;
        uniform float u_vignetteRadius;
        varying vec2 v_texCoord;
        
        void main() {
            vec3 color = texture2D(u_texture, v_texCoord).rgb;
            
            vec2 center = vec2(0.5);
            float dist = distance(v_texCoord, center);
            float vignette = smoothstep(u_vignetteRadius, u_vignetteRadius - 0.3, dist);
            vignette = mix(1.0 - u_vignetteStrength, 1.0, vignette);
            
            gl_FragColor = vec4(color * vignette, texture2D(u_texture, v_texCoord).a);
        }
    `;

        // Color grading fragment shader
        const colorGradingFragmentShader = `
        precision mediump float;
        uniform sampler2D u_texture;
        uniform float u_brightness;
        uniform float u_contrast;
        uniform float u_saturation;
        uniform float u_hue;
        varying vec2 v_texCoord;
        
        void main() {
            vec3 color = texture2D(u_texture, v_texCoord).rgb;
            
            // Brightness
            color += u_brightness;
            
            // Contrast
            color = (color - 0.5) * u_contrast + 0.5;
            
            // Simple saturation adjustment
            float gray = dot(color, vec3(0.299, 0.587, 0.114));
            color = mix(vec3(gray), color, u_saturation);
            
            gl_FragColor = vec4(clamp(color, 0.0, 1.0), texture2D(u_texture, v_texCoord).a);
        }
    `;

        // Pixelate fragment shader
        const pixelateFragmentShader = `
        precision mediump float;
        uniform sampler2D u_texture;
        uniform vec2 u_resolution;
        uniform float u_pixelSize;
        varying vec2 v_texCoord;
        
        void main() {
            vec2 pixelatedUV = floor(v_texCoord * u_resolution / u_pixelSize) * u_pixelSize / u_resolution;
            gl_FragColor = texture2D(u_texture, pixelatedUV);
        }
    `;

        // Create shader programs
        this.shaders.postPassthrough = this.createShaderProgram(postVertexShader, passthroughFragmentShader);
        this.shaders.postBlur = this.createShaderProgram(postVertexShader, blurFragmentShader);
        this.shaders.postBloomExtract = this.createShaderProgram(postVertexShader, bloomExtractFragmentShader);
        this.shaders.postBloomCombine = this.createShaderProgram(postVertexShader, bloomCombineFragmentShader);
        this.shaders.postFXAA = this.createShaderProgram(postVertexShader, fxaaFragmentShader);
        this.shaders.postChromaticAberration = this.createShaderProgram(postVertexShader, chromaticAberrationFragmentShader);
        this.shaders.postVignette = this.createShaderProgram(postVertexShader, vignetteFragmentShader);
        this.shaders.postColorGrading = this.createShaderProgram(postVertexShader, colorGradingFragmentShader);
        this.shaders.postPixelate = this.createShaderProgram(postVertexShader, pixelateFragmentShader);
    }

    /*
     * Enable post-processing
     */
    enablePostProcessing() {
        this.postProcessing.enabled = true;
    }

    /*
     * Disable post-processing
     */
    disablePostProcessing() {
        this.postProcessing.enabled = false;
    }

    /*
     * Add a post-processing effect to the pipeline
     */
    addPostEffect(effectName, parameters = {}) {
        const effect = {
            name: effectName,
            parameters: { ...parameters }
        };

        // Set default parameters for each effect
        switch (effectName) {
            case 'blur':
                effect.parameters = {
                    radius: 2.0,
                    ...parameters
                };
                break;
            case 'bloom':
                effect.parameters = {
                    strength: 0.5,
                    threshold: 0.7,
                    ...parameters
                };
                break;
            case 'chromaticAberration':
                effect.parameters = {
                    strength: 0.01,
                    ...parameters
                };
                break;
            case 'vignette':
                effect.parameters = {
                    strength: 0.5,
                    radius: 0.8,
                    ...parameters
                };
                break;
            case 'colorGrading':
                effect.parameters = {
                    brightness: 0.0,
                    contrast: 1.0,
                    saturation: 1.0,
                    hue: 0.0,
                    ...parameters
                };
                break;
            case 'pixelate':
                effect.parameters = {
                    pixelSize: 4.0,
                    ...parameters
                };
                break;
        }

        this.postProcessing.effects.push(effect);
        this.enablePostProcessing();
    }

    /*
     * Clear all post-processing effects
     */
    clearPostEffects() {
        this.postProcessing.effects = [];
        this.disablePostProcessing();
    }

    /*
     * Update parameters for a specific post-processing effect
     */
    updatePostEffect(effectName, parameters) {
        const effect = this.postProcessing.effects.find(e => e.name === effectName);
        if (effect) {
            Object.assign(effect.parameters, parameters);
        }
    }

    /*
     * Remove a specific post-processing effect
     */
    removePostEffect(effectName) {
        this.postProcessing.effects = this.postProcessing.effects.filter(e => e.name !== effectName);
        if (this.postProcessing.effects.length === 0) {
            this.disablePostProcessing();
        }
    }

    /*
     * Render post-processing effects
     */
    renderPostProcessing() {
        if (!this.postProcessing.enabled || this.postProcessing.effects.length === 0) {
            return;
        }

        const gl = this.gl;

        // For bloom, we need special handling with multiple passes
        const hasBloom = this.postProcessing.effects.some(e =>
            e.name === 'bloomExtract' || e.name === 'bloomCombine'
        );

        if (hasBloom) {
            this.renderBloomEffect();
            return;
        }

        // Original post-processing for non-bloom effects
        let inputTexture = this.postProcessing.tempTextures[0];
        let sourceFramebuffer = 0;
        let targetFramebuffer = 1;

        for (let i = 0; i < this.postProcessing.effects.length; i++) {
            const effect = this.postProcessing.effects[i];
            const isLastEffect = i === this.postProcessing.effects.length - 1;

            if (isLastEffect) {
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            } else {
                gl.bindFramebuffer(gl.FRAMEBUFFER, this.postProcessing.framebuffers[targetFramebuffer]);
            }

            gl.viewport(0, 0, this.width, this.height);
            gl.clear(gl.COLOR_BUFFER_BIT);

            this.renderPostEffect(effect, inputTexture);

            if (!isLastEffect) {
                inputTexture = this.postProcessing.tempTextures[targetFramebuffer];
                const temp = sourceFramebuffer;
                sourceFramebuffer = targetFramebuffer;
                targetFramebuffer = temp;
            }
        }
    }

    /*
    * Specialized bloom rendering with proper multi-pass setup
    */
    renderBloomEffect() {
        const gl = this.gl;

        // Get bloom parameters
        const extractEffect = this.postProcessing.effects.find(e => e.name === 'bloomExtract');
        const blurEffect = this.postProcessing.effects.find(e => e.name === 'blur');
        const combineEffect = this.postProcessing.effects.find(e => e.name === 'bloomCombine');

        const threshold = extractEffect ? extractEffect.parameters.threshold : 0.5;
        const blurRadius = blurEffect ? blurEffect.parameters.radius : 2.0;
        const strength = combineEffect ? combineEffect.parameters.strength : 1.0;

        // Create bloom framebuffer only once
        if (!this.bloomFramebuffer) {
            this.bloomFramebuffer = gl.createFramebuffer();
            this.bloomTexture = gl.createTexture();

            gl.bindTexture(gl.TEXTURE_2D, this.bloomTexture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            gl.bindFramebuffer(gl.FRAMEBUFFER, this.bloomFramebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.bloomTexture, 0);
        }

        // Extract bright areas
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.bloomFramebuffer);
        gl.viewport(0, 0, this.width, this.height);
        gl.clear(gl.COLOR_BUFFER_BIT);

        const extractProgram = this.shaders.postBloomExtract;
        gl.useProgram(extractProgram);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.postProcessing.tempTextures[0]);
        gl.uniform1i(gl.getUniformLocation(extractProgram, 'u_texture'), 0);
        gl.uniform1f(gl.getUniformLocation(extractProgram, 'u_bloomThreshold'), threshold);

        this.renderFullscreenQuad(extractProgram);

        // Combined blur passes (more efficient)
        this.renderOptimizedBlur(this.bloomTexture, blurRadius);

        // Final combine
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.viewport(0, 0, this.width, this.height);
        gl.clear(gl.COLOR_BUFFER_BIT);

        const combineProgram = this.shaders.postBloomCombine;
        gl.useProgram(combineProgram);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.postProcessing.tempTextures[0]);
        gl.uniform1i(gl.getUniformLocation(combineProgram, 'u_texture'), 0);

        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, this.bloomTexture);
        gl.uniform1i(gl.getUniformLocation(combineProgram, 'u_bloomTexture'), 1);
        gl.uniform1f(gl.getUniformLocation(combineProgram, 'u_bloomStrength'), strength);

        this.renderFullscreenQuad(combineProgram);
    }

    renderOptimizedBlur(inputTexture, radius) {
        const gl = this.gl;
        const blurProgram = this.shaders.postBlur;

        gl.useProgram(blurProgram);
        gl.uniform2f(gl.getUniformLocation(blurProgram, 'u_resolution'), this.width, this.height);
        gl.uniform1f(gl.getUniformLocation(blurProgram, 'u_blurRadius'), radius);

        // Horizontal pass
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.postProcessing.framebuffers[1]);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, inputTexture);
        gl.uniform1i(gl.getUniformLocation(blurProgram, 'u_texture'), 0);
        gl.uniform2f(gl.getUniformLocation(blurProgram, 'u_direction'), 1.0, 0.0);

        this.renderFullscreenQuad(blurProgram);

        // Vertical pass
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.bloomFramebuffer);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.postProcessing.tempTextures[1]);
        gl.uniform2f(gl.getUniformLocation(blurProgram, 'u_direction'), 0.0, 1.0);

        this.renderFullscreenQuad(blurProgram);
    }

    /*
     * Render a single post-processing effect
     */
    renderPostEffect(effect, inputTexture) {
        const gl = this.gl;
        let program;

        // Get shader program for effect
        switch (effect.name) {
            case 'blur':
                program = this.shaders.postBlur;
                break;
            case 'bloom':
                program = this.shaders.postBloom;
                break;
            case 'fxaa':
                program = this.shaders.postFXAA;
                break;
            case 'chromaticAberration':
                program = this.shaders.postChromaticAberration;
                break;
            case 'vignette':
                program = this.shaders.postVignette;
                break;
            case 'colorGrading':
                program = this.shaders.postColorGrading;
                break;
            case 'pixelate':
                program = this.shaders.postPixelate;
                break;
            default:
                program = this.shaders.postPassthrough;
        }

        gl.useProgram(program);

        // Bind input texture
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, inputTexture);
        gl.uniform1i(gl.getUniformLocation(program, 'u_texture'), 0);

        // Set common uniforms
        gl.uniform2f(gl.getUniformLocation(program, 'u_resolution'), this.width, this.height);

        // Set effect-specific uniforms
        this.setPostEffectUniforms(program, effect);

        // Bind fullscreen quad and render
        this.renderFullscreenQuad(program);
    }

    /*
     * Set uniforms for specific post-processing effects
     */
    setPostEffectUniforms(program, effect) {
        const gl = this.gl;
        const params = effect.parameters;

        switch (effect.name) {
            case 'blur':
                const directionLoc = gl.getUniformLocation(program, 'u_direction');
                const radiusLoc = gl.getUniformLocation(program, 'u_blurRadius');

                if (directionLoc !== null) {
                    // For now, just do horizontal blur. For better quality, you'd do two passes
                    gl.uniform2f(directionLoc, 1.0, 0.0);
                }
                if (radiusLoc !== null) {
                    gl.uniform1f(radiusLoc, params.radius || 2.0);
                }
                break;

            case 'bloom':
                const strengthLoc = gl.getUniformLocation(program, 'u_bloomStrength');
                const thresholdLoc = gl.getUniformLocation(program, 'u_bloomThreshold');

                if (strengthLoc !== null) {
                    gl.uniform1f(strengthLoc, params.strength || 0.5);
                }
                if (thresholdLoc !== null) {
                    gl.uniform1f(thresholdLoc, params.threshold || 0.7);
                }
                break;

            case 'chromaticAberration':
                const aberrationLoc = gl.getUniformLocation(program, 'u_aberrationStrength');
                if (aberrationLoc !== null) {
                    gl.uniform1f(aberrationLoc, params.strength || 0.01);
                }
                break;

            case 'vignette':
                const vignetteStrengthLoc = gl.getUniformLocation(program, 'u_vignetteStrength');
                const vignetteRadiusLoc = gl.getUniformLocation(program, 'u_vignetteRadius');

                if (vignetteStrengthLoc !== null) {
                    gl.uniform1f(vignetteStrengthLoc, params.strength || 0.5);
                }
                if (vignetteRadiusLoc !== null) {
                    gl.uniform1f(vignetteRadiusLoc, params.radius || 0.8);
                }
                break;

            case 'colorGrading':
                const brightnessLoc = gl.getUniformLocation(program, 'u_brightness');
                const contrastLoc = gl.getUniformLocation(program, 'u_contrast');
                const saturationLoc = gl.getUniformLocation(program, 'u_saturation');
                const hueLoc = gl.getUniformLocation(program, 'u_hue');

                if (brightnessLoc !== null) {
                    gl.uniform1f(brightnessLoc, params.brightness || 0.0);
                }
                if (contrastLoc !== null) {
                    gl.uniform1f(contrastLoc, params.contrast || 1.0);
                }
                if (saturationLoc !== null) {
                    gl.uniform1f(saturationLoc, params.saturation || 1.0);
                }
                if (hueLoc !== null) {
                    gl.uniform1f(hueLoc, params.hue || 0.0);
                }
                break;

            case 'pixelate':
                const pixelSizeLoc = gl.getUniformLocation(program, 'u_pixelSize');
                if (pixelSizeLoc !== null) {
                    gl.uniform1f(pixelSizeLoc, params.pixelSize || 4.0);
                }
                break;
        }
    }

    /*
     * Render fullscreen quad for post-processing
     */
    renderFullscreenQuad(program) {
        const gl = this.gl;

        // Bind quad vertex buffer
        gl.bindBuffer(gl.ARRAY_BUFFER, this.postProcessing.quadBuffer);

        // Set up position attribute
        const positionLoc = gl.getAttribLocation(program, 'a_position');
        if (positionLoc >= 0) {
            gl.enableVertexAttribArray(positionLoc);
            gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 16, 0);
        }

        // Set up texture coordinate attribute
        const texCoordLoc = gl.getAttribLocation(program, 'a_texCoord');
        if (texCoordLoc >= 0) {
            gl.enableVertexAttribArray(texCoordLoc);
            gl.vertexAttribPointer(texCoordLoc, 2, gl.FLOAT, false, 16, 8);
        }

        // Bind index buffer and draw
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.postProcessing.quadIndexBuffer);
        gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
    }

    /*
        * Create built-in shaders for batched rendering
        * Optimized shaders that can handle multiple objects in single draw calls
    */
    createBuiltInShaders() {
        // Batched rectangle vertex shader
        const batchedRectVertexShader = `
        precision mediump float;
        attribute vec2 a_position;
        attribute vec4 a_color;
        uniform vec2 u_resolution;
        varying vec4 v_color;
        
        void main() {
            // Convert to normalized device coordinates (-1 to 1)
            vec2 normalized = (a_position / u_resolution) * 2.0 - 1.0;
            normalized.y = -normalized.y; // Flip Y coordinate
            
            gl_Position = vec4(normalized, 0, 1);
            v_color = a_color;
        }
    `;

        // Batched fragment shader
        const batchedFragmentShader = `
        precision mediump float;
        varying vec4 v_color;
        
        void main() {
            gl_FragColor = v_color;
        }
    `;

        // Circle vertex shader
        const circleVertexShader = `
        precision mediump float;
        attribute vec2 a_position;
        attribute vec4 a_color;
        attribute vec2 a_center;
        attribute float a_radius;
        uniform vec2 u_resolution;
        varying vec4 v_color;
        varying vec2 v_center;
        varying float v_radius;
        varying vec2 v_fragCoord;
        
        void main() {
            vec2 normalized = (a_position / u_resolution) * 2.0 - 1.0;
            normalized.y = -normalized.y;
            
            gl_Position = vec4(normalized, 0, 1);
            v_color = a_color;
            v_center = (a_center / u_resolution) * 2.0 - 1.0;
            v_center.y = -v_center.y;
            v_radius = a_radius;
            v_fragCoord = a_position;
        }
    `;

        // Enhanced circle fragment shader that can handle both fill and stroke
        const circleFragmentShader = `
            precision mediump float;
            varying vec4 v_color;
            varying vec2 v_center;
            varying float v_radius;
            varying vec2 v_fragCoord;
            uniform vec2 u_resolution;
            uniform float u_strokeWidth;
            uniform int u_isStroke;
            
            void main() {
                vec2 centerPixels = (v_center + 1.0) * 0.5 * u_resolution;
                centerPixels.y = u_resolution.y - centerPixels.y;
                
                float dist = distance(v_fragCoord, centerPixels);
                
                if (u_isStroke == 1) {
                    // Stroke mode - render only the ring
                    float innerRadius = v_radius - u_strokeWidth;
                    if (dist > v_radius || dist < innerRadius) {
                        discard;
                    }
                } else {
                    // Fill mode - render the entire circle
                    if (dist > v_radius) {
                        discard;
                    }
                }
                
                gl_FragColor = v_color;
            }
        `;

        // Ellipse vertex shader
        const ellipseVertexShader = `
        precision mediump float;
        attribute vec2 a_position;
        attribute vec4 a_color;
        attribute vec2 a_center;
        attribute vec2 a_radius;
        uniform vec2 u_resolution;
        varying vec4 v_color;
        varying vec2 v_center;
        varying vec2 v_radius;
        varying vec2 v_fragCoord;
        
        void main() {
            vec2 normalized = (a_position / u_resolution) * 2.0 - 1.0;
            normalized.y = -normalized.y;
            
            gl_Position = vec4(normalized, 0, 1);
            v_color = a_color;
            v_center = (a_center / u_resolution) * 2.0 - 1.0;
            v_center.y = -v_center.y;
            v_radius = a_radius;
            v_fragCoord = a_position;
        }
    `;

        const ellipseFragmentShader = `
        precision mediump float;
        varying vec4 v_color;
        varying vec2 v_center;
        varying vec2 v_radius;
        varying vec2 v_fragCoord;
        uniform vec2 u_resolution;
        
        void main() {
            vec2 centerPixels = (v_center + 1.0) * 0.5 * u_resolution;
            centerPixels.y = u_resolution.y - centerPixels.y;
            
            vec2 diff = v_fragCoord - centerPixels;
            float ellipse = (diff.x * diff.x) / (v_radius.x * v_radius.x) + 
                           (diff.y * diff.y) / (v_radius.y * v_radius.y);
            
            if (ellipse > 1.0) {
                discard;
            }
            gl_FragColor = v_color;
        }
    `;

        // Enhanced Image vertex shader
        const imageVertexShader = `
    precision mediump float;
    attribute vec2 a_position;
    attribute vec2 a_texCoord;
    uniform vec2 u_resolution;
    varying vec2 v_texCoord;
    
    void main() {
        vec2 normalized = (a_position / u_resolution) * 2.0 - 1.0;
        normalized.y = -normalized.y;
        
        gl_Position = vec4(normalized, 0, 1);
        v_texCoord = a_texCoord;
    }
`;

        // Enhanced Image fragment shader with color manipulation
        const imageFragmentShader = `
    precision mediump float;
    uniform sampler2D u_texture;
    uniform float u_globalAlpha;
    
    // Color manipulation uniforms
    uniform float u_hue;
    uniform float u_saturation;
    uniform float u_lightness;
    uniform float u_brightness;
    uniform float u_contrast;
    uniform vec4 u_colorTint;
    uniform float u_opacity;
    uniform int u_colorMode;
    uniform vec4 u_colorMultiply;
    uniform vec4 u_colorAdd;
    uniform float u_gamma;
    uniform float u_exposure;
    
    varying vec2 v_texCoord;
    
    // Convert RGB to HSL
    vec3 rgb2hsl(vec3 c) {
        vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
        vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
        vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
        
        float d = q.x - min(q.w, q.y);
        float e = 1.0e-10;
        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
    }
    
    // Convert HSL to RGB
    vec3 hsl2rgb(vec3 c) {
        vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);
        return c.z + c.y * (rgb - 0.5) * (1.0 - abs(2.0 * c.z - 1.0));
    }
    
    // Apply color temperature effect
    vec3 applyColorTemperature(vec3 color, float temperature) {
        // Simplified color temperature adjustment
        float t = temperature * 0.01;
        vec3 warm = vec3(1.0, 0.8, 0.6);
        vec3 cool = vec3(0.6, 0.8, 1.0);
        return mix(color * cool, color * warm, clamp(t + 0.5, 0.0, 1.0));
    }
    
    void main() {
        vec4 texColor = texture2D(u_texture, v_texCoord);
        vec3 color = texColor.rgb;
        float alpha = texColor.a;
        
        // Apply gamma correction first if needed
        if (u_gamma != 1.0) {
            color = pow(color, vec3(1.0 / u_gamma));
        }
        
        // Apply exposure
        if (u_exposure != 0.0) {
            color *= pow(2.0, u_exposure);
        }
        
        // Apply brightness and contrast
        if (u_brightness != 0.0 || u_contrast != 1.0) {
            color += u_brightness;
            color = (color - 0.5) * u_contrast + 0.5;
        }
        
        // Apply HSL adjustments
        if (u_hue != 0.0 || u_saturation != 1.0 || u_lightness != 0.0) {
            vec3 hsl = rgb2hsl(color);
            
            // Adjust hue (wrap around)
            hsl.x = mod(hsl.x + u_hue / 360.0, 1.0);
            
            // Adjust saturation
            hsl.y *= u_saturation;
            
            // Adjust lightness
            hsl.z += u_lightness;
            
            // Clamp HSL values
            hsl = clamp(hsl, vec3(0.0), vec3(1.0));
            
            color = hsl2rgb(hsl);
        }
        
        // Apply color modes
        if (u_colorMode == 1) {
            // Grayscale
            float gray = dot(color, vec3(0.299, 0.587, 0.114));
            color = vec3(gray);
        } else if (u_colorMode == 2) {
            // Sepia
            vec3 sepia = vec3(
                dot(color, vec3(0.393, 0.769, 0.189)),
                dot(color, vec3(0.349, 0.686, 0.168)),
                dot(color, vec3(0.272, 0.534, 0.131))
            );
            color = sepia;
        } else if (u_colorMode == 3) {
            // Invert
            color = 1.0 - color;
        } else if (u_colorMode == 4) {
            // Black and white (threshold)
            float gray = dot(color, vec3(0.299, 0.587, 0.114));
            color = vec3(step(0.5, gray));
        }
        
        // Apply color multiply
        color *= u_colorMultiply.rgb;
        alpha *= u_colorMultiply.a;
        
        // Apply color addition
        color += u_colorAdd.rgb;
        alpha += u_colorAdd.a;
        
        // Apply color tint
        color = mix(color, u_colorTint.rgb, u_colorTint.a);
        
        // Apply opacity
        alpha *= u_opacity;
        
        // Clamp final color
        color = clamp(color, 0.0, 1.0);
        alpha = clamp(alpha, 0.0, 1.0);
        
        gl_FragColor = vec4(color, alpha * u_globalAlpha);
    }
`;

        this.shaders.batchedRect = this.createShaderProgram(batchedRectVertexShader, batchedFragmentShader);
        this.shaders.batchedCircle = this.createShaderProgram(circleVertexShader, circleFragmentShader);
        this.shaders.batchedEllipse = this.createShaderProgram(ellipseVertexShader, ellipseFragmentShader);
        this.shaders.batchedLine = this.createShaderProgram(batchedRectVertexShader, batchedFragmentShader);
        this.shaders.image = this.createShaderProgram(imageVertexShader, imageFragmentShader);
    }

    // Canvas-like API methods

    /*
    * Clear the canvas and reset batches
    * Sets the clear color to transparent and clears the color buffer
    */
    clear() {
        // First flush any pending batches before clearing
        this.flush();

        this.gl.clear(this.gl.COLOR_BUFFER_BIT);

        // Reset all batches AFTER clearing
        this.batchBuffers.rectangles.currentVertices = 0;
        this.batchBuffers.rectangles.currentIndices = 0;
        this.batchBuffers.circles.currentVertices = 0;
        this.batchBuffers.circles.currentIndices = 0;
        this.batchBuffers.lines.currentVertices = 0;
    }

    /*
    * Clear a rectangular area to transparent
    * Canvas API equivalent: clearRect(x, y, width, height)
    * @param {number} x - X coordinate of rectangle
    * @param {number} y - Y coordinate of rectangle  
    * @param {number} width - Width of rectangle
    * @param {number} height - Height of rectangle
    */
    clearRect(x, y, width, height) {
        // Flush current batches first
        this.flush();

        const gl = this.gl;

        // Enable scissor test to limit clearing to specific rectangle
        gl.enable(gl.SCISSOR_TEST);

        // Transform coordinates if needed
        const [transformedX, transformedY] = this.transformPoint(x, y);
        const [transformedX2, transformedY2] = this.transformPoint(x + width, y + height);

        // Calculate actual rectangle bounds
        const minX = Math.min(transformedX, transformedX2);
        const maxX = Math.max(transformedX, transformedX2);
        const minY = Math.min(transformedY, transformedY2);
        const maxY = Math.max(transformedY, transformedY2);

        // Convert to WebGL screen coordinates (flip Y)
        const screenY = this.height - maxY;
        const rectWidth = maxX - minX;
        const rectHeight = maxY - minY;

        // Set scissor rectangle
        gl.scissor(
            Math.floor(minX),
            Math.floor(screenY),
            Math.ceil(rectWidth),
            Math.ceil(rectHeight)
        );

        // Clear the scissored area
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Disable scissor test
        gl.disable(gl.SCISSOR_TEST);
    }

    /*
     * Set the clear color (background color when clearing)
     * @param {string|Array} color - Color to clear to
     */
    setClearColor(color) {
        const rgba = this.parseColor(color);
        this.gl.clearColor(rgba[0], rgba[1], rgba[2], rgba[3]);
    }

    /*
     * Get current clear color
     * @return {Array} - RGBA array of current clear color
     */
    getClearColor() {
        const gl = this.gl;
        return gl.getParameter(gl.COLOR_CLEAR_VALUE);
    }

    /*
     * Clear canvas to a specific color
     * @param {string|Array} color - Color to clear to (optional, uses current clear color if not specified)
     */
    clearToColor(color) {
        if (color) {
            // Temporarily set clear color
            const currentClearColor = this.getClearColor();
            this.setClearColor(color);
            this.clear();
            // Restore previous clear color
            this.gl.clearColor(currentClearColor[0], currentClearColor[1], currentClearColor[2], currentClearColor[3]);
        } else {
            this.clear();
        }
    }

    /*
     * Clear a rectangular area to a specific color
     * @param {number} x - X coordinate
     * @param {number} y - Y coordinate
     * @param {number} width - Width
     * @param {number} height - Height
     * @param {string|Array} color - Color to clear to
     */
    clearRectToColor(x, y, width, height, color) {
        // Save current fill style
        const currentFillStyle = [...this.state.fillStyle];
        const currentGlobalAlpha = this.state.globalAlpha;

        // Set fill style to clear color with full opacity
        this.fillStyle = color;
        this.globalAlpha = 1;

        // Draw a rectangle with the clear color
        this.fillRect(x, y, width, height);

        // Restore previous fill style
        this.state.fillStyle = currentFillStyle;
        this.state.globalAlpha = currentGlobalAlpha;
    }

    /*
     * Fill entire canvas with a color (like clearToColor but uses fillStyle)
     */
    fillCanvas() {
        this.fillRect(0, 0, this.width, this.height);
    }

    /*
     * Clear with checkerboard pattern (useful for transparency visualization)
     * @param {number} size - Size of checkerboard squares (default: 16)
     * @param {string|Array} color1 - First color (default: light gray)
     * @param {string|Array} color2 - Second color (default: white)
     */
    clearWithCheckerboard(size = 16, color1 = '#E0E0E0', color2 = '#FFFFFF') {
        // Save current state
        const currentFillStyle = [...this.state.fillStyle];

        // Clear to transparent first
        this.clear();

        // Draw checkerboard pattern
        const cols = Math.ceil(this.width / size);
        const rows = Math.ceil(this.height / size);

        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                // Alternate colors based on position
                const isEven = (row + col) % 2 === 0;
                this.fillStyle = isEven ? color1 : color2;
                this.fillRect(col * size, row * size, size, size);
            }
        }

        // Restore fill style
        this.state.fillStyle = currentFillStyle;
    }

    /*
     * Set global alpha (transparency)
     * @param {number} alpha - Alpha value (0-1)
     */
    set globalAlpha(alpha) {
        this.state.globalAlpha = Math.max(0, Math.min(1, alpha));
    }

    get globalAlpha() {
        return this.state.globalAlpha;
    }

    /*
     * Set line cap style
     * @param {string} cap - 'butt', 'round', or 'square'
     */
    set lineCap(cap) {
        this.state.lineCap = cap;
    }

    get lineCap() {
        return this.state.lineCap;
    }

    /*
     * Set line join style
     * @param {string} join - 'miter', 'round', or 'bevel'
     */
    set lineJoin(join) {
        this.state.lineJoin = join;
    }

    get lineJoin() {
        return this.state.lineJoin;
    }

    /*
     * Set text properties
     */
    set font(font) {
        this.state.font = font;
    }

    get font() {
        return this.state.font;
    }

    set textAlign(align) {
        this.state.textAlign = align;
    }

    get textAlign() {
        return this.state.textAlign;
    }

    set textBaseline(baseline) {
        this.state.textBaseline = baseline;
    }

    get textBaseline() {
        return this.state.textBaseline;
    }

    /*
    * Set up WebGL context loss and restore handling
    */
    setupContextLossHandling() {
        // Store the lose context extension for emergency use
        this.loseContextExtension = this.gl.getExtension('WEBGL_lose_context');

        // Handle context lost event
        this.canvas.addEventListener('webglcontextlost', (event) => {
            // console.warn('WebGL context lost');
            event.preventDefault(); // This is crucial - prevents default behavior
            this.contextLost = true;

            // Stop any ongoing animations immediately
            if (this.animationId) {
                cancelAnimationFrame(this.animationId);
                this.animationId = null;
            }

            // Clear all pending timeouts/intervals
            this.clearAllTimers();

            // Clear all resources immediately - don't try to delete WebGL objects
            this.clearResourcesOnContextLoss();

            // Emit custom event
            if (this.canvas && typeof this.canvas.dispatchEvent === 'function') {
                try {
                    this.canvas.dispatchEvent(new CustomEvent('contextlost'));
                } catch (e) {
                    // console.warn('Failed to dispatch contextlost event:', e);
                }
            }
        }, false);

        // Handle context restored event with retry mechanism
        this.canvas.addEventListener('webglcontextrestored', (event) => {
            // console.log('WebGL context restored');
            this.contextLost = false;

            // Add a small delay before restoration to ensure stability
            setTimeout(() => {
                this.attemptContextRestore();
            }, 100);
        }, false);

        // Monitor for context loss in critical operations
        this.setupContextMonitoring();
    }

    /*
    * Attempt context restoration with error handling
    */
    attemptContextRestore() {
        let attempts = 0;
        const maxAttempts = 3;

        const restore = () => {
            try {
                this.restoreWebGLState();

                // Run restore callbacks
                this.contextRestoreCallbacks.forEach(callback => {
                    try {
                        callback();
                    } catch (e) {
                        // console.error('Error in context restore callback:', e);
                    }
                });

                // Emit custom event
                if (this.canvas && typeof this.canvas.dispatchEvent === 'function') {
                    this.canvas.dispatchEvent(new CustomEvent('contextrestored'));
                }

                // console.log('WebGL context successfully restored');
            } catch (e) {
                attempts++;
                // console.error(`Context restore attempt ${attempts} failed:`, e);

                if (attempts < maxAttempts) {
                    // console.log(`Retrying context restore in ${attempts * 500}ms...`);
                    setTimeout(restore, attempts * 500);
                } else {
                    // console.error('Failed to restore WebGL context after maximum attempts');
                    this.contextLost = true;
                }
            }
        };

        restore();
    }

    /*
    * Monitor context health during operations
    */
    setupContextMonitoring() {
        // Check context periodically but less frequently to reduce overhead
        this.contextHealthCheck = setInterval(() => {
            if (this.gl && !this.contextLost) {
                try {
                    if (this.gl.isContextLost()) {
                        // console.warn('Context loss detected during health check');
                        this.contextLost = true;
                        this.clearResourcesOnContextLoss();
                    }
                } catch (e) {
                    // If we can't even call isContextLost, context is definitely lost
                    // console.warn('Cannot check context health, assuming lost');
                    this.contextLost = true;
                    this.clearResourcesOnContextLoss();
                }
            }
        }, 10000); // Check every 10 seconds instead of 5
    }

    /*
    * Clear all timers and intervals
    */
    clearAllTimers() {
        // Clear any stored timer IDs
        if (this.timers) {
            this.timers.forEach(id => clearTimeout(id));
            this.timers.clear();
        }
    }

    /*
     * Clear resources when context is lost
     */
    clearResourcesOnContextLoss() {
        // Clear texture cache references (textures are automatically lost)
        this.textureCache.clear();
        this.fontCache.clear();

        // Clear shader references (programs are automatically lost)
        this.shaders = {};

        // Reset batch state without trying to delete buffers
        if (this.batchBuffers) {
            Object.values(this.batchBuffers).forEach(batch => {
                if (batch) {
                    batch.currentVertices = 0;
                    batch.currentIndices = 0;
                    if (batch.currentQuads !== undefined) batch.currentQuads = 0;
                    batch.currentTexture = null;
                    // Don't try to delete buffers - they're automatically lost
                    batch.vertices = null;
                    batch.colors = null;
                    batch.indices = null;
                    batch.centers = null;
                    batch.radii = null;
                    batch.texCoords = null;
                }
            });
        }

        // Clear post-processing resources references
        if (this.postProcessing) {
            this.postProcessing.framebuffers = [];
            this.postProcessing.tempTextures = [];
            this.postProcessing.quadBuffer = null;
            this.postProcessing.quadIndexBuffer = null;
        }

        // Clear custom buffers
        this.customVertexBuffer = null;
        this.customIndexBuffer = null;
        this.currentShader = null;
    }

    /*
     * Restore WebGL state after context restore
     */
    restoreWebGLState() {
        if (!this.gl || this.gl.isContextLost()) {
            // console.error('Cannot restore state - context is still lost');
            return;
        }

        try {
            // Reinitialize WebGL
            this.init();

            // Recreate built-in shaders
            this.createBuiltInShaders();

            // Recreate batch buffers
            this.createBatchBuffers();

            // Set initial viewport
            this.gl.viewport(0, 0, this.width, this.height);
            this.gl.enable(this.gl.BLEND);
            this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);

            // console.log('WebGL state restored successfully');
        } catch (e) {
            // console.error('Failed to restore WebGL state:', e);
            this.contextLost = true; // Keep marked as lost if restore fails
            throw e;
        }
    }

    /*
 * Periodic texture cache cleanup
 */
    cleanupTextureCache() {
        const now = performance.now();
        const maxAge = 30000; // 30 seconds

        for (const [image, data] of this.textureCache.entries()) {
            if (now - data.lastUsed > maxAge) {
                if (data.atlas === null && this.gl.isTexture(data.texture)) {
                    this.gl.deleteTexture(data.texture);
                }
                this.textureCache.delete(image);
            }
        }
    }

    /*
     * Add callback to run when context is restored
     * @param {Function} callback - Function to call on context restore
     */
    onContextRestore(callback) {
        this.contextRestoreCallbacks.push(callback);
    }

    /*
     * Check if context is lost before performing operations
     */
    isContextLost() {
        return this.contextLost || (this.gl && this.gl.isContextLost());
    }

    isFramebufferValid(framebuffer) {
        return framebuffer &&
            this.gl.isFramebuffer(framebuffer) &&
            this.gl.getFramebufferAttachmentParameter(
                this.gl.FRAMEBUFFER,
                this.gl.COLOR_ATTACHMENT0,
                this.gl.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME
            ) !== null;
    }

    /*
     * Set VSync enabled/disabled
     * @param {boolean} enabled - Whether to enable VSync
     */
    setVSync(enabled) {
        this.frameTime.enabled = enabled;
        this.options.vsync = enabled;

        if (enabled) {
            console.log(`VSync enabled - Target FPS: ${this.frameTime.targetFPS}`);
        } else {
            console.log('VSync disabled - Unlimited frame rate');
        }
    }

    /*
     * Get current VSync state
     * @return {boolean} - Whether VSync is enabled
     */
    getVSync() {
        return this.frameTime.enabled;
    }

    /*
     * Set target FPS for VSync
     * @param {number} fps - Target frames per second
     */
    setTargetFPS(fps) {
        fps = Math.max(1, Math.min(240, fps)); // Clamp between 1-240 FPS
        this.frameTime.targetFPS = fps;
        this.frameTime.targetFrameTime = 1000 / fps;
        this.frameTime.adaptiveTargetFPS = fps;
        this.options.targetFPS = fps;

        console.log(`Target FPS set to: ${fps} (${this.frameTime.targetFrameTime.toFixed(2)}ms per frame)`);
    }

    /*
     * Get current target FPS
     * @return {number} - Target FPS
     */
    getTargetFPS() {
        return this.frameTime.targetFPS;
    }

    /*
     * Enable/disable adaptive sync
     * @param {boolean} enabled - Whether to enable adaptive sync
     */
    setAdaptiveSync(enabled) {
        this.frameTime.adaptiveSync = enabled;
        this.options.adaptiveSync = enabled;

        if (enabled) {
            console.log('Adaptive sync enabled - FPS will adjust based on performance');
        } else {
            console.log('Adaptive sync disabled');
            this.frameTime.adaptiveTargetFPS = this.frameTime.targetFPS;
        }
    }

    /*
     * Get frame timing statistics
     * @return {Object} - Frame timing information
     */
    getFrameStats() {
        return {
            vsyncEnabled: this.frameTime.enabled,
            targetFPS: this.frameTime.targetFPS,
            actualFPS: this.frameTime.actualFPS,
            adaptiveTargetFPS: this.frameTime.adaptiveTargetFPS,
            minFrameTime: this.frameTime.minFrameTime,
            maxFrameTime: this.frameTime.maxFrameTime,
            avgFrameTime: this.frameTime.avgFrameTime,
            frameTimeVariance: this.frameTime.frameTimeVariance,
            performanceScore: this.frameTime.performanceScore,
            adaptiveSync: this.frameTime.adaptiveSync,
            frameCount: this.frameTime.frameCount
        };
    }

    /*
     * Update frame timing statistics
     * @param {number} startTime - Frame start time
     */
    updateFrameStats(startTime) {
        const now = performance.now();
        const frameTime = now - this.frameTime.lastFrameTime;
        const renderTime = now - startTime;

        if (this.frameTime.lastFrameTime > 0) {
            // Update frame buffer
            this.frameTime.frameBuffer.push(frameTime);
            if (this.frameTime.frameBuffer.length > this.frameTime.bufferSize) {
                this.frameTime.frameBuffer.shift();
            }

            // Calculate statistics
            this.frameTime.minFrameTime = Math.min(this.frameTime.minFrameTime, frameTime);
            this.frameTime.maxFrameTime = Math.max(this.frameTime.maxFrameTime, frameTime);

            // Calculate average and variance
            const sum = this.frameTime.frameBuffer.reduce((a, b) => a + b, 0);
            this.frameTime.avgFrameTime = sum / this.frameTime.frameBuffer.length;
            this.frameTime.actualFPS = 1000 / this.frameTime.avgFrameTime;

            // Calculate variance
            const variance = this.frameTime.frameBuffer.reduce((acc, time) => {
                return acc + Math.pow(time - this.frameTime.avgFrameTime, 2);
            }, 0) / this.frameTime.frameBuffer.length;
            this.frameTime.frameTimeVariance = Math.sqrt(variance);

            // Update performance score
            this.updatePerformanceScore(frameTime, renderTime);

            // Adaptive sync adjustment
            if (this.frameTime.adaptiveSync) {
                this.updateAdaptiveSync();
            }
        }

        this.frameTime.lastFrameTime = now;
        this.frameTime.frameCount++;
    }

    /*
     * Update performance score based on frame timing
     * @param {number} frameTime - Time for this frame
     * @param {number} renderTime - Time spent rendering
     */
    updatePerformanceScore(frameTime, renderTime) {
        const targetTime = this.frameTime.targetFrameTime;

        // Performance score based on how close we are to target
        let score = 1.0;

        if (frameTime > targetTime) {
            // We're running slow
            score = Math.max(0.1, targetTime / frameTime);
        } else {
            // We're running fast - not necessarily bad
            score = Math.min(1.0, 1.0 - (targetTime - frameTime) / targetTime * 0.1);
        }

        // Factor in rendering time vs total frame time
        const renderRatio = renderTime / frameTime;
        if (renderRatio > 0.8) {
            // High render time indicates potential performance issues
            score *= Math.max(0.5, 1.0 - (renderRatio - 0.8) * 2);
        }

        // Smooth the performance score
        this.frameTime.performanceScore = this.frameTime.performanceScore * 0.95 + score * 0.05;
    }

    /*
     * Update adaptive sync target FPS
     */
    updateAdaptiveSync() {
        this.frameTime.adaptiveUpdateCounter++;

        // Only update every 30 frames to avoid oscillation
        if (this.frameTime.adaptiveUpdateCounter < 30) {
            return;
        }

        this.frameTime.adaptiveUpdateCounter = 0;

        const performance = this.frameTime.performanceScore;
        const currentAdaptiveTarget = this.frameTime.adaptiveTargetFPS;
        const baseTarget = this.frameTime.targetFPS;

        if (performance < 0.8) {
            // Performance is poor, reduce target FPS
            const newTarget = Math.max(baseTarget * 0.5, currentAdaptiveTarget * 0.9);
            this.frameTime.adaptiveTargetFPS = newTarget;
            console.log(`Adaptive sync: Reduced target FPS to ${newTarget.toFixed(1)} (performance: ${(performance * 100).toFixed(1)}%)`);
        } else if (performance > 0.95 && currentAdaptiveTarget < baseTarget) {
            // Performance is excellent, try to increase FPS back toward target
            const newTarget = Math.min(baseTarget, currentAdaptiveTarget * 1.1);
            this.frameTime.adaptiveTargetFPS = newTarget;
            console.log(`Adaptive sync: Increased target FPS to ${newTarget.toFixed(1)} (performance: ${(performance * 100).toFixed(1)}%)`);
        }
    }

    /*
     * Start animation loop with VSync
     * @param {Function} callback - Function to call each frame
     */
    startAnimationLoop(callback) {
        if (this.frameTime.isAnimating) {
            console.warn('Animation loop already running');
            return;
        }

        this.frameTime.renderCallback = callback;
        this.frameTime.isAnimating = true;
        this.frameTime.lastFrameTime = performance.now();

        if (this.frameTime.enabled) {
            this.vsyncAnimationLoop();
        } else {
            this.unlimitedAnimationLoop();
        }
    }

    /*
     * Stop animation loop
     */
    stopAnimationLoop() {
        this.frameTime.isAnimating = false;
        this.frameTime.renderCallback = null;

        if (this.frameTime.animationId) {
            cancelAnimationFrame(this.frameTime.animationId);
            this.frameTime.animationId = null;
        }

        console.log('Animation loop stopped');
    }

    /*
     * VSync-limited animation loop
     */
    vsyncAnimationLoop() {
        if (!this.frameTime.isAnimating) return;

        const now = performance.now();
        const targetFPS = this.frameTime.adaptiveSync ?
            this.frameTime.adaptiveTargetFPS :
            this.frameTime.targetFPS;
        const targetFrameTime = 1000 / targetFPS;
        const elapsed = now - this.frameTime.lastFrameTime;

        if (elapsed >= targetFrameTime - 1) { // -1ms tolerance for timing precision
            if (this.frameTime.renderCallback) {
                this.frameTime.renderCallback(now, elapsed);
            }
        }

        this.frameTime.animationId = requestAnimationFrame(() => this.vsyncAnimationLoop());
    }

    /*
     * Unlimited frame rate animation loop
     */
    unlimitedAnimationLoop() {
        if (!this.frameTime.isAnimating) return;

        const now = performance.now();
        const elapsed = now - this.frameTime.lastFrameTime;

        if (this.frameTime.renderCallback) {
            this.frameTime.renderCallback(now, elapsed);
        }

        this.frameTime.animationId = requestAnimationFrame(() => this.unlimitedAnimationLoop());
    }

    /*
     * Wait for next frame (useful for manual timing control)
     * @return {Promise} - Promise that resolves on next frame
     */
    waitForNextFrame() {
        return new Promise(resolve => {
            if (this.frameTime.enabled) {
                const now = performance.now();
                const targetFPS = this.frameTime.adaptiveSync ?
                    this.frameTime.adaptiveTargetFPS :
                    this.frameTime.targetFPS;
                const targetFrameTime = 1000 / targetFPS;
                const elapsed = now - this.frameTime.lastFrameTime;
                const remaining = Math.max(0, targetFrameTime - elapsed);

                setTimeout(() => {
                    requestAnimationFrame(resolve);
                }, remaining);
            } else {
                requestAnimationFrame(resolve);
            }
        });
    }

    /*
     * Convenience method: Render with automatic VSync
     * @param {Function} renderCallback - Function to call for rendering
     */
    renderWithVSync(renderCallback) {
        if (!this.frameTime.isAnimating) {
            this.startAnimationLoop((time, deltaTime) => {
                this.clear();
                renderCallback(time, deltaTime);
                this.flush();
            });
        }
    }

    /*
     * Reset frame timing statistics
     */
    resetFrameStats() {
        this.frameTime.frameCount = 0;
        this.frameTime.minFrameTime = Infinity;
        this.frameTime.maxFrameTime = 0;
        this.frameTime.frameBuffer = [];
        this.frameTime.performanceScore = 1.0;
        this.frameTime.adaptiveTargetFPS = this.frameTime.targetFPS;
        this.frameTime.lastFrameTime = performance.now();

        console.log('Frame timing statistics reset');
    }

    /*
     * Get VSync configuration object
     * @return {Object} - VSync configuration
     */
    getVSyncConfig() {
        return {
            enabled: this.frameTime.enabled,
            targetFPS: this.frameTime.targetFPS,
            adaptiveSync: this.frameTime.adaptiveSync,
            frameTimingBuffer: this.frameTime.bufferSize
        };
    }

    /*
     * Set VSync configuration
     * @param {Object} config - VSync configuration object
     */
    setVSyncConfig(config) {
        if (config.enabled !== undefined) {
            this.setVSync(config.enabled);
        }
        if (config.targetFPS !== undefined) {
            this.setTargetFPS(config.targetFPS);
        }
        if (config.adaptiveSync !== undefined) {
            this.setAdaptiveSync(config.adaptiveSync);
        }
        if (config.frameTimingBuffer !== undefined) {
            this.frameTime.bufferSize = Math.max(10, Math.min(100, config.frameTimingBuffer));
        }
    }

    /*
     * Flush all batches to GPU
     */
    flush() {
        if (this.isContextLost() || !this.gl) {
            return;
        }

        const startTime = performance.now();

        try {
            // Check if we need advanced blending
            const needsAdvancedBlend = this.applyAdvancedBlendMode(this.state.globalCompositeOperation);

            if (needsAdvancedBlend) {
                // Render to texture first, then composite
                this.renderBatchesToTexture();
                this.compositeWithAdvancedBlend(this.state.globalCompositeOperation);
            } else {
                // Standard rendering path
                if (this.postProcessing.enabled && this.postProcessing.effects.length > 0) {
                    if (!this.isFramebufferValid(this.postProcessing.framebuffers[0])) {
                        this.createPostProcessingFramebuffers();
                    }

                    this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.postProcessing.framebuffers[0]);
                    this.gl.viewport(0, 0, this.width, this.height);
                    this.gl.clear(this.gl.COLOR_BUFFER_BIT);

                    this.flushRectangles();
                    this.flushCircles();
                    this.flushEllipses();
                    this.flushLines();
                    this.flushImages();

                    this.renderPostProcessing();
                } else {
                    this.flushRectangles();
                    this.flushCircles();
                    this.flushEllipses();
                    this.flushLines();
                    this.flushImages();
                }
            }

            // Update frame timing statistics
            if (this.frameTime.enabled) {
                this.updateFrameStats(startTime);
            }

        } catch (e) {
            if (this.gl && this.gl.isContextLost()) {
                this.contextLost = true;
                this.clearResourcesOnContextLoss();
            }
        }
    }

    /*
    * Ultra-fast image batch flushing
    */
    flushImageBatch() {
        const batch = this.imageBatchBuffer;
        if (batch.currentQuads === 0 || !batch.currentTexture) return;

        const gl = this.gl;
        const program = this.shaders.instancedImage;

        gl.useProgram(program);

        // Bind texture once
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, batch.currentTexture);
        gl.uniform1i(gl.getUniformLocation(program, 'u_texture'), 0);

        // Set uniforms
        gl.uniform2f(gl.getUniformLocation(program, 'u_resolution'), this.width, this.height);
        gl.uniform1f(gl.getUniformLocation(program, 'u_globalAlpha'), this.state.globalAlpha);
        gl.uniformMatrix3fv(gl.getUniformLocation(program, 'u_globalTransform'), false, this.state.transform);

        // Upload vertex data (only current portion)
        const vertexCount = batch.currentQuads * 8;
        gl.bindBuffer(gl.ARRAY_BUFFER, batch.vertices);
        gl.bufferData(gl.ARRAY_BUFFER, batch.vertexData.subarray(0, vertexCount), gl.DYNAMIC_DRAW);

        const positionLoc = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(positionLoc);
        gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

        // Upload texture coordinate data
        gl.bindBuffer(gl.ARRAY_BUFFER, batch.texCoords);
        gl.bufferData(gl.ARRAY_BUFFER, batch.texCoordData.subarray(0, vertexCount), gl.DYNAMIC_DRAW);

        const texCoordLoc = gl.getAttribLocation(program, 'a_texCoord');
        gl.enableVertexAttribArray(texCoordLoc);
        gl.vertexAttribPointer(texCoordLoc, 2, gl.FLOAT, false, 0, 0);

        // Upload transform data
        const transformCount = batch.currentQuads * 6;
        gl.bindBuffer(gl.ARRAY_BUFFER, batch.transforms);
        gl.bufferData(gl.ARRAY_BUFFER, batch.transformData.subarray(0, transformCount), gl.DYNAMIC_DRAW);

        const transformLoc = gl.getAttribLocation(program, 'a_transform');
        gl.enableVertexAttribArray(transformLoc);
        gl.vertexAttribPointer(transformLoc, 6, gl.FLOAT, false, 0, 0);

        // Use pre-generated indices
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, batch.indices);

        // Draw all quads in one call
        gl.drawElements(gl.TRIANGLES, batch.currentQuads * 6, gl.UNSIGNED_SHORT, 0);

        // Reset batch
        batch.currentQuads = 0;
        batch.currentTexture = null;
    }

    /*
     * Flush image batch
     */
    flushImages() {
        const batch = this.batchBuffers.images;
        if (batch.currentQuads === 0 || !batch.currentTexture) return;

        const gl = this.gl;
        const program = this.shaders.image;

        gl.useProgram(program);

        // Bind and activate texture
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, batch.currentTexture);

        // Set texture uniform
        const textureLocation = gl.getUniformLocation(program, 'u_texture');
        if (textureLocation !== null) {
            gl.uniform1i(textureLocation, 0);
        }

        // Upload and bind vertex data
        gl.bindBuffer(gl.ARRAY_BUFFER, batch.vertices);
        gl.bufferData(gl.ARRAY_BUFFER, batch.vertexData.subarray(0, batch.currentVertices * 2), gl.DYNAMIC_DRAW);

        const positionLoc = gl.getAttribLocation(program, 'a_position');
        if (positionLoc >= 0) {
            gl.enableVertexAttribArray(positionLoc);
            gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
        }

        // Upload and bind texture coordinate data
        gl.bindBuffer(gl.ARRAY_BUFFER, batch.texCoords);
        gl.bufferData(gl.ARRAY_BUFFER, batch.texCoordData.subarray(0, batch.currentVertices * 2), gl.DYNAMIC_DRAW);

        const texCoordLoc = gl.getAttribLocation(program, 'a_texCoord');
        if (texCoordLoc >= 0) {
            gl.enableVertexAttribArray(texCoordLoc);
            gl.vertexAttribPointer(texCoordLoc, 2, gl.FLOAT, false, 0, 0);
        }

        // Upload and bind index data
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, batch.indices);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, batch.indexData.subarray(0, batch.currentIndices), gl.DYNAMIC_DRAW);

        // Set basic uniforms
        const resolutionLoc = gl.getUniformLocation(program, 'u_resolution');
        if (resolutionLoc !== null) {
            gl.uniform2f(resolutionLoc, this.width, this.height);
        }

        const globalAlphaLoc = gl.getUniformLocation(program, 'u_globalAlpha');
        if (globalAlphaLoc !== null) {
            gl.uniform1f(globalAlphaLoc, this.state.globalAlpha);
        }

        // Set color manipulation uniforms
        const hueLocation = gl.getUniformLocation(program, 'u_hue');
        if (hueLocation !== null) {
            gl.uniform1f(hueLocation, this.state.imageHue);
        }

        const saturationLocation = gl.getUniformLocation(program, 'u_saturation');
        if (saturationLocation !== null) {
            gl.uniform1f(saturationLocation, this.state.imageSaturation);
        }

        const lightnessLocation = gl.getUniformLocation(program, 'u_lightness');
        if (lightnessLocation !== null) {
            gl.uniform1f(lightnessLocation, this.state.imageLightness);
        }

        const brightnessLocation = gl.getUniformLocation(program, 'u_brightness');
        if (brightnessLocation !== null) {
            gl.uniform1f(brightnessLocation, this.state.imageBrightness);
        }

        const contrastLocation = gl.getUniformLocation(program, 'u_contrast');
        if (contrastLocation !== null) {
            gl.uniform1f(contrastLocation, this.state.imageContrast);
        }

        const colorTintLocation = gl.getUniformLocation(program, 'u_colorTint');
        if (colorTintLocation !== null) {
            gl.uniform4fv(colorTintLocation, this.state.imageColorTint);
        }

        const opacityLocation = gl.getUniformLocation(program, 'u_opacity');
        if (opacityLocation !== null) {
            gl.uniform1f(opacityLocation, this.state.imageOpacity);
        }

        const colorModeLocation = gl.getUniformLocation(program, 'u_colorMode');
        if (colorModeLocation !== null) {
            gl.uniform1i(colorModeLocation, this.state.imageColorMode);
        }

        const colorMultiplyLocation = gl.getUniformLocation(program, 'u_colorMultiply');
        if (colorMultiplyLocation !== null) {
            gl.uniform4fv(colorMultiplyLocation, this.state.imageColorMultiply);
        }

        const colorAddLocation = gl.getUniformLocation(program, 'u_colorAdd');
        if (colorAddLocation !== null) {
            gl.uniform4fv(colorAddLocation, this.state.imageColorAdd);
        }

        const gammaLocation = gl.getUniformLocation(program, 'u_gamma');
        if (gammaLocation !== null) {
            gl.uniform1f(gammaLocation, this.state.imageGamma);
        }

        const exposureLocation = gl.getUniformLocation(program, 'u_exposure');
        if (exposureLocation !== null) {
            gl.uniform1f(exposureLocation, this.state.imageExposure);
        }

        // Draw all batched quads in one call
        gl.drawElements(gl.TRIANGLES, batch.currentIndices, gl.UNSIGNED_SHORT, 0);

        // Check for errors
        this.checkGLError('flushImages');

        // Reset batch
        batch.currentVertices = 0;
        batch.currentIndices = 0;
        batch.currentQuads = 0;
        batch.currentTexture = null;

        // Clean up
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    }

    /*
    * Force flush of images using a specific texture
    * Useful when you want to ensure images are drawn before switching textures
    */
    flushImagesForTexture(texture) {
        const batch = this.batchBuffers.images;
        if (batch.currentTexture === texture && batch.currentQuads > 0) {
            this.flushImages();
        }
    }

    /*
    * Get current image batch statistics
    * Useful for monitoring batching efficiency
    */
    getImageBatchStats() {
        const batch = this.batchBuffers.images;
        return {
            currentQuads: batch.currentQuads,
            maxQuads: batch.maxQuads,
            currentTexture: batch.currentTexture,
            batchUtilization: (batch.currentQuads / batch.maxQuads * 100).toFixed(1) + '%'
        };
    }

    /*
     * Flush ellipse batch
     */
    flushEllipses() {
        const batch = this.batchBuffers.ellipses;
        if (batch.currentVertices === 0) return;

        const gl = this.gl;
        const program = this.shaders.batchedEllipse;

        gl.useProgram(program);

        // Upload vertex data
        gl.bindBuffer(gl.ARRAY_BUFFER, batch.vertices);
        gl.bufferData(gl.ARRAY_BUFFER, batch.vertexData.subarray(0, batch.currentVertices * 2), gl.DYNAMIC_DRAW);

        const positionLoc = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(positionLoc);
        gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

        // Upload color data
        gl.bindBuffer(gl.ARRAY_BUFFER, batch.colors);
        gl.bufferData(gl.ARRAY_BUFFER, batch.colorData.subarray(0, batch.currentVertices * 4), gl.DYNAMIC_DRAW);

        const colorLoc = gl.getAttribLocation(program, 'a_color');
        gl.enableVertexAttribArray(colorLoc);
        gl.vertexAttribPointer(colorLoc, 4, gl.FLOAT, false, 0, 0);

        // Upload center data
        gl.bindBuffer(gl.ARRAY_BUFFER, batch.centers);
        gl.bufferData(gl.ARRAY_BUFFER, batch.centerData.subarray(0, batch.currentVertices * 2), gl.DYNAMIC_DRAW);

        const centerLoc = gl.getAttribLocation(program, 'a_center');
        gl.enableVertexAttribArray(centerLoc);
        gl.vertexAttribPointer(centerLoc, 2, gl.FLOAT, false, 0, 0);

        // Upload radius data (radiusX, radiusY)
        gl.bindBuffer(gl.ARRAY_BUFFER, batch.radii);
        gl.bufferData(gl.ARRAY_BUFFER, batch.radiusData.subarray(0, batch.currentVertices * 2), gl.DYNAMIC_DRAW);

        const radiusLoc = gl.getAttribLocation(program, 'a_radius');
        gl.enableVertexAttribArray(radiusLoc);
        gl.vertexAttribPointer(radiusLoc, 2, gl.FLOAT, false, 0, 0);

        // Upload index data
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, batch.indices);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, batch.indexData.subarray(0, batch.currentIndices), gl.DYNAMIC_DRAW);

        // Set uniforms
        const resolutionLoc = gl.getUniformLocation(program, 'u_resolution');
        gl.uniform2f(resolutionLoc, this.width, this.height);

        // Draw all ellipses
        gl.drawElements(gl.TRIANGLES, batch.currentIndices, gl.UNSIGNED_SHORT, 0);

        // Reset batch
        batch.currentVertices = 0;
        batch.currentIndices = 0;
    }

    /*
     * Flush rectangle batch
     */
    flushRectangles() {
        const batch = this.batchBuffers.rectangles;
        if (batch.currentVertices === 0) return;

        const gl = this.gl;
        const program = this.shaders.batchedRect;

        gl.useProgram(program);

        // Upload vertex data
        gl.bindBuffer(gl.ARRAY_BUFFER, batch.vertices);
        gl.bufferData(gl.ARRAY_BUFFER, batch.vertexData.subarray(0, batch.currentVertices * 2), gl.DYNAMIC_DRAW);

        const positionLoc = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(positionLoc);
        gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

        // Upload color data
        gl.bindBuffer(gl.ARRAY_BUFFER, batch.colors);
        gl.bufferData(gl.ARRAY_BUFFER, batch.colorData.subarray(0, batch.currentVertices * 4), gl.DYNAMIC_DRAW);

        const colorLoc = gl.getAttribLocation(program, 'a_color');
        gl.enableVertexAttribArray(colorLoc);
        gl.vertexAttribPointer(colorLoc, 4, gl.FLOAT, false, 0, 0);

        // Upload index data
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, batch.indices);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, batch.indexData.subarray(0, batch.currentIndices), gl.DYNAMIC_DRAW);

        // Set uniforms
        const resolutionLoc = gl.getUniformLocation(program, 'u_resolution');
        gl.uniform2f(resolutionLoc, this.width, this.height);

        // Draw all rectangles in one call!
        gl.drawElements(gl.TRIANGLES, batch.currentIndices, gl.UNSIGNED_SHORT, 0);

        // Reset batch after flushing
        batch.currentVertices = 0;
        batch.currentIndices = 0;

        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    }

    /*
     * Flush circle batch using instanced rendering
     */
    flushCircles() {
        const batch = this.batchBuffers.circles;
        if (batch.currentVertices === 0) return;

        const gl = this.gl;
        const program = this.shaders.batchedCircle;

        // Check if program exists and is valid
        if (!program || !gl.isProgram(program)) {
            // console.error('Circle shader program not available or invalid');
            // Reset batch to prevent infinite loop
            batch.currentVertices = 0;
            batch.currentIndices = 0;
            return;
        }

        gl.useProgram(program);

        // Upload vertex data
        gl.bindBuffer(gl.ARRAY_BUFFER, batch.vertices);
        gl.bufferData(gl.ARRAY_BUFFER, batch.vertexData.subarray(0, batch.currentVertices * 2), gl.DYNAMIC_DRAW);

        const positionLoc = gl.getAttribLocation(program, 'a_position');
        if (positionLoc >= 0) {
            gl.enableVertexAttribArray(positionLoc);
            gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
        }

        // Upload color data
        gl.bindBuffer(gl.ARRAY_BUFFER, batch.colors);
        gl.bufferData(gl.ARRAY_BUFFER, batch.colorData.subarray(0, batch.currentVertices * 4), gl.DYNAMIC_DRAW);

        const colorLoc = gl.getAttribLocation(program, 'a_color');
        if (colorLoc >= 0) {
            gl.enableVertexAttribArray(colorLoc);
            gl.vertexAttribPointer(colorLoc, 4, gl.FLOAT, false, 0, 0);
        }

        // Upload center data
        gl.bindBuffer(gl.ARRAY_BUFFER, batch.centers);
        gl.bufferData(gl.ARRAY_BUFFER, batch.centerData.subarray(0, batch.currentVertices * 2), gl.DYNAMIC_DRAW);

        const centerLoc = gl.getAttribLocation(program, 'a_center');
        if (centerLoc >= 0) {
            gl.enableVertexAttribArray(centerLoc);
            gl.vertexAttribPointer(centerLoc, 2, gl.FLOAT, false, 0, 0);
        }

        // Upload radius data
        gl.bindBuffer(gl.ARRAY_BUFFER, batch.radii);
        gl.bufferData(gl.ARRAY_BUFFER, batch.radiusData.subarray(0, batch.currentVertices), gl.DYNAMIC_DRAW);

        const radiusLoc = gl.getAttribLocation(program, 'a_radius');
        if (radiusLoc >= 0) {
            gl.enableVertexAttribArray(radiusLoc);
            gl.vertexAttribPointer(radiusLoc, 1, gl.FLOAT, false, 0, 0);
        }

        // Upload index data
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, batch.indices);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, batch.indexData.subarray(0, batch.currentIndices), gl.DYNAMIC_DRAW);

        // Set uniforms
        const resolutionLoc = gl.getUniformLocation(program, 'u_resolution');
        if (resolutionLoc !== null) {
            gl.uniform2f(resolutionLoc, this.width, this.height);
        }

        // Add stroke uniforms
        const strokeWidthLoc = gl.getUniformLocation(program, 'u_strokeWidth');
        if (strokeWidthLoc !== null) {
            gl.uniform1f(strokeWidthLoc, this.state.lineWidth);
        }

        const isStrokeLoc = gl.getUniformLocation(program, 'u_isStroke');
        if (isStrokeLoc !== null) {
            // This would need to be set based on whether we're drawing fill or stroke circles
            // For now, default to fill (0)
            gl.uniform1i(isStrokeLoc, 0);
        }

        // Draw all circles in one call!
        gl.drawElements(gl.TRIANGLES, batch.currentIndices, gl.UNSIGNED_SHORT, 0);

        // Reset batch after flushing
        batch.currentVertices = 0;
        batch.currentIndices = 0;

        // Clean up
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
    }

    /*
     * Flush line batch
     */
    flushLines() {
        const batch = this.batchBuffers.lines;
        if (batch.currentVertices === 0) return;

        const gl = this.gl;
        const program = this.shaders.batchedLine;

        gl.useProgram(program);

        // Upload vertex data
        gl.bindBuffer(gl.ARRAY_BUFFER, batch.vertices);
        gl.bufferData(gl.ARRAY_BUFFER, batch.vertexData.subarray(0, batch.currentVertices * 2), gl.DYNAMIC_DRAW);

        const positionLoc = gl.getAttribLocation(program, 'a_position');
        gl.enableVertexAttribArray(positionLoc);
        gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

        // Upload color data
        gl.bindBuffer(gl.ARRAY_BUFFER, batch.colors);
        gl.bufferData(gl.ARRAY_BUFFER, batch.colorData.subarray(0, batch.currentVertices * 4), gl.DYNAMIC_DRAW);

        const colorLoc = gl.getAttribLocation(program, 'a_color');
        gl.enableVertexAttribArray(colorLoc);
        gl.vertexAttribPointer(colorLoc, 4, gl.FLOAT, false, 0, 0);

        // Set uniforms
        const resolutionLoc = gl.getUniformLocation(program, 'u_resolution');
        gl.uniform2f(resolutionLoc, this.width, this.height);

        // Draw all lines
        gl.drawArrays(gl.LINES, 0, batch.currentVertices);

        // Reset batch after flushing
        batch.currentVertices = 0;
    }

    /*
        * Set fill style (color)
        * Accepts color in hex, rgb, rgba, or array format
        * @param {string|Array} color - Color value
    */
    set fillStyle(color) {
        if (!this.useWebGL) {
            this.ctx.fillStyle = color;
            return;
        }

        this.state.fillStyle = this.parseColor(color);
    }

    /*
        * Get current fill style
        * Returns the fill style as an RGBA array
        * @return {Array}
    */
    get fillStyle() {
        if (!this.useWebGL) {
            return this.ctx.fillStyle;
        }

        return this.state.fillStyle;
    }

    /*
        * Set stroke style (color)
        * Accepts color in hex, rgb, rgba, or array format
        * @param {string|Array} color - Color value
    */
    set strokeStyle(color) {
        if (!this.useWebGL) {
            this.ctx.strokeStyle = color;
            return;
        }

        this.state.strokeStyle = this.parseColor(color);
    }

    /*
        * Get current stroke style
        * Returns the stroke style as an RGBA array
        * @return {Array}
    */
    get strokeStyle() {
        if (!this.useWebGL) {
            return this.ctx.strokeStyle;
        }

        return this.state.strokeStyle;
    }

    /*
        * Set line width for strokes
        * @param {number} width - Line width in pixels
    */
    set lineWidth(width) {
        if (!this.useWebGL) {
            this.ctx.lineWidth = width;
            return;
        }

        this.state.lineWidth = Math.max(0, width);

        // Try to set WebGL line width for thin lines (fallback)
        if (this.gl && width <= 1) {
            try {
                this.gl.lineWidth(width);
            } catch (e) {
                // Some browsers/drivers don't support this
                // console.warn('WebGL lineWidth not supported, using rectangle-based rendering');
            }
        }
    }

    /*
        * Get current line width
        * Returns the line width in pixels
        * @return {number}
    */
    get lineWidth() {
        if (!this.useWebGL) {
            return this.ctx.lineWidth;
        }

        return this.state.lineWidth;
    }

    /*
 * Set shadow properties
 */
    set shadowColor(color) {
        if (!this.useWebGL) {
            this.ctx.shadowColor = color;
            return;
        }

        this.state.shadowColor = this.parseColor(color);
    }

    get shadowColor() {
        if (!this.useWebGL) {
            return this.ctx.shadowColor;
        }

        return this.state.shadowColor;
    }

    set shadowBlur(blur) {
        if (!this.useWebGL) {
            this.ctx.shadowBlur = Math.max(0, blur);
            return;
        }

        this.state.shadowBlur = Math.max(0, blur);
    }

    get shadowBlur() {
        if (!this.useWebGL) {
            return this.ctx.shadowBlur;
        }

        return this.state.shadowBlur;
    }

    set shadowOffsetX(offset) {
        if (!this.useWebGL) {
            this.ctx.shadowOffsetX = offset;
            return;
        }

        this.state.shadowOffsetX = offset;
    }

    get shadowOffsetX() {
        if (!this.useWebGL) {
            return this.ctx.shadowOffsetX;
        }

        return this.state.shadowOffsetX;
    }

    set shadowOffsetY(offset) {
        if (!this.useWebGL) {
            this.ctx.shadowOffsetY = offset;
            return;
        }

        this.state.shadowOffsetY = offset;
    }

    get shadowOffsetY() {
        if (!this.useWebGL) {
            return this.ctx.shadowOffsetY;
        }

        return this.state.shadowOffsetY;
    }

    /*
    * Set image smoothing
    */
    set imageSmoothingEnabled(enabled) {
        if (!this.useWebGL) {
            this.ctx.imageSmoothingEnabled = enabled;
            return;
        }

        this.state.imageSmoothingEnabled = enabled;

        // Update existing textures
        this.textureCache.forEach((cacheEntry) => {
            const gl = this.gl;

            // Handle both old cache format (direct texture) and new cache format (object with texture property)
            const texture = cacheEntry.texture || cacheEntry;

            if (texture && gl.isTexture(texture)) {
                gl.bindTexture(gl.TEXTURE_2D, texture);

                if (enabled) {
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                } else {
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                }
            }
        });
    }

    get imageSmoothingEnabled() {
        if (!this.useWebGL) {
            return this.ctx.imageSmoothingEnabled;
        }

        return this.state.imageSmoothingEnabled;
    }

    /*
     * Set image smoothing quality
     */
    set imageSmoothingQuality(quality) {
        if (!this.useWebGL) {
            this.ctx.imageSmoothingQuality = quality;
            return;
        }

        const validQualities = ['low', 'medium', 'high'];
        const intQualities = [0, 1, 2]; // For compatibility with numeric values
        if (validQualities.includes(quality)) {
            this.state.imageSmoothingQuality = quality;
        } else if (intQualities.includes(quality)) {
            this.state.imageSmoothingQuality = validQualities[quality];
        }
    }

    get imageSmoothingQuality() {
        if (!this.useWebGL) {
            return this.ctx.imageSmoothingQuality;
        }

        return this.state.imageSmoothingQuality || 'low';
    }

    /*
    * Set global composite operation
    */
    set globalCompositeOperation(operation) {
        if (!this.useWebGL) {
            this.ctx.globalCompositeOperation = operation;
            return;
        }

        const validOperations = [
            'source-over', 'source-in', 'source-out', 'source-atop',
            'destination-over', 'destination-in', 'destination-out', 'destination-atop',
            'lighter', 'copy', 'xor', 'multiply', 'screen', 'overlay',
            'darken', 'lighten', 'color-dodge', 'color-burn',
            'hard-light', 'soft-light', 'difference', 'exclusion'
        ];

        if (validOperations.includes(operation)) {
            this.state.globalCompositeOperation = operation;
            // Update WebGL blend mode - this now properly handles advanced modes
            this.updateBlendMode(operation);
        }
    }

    get globalCompositeOperation() {
        if (!this.useWebGL) {
            return this.ctx.globalCompositeOperation;
        }

        return this.state.globalCompositeOperation;
    }

    /*
    * Set line dash offset
    * @param {number} offset - Dash offset
    */
    set lineDashOffset(offset) {
        this.state.lineDashOffset = offset;
    }

    get lineDashOffset() {
        return this.state.lineDashOffset;
    }

    // HSL Properties
    set imageHue(hue) {
        this.state.imageHue = Math.max(-180, Math.min(180, hue));
    }

    get imageHue() {
        return this.state.imageHue;
    }

    set imageSaturation(saturation) {
        this.state.imageSaturation = Math.max(0, saturation);
    }

    get imageSaturation() {
        return this.state.imageSaturation;
    }

    set imageLightness(lightness) {
        this.state.imageLightness = Math.max(-1, Math.min(1, lightness));
    }

    get imageLightness() {
        return this.state.imageLightness;
    }

    // Brightness/Contrast
    set imageBrightness(brightness) {
        this.state.imageBrightness = Math.max(-1, Math.min(1, brightness));
    }

    get imageBrightness() {
        return this.state.imageBrightness;
    }

    set imageContrast(contrast) {
        this.state.imageContrast = Math.max(0, contrast);
    }

    get imageContrast() {
        return this.state.imageContrast;
    }

    // Opacity (separate from globalAlpha)
    set imageOpacity(opacity) {
        this.state.imageOpacity = Math.max(0, Math.min(1, opacity));
    }

    get imageOpacity() {
        return this.state.imageOpacity;
    }

    // Color tint
    set imageColorTint(color) {
        if (Array.isArray(color)) {
            this.state.imageColorTint = [...color];
        } else {
            this.state.imageColorTint = this.parseColor(color);
        }
    }

    get imageColorTint() {
        return [...this.state.imageColorTint];
    }

    // Color mode
    set imageColorMode(mode) {
        this.state.imageColorMode = Math.max(0, Math.min(4, Math.floor(mode)));
    }

    get imageColorMode() {
        return this.state.imageColorMode;
    }

    // Color multiply
    set imageColorMultiply(color) {
        if (Array.isArray(color)) {
            this.state.imageColorMultiply = [...color];
        } else {
            this.state.imageColorMultiply = this.parseColor(color);
        }
    }

    get imageColorMultiply() {
        return [...this.state.imageColorMultiply];
    }

    // Color add
    set imageColorAdd(color) {
        if (Array.isArray(color)) {
            this.state.imageColorAdd = [...color];
        } else {
            this.state.imageColorAdd = this.parseColor(color);
        }
    }

    get imageColorAdd() {
        return [...this.state.imageColorAdd];
    }

    // Gamma correction
    set imageGamma(gamma) {
        this.state.imageGamma = Math.max(0.1, Math.min(3, gamma));
    }

    get imageGamma() {
        return this.state.imageGamma;
    }

    // Exposure
    set imageExposure(exposure) {
        this.state.imageExposure = Math.max(-3, Math.min(3, exposure));
    }

    get imageExposure() {
        return this.state.imageExposure;
    }

    /*
     * Get canvas style object for CSS modifications
     * @return {CSSStyleDeclaration} - The canvas element's style object
     */
    get style() {
        return this.canvas.style;
    }

    /*
     * Set canvas style properties
     * @param {Object|string} styles - Style object or CSS string
     */
    set style(styles) {
        if (typeof styles === 'string') {
            this.canvas.style.cssText = styles;
        } else if (typeof styles === 'object' && styles !== null) {
            Object.assign(this.canvas.style, styles);
        }
    }

    /*
     * Convenience method to set background color
     * @param {string} color - CSS color value
     */
    setBackgroundColor(color) {
        this.canvas.style.backgroundColor = color;
    }

    /*
     * Get current background color
     * @return {string} - Current background color
     */
    getBackgroundColor() {
        return this.canvas.style.backgroundColor;
    }

    /*
     * Convenience method to set canvas border
     * @param {string} border - CSS border value
     */
    setBorder(border) {
        this.canvas.style.border = border;
    }

    /*
     * Convenience method to set canvas border radius
     * @param {string} radius - CSS border-radius value
     */
    setBorderRadius(radius) {
        this.canvas.style.borderRadius = radius;
    }

    /*
     * Convenience method to set canvas cursor
     * @param {string} cursor - CSS cursor value
     */
    setCursor(cursor) {
        this.canvas.style.cursor = cursor;
    }

    /*
     * Apply multiple CSS styles at once
     * @param {Object} styles - Object with CSS property-value pairs
     */
    applyStyles(styles) {
        Object.assign(this.canvas.style, styles);
    }

    /*
     * Convenience methods for common image color effects
     */

    // Reset all image color properties to default
    resetImageColors() {
        this.state.imageHue = 0;
        this.state.imageSaturation = 1;
        this.state.imageLightness = 0;
        this.state.imageBrightness = 0;
        this.state.imageContrast = 1;
        this.state.imageOpacity = 1;
        this.state.imageColorTint = [0, 0, 0, 0];
        this.state.imageColorMode = 0;
        this.state.imageColorMultiply = [1, 1, 1, 1];
        this.state.imageColorAdd = [0, 0, 0, 0];
        this.state.imageGamma = 1;
        this.state.imageExposure = 0;
    }

    // Apply a color filter preset
    applyImageFilter(filterName, intensity = 1.0) {
        this.resetImageColors();

        switch (filterName.toLowerCase()) {
            case 'grayscale':
            case 'greyscale':
                this.imageColorMode = 1;
                break;

            case 'sepia':
                this.imageColorMode = 2;
                break;

            case 'invert':
            case 'negative':
                this.imageColorMode = 3;
                break;

            case 'blackwhite':
            case 'threshold':
                this.imageColorMode = 4;
                break;

            case 'vintage':
                this.imageHue = 30 * intensity;
                this.imageSaturation = 0.7;
                this.imageContrast = 1.2;
                this.imageColorTint = [0.9, 0.8, 0.6, 0.1 * intensity];
                break;

            case 'cold':
                this.imageColorTint = [0.6, 0.8, 1.0, 0.2 * intensity];
                break;

            case 'warm':
                this.imageColorTint = [1.0, 0.8, 0.6, 0.2 * intensity];
                break;

            case 'dramatic':
                this.imageContrast = 1.5;
                this.imageSaturation = 1.3;
                this.imageBrightness = -0.1;
                break;

            case 'fade':
                this.imageOpacity = 0.7 * intensity;
                this.imageContrast = 0.8;
                break;

            case 'bright':
                this.imageBrightness = 0.3 * intensity;
                this.imageExposure = 0.5 * intensity;
                break;

            case 'dark':
                this.imageBrightness = -0.3 * intensity;
                this.imageExposure = -0.5 * intensity;
                break;
        }
    }

    // Batch set multiple image properties
    setImageColors(options) {
        if (options.hue !== undefined) this.imageHue = options.hue;
        if (options.saturation !== undefined) this.imageSaturation = options.saturation;
        if (options.lightness !== undefined) this.imageLightness = options.lightness;
        if (options.brightness !== undefined) this.imageBrightness = options.brightness;
        if (options.contrast !== undefined) this.imageContrast = options.contrast;
        if (options.opacity !== undefined) this.imageOpacity = options.opacity;
        if (options.tint !== undefined) this.imageColorTint = options.tint;
        if (options.mode !== undefined) this.imageColorMode = options.mode;
        if (options.multiply !== undefined) this.imageColorMultiply = options.multiply;
        if (options.add !== undefined) this.imageColorAdd = options.add;
        if (options.gamma !== undefined) this.imageGamma = options.gamma;
        if (options.exposure !== undefined) this.imageExposure = options.exposure;
    }

    // Get current image color settings
    getImageColors() {
        return {
            hue: this.state.imageHue,
            saturation: this.state.imageSaturation,
            lightness: this.state.imageLightness,
            brightness: this.state.imageBrightness,
            contrast: this.state.imageContrast,
            opacity: this.state.imageOpacity,
            tint: [...this.state.imageColorTint],
            mode: this.state.imageColorMode,
            multiply: [...this.state.imageColorMultiply],
            add: [...this.state.imageColorAdd],
            gamma: this.state.imageGamma,
            exposure: this.state.imageExposure
        };
    }

    /*
    * Update WebGL blend mode based on composite operation
    */
    updateBlendMode(operation) {
        const gl = this.gl;

        // Enable blending
        gl.enable(gl.BLEND);

        switch (operation) {
            case 'source-over':
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                break;

            case 'multiply':
                // For multiply blend mode, we need special handling
                gl.blendFunc(gl.DST_COLOR, gl.ZERO);
                break;

            case 'screen':
                gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_COLOR);
                break;

            case 'lighter':
                gl.blendFunc(gl.ONE, gl.ONE);
                break;

            case 'darken':
                gl.blendFunc(gl.ONE, gl.ONE);
                gl.blendEquation(gl.MIN);
                break;

            case 'lighten':
                gl.blendFunc(gl.ONE, gl.ONE);
                gl.blendEquation(gl.MAX);
                break;

            case 'copy':
                gl.blendFunc(gl.ONE, gl.ZERO);
                break;

            case 'xor':
                gl.blendFunc(gl.ONE_MINUS_DST_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                break;

            // For complex blend modes, use the advanced blend system
            case 'overlay':
            case 'color-dodge':
            case 'color-burn':
            case 'hard-light':
            case 'soft-light':
            case 'difference':
            case 'exclusion':
                // These will be handled by the advanced blend system
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                break;

            default:
                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                break;
        }

        // Reset blend equation for most modes
        if (operation !== 'darken' && operation !== 'lighten') {
            gl.blendEquation(gl.FUNC_ADD);
        }
    }

    renderWithAdvancedBlend(operation) {
        if (!this.advancedBlendShaders) {
            this.createAdvancedBlendShaders();
        }

        if (!this.advancedBlendShaders[operation]) {
            console.warn(`Advanced blend mode "${operation}" not available, falling back to standard blending`);
            this.updateBlendMode(operation);
            return false;
        }

        const gl = this.gl;

        // Create blend framebuffers if they don't exist
        if (!this.blendFramebuffers) {
            this.createBlendFramebuffers();
        }

        // STEP 1: Capture current screen contents to destination texture
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.blendFramebuffers[1]);
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Copy current screen to destination texture
        gl.bindTexture(gl.TEXTURE_2D, this.blendTextures[1]);
        gl.copyTexImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 0, 0, this.width, this.height, 0);

        // STEP 2: Render new content to source texture
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.blendFramebuffers[0]);
        gl.clear(gl.COLOR_BUFFER_BIT);

        // Render all current batches to source texture
        this.flushRectangles();
        this.flushCircles();
        this.flushEllipses();
        this.flushLines();
        this.flushImages();

        // STEP 3: Composite with advanced blend mode to screen
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);

        // Disable blending for the final composite pass
        gl.disable(gl.BLEND);

        const program = this.advancedBlendShaders[operation];
        gl.useProgram(program);

        // Bind source texture (what we just rendered)
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, this.blendTextures[0]);
        gl.uniform1i(gl.getUniformLocation(program, 'u_sourceTexture'), 0);

        // Bind destination texture (current screen contents)
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, this.blendTextures[1]);
        gl.uniform1i(gl.getUniformLocation(program, 'u_destinationTexture'), 1);

        // Set global alpha uniform for the blend
        const globalAlphaLoc = gl.getUniformLocation(program, 'u_globalAlpha');
        if (globalAlphaLoc !== null) {
            gl.uniform1f(globalAlphaLoc, this.state.globalAlpha);
        }

        // Render fullscreen quad to apply blend
        this.renderFullscreenQuad(program);

        // Re-enable blending for subsequent draws
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        return true;
    }

    // Create framebuffers for advanced blending
    createBlendFramebuffers() {
        const gl = this.gl;

        this.blendFramebuffers = [];
        this.blendTextures = [];

        for (let i = 0; i < 2; i++) {
            const framebuffer = gl.createFramebuffer();
            const texture = gl.createTexture();

            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);

            if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
                console.error('Blend framebuffer is not complete');
            }

            this.blendFramebuffers.push(framebuffer);
            this.blendTextures.push(texture);
        }

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }

    applyAdvancedBlendMode(operation) {
        const advancedModes = [
            'overlay', 'multiply', 'screen', 'darken', 'lighten',
            'color-dodge', 'color-burn', 'hard-light', 'soft-light',
            'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'
        ];

        if (advancedModes.includes(operation)) {
            // For multiply, we can handle it with simple blend functions
            if (operation === 'multiply') {
                this.updateBlendMode(operation);
                return false; // Use standard path
            }

            // For other complex modes, use advanced blending
            return this.renderWithAdvancedBlend(operation);
        } else {
            // Use standard WebGL blend functions
            this.updateBlendMode(operation);
            return false;
        }
    }

    createAdvancedBlendShaders() {
        // Base vertex shader for all blend modes
        const baseVertexShader = `
        precision mediump float;
        attribute vec2 a_position;
        attribute vec2 a_texCoord;
        varying vec2 v_texCoord;
        
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
            v_texCoord = a_texCoord;
        }
    `;

        // Overlay blend mode shader
        const overlayFragmentShader = `
        precision mediump float;
        uniform sampler2D u_sourceTexture;
        uniform sampler2D u_destinationTexture;
        varying vec2 v_texCoord;
        
        vec3 overlay(vec3 base, vec3 blend) {
            return mix(
                2.0 * base * blend,
                1.0 - 2.0 * (1.0 - base) * (1.0 - blend),
                step(0.5, base)
            );
        }
        
        void main() {
            vec4 src = texture2D(u_sourceTexture, v_texCoord);
            vec4 dst = texture2D(u_destinationTexture, v_texCoord);
            
            vec3 result = overlay(dst.rgb, src.rgb);
            float alpha = src.a + dst.a * (1.0 - src.a);
            
            gl_FragColor = vec4(result, alpha);
        }
    `;

        // Multiply blend mode shader
        const multiplyFragmentShader = `
        precision mediump float;
        uniform sampler2D u_sourceTexture;
        uniform sampler2D u_destinationTexture;
        varying vec2 v_texCoord;
        
        void main() {
            vec4 src = texture2D(u_sourceTexture, v_texCoord);
            vec4 dst = texture2D(u_destinationTexture, v_texCoord);
            
            vec3 result = dst.rgb * src.rgb;
            float alpha = src.a + dst.a * (1.0 - src.a);
            
            gl_FragColor = vec4(result, alpha);
        }
    `;

        const multiplySimpleFragmentShader = `
    precision mediump float;
    uniform sampler2D u_texture;
    uniform float u_globalAlpha;
    uniform vec3 u_multiplyColor;
    varying vec2 v_texCoord;
    
    void main() {
        vec4 base = texture2D(u_texture, v_texCoord);
        
        // Multiply the base color with the multiply color
        vec3 result = base.rgb * u_multiplyColor;
        
        gl_FragColor = vec4(result, base.a * u_globalAlpha);
    }
`;

        // Screen blend mode shader
        const screenFragmentShader = `
        precision mediump float;
        uniform sampler2D u_sourceTexture;
        uniform sampler2D u_destinationTexture;
        varying vec2 v_texCoord;
        
        void main() {
            vec4 src = texture2D(u_sourceTexture, v_texCoord);
            vec4 dst = texture2D(u_destinationTexture, v_texCoord);
            
            vec3 result = 1.0 - (1.0 - dst.rgb) * (1.0 - src.rgb);
            float alpha = src.a + dst.a * (1.0 - src.a);
            
            gl_FragColor = vec4(result, alpha);
        }
    `;

        // Darken blend mode shader
        const darkenFragmentShader = `
        precision mediump float;
        uniform sampler2D u_sourceTexture;
        uniform sampler2D u_destinationTexture;
        varying vec2 v_texCoord;
        
        void main() {
            vec4 src = texture2D(u_sourceTexture, v_texCoord);
            vec4 dst = texture2D(u_destinationTexture, v_texCoord);
            
            vec3 result = min(dst.rgb, src.rgb);
            float alpha = src.a + dst.a * (1.0 - src.a);
            
            gl_FragColor = vec4(result, alpha);
        }
    `;

        // Lighten blend mode shader
        const lightenFragmentShader = `
        precision mediump float;
        uniform sampler2D u_sourceTexture;
        uniform sampler2D u_destinationTexture;
        varying vec2 v_texCoord;
        
        void main() {
            vec4 src = texture2D(u_sourceTexture, v_texCoord);
            vec4 dst = texture2D(u_destinationTexture, v_texCoord);
            
            vec3 result = max(dst.rgb, src.rgb);
            float alpha = src.a + dst.a * (1.0 - src.a);
            
            gl_FragColor = vec4(result, alpha);
        }
    `;

        // Color Dodge blend mode shader
        const colorDodgeFragmentShader = `
        precision mediump float;
        uniform sampler2D u_sourceTexture;
        uniform sampler2D u_destinationTexture;
        varying vec2 v_texCoord;
        
        vec3 colorDodge(vec3 base, vec3 blend) {
            vec3 result = vec3(0.0);
            result.r = (blend.r == 1.0) ? 1.0 : min(1.0, base.r / (1.0 - blend.r));
            result.g = (blend.g == 1.0) ? 1.0 : min(1.0, base.g / (1.0 - blend.g));
            result.b = (blend.b == 1.0) ? 1.0 : min(1.0, base.b / (1.0 - blend.b));
            return result;
        }
        
        void main() {
            vec4 src = texture2D(u_sourceTexture, v_texCoord);
            vec4 dst = texture2D(u_destinationTexture, v_texCoord);
            
            vec3 result = colorDodge(dst.rgb, src.rgb);
            float alpha = src.a + dst.a * (1.0 - src.a);
            
            gl_FragColor = vec4(result, alpha);
        }
    `;

        // Color Burn blend mode shader
        const colorBurnFragmentShader = `
        precision mediump float;
        uniform sampler2D u_sourceTexture;
        uniform sampler2D u_destinationTexture;
        varying vec2 v_texCoord;
        
        vec3 colorBurn(vec3 base, vec3 blend) {
            vec3 result = vec3(0.0);
            result.r = (blend.r == 0.0) ? 0.0 : max(0.0, 1.0 - (1.0 - base.r) / blend.r);
            result.g = (blend.g == 0.0) ? 0.0 : max(0.0, 1.0 - (1.0 - base.g) / blend.g);
            result.b = (blend.b == 0.0) ? 0.0 : max(0.0, 1.0 - (1.0 - base.b) / blend.b);
            return result;
        }
        
        void main() {
            vec4 src = texture2D(u_sourceTexture, v_texCoord);
            vec4 dst = texture2D(u_destinationTexture, v_texCoord);
            
            vec3 result = colorBurn(dst.rgb, src.rgb);
            float alpha = src.a + dst.a * (1.0 - src.a);
            
            gl_FragColor = vec4(result, alpha);
        }
    `;

        // Hard Light blend mode shader
        const hardLightFragmentShader = `
        precision mediump float;
        uniform sampler2D u_sourceTexture;
        uniform sampler2D u_destinationTexture;
        varying vec2 v_texCoord;
        
        vec3 hardLight(vec3 base, vec3 blend) {
            return mix(
                2.0 * base * blend,
                1.0 - 2.0 * (1.0 - base) * (1.0 - blend),
                step(0.5, blend)
            );
        }
        
        void main() {
            vec4 src = texture2D(u_sourceTexture, v_texCoord);
            vec4 dst = texture2D(u_destinationTexture, v_texCoord);
            
            vec3 result = hardLight(dst.rgb, src.rgb);
            float alpha = src.a + dst.a * (1.0 - src.a);
            
            gl_FragColor = vec4(result, alpha);
        }
    `;

        // Soft Light blend mode shader
        const softLightFragmentShader = `
        precision mediump float;
        uniform sampler2D u_sourceTexture;
        uniform sampler2D u_destinationTexture;
        varying vec2 v_texCoord;
        
        vec3 softLight(vec3 base, vec3 blend) {
            vec3 result = vec3(0.0);
            
            // Soft light formula
            for(int i = 0; i < 3; i++) {
                float b = base[i];
                float s = blend[i];
                
                if(s <= 0.5) {
                    result[i] = b - (1.0 - 2.0 * s) * b * (1.0 - b);
                } else {
                    float d = (b <= 0.25) ? ((16.0 * b - 12.0) * b + 4.0) * b : sqrt(b);
                    result[i] = b + (2.0 * s - 1.0) * (d - b);
                }
            }
            
            return result;
        }
        
        void main() {
            vec4 src = texture2D(u_sourceTexture, v_texCoord);
            vec4 dst = texture2D(u_destinationTexture, v_texCoord);
            
            vec3 result = softLight(dst.rgb, src.rgb);
            float alpha = src.a + dst.a * (1.0 - src.a);
            
            gl_FragColor = vec4(result, alpha);
        }
    `;

        // Difference blend mode shader
        const differenceFragmentShader = `
        precision mediump float;
        uniform sampler2D u_sourceTexture;
        uniform sampler2D u_destinationTexture;
        varying vec2 v_texCoord;
        
        void main() {
            vec4 src = texture2D(u_sourceTexture, v_texCoord);
            vec4 dst = texture2D(u_destinationTexture, v_texCoord);
            
            vec3 result = abs(dst.rgb - src.rgb);
            float alpha = src.a + dst.a * (1.0 - src.a);
            
            gl_FragColor = vec4(result, alpha);
        }
    `;

        // Exclusion blend mode shader
        const exclusionFragmentShader = `
        precision mediump float;
        uniform sampler2D u_sourceTexture;
        uniform sampler2D u_destinationTexture;
        varying vec2 v_texCoord;
        
        void main() {
            vec4 src = texture2D(u_sourceTexture, v_texCoord);
            vec4 dst = texture2D(u_destinationTexture, v_texCoord);
            
            vec3 result = dst.rgb + src.rgb - 2.0 * dst.rgb * src.rgb;
            float alpha = src.a + dst.a * (1.0 - src.a);
            
            gl_FragColor = vec4(result, alpha);
        }
    `;

        // Hue blend mode shader (requires HSL conversion)
        const hueFragmentShader = `
        precision mediump float;
        uniform sampler2D u_sourceTexture;
        uniform sampler2D u_destinationTexture;
        varying vec2 v_texCoord;
        
        vec3 rgb2hsl(vec3 c) {
            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
            
            float d = q.x - min(q.w, q.y);
            float e = 1.0e-10;
            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
        }
        
        vec3 hsl2rgb(vec3 c) {
            vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);
            return c.z + c.y * (rgb - 0.5) * (1.0 - abs(2.0 * c.z - 1.0));
        }
        
        void main() {
            vec4 src = texture2D(u_sourceTexture, v_texCoord);
            vec4 dst = texture2D(u_destinationTexture, v_texCoord);
            
            vec3 baseHSL = rgb2hsl(dst.rgb);
            vec3 blendHSL = rgb2hsl(src.rgb);
            
            vec3 result = hsl2rgb(vec3(blendHSL.x, baseHSL.y, baseHSL.z));
            float alpha = src.a + dst.a * (1.0 - src.a);
            
            gl_FragColor = vec4(result, alpha);
        }
    `;

        // Saturation blend mode shader
        const saturationFragmentShader = `
        precision mediump float;
        uniform sampler2D u_sourceTexture;
        uniform sampler2D u_destinationTexture;
        varying vec2 v_texCoord;
        
        vec3 rgb2hsl(vec3 c) {
            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
            
            float d = q.x - min(q.w, q.y);
            float e = 1.0e-10;
            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
        }
        
        vec3 hsl2rgb(vec3 c) {
            vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);
            return c.z + c.y * (rgb - 0.5) * (1.0 - abs(2.0 * c.z - 1.0));
        }
        
        void main() {
            vec4 src = texture2D(u_sourceTexture, v_texCoord);
            vec4 dst = texture2D(u_destinationTexture, v_texCoord);
            
            vec3 baseHSL = rgb2hsl(dst.rgb);
            vec3 blendHSL = rgb2hsl(src.rgb);
            
            vec3 result = hsl2rgb(vec3(baseHSL.x, blendHSL.y, baseHSL.z));
            float alpha = src.a + dst.a * (1.0 - src.a);
            
            gl_FragColor = vec4(result, alpha);
        }
    `;

        // Color blend mode shader
        const colorFragmentShader = `
        precision mediump float;
        uniform sampler2D u_sourceTexture;
        uniform sampler2D u_destinationTexture;
        varying vec2 v_texCoord;
        
        vec3 rgb2hsl(vec3 c) {
            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
            
            float d = q.x - min(q.w, q.y);
            float e = 1.0e-10;
            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
        }
        
        vec3 hsl2rgb(vec3 c) {
            vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);
            return c.z + c.y * (rgb - 0.5) * (1.0 - abs(2.0 * c.z - 1.0));
        }
        
        void main() {
            vec4 src = texture2D(u_sourceTexture, v_texCoord);
            vec4 dst = texture2D(u_destinationTexture, v_texCoord);
            
            vec3 baseHSL = rgb2hsl(dst.rgb);
            vec3 blendHSL = rgb2hsl(src.rgb);
            
            vec3 result = hsl2rgb(vec3(blendHSL.x, blendHSL.y, baseHSL.z));
            float alpha = src.a + dst.a * (1.0 - src.a);
            
            gl_FragColor = vec4(result, alpha);
        }
    `;

        // Luminosity blend mode shader
        const luminosityFragmentShader = `
        precision mediump float;
        uniform sampler2D u_sourceTexture;
        uniform sampler2D u_destinationTexture;
        varying vec2 v_texCoord;
        
        vec3 rgb2hsl(vec3 c) {
            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
            
            float d = q.x - min(q.w, q.y);
            float e = 1.0e-10;
            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
        }
        
        vec3 hsl2rgb(vec3 c) {
            vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);
            return c.z + c.y * (rgb - 0.5) * (1.0 - abs(2.0 * c.z - 1.0));
        }
        
        void main() {
            vec4 src = texture2D(u_sourceTexture, v_texCoord);
            vec4 dst = texture2D(u_destinationTexture, v_texCoord);
            
            vec3 baseHSL = rgb2hsl(dst.rgb);
            vec3 blendHSL = rgb2hsl(src.rgb);
            
            vec3 result = hsl2rgb(vec3(baseHSL.x, baseHSL.y, blendHSL.z));
            float alpha = src.a + dst.a * (1.0 - src.a);
            
            gl_FragColor = vec4(result, alpha);
        }
    `;

        // Create all the shader programs
        this.advancedBlendShaders = {
            overlay: this.createShaderProgram(baseVertexShader, overlayFragmentShader),
            multiply: this.createShaderProgram(baseVertexShader, multiplyFragmentShader),
            screen: this.createShaderProgram(baseVertexShader, screenFragmentShader),
            darken: this.createShaderProgram(baseVertexShader, darkenFragmentShader),
            lighten: this.createShaderProgram(baseVertexShader, lightenFragmentShader),
            'color-dodge': this.createShaderProgram(baseVertexShader, colorDodgeFragmentShader),
            'color-burn': this.createShaderProgram(baseVertexShader, colorBurnFragmentShader),
            'hard-light': this.createShaderProgram(baseVertexShader, hardLightFragmentShader),
            'soft-light': this.createShaderProgram(baseVertexShader, softLightFragmentShader),
            difference: this.createShaderProgram(baseVertexShader, differenceFragmentShader),
            exclusion: this.createShaderProgram(baseVertexShader, exclusionFragmentShader),
            hue: this.createShaderProgram(baseVertexShader, hueFragmentShader),
            saturation: this.createShaderProgram(baseVertexShader, saturationFragmentShader),
            color: this.createShaderProgram(baseVertexShader, colorFragmentShader),
            luminosity: this.createShaderProgram(baseVertexShader, luminosityFragmentShader)
        };

        this.shaders.multiplySimple = this.createShaderProgram(baseVertexShader, multiplySimpleFragmentShader);

        console.log('All advanced blend mode shaders created successfully');
    }

    /*
     * Add color stop to gradient
     * @param {number} offset - Position (0-1)
     * @param {string} color - Color at this position
     */
    addColorStop(gradient, offset, color) {
        if (gradient && gradient.colorStops) {
            gradient.colorStops.push({
                offset: Math.max(0, Math.min(1, offset)),
                color: this.parseColor(color)
            });
            // Sort by offset
            gradient.colorStops.sort((a, b) => a.offset - b.offset);
        }
    }

    /*
        * Parse color input
        * Converts hex, rgb, rgba, or array formats to RGBA array
        * @param {string|Array} color - Color value
        * @return {Array} - RGBA array
    */
    parseColor(color) {
        if (Array.isArray(color)) return color;

        // Handle gradient objects
        if (color && typeof color === 'object' && color.type) {
            if (color.type === 'linear' || color.type === 'radial') {
                return this.evaluateGradient(color, 0.5, 0.5); // Default to middle
            }
            if (color.type === 'pattern') {
                return [1, 1, 1, 1]; // Default white for patterns
            }
        }

        if (typeof color === 'string') {
            // Handle named colors
            const namedColors = {
                'transparent': [0, 0, 0, 0],
                'black': [0, 0, 0, 1],
                'white': [1, 1, 1, 1],
                'red': [1, 0, 0, 1],
                'green': [0, 1, 0, 1],
                'blue': [0, 0, 1, 1],
                'yellow': [1, 1, 0, 1],
                'cyan': [0, 1, 1, 1],
                'magenta': [1, 0, 1, 1],
                'gray': [0.5, 0.5, 0.5, 1],
                'grey': [0.5, 0.5, 0.5, 1]
            };

            if (namedColors[color.toLowerCase()]) {
                return namedColors[color.toLowerCase()];
            }

            if (color.startsWith('#')) {
                // Hex color - support both 3 and 6 character formats
                const hex = color.substring(1);
                if (hex.length === 3) {
                    const r = parseInt(hex[0] + hex[0], 16) / 255;
                    const g = parseInt(hex[1] + hex[1], 16) / 255;
                    const b = parseInt(hex[2] + hex[2], 16) / 255;
                    return [r, g, b, 1];
                } else if (hex.length === 6) {
                    const r = parseInt(hex.substring(0, 2), 16) / 255;
                    const g = parseInt(hex.substring(2, 4), 16) / 255;
                    const b = parseInt(hex.substring(4, 6), 16) / 255;
                    return [r, g, b, 1];
                }
            }

            if (color.startsWith('rgb')) {
                // RGB/RGBA color
                const values = color.match(/[\d.]+/g);
                if (values && values.length >= 3) {
                    const r = parseFloat(values[0]) / 255;
                    const g = parseFloat(values[1]) / 255;
                    const b = parseFloat(values[2]) / 255;
                    const a = values.length > 3 ? parseFloat(values[3]) : 1;
                    return [r, g, b, a];
                }
            }

            if (color.startsWith('hsl')) {
                // HSL color - convert to RGB
                const values = color.match(/[\d.]+/g);
                if (values && values.length >= 3) {
                    const h = parseFloat(values[0]) / 360;
                    const s = parseFloat(values[1]) / 100;
                    const l = parseFloat(values[2]) / 100;
                    const a = values.length > 3 ? parseFloat(values[3]) : 1;

                    const hslToRgb = (h, s, l) => {
                        let r, g, b;
                        if (s === 0) {
                            r = g = b = l;
                        } else {
                            const hue2rgb = (p, q, t) => {
                                if (t < 0) t += 1;
                                if (t > 1) t -= 1;
                                if (t < 1 / 6) return p + (q - p) * 6 * t;
                                if (t < 1 / 2) return q;
                                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                                return p;
                            };
                            const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                            const p = 2 * l - q;
                            r = hue2rgb(p, q, h + 1 / 3);
                            g = hue2rgb(p, q, h);
                            b = hue2rgb(p, q, h - 1 / 3);
                        }
                        return [r, g, b, a];
                    };

                    return hslToRgb(h, s, l);
                }
            }
        }

        // Default to white
        return [1, 1, 1, 1];
    }

    /*
 * Evaluate gradient color at specific coordinates
 */
    evaluateGradient(gradient, x, y) {
        if (!gradient.colorStops || gradient.colorStops.length === 0) {
            return [1, 1, 1, 1]; // Default white
        }

        if (gradient.colorStops.length === 1) {
            return gradient.colorStops[0].color;
        }

        let t = 0;
        if (gradient.type === 'linear') {
            // Calculate position along gradient line
            const dx = gradient.x1 - gradient.x0;
            const dy = gradient.y1 - gradient.y0;
            const length = Math.sqrt(dx * dx + dy * dy);

            if (length > 0) {
                const px = x - gradient.x0;
                const py = y - gradient.y0;
                t = (px * dx + py * dy) / (length * length);
            }
        } else if (gradient.type === 'radial') {
            // Calculate distance from center
            const dx = x - gradient.x0;
            const dy = y - gradient.y0;
            const dist = Math.sqrt(dx * dx + dy * dy);
            t = dist / gradient.r1;
        }

        t = Math.max(0, Math.min(1, t));

        // Find surrounding color stops
        let stop1 = gradient.colorStops[0];
        let stop2 = gradient.colorStops[gradient.colorStops.length - 1];

        for (let i = 0; i < gradient.colorStops.length - 1; i++) {
            if (t >= gradient.colorStops[i].offset && t <= gradient.colorStops[i + 1].offset) {
                stop1 = gradient.colorStops[i];
                stop2 = gradient.colorStops[i + 1];
                break;
            }
        }

        // Interpolate between colors
        if (stop1.offset === stop2.offset) {
            return stop1.color;
        }

        const factor = (t - stop1.offset) / (stop2.offset - stop1.offset);
        return [
            stop1.color[0] + (stop2.color[0] - stop1.color[0]) * factor,
            stop1.color[1] + (stop2.color[1] - stop1.color[1]) * factor,
            stop1.color[2] + (stop2.color[2] - stop1.color[2]) * factor,
            stop1.color[3] + (stop2.color[3] - stop1.color[3]) * factor
        ];
    }

    /*
        * Transfer current state to 2D context
        * Applies the current state properties to the 2D canvas context
    */
    transferContextState() {
        if (!this.useWebGL) {
            if (!this.ctx) return;
            // Apply current state to 2D context
            this.ctx.fillStyle = `rgba(${Math.round(this.state.fillStyle[0] * 255)}, ${Math.round(this.state.fillStyle[1] * 255)}, ${Math.round(this.state.fillStyle[2] * 255)}, ${this.state.fillStyle[3]})`;
            this.ctx.strokeStyle = `rgba(${Math.round(this.state.strokeStyle[0] * 255)}, ${Math.round(this.state.strokeStyle[1] * 255)}, ${Math.round(this.state.strokeStyle[2] * 255)}, ${this.state.strokeStyle[3]})`;
            this.ctx.lineWidth = this.state.lineWidth;
            this.ctx.lineCap = this.state.lineCap;
            this.ctx.lineJoin = this.state.lineJoin;
            this.ctx.miterLimit = this.state.miterLimit;
            this.ctx.setLineDash(this.state.lineDash);
            this.ctx.lineDashOffset = this.state.lineDashOffset;
            this.ctx.globalAlpha = this.state.globalAlpha;
            this.ctx.globalCompositeOperation = this.state.globalCompositeOperation;
            this.ctx.font = this.state.font;
            this.ctx.textAlign = this.state.textAlign;
            this.ctx.textBaseline = this.state.textBaseline;
            this.ctx.shadowColor = `rgba(${Math.round(this.state.shadowColor[0] * 255)}, ${Math.round(this.state.shadowColor[1] * 255)}, ${Math.round(this.state.shadowColor[2] * 255)}, ${this.state.shadowColor[3]})`;
            this.ctx.shadowBlur = this.state.shadowBlur;
            this.ctx.shadowOffsetX = this.state.shadowOffsetX;
            this.ctx.shadowOffsetY = this.state.shadowOffsetY;
            this.ctx.imageSmoothingEnabled = this.state.imageSmoothingEnabled;
            this.ctx.imageSmoothingQuality = this.state.imageSmoothingQuality || 'low';
            // Apply transform matrix
            this.ctx.setTransform(
                this.state.transform[0], this.state.transform[1],
                this.state.transform[2], this.state.transform[3],
                this.state.transform[4], this.state.transform[5]
            );
        }
    }

    /*
     * Convenience methods for common post-processing effects
     */

    // Add blur effect
    addBlur(radius = 2.0) {
        this.addPostEffect('blur', { radius });
    }

    // Add bloom effect
    addBloom(strength = 1.0, threshold = 0.5, blurRadius = 2.0) {
        // Remove existing bloom effects first
        this.removePostEffect('bloomExtract');
        this.removePostEffect('blur');
        this.removePostEffect('bloomCombine');

        // Add bloom extract
        this.addPostEffect('bloomExtract', { threshold });

        // Add blur for the bloom texture
        this.addPostEffect('blur', { radius: blurRadius });

        // Add bloom combine
        this.addPostEffect('bloomCombine', {
            strength,
            originalTexture: null // Will be set during rendering
        });
    }

    // Add FXAA antialiasing
    addFXAA() {
        this.addPostEffect('fxaa');
    }

    // Add chromatic aberration
    addChromaticAberration(strength = 0.01) {
        this.addPostEffect('chromaticAberration', { strength });
    }

    // Add vignette effect
    addVignette(strength = 0.5, radius = 0.8) {
        this.addPostEffect('vignette', { strength, radius });
    }

    // Add color grading
    addColorGrading(brightness = 0.0, contrast = 1.0, saturation = 1.0, hue = 0.0) {
        this.addPostEffect('colorGrading', { brightness, contrast, saturation, hue });
    }

    // Add pixelate effect
    addPixelate(pixelSize = 4.0) {
        this.addPostEffect('pixelate', { pixelSize });
    }

    /*
        * Save the current state
        * Saves all drawing state to the state stack
    */
    save() {
        if (!this.useWebGL) {
            if (!this.ctx) return;
            this.transferContextState();
            this.ctx.save();
            return;
        }

        this.stateStack.push({
            fillStyle: [...this.state.fillStyle],
            strokeStyle: [...this.state.strokeStyle],
            lineWidth: this.state.lineWidth,
            lineCap: this.state.lineCap,
            lineJoin: this.state.lineJoin,
            miterLimit: this.state.miterLimit,
            lineDashOffset: this.state.lineDashOffset,
            lineDash: [...this.state.lineDash],
            globalAlpha: this.state.globalAlpha,
            globalCompositeOperation: this.state.globalCompositeOperation,
            textAlign: this.state.textAlign,
            textBaseline: this.state.textBaseline,
            font: this.state.font,
            shadowColor: [...this.state.shadowColor],
            shadowBlur: this.state.shadowBlur,
            shadowOffsetX: this.state.shadowOffsetX,
            shadowOffsetY: this.state.shadowOffsetY,
            imageSmoothingEnabled: this.state.imageSmoothingEnabled,
            transform: [...this.state.transform],

            // Image color properties
            imageHue: this.state.imageHue,
            imageSaturation: this.state.imageSaturation,
            imageLightness: this.state.imageLightness,
            imageBrightness: this.state.imageBrightness,
            imageContrast: this.state.imageContrast,
            imageOpacity: this.state.imageOpacity,
            imageColorTint: [...this.state.imageColorTint],
            imageColorMode: this.state.imageColorMode,
            imageColorMultiply: [...this.state.imageColorMultiply],
            imageColorAdd: [...this.state.imageColorAdd],
            imageGamma: this.state.imageGamma,
            imageExposure: this.state.imageExposure
        });
    }

    /*
        * Restore the last saved state
        * Restores fillStyle, strokeStyle, lineWidth, and transform from the state stack
    */
    restore() {
        if (!this.useWebGL) {
            if (!this.ctx) return;
            this.ctx.restore();
            return;
        }

        if (this.stateStack.length > 0) {
            this.state = this.stateStack.pop();
        }
    }

    /*
     * Add rectangle to batch
     */
    addRectangleToBatch(x, y, width, height, color) {
        if (!this.useWebGL) {
            return;
            this.transferContextState();
        }

        const batch = this.batchBuffers.rectangles;

        if (batch.currentVertices + 4 > batch.maxVertices) {
            this.flushRectangles();
            batch.currentVertices = 0;
            batch.currentIndices = 0;
        }

        // Transform rectangle vertices properly
        const [x1, y1] = this.transformPoint(x, y);
        const [x2, y2] = this.transformPoint(x + width, y);
        const [x3, y3] = this.transformPoint(x, y + height);
        const [x4, y4] = this.transformPoint(x + width, y + height);

        const vertexIndex = batch.currentVertices;

        // Add vertices
        batch.vertexData[vertexIndex * 2 + 0] = x1;
        batch.vertexData[vertexIndex * 2 + 1] = y1;
        batch.vertexData[vertexIndex * 2 + 2] = x2;
        batch.vertexData[vertexIndex * 2 + 3] = y2;
        batch.vertexData[vertexIndex * 2 + 4] = x3;
        batch.vertexData[vertexIndex * 2 + 5] = y3;
        batch.vertexData[vertexIndex * 2 + 6] = x4;
        batch.vertexData[vertexIndex * 2 + 7] = y4;

        // Apply global alpha to colors
        const finalColor = [
            color[0],
            color[1],
            color[2],
            color[3] * this.state.globalAlpha
        ];

        // Add colors for all 4 vertices
        for (let i = 0; i < 4; i++) {
            batch.colorData[(vertexIndex + i) * 4 + 0] = finalColor[0];
            batch.colorData[(vertexIndex + i) * 4 + 1] = finalColor[1];
            batch.colorData[(vertexIndex + i) * 4 + 2] = finalColor[2];
            batch.colorData[(vertexIndex + i) * 4 + 3] = finalColor[3];
        }

        // Add indices (two triangles)
        const indexBase = batch.currentVertices;
        const indexOffset = batch.currentIndices;
        batch.indexData[indexOffset + 0] = indexBase + 0;
        batch.indexData[indexOffset + 1] = indexBase + 1;
        batch.indexData[indexOffset + 2] = indexBase + 2;
        batch.indexData[indexOffset + 3] = indexBase + 1;
        batch.indexData[indexOffset + 4] = indexBase + 2;
        batch.indexData[indexOffset + 5] = indexBase + 3;

        batch.currentVertices += 4;
        batch.currentIndices += 6;
    }

    /*
 * Add stroke circle to batch (renders as ring/outline)
 */
    addStrokeCircleToBatch(x, y, radius, lineWidth, color) {
        if (!this.useWebGL) {
            return;
        }

        const batch = this.batchBuffers.circles;

        if (batch.currentVertices + 4 > batch.maxVertices) {
            this.flushCircles();
            batch.currentVertices = 0;
            batch.currentIndices = 0;
        }

        const [cx, cy] = this.transformPoint(x, y);
        const outerRadius = radius + lineWidth / 2;
        const vertexIndex = batch.currentVertices;

        // Create quad around the outer circle
        const vertices = [
            [cx - outerRadius, cy - outerRadius],
            [cx + outerRadius, cy - outerRadius],
            [cx - outerRadius, cy + outerRadius],
            [cx + outerRadius, cy + outerRadius]
        ];

        // Apply global alpha consistently
        const finalColor = [
            color[0],
            color[1],
            color[2],
            color[3] * this.state.globalAlpha
        ];

        for (let i = 0; i < 4; i++) {
            batch.vertexData[(vertexIndex + i) * 2 + 0] = vertices[i][0];
            batch.vertexData[(vertexIndex + i) * 2 + 1] = vertices[i][1];

            batch.colorData[(vertexIndex + i) * 4 + 0] = finalColor[0];
            batch.colorData[(vertexIndex + i) * 4 + 1] = finalColor[1];
            batch.colorData[(vertexIndex + i) * 4 + 2] = finalColor[2];
            batch.colorData[(vertexIndex + i) * 4 + 3] = finalColor[3];

            batch.centerData[(vertexIndex + i) * 2 + 0] = cx;
            batch.centerData[(vertexIndex + i) * 2 + 1] = cy;

            // Store both inner and outer radius in the radius data
            // We'll use radiusData for outer radius and add innerRadius data
            batch.radiusData[vertexIndex + i] = outerRadius;
        }

        // We need to modify the circle shader to handle stroke circles
        // For now, let's store the inner radius in a separate way
        // This is a workaround - ideally we'd have a separate stroke circle shader

        // Add indices
        const indexBase = batch.currentVertices;
        const indexOffset = batch.currentIndices;
        batch.indexData[indexOffset + 0] = indexBase + 0;
        batch.indexData[indexOffset + 1] = indexBase + 1;
        batch.indexData[indexOffset + 2] = indexBase + 2;
        batch.indexData[indexOffset + 3] = indexBase + 1;
        batch.indexData[indexOffset + 4] = indexBase + 2;
        batch.indexData[indexOffset + 5] = indexBase + 3;

        batch.currentVertices += 4;
        batch.currentIndices += 6;
    }

    /*
     * Add circle to batch
     */
    addCircleToBatch(x, y, radius, color) {
        if (!this.useWebGL) {
            return;
            this.transferContextState();
        }

        const batch = this.batchBuffers.circles;

        if (batch.currentVertices + 4 > batch.maxVertices) {
            this.flushCircles();
            batch.currentVertices = 0;
            batch.currentIndices = 0;
        }

        const [cx, cy] = this.transformPoint(x, y);
        const vertexIndex = batch.currentVertices;

        // Create quad around circle
        const vertices = [
            [cx - radius, cy - radius],
            [cx + radius, cy - radius],
            [cx - radius, cy + radius],
            [cx + radius, cy + radius]
        ];

        // Apply global alpha consistently
        const finalColor = [
            color[0],
            color[1],
            color[2],
            color[3] * this.state.globalAlpha
        ];

        for (let i = 0; i < 4; i++) {
            batch.vertexData[(vertexIndex + i) * 2 + 0] = vertices[i][0];
            batch.vertexData[(vertexIndex + i) * 2 + 1] = vertices[i][1];

            batch.colorData[(vertexIndex + i) * 4 + 0] = finalColor[0];
            batch.colorData[(vertexIndex + i) * 4 + 1] = finalColor[1];
            batch.colorData[(vertexIndex + i) * 4 + 2] = finalColor[2];
            batch.colorData[(vertexIndex + i) * 4 + 3] = finalColor[3];

            batch.centerData[(vertexIndex + i) * 2 + 0] = cx;
            batch.centerData[(vertexIndex + i) * 2 + 1] = cy;

            batch.radiusData[vertexIndex + i] = radius;
        }

        // Add indices
        const indexBase = batch.currentVertices;
        const indexOffset = batch.currentIndices;
        batch.indexData[indexOffset + 0] = indexBase + 0;
        batch.indexData[indexOffset + 1] = indexBase + 1;
        batch.indexData[indexOffset + 2] = indexBase + 2;
        batch.indexData[indexOffset + 3] = indexBase + 1;
        batch.indexData[indexOffset + 4] = indexBase + 2;
        batch.indexData[indexOffset + 5] = indexBase + 3;

        batch.currentVertices += 4;
        batch.currentIndices += 6;
    }

    /*
     * Add ellipse to batch
     */
    addEllipseToBatch(x, y, radiusX, radiusY, color) {
        if (!this.useWebGL) {
            return;
            this.transferContextState();
        }

        const batch = this.batchBuffers.ellipses;

        if (batch.currentVertices + 4 > batch.maxVertices) {
            this.flushEllipses();
            batch.currentVertices = 0;
            batch.currentIndices = 0;
        }

        const [cx, cy] = this.transformPoint(x, y);
        const vertexIndex = batch.currentVertices;

        // Create quad around ellipse
        const vertices = [
            [cx - radiusX, cy - radiusY],
            [cx + radiusX, cy - radiusY],
            [cx - radiusX, cy + radiusY],
            [cx + radiusX, cy + radiusY]
        ];

        // Apply global alpha consistently like other batches
        const finalColor = [
            color[0],
            color[1],
            color[2],
            color[3] * this.state.globalAlpha
        ];

        for (let i = 0; i < 4; i++) {
            batch.vertexData[(vertexIndex + i) * 2 + 0] = vertices[i][0];
            batch.vertexData[(vertexIndex + i) * 2 + 1] = vertices[i][1];

            batch.colorData[(vertexIndex + i) * 4 + 0] = finalColor[0];
            batch.colorData[(vertexIndex + i) * 4 + 1] = finalColor[1];
            batch.colorData[(vertexIndex + i) * 4 + 2] = finalColor[2];
            batch.colorData[(vertexIndex + i) * 4 + 3] = finalColor[3];

            batch.centerData[(vertexIndex + i) * 2 + 0] = cx;
            batch.centerData[(vertexIndex + i) * 2 + 1] = cy;

            batch.radiusData[(vertexIndex + i) * 2 + 0] = radiusX;
            batch.radiusData[(vertexIndex + i) * 2 + 1] = radiusY;
        }

        // Add indices
        const indexBase = batch.currentVertices;
        const indexOffset = batch.currentIndices;
        batch.indexData[indexOffset + 0] = indexBase + 0;
        batch.indexData[indexOffset + 1] = indexBase + 1;
        batch.indexData[indexOffset + 2] = indexBase + 2;
        batch.indexData[indexOffset + 3] = indexBase + 1;
        batch.indexData[indexOffset + 4] = indexBase + 2;
        batch.indexData[indexOffset + 5] = indexBase + 3;

        batch.currentVertices += 4;
        batch.currentIndices += 6;
    }

    /*
     * Add image to batch
     */
    addImageToBatch(texture, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {
        const batch = this.batchBuffers.images;

        // If different texture, flush current batch
        if (batch.currentTexture && batch.currentTexture !== texture) {
            this.flushImages();
        }

        // If batch is full, flush it
        if (batch.currentQuads >= batch.maxQuads) {
            this.flushImages();
        }

        batch.currentTexture = texture;

        // Transform rectangle vertices
        const [x1, y1] = this.transformPoint(dx, dy);
        const [x2, y2] = this.transformPoint(dx + dWidth, dy);
        const [x3, y3] = this.transformPoint(dx, dy + dHeight);
        const [x4, y4] = this.transformPoint(dx + dWidth, dy + dHeight);

        const vertexIndex = batch.currentVertices;
        const quadIndex = batch.currentQuads;

        // Add vertices
        batch.vertexData[vertexIndex * 2 + 0] = x1;
        batch.vertexData[vertexIndex * 2 + 1] = y1;
        batch.vertexData[vertexIndex * 2 + 2] = x2;
        batch.vertexData[vertexIndex * 2 + 3] = y2;
        batch.vertexData[vertexIndex * 2 + 4] = x3;
        batch.vertexData[vertexIndex * 2 + 5] = y3;
        batch.vertexData[vertexIndex * 2 + 6] = x4;
        batch.vertexData[vertexIndex * 2 + 7] = y4;

        // Calculate texture coordinates (assuming full texture for now)
        const imgWidth = texture.width || sWidth || dWidth;
        const imgHeight = texture.height || sHeight || dHeight;

        const u1 = sx / imgWidth;
        const v1 = 1.0 - (sy + sHeight) / imgHeight; // Flip Y
        const u2 = (sx + sWidth) / imgWidth;
        const v2 = 1.0 - sy / imgHeight; // Flip Y

        // Add texture coordinates
        batch.texCoordData[vertexIndex * 2 + 0] = u1; batch.texCoordData[vertexIndex * 2 + 1] = v2; // TL
        batch.texCoordData[vertexIndex * 2 + 2] = u2; batch.texCoordData[vertexIndex * 2 + 3] = v2; // TR
        batch.texCoordData[vertexIndex * 2 + 4] = u1; batch.texCoordData[vertexIndex * 2 + 5] = v1; // BL
        batch.texCoordData[vertexIndex * 2 + 6] = u2; batch.texCoordData[vertexIndex * 2 + 7] = v1; // BR

        // Add indices (two triangles)
        const indexBase = batch.currentVertices;
        const indexOffset = batch.currentIndices;
        batch.indexData[indexOffset + 0] = indexBase + 0;
        batch.indexData[indexOffset + 1] = indexBase + 1;
        batch.indexData[indexOffset + 2] = indexBase + 2;
        batch.indexData[indexOffset + 3] = indexBase + 1;
        batch.indexData[indexOffset + 4] = indexBase + 2;
        batch.indexData[indexOffset + 5] = indexBase + 3;

        batch.currentVertices += 4;
        batch.currentIndices += 6;
        batch.currentQuads += 1;
    }

    /*
    * Enhanced image batch system with texture atlas support
    */
    createImageBatchSystem() {
        // Create texture atlas for small images
        this.textureAtlas = {
            canvas: document.createElement('canvas'),
            ctx: null,
            width: 2048,
            height: 2048,
            regions: new Map(),
            currentX: 0,
            currentY: 0,
            rowHeight: 0,
            needsUpdate: false
        };

        this.textureAtlas.canvas.width = this.textureAtlas.width;
        this.textureAtlas.canvas.height = this.textureAtlas.height;
        this.textureAtlas.ctx = this.textureAtlas.canvas.getContext('2d');

        // Create atlas texture
        this.atlasTexture = null;

        // Improved batch buffer for images
        const gl = this.gl;
        const maxQuads = 5000; // Reduced for better stability

        this.imageBatchBuffer = {
            vertices: gl.createBuffer(),
            texCoords: gl.createBuffer(),
            indices: gl.createBuffer(),
            transformPos: gl.createBuffer(),    // Position transforms
            transformScale: gl.createBuffer(),  // Scale transforms
            transformRot: gl.createBuffer(),    // Rotation transforms
            transformAlpha: gl.createBuffer(),  // Alpha transforms

            maxQuads,
            currentQuads: 0,

            // Use typed arrays for better performance
            vertexData: new Float32Array(maxQuads * 8),     // 4 vertices * 2 coords
            texCoordData: new Float32Array(maxQuads * 8),   // 4 vertices * 2 tex coords
            indexData: new Uint16Array(maxQuads * 6),       // 2 triangles * 3 indices
            transformPosData: new Float32Array(maxQuads * 8),    // 4 vertices * 2 pos
            transformScaleData: new Float32Array(maxQuads * 8),  // 4 vertices * 2 scale
            transformRotData: new Float32Array(maxQuads * 4),    // 4 vertices * 1 rotation
            transformAlphaData: new Float32Array(maxQuads * 4),  // 4 vertices * 1 alpha

            currentTexture: null,
            textureCache: new Map(),

            // Pre-generate indices for better performance
            indicesGenerated: false
        };

        // Pre-generate all indices once
        this.preGenerateIndices();

        // Create instanced rendering shader
        this.createInstancedImageShader();
    }

    /*
     * Pre-generate indices for all possible quads
     */
    preGenerateIndices() {
        const batch = this.imageBatchBuffer;

        for (let i = 0; i < batch.maxQuads; i++) {
            const vertexIndex = i * 4;
            const indexOffset = i * 6;

            // First triangle
            batch.indexData[indexOffset + 0] = vertexIndex + 0;
            batch.indexData[indexOffset + 1] = vertexIndex + 1;
            batch.indexData[indexOffset + 2] = vertexIndex + 2;

            // Second triangle
            batch.indexData[indexOffset + 3] = vertexIndex + 1;
            batch.indexData[indexOffset + 4] = vertexIndex + 3;
            batch.indexData[indexOffset + 5] = vertexIndex + 2;
        }

        // Upload indices once
        const gl = this.gl;
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, batch.indices);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, batch.indexData, gl.STATIC_DRAW);

        batch.indicesGenerated = true;
    }

    /*
     * Create instanced image shader for better performance
     */
    createInstancedImageShader() {
        const vertexShader = `
    precision highp float;
    attribute vec2 a_position;
    attribute vec2 a_texCoord;
    attribute vec2 a_transformPos;    // x, y position
    attribute vec2 a_transformScale;  // scaleX, scaleY
    attribute float a_transformRot;   // rotation
    attribute float a_transformAlpha; // alpha
    
    uniform vec2 u_resolution;
    uniform mat3 u_globalTransform;
    
    varying vec2 v_texCoord;
    varying float v_alpha;
    
    void main() {
        // Extract transform components
        vec2 position = a_transformPos;
        vec2 scale = a_transformScale;
        float rotation = a_transformRot;
        v_alpha = a_transformAlpha;
        
        // Apply local transform
        vec2 rotatedPos = a_position;
        if (rotation != 0.0) {
            float cos_r = cos(rotation);
            float sin_r = sin(rotation);
            rotatedPos = vec2(
                a_position.x * cos_r - a_position.y * sin_r,
                a_position.x * sin_r + a_position.y * cos_r
            );
        }
        
        vec2 scaledPos = rotatedPos * scale + position;
        
        // Apply global transform
        vec3 transformed = u_globalTransform * vec3(scaledPos, 1.0);
        
        // Convert to clip space
        vec2 clipSpace = (transformed.xy / u_resolution) * 2.0 - 1.0;
        clipSpace.y = -clipSpace.y;
        
        gl_Position = vec4(clipSpace, 0.0, 1.0);
        v_texCoord = a_texCoord;
    }
`;

        const fragmentShader = `
    precision mediump float;
    uniform sampler2D u_texture;
    uniform float u_globalAlpha;
    
    varying vec2 v_texCoord;
    varying float v_alpha;
    
    void main() {
        vec4 texColor = texture2D(u_texture, v_texCoord);
        gl_FragColor = vec4(texColor.rgb, texColor.a * v_alpha * u_globalAlpha);
    }
`;

        this.shaders.instancedImage = this.createShaderProgram(vertexShader, fragmentShader);
    }

    /*
     * Add image to texture atlas for small images
     */
    addToTextureAtlas(image) {
        const atlas = this.textureAtlas;
        const maxSize = 256; // Only atlas images smaller than this

        // Check if image is too large for atlas
        if (image.width > maxSize || image.height > maxSize) {
            return null;
        }

        // Check if already in atlas
        if (atlas.regions.has(image)) {
            return atlas.regions.get(image);
        }

        // Check if there's space
        if (atlas.currentX + image.width > atlas.width) {
            // Move to next row
            atlas.currentX = 0;
            atlas.currentY += atlas.rowHeight;
            atlas.rowHeight = 0;
        }

        if (atlas.currentY + image.height > atlas.height) {
            // Atlas is full
            return null;
        }

        // Add image to atlas
        const region = {
            x: atlas.currentX,
            y: atlas.currentY,
            width: image.width,
            height: image.height,
            u1: atlas.currentX / atlas.width,
            v1: atlas.currentY / atlas.height,
            u2: (atlas.currentX + image.width) / atlas.width,
            v2: (atlas.currentY + image.height) / atlas.height
        };

        atlas.ctx.drawImage(image, atlas.currentX, atlas.currentY);
        atlas.regions.set(image, region);
        atlas.needsUpdate = true;

        // Update position
        atlas.currentX += image.width;
        atlas.rowHeight = Math.max(atlas.rowHeight, image.height);

        return region;
    }

    /*
     * Update atlas texture
     */
    updateAtlasTexture() {
        const atlas = this.textureAtlas;
        if (!atlas.needsUpdate) return;

        if (!this.atlasTexture) {
            this.atlasTexture = this.gl.createTexture();
        }

        const gl = this.gl;
        gl.bindTexture(gl.TEXTURE_2D, this.atlasTexture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, atlas.canvas);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        atlas.needsUpdate = false;
    }

    /*
     * Get or create texture from image
     */
    getOrCreateTexture(image) {
        // Check cache first
        if (this.textureCache.has(image)) {
            const cached = this.textureCache.get(image);
            if (this.gl.isTexture(cached.texture || cached)) {
                if (cached.lastUsed !== undefined) {
                    cached.lastUsed = performance.now();
                }
                return cached.texture || cached;
            }
            // Remove invalid texture
            this.textureCache.delete(image);
        }

        // Try to add to atlas first (for small images) - only if atlas is available
        if (this.textureAtlas) {
            const atlasRegion = this.addToTextureAtlas(image);
            if (atlasRegion) {
                this.updateAtlasTexture();
                this.textureCache.set(image, {
                    texture: this.atlasTexture,
                    atlas: atlasRegion,
                    lastUsed: performance.now()
                });
                return this.atlasTexture;
            }
        }

        // Create individual texture for large images
        return this.safeWebGLOperation(() => {
            const gl = this.gl;
            const texture = gl.createTexture();

            gl.bindTexture(gl.TEXTURE_2D, texture);

            // Use more efficient texture parameters
            const smoothing = this.state.imageSmoothingEnabled;
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, smoothing ? gl.LINEAR : gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, smoothing ? gl.LINEAR : gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            // Use efficient texture upload
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

            // Cache with metadata
            this.textureCache.set(image, {
                texture: texture,
                width: image.width || image.videoWidth || image.naturalWidth,
                height: image.height || image.videoHeight || image.naturalHeight,
                lastUsed: performance.now(),
                atlas: null
            });

            return texture;
        }, 'optimized texture creation');
    }

    /*
     * Clean up old textures when cache gets too large
     */
    cleanupOldTextures() {
        if (this.textureCache.size <= 50) return;

        let count = 0;
        const toDelete = [];

        for (const [image, texture] of this.textureCache.entries()) {
            if (count++ > 25) break; // Keep only the first 25
            toDelete.push([image, texture]);
        }

        toDelete.forEach(([image, texture]) => {
            if (this.gl && this.gl.isTexture(texture)) {
                this.gl.deleteTexture(texture);
            }
            this.textureCache.delete(image);
        });

        // console.log(`Cleaned up ${toDelete.length} old textures`);
    }

    /*
     * Draw image
     * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image - Image to draw
     * @param {number} sx - Source x (optional)
     * @param {number} sy - Source y (optional)  
     * @param {number} sWidth - Source width (optional)
     * @param {number} sHeight - Source height (optional)
     * @param {number} dx - Destination x
     * @param {number} dy - Destination y
     * @param {number} dWidth - Destination width (optional)
     * @param {number} dHeight - Destination height (optional)
     */
    drawImage(image, ...args) {
        // Check if image is loaded
        if (!image || !image.complete || image.naturalWidth === 0) {
            //// console.warn('Image not loaded or invalid');
            return;
        }

        let sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight;

        if (args.length === 2) {
            // drawImage(image, dx, dy)
            [dx, dy] = args;
            sx = 0;
            sy = 0;
            sWidth = image.width || image.videoWidth || image.naturalWidth;
            sHeight = image.height || image.videoHeight || image.naturalHeight;
            dWidth = sWidth;
            dHeight = sHeight;
        } else if (args.length === 4) {
            // drawImage(image, dx, dy, dWidth, dHeight)
            [dx, dy, dWidth, dHeight] = args;
            sx = 0;
            sy = 0;
            sWidth = image.width || image.videoWidth || image.naturalWidth;
            sHeight = image.height || image.videoHeight || image.naturalHeight;
        } else if (args.length === 8) {
            // drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
            [sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight] = args;
        } else {
            throw new Error('Invalid number of arguments for drawImage');
        }

        const texture = this.getOrCreateTexture(image);
        // Now just add to batch instead of rendering immediately
        this.addImageToBatch(texture, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
    }

    /*
    * Ellipse path
    * @param {number} x - X coordinate of center
    * @param {number} y - Y coordinate of center
    * @param {number} radiusX - Horizontal radius
    * @param {number} radiusY - Vertical radius
    * @param {number} rotation - Rotation in radians (optional)
    * @param {number} startAngle - Start angle in radians (optional)
    * @param {number} endAngle - End angle in radians (optional)
    * @param {boolean} counterclockwise - Direction (optional)
    */
    ellipse(x, y, radiusX, radiusY, rotation = 0, startAngle = 0, endAngle = 2 * Math.PI, counterclockwise = false) {
        // Transform the ellipse based on rotation
        this.save();
        this.translate(x, y);
        this.rotate(rotation);
        this.scale(radiusX, radiusY);
        this.arc(0, 0, 1, startAngle, endAngle, counterclockwise);
        this.restore();
    }

    /*
     * Fill ellipse
     * @param {number} x - X coordinate of center
     * @param {number} y - Y coordinate of center
     * @param {number} radiusX - Horizontal radius
     * @param {number} radiusY - Vertical radius
     * @param {number} rotation - Rotation in radians (optional)
     * @param {number} startAngle - Start angle in radians (optional)
     * @param {number} endAngle - End angle in radians (optional)
     * @param {boolean} counterclockwise - Direction (optional)
     */
    fillEllipse(x, y, radiusX, radiusY, rotation = 0, startAngle = 0, endAngle = 2 * Math.PI, counterclockwise = false) {
        this.addEllipseToBatch(x, y, radiusX, radiusY, this.state.fillStyle);
    }

    /*
     * Stroke ellipse
     */
    strokeEllipse(x, y, radiusX, radiusY, rotation = 0, startAngle = 0, endAngle = 2 * Math.PI, counterclockwise = false) {
        this.addEllipseToBatch(x, y, radiusX, radiusY, this.state.strokeStyle);
    }

    /*
    * Rounded rectangle path
    * @param {number} x - X coordinate of the rectangle
    * @param {number} y - Y coordinate of the rectangle
    * @param {number} width - Width of the rectangle
    * @param {number} height - Height of the rectangle
    * @param {number|Array} radii - Corner radii (single value or array of four values)
    */
    roundRect(x, y, width, height, radii = 0) {
        if (!Array.isArray(radii)) {
            radii = [radii, radii, radii, radii];
        } else if (radii.length === 1) {
            radii = [radii[0], radii[0], radii[0], radii[0]];
        } else if (radii.length === 2) {
            radii = [radii[0], radii[1], radii[0], radii[1]];
        }

        const [tl, tr, br, bl] = radii;

        this.beginPath();
        this.moveTo(x + tl, y);
        this.lineTo(x + width - tr, y);
        this.quadraticCurveTo(x + width, y, x + width, y + tr);
        this.lineTo(x + width, y + height - br);
        this.quadraticCurveTo(x + width, y + height, x + width - br, y + height);
        this.lineTo(x + bl, y + height);
        this.quadraticCurveTo(x, y + height, x, y + height - bl);
        this.lineTo(x, y + tl);
        this.quadraticCurveTo(x, y, x + tl, y);
        this.closePath();
    }

    /*
        * Fill rectangle - adds to batch
        * @param {number} x - X coordinate of the rectangle
        * @param {number} y - Y coordinate of the rectangle
        * @param {number} width - Width of the rectangle    
        * @param {number} height - Height of the rectangle
    */
    fillRect(x, y, width, height) {
        this.addRectangleToBatch(x, y, width, height, this.state.fillStyle);
    }

    /*
        * Stroke rectangle - adds to batch (not implemented in this version)
        * @param {number} x - X coordinate of the rectangle
        * @param {number} y - Y coordinate of the rectangle
        * @param {number} width - Width of the rectangle    
        * @param {number} height - Height of the rectangle
    */
    strokeRect(x, y, width, height) {
        if (this.state.lineDash.length > 0) {
            // Draw dashed rectangle by drawing each side separately
            this.drawDashedLine(x, y, x + width, y); // Top
            this.drawDashedLine(x + width, y, x + width, y + height); // Right
            this.drawDashedLine(x + width, y + height, x, y + height); // Bottom
            this.drawDashedLine(x, y + height, x, y); // Left
        } else {
            // Original solid rectangle stroke
            const lineWidth = this.state.lineWidth;
            const halfWidth = lineWidth / 2;

            // Draw four rectangles to form the stroke
            // Top
            this.addRectangleToBatch(x - halfWidth, y - halfWidth, width + lineWidth, lineWidth, this.state.strokeStyle);
            // Bottom  
            this.addRectangleToBatch(x - halfWidth, y + height - halfWidth, width + lineWidth, lineWidth, this.state.strokeStyle);
            // Left
            this.addRectangleToBatch(x - halfWidth, y + halfWidth, lineWidth, height - lineWidth, this.state.strokeStyle);
            // Right
            this.addRectangleToBatch(x + width - halfWidth, y + halfWidth, lineWidth, height - lineWidth, this.state.strokeStyle);
        }
    }

    /*
        * Fill circle - adds to batch
        * @param {number} x - X coordinate of the circle center
        * @param {number} y - Y coordinate of the circle center
        * @param {number} radius - Radius of the circle
    */
    fillCircle(x, y, radius) {
        this.addCircleToBatch(x, y, radius, this.state.fillStyle);
    }

    /*
        * Stroke circle - adds to batch
        * @param {number} x - X coordinate of the circle center
        * @param {number} y - Y coordinate of the circle center
        * @param {number} radius - Radius of the circle
    */
    strokeCircle(x, y, radius) {
        // Clear any existing path to prevent unwanted connections
        this.beginPath();

        // For stroke circle, we need to draw a ring (hollow circle)
        // We can do this by drawing two circles: outer and inner
        const lineWidth = this.state.lineWidth;
        const outerRadius = radius + lineWidth / 2;
        const innerRadius = Math.max(0, radius - lineWidth / 2);

        if (innerRadius > 0) {
            // Draw as a ring using a custom approach
            this.addStrokeCircleToBatch(x, y, radius, lineWidth, this.state.strokeStyle);
        } else {
            // If inner radius is 0, just draw a filled circle
            this.addCircleToBatch(x, y, outerRadius, this.state.strokeStyle);
        }
    }

    /*
     * Enhanced drawLine method with dashed line support
     * @param {number} x1 - Start X
     * @param {number} y1 - Start Y
     * @param {number} x2 - End X
     * @param {number} y2 - End Y
     */
    drawLine(x1, y1, x2, y2) {
        if (this.state.lineDash.length > 0) {
            this.drawDashedLine(x1, y1, x2, y2);
        } else {
            const lineWidth = this.state.lineWidth;

            // For line width of 1 or less, use the simple line rendering
            if (lineWidth <= 1) {
                this.drawThinLine(x1, y1, x2, y2);
            } else {
                // For thick lines, draw as rectangles
                this.drawThickLine(x1, y1, x2, y2, lineWidth);
            }
        }
    }

    /*
    * Draw dashed line
    * @param {number} x1 - Start X
    * @param {number} y1 - Start Y
    * @param {number} x2 - End X
    * @param {number} y2 - End Y
    */
    drawDashedLine(x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const lineLength = Math.sqrt(dx * dx + dy * dy);

        if (lineLength === 0) return;

        // Normalized direction
        const unitX = dx / lineLength;
        const unitY = dy / lineLength;

        const dashPattern = this.state.lineDash;
        const dashOffset = this.state.lineDashOffset;

        let currentDistance = -dashOffset; // Start with offset
        let currentX = x1;
        let currentY = y1;
        let dashIndex = 0;
        let isDrawing = true; // Start drawing if offset is negative or zero

        // Adjust for positive dash offset
        if (dashOffset > 0) {
            // Skip forward through the pattern
            let offsetRemaining = dashOffset;
            while (offsetRemaining > 0 && dashPattern.length > 0) {
                const dashLength = dashPattern[dashIndex % dashPattern.length];
                if (offsetRemaining >= dashLength) {
                    offsetRemaining -= dashLength;
                    dashIndex++;
                    isDrawing = !isDrawing;
                } else {
                    currentDistance = dashLength - offsetRemaining;
                    break;
                }
            }
        }

        while (currentDistance < lineLength) {
            const dashLength = dashPattern[dashIndex % dashPattern.length];
            const segmentEnd = Math.min(currentDistance + dashLength, lineLength);

            if (isDrawing && segmentEnd > Math.max(0, currentDistance)) {
                // Calculate segment coordinates
                const segmentStart = Math.max(0, currentDistance);
                const startX = x1 + unitX * segmentStart;
                const startY = y1 + unitY * segmentStart;
                const endX = x1 + unitX * segmentEnd;
                const endY = y1 + unitY * segmentEnd;

                // Draw this segment
                if (this.state.lineWidth <= 1) {
                    this.drawThinLine(startX, startY, endX, endY);
                } else {
                    this.drawThickLine(startX, startY, endX, endY, this.state.lineWidth);
                }
            }

            currentDistance += dashLength;
            dashIndex++;
            isDrawing = !isDrawing;
        }
    }

    /*
     * Apply dashed stroke to path segments
     * @param {Array} segments - Path segments to apply dashing to
     * @return {Array} - Dashed segments
     */
    applyDashesToSegments(segments) {
        if (this.state.lineDash.length === 0) {
            return segments;
        }

        const dashedSegments = [];

        for (const segment of segments) {
            const segmentDashes = this.getDashedSegments(
                segment.x1, segment.y1,
                segment.x2, segment.y2
            );
            dashedSegments.push(...segmentDashes);
        }

        return dashedSegments;
    }

    /*
     * Get dashed segments for a single line
     * @param {number} x1 - Start X
     * @param {number} y1 - Start Y
     * @param {number} x2 - End X
     * @param {number} y2 - End Y
     * @return {Array} - Array of dashed line segments
     */
    getDashedSegments(x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const lineLength = Math.sqrt(dx * dx + dy * dy);

        if (lineLength === 0) return [];

        const unitX = dx / lineLength;
        const unitY = dy / lineLength;

        const dashPattern = this.state.lineDash;
        const dashOffset = this.state.lineDashOffset;
        const segments = [];

        let currentDistance = -dashOffset;
        let dashIndex = 0;
        let isDrawing = true;

        // Handle positive dash offset
        if (dashOffset > 0) {
            let offsetRemaining = dashOffset;
            while (offsetRemaining > 0 && dashPattern.length > 0) {
                const dashLength = dashPattern[dashIndex % dashPattern.length];
                if (offsetRemaining >= dashLength) {
                    offsetRemaining -= dashLength;
                    dashIndex++;
                    isDrawing = !isDrawing;
                } else {
                    currentDistance = dashLength - offsetRemaining;
                    break;
                }
            }
        }

        while (currentDistance < lineLength) {
            const dashLength = dashPattern[dashIndex % dashPattern.length];
            const segmentEnd = Math.min(currentDistance + dashLength, lineLength);

            if (isDrawing && segmentEnd > Math.max(0, currentDistance)) {
                const segmentStart = Math.max(0, currentDistance);
                segments.push({
                    x1: x1 + unitX * segmentStart,
                    y1: y1 + unitY * segmentStart,
                    x2: x1 + unitX * segmentEnd,
                    y2: y1 + unitY * segmentEnd,
                    type: 'dash'
                });
            }

            currentDistance += dashLength;
            dashIndex++;
            isDrawing = !isDrawing;
        }

        return segments;
    }

    /*
    * Draw line join between two segments
    * @param {Object} seg1 - First segment
    * @param {Object} seg2 - Second segment
    * @param {number} width - Line width
    */
    drawLineJoin(seg1, seg2, width) {
        const joinX = seg1.x2;
        const joinY = seg1.y2;
        const halfWidth = width / 2;

        if (this.state.lineJoin === 'round') {
            // Draw a circle at the join point
            this.fillCircle(joinX, joinY, halfWidth);
        } else if (this.state.lineJoin === 'bevel') {
            // Calculate bevel join geometry (simplified)
            // This is complex geometry, so for now just draw a circle
            this.fillCircle(joinX, joinY, halfWidth);
        }
        // For 'miter', we don't need to do anything extra as the rectangles will overlap
    }

    /*
     * Draw thin line using GL_LINES (original implementation)
     */
    drawThinLine(x1, y1, x2, y2) {
        const batch = this.batchBuffers.lines;

        // Check if batch is full
        if (batch.currentVertices + 2 > batch.maxVertices) {
            this.flushLines();
            batch.currentVertices = 0;
        }

        // Transform line endpoints
        const [tx1, ty1] = this.transformPoint(x1, y1);
        const [tx2, ty2] = this.transformPoint(x2, y2);

        const vertexIndex = batch.currentVertices;
        const color = this.state.strokeStyle;

        // Apply global alpha to line colors
        const finalColor = [
            color[0],
            color[1],
            color[2],
            color[3] * this.state.globalAlpha
        ];

        // Add vertices
        batch.vertexData[vertexIndex * 2 + 0] = tx1;
        batch.vertexData[vertexIndex * 2 + 1] = ty1;
        batch.vertexData[vertexIndex * 2 + 2] = tx2;
        batch.vertexData[vertexIndex * 2 + 3] = ty2;

        // Add colors with global alpha
        for (let i = 0; i < 2; i++) {
            batch.colorData[(vertexIndex + i) * 4 + 0] = finalColor[0];
            batch.colorData[(vertexIndex + i) * 4 + 1] = finalColor[1];
            batch.colorData[(vertexIndex + i) * 4 + 2] = finalColor[2];
            batch.colorData[(vertexIndex + i) * 4 + 3] = finalColor[3];
        }

        batch.currentVertices += 2;
    }

    /*
     * Draw thick line as a rectangle
     * @param {number} x1 - Start X
     * @param {number} y1 - Start Y
     * @param {number} x2 - End X
     * @param {number} y2 - End Y
     * @param {number} width - Line width
     */
    drawThickLine(x1, y1, x2, y2, width) {
        // Calculate line direction and perpendicular
        const dx = x2 - x1;
        const dy = y2 - y1;
        const length = Math.sqrt(dx * dx + dy * dy);

        if (length === 0) {
            // Draw a small circle for zero-length lines
            this.fillCircle(x1, y1, width / 2);
            return;
        }

        // Normalized perpendicular vector
        const perpX = -dy / length;
        const perpY = dx / length;

        // Half width offset
        const halfWidth = width / 2;
        const offsetX = perpX * halfWidth;
        const offsetY = perpY * halfWidth;

        // Calculate the four corners of the line rectangle
        const corners = [
            { x: x1 - offsetX, y: y1 - offsetY }, // Bottom-left of line start
            { x: x1 + offsetX, y: y1 + offsetY }, // Top-left of line start
            { x: x2 + offsetX, y: y2 + offsetY }, // Top-right of line end
            { x: x2 - offsetX, y: y2 - offsetY }  // Bottom-right of line end
        ];

        // Handle line caps
        if (this.state.lineCap !== 'butt') {
            this.drawLineWithCaps(corners, x1, y1, x2, y2, width, dx, dy, length);
        } else {
            this.drawLineRectangle(corners);
        }
    }

    /*
     * Draw line rectangle using the rectangle batch
     * @param {Array} corners - Four corner points
     */
    drawLineRectangle(corners) {
        const batch = this.batchBuffers.rectangles;

        if (batch.currentVertices + 4 > batch.maxVertices) {
            this.flushRectangles();
            batch.currentVertices = 0;
            batch.currentIndices = 0;
        }

        // Transform corners
        const transformedCorners = corners.map(corner =>
            this.transformPoint(corner.x, corner.y)
        );

        const vertexIndex = batch.currentVertices;
        const color = this.state.strokeStyle;

        // Apply global alpha
        const finalColor = [
            color[0],
            color[1],
            color[2],
            color[3] * this.state.globalAlpha
        ];

        // Add vertices (reorder for proper triangle winding)
        batch.vertexData[vertexIndex * 2 + 0] = transformedCorners[0][0]; // Bottom-left
        batch.vertexData[vertexIndex * 2 + 1] = transformedCorners[0][1];
        batch.vertexData[vertexIndex * 2 + 2] = transformedCorners[3][0]; // Bottom-right
        batch.vertexData[vertexIndex * 2 + 3] = transformedCorners[3][1];
        batch.vertexData[vertexIndex * 2 + 4] = transformedCorners[1][0]; // Top-left
        batch.vertexData[vertexIndex * 2 + 5] = transformedCorners[1][1];
        batch.vertexData[vertexIndex * 2 + 6] = transformedCorners[2][0]; // Top-right
        batch.vertexData[vertexIndex * 2 + 7] = transformedCorners[2][1];

        // Add colors for all 4 vertices
        for (let i = 0; i < 4; i++) {
            batch.colorData[(vertexIndex + i) * 4 + 0] = finalColor[0];
            batch.colorData[(vertexIndex + i) * 4 + 1] = finalColor[1];
            batch.colorData[(vertexIndex + i) * 4 + 2] = finalColor[2];
            batch.colorData[(vertexIndex + i) * 4 + 3] = finalColor[3];
        }

        // Add indices (two triangles)
        const indexBase = batch.currentVertices;
        const indexOffset = batch.currentIndices;
        batch.indexData[indexOffset + 0] = indexBase + 0;
        batch.indexData[indexOffset + 1] = indexBase + 1;
        batch.indexData[indexOffset + 2] = indexBase + 2;
        batch.indexData[indexOffset + 3] = indexBase + 1;
        batch.indexData[indexOffset + 4] = indexBase + 2;
        batch.indexData[indexOffset + 5] = indexBase + 3;

        batch.currentVertices += 4;
        batch.currentIndices += 6;
    }

    /*
     * Draw line with caps (round or square)
     * @param {Array} corners - Base rectangle corners
     * @param {number} x1 - Start X
     * @param {number} y1 - Start Y
     * @param {number} x2 - End X
     * @param {number} y2 - End Y
     * @param {number} width - Line width
     * @param {number} dx - X direction
     * @param {number} dy - Y direction
     * @param {number} length - Line length
     */
    drawLineWithCaps(corners, x1, y1, x2, y2, width, dx, dy, length) {
        // Draw the main line rectangle
        this.drawLineRectangle(corners);

        const halfWidth = width / 2;

        if (this.state.lineCap === 'round') {
            // Draw round caps as circles
            this.fillCircle(x1, y1, halfWidth);
            this.fillCircle(x2, y2, halfWidth);
        } else if (this.state.lineCap === 'square') {
            // Extend the line by half width on each end
            const extendX = (dx / length) * halfWidth;
            const extendY = (dy / length) * halfWidth;

            // Extended corners
            const perpX = -dy / length;
            const perpY = dx / length;
            const offsetX = perpX * halfWidth;
            const offsetY = perpY * halfWidth;

            // Start cap
            const startCap = [
                { x: x1 - extendX - offsetX, y: y1 - extendY - offsetY },
                { x: x1 - extendX + offsetX, y: y1 - extendY + offsetY },
                { x: x1 + offsetX, y: y1 + offsetY },
                { x: x1 - offsetX, y: y1 - offsetY }
            ];

            // End cap
            const endCap = [
                { x: x2 - offsetX, y: y2 - offsetY },
                { x: x2 + offsetX, y: y2 + offsetY },
                { x: x2 + extendX + offsetX, y: y2 + extendY + offsetY },
                { x: x2 + extendX - offsetX, y: y2 + extendY - offsetY }
            ];

            this.drawLineRectangle(startCap);
            this.drawLineRectangle(endCap);
        }
    }

    /*
     * Helper method to create a dash pattern from CSS-style dash array
     * @param {Array} dashArray - Array of dash and gap lengths
     * @return {Array} - Normalized dash pattern
     */
    createDashPattern(dashArray) {
        if (!Array.isArray(dashArray) || dashArray.length === 0) {
            return [];
        }

        // Ensure positive values
        const pattern = dashArray.map(value => Math.max(0, Number(value) || 0));

        // If odd number of elements, duplicate the array
        if (pattern.length % 2 === 1) {
            return [...pattern, ...pattern];
        }

        return pattern;
    }

    /*
     * Set dash pattern with validation
     * @param {Array} pattern - Dash pattern
     */
    setLineDash(segments) {
        if (!Array.isArray(segments)) {
            this.state.lineDash = [];
            return;
        }

        // Filter out non-positive values and convert to numbers
        const validSegments = segments
            .map(seg => Number(seg))
            .filter(seg => !isNaN(seg) && seg > 0);

        // If all segments were invalid, clear the pattern
        if (validSegments.length === 0) {
            this.state.lineDash = [];
            return;
        }

        // If odd number of segments, repeat the pattern
        if (validSegments.length % 2 === 1) {
            this.state.lineDash = [...validSegments, ...validSegments];
        } else {
            this.state.lineDash = validSegments;
        }
    }

    // Set dotted line pattern
    setDottedLine(dotSize = 2, gapSize = 2) {
        this.setLineDash([dotSize, gapSize]);
    }

    // Set dashed line pattern
    setDashedLine(dashSize = 5, gapSize = 5) {
        this.setLineDash([dashSize, gapSize]);
    }

    // Set dash-dot pattern
    setDashDotLine(dashSize = 5, gapSize = 2, dotSize = 1) {
        this.setLineDash([dashSize, gapSize, dotSize, gapSize]);
    }

    // Set dash-dot-dot pattern
    setDashDotDotLine(dashSize = 5, gapSize = 2, dotSize = 1) {
        this.setLineDash([dashSize, gapSize, dotSize, gapSize, dotSize, gapSize]);
    }

    // Clear dash pattern (solid line)
    setSolidLine() {
        this.setLineDash([]);
    }

    /*
    * Get current line dash pattern
    * @return {Array} - Current dash pattern
    */
    getLineDash() {
        return [...this.state.lineDash];
    }

    /*
     * Begin a new path
     */
    beginPath() {
        this.currentPath = [];
    }

    /*
     * Close the current path
     */
    closePath() {
        if (this.currentPath.length > 0) {
            this.currentPath.push({ type: 'close' });
        }
    }

    /*
     * Move to point without drawing
     * @param {number} x - X coordinate
     * @param {number} y - Y coordinate
     */
    moveTo(x, y) {
        this.currentPath.push({ type: 'moveTo', x, y });
        this.pathStartX = x;
        this.pathStartY = y;
        this.currentX = x;
        this.currentY = y;
    }

    /*
     * Draw line to point
     * @param {number} x - X coordinate
     * @param {number} y - Y coordinate
     */
    lineTo(x, y) {
        this.currentPath.push({ type: 'lineTo', x, y });
        this.currentX = x;
        this.currentY = y;
    }

    /*
     * Draw quadratic curve
     * @param {number} cpx - Control point X
     * @param {number} cpy - Control point Y
     * @param {number} x - End point X
     * @param {number} y - End point Y
     */
    quadraticCurveTo(cpx, cpy, x, y) {
        this.currentPath.push({ type: 'quadraticCurveTo', cpx, cpy, x, y });
        this.currentX = x;
        this.currentY = y;
    }

    /*
     * Draw bezier curve
     * @param {number} cp1x - Control point 1 X
     * @param {number} cp1y - Control point 1 Y
     * @param {number} cp2x - Control point 2 X
     * @param {number} cp2y - Control point 2 Y
     * @param {number} x - End point X
     * @param {number} y - End point Y
     */
    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
        this.currentPath.push({ type: 'bezierCurveTo', cp1x, cp1y, cp2x, cp2y, x, y });
        this.currentX = x;
        this.currentY = y;
    }

    /*
     * Draw arc
     * @param {number} x - Center X
     * @param {number} y - Center Y
     * @param {number} radius - Arc radius
     * @param {number} startAngle - Start angle in radians
     * @param {number} endAngle - End angle in radians
     * @param {boolean} counterclockwise - Direction
     */
    arc(x, y, radius, startAngle, endAngle, counterclockwise = false) {
        // If this is the start of a new path or we're at 0,0, move to the arc start point
        if (this.currentPath.length === 0 || (this.currentX === 0 && this.currentY === 0)) {
            const startX = x + Math.cos(startAngle) * radius;
            const startY = y + Math.sin(startAngle) * radius;
            this.moveTo(startX, startY);
        }

        this.currentPath.push({ type: 'arc', x, y, radius, startAngle, endAngle, counterclockwise });

        // Update current position to end of arc
        this.currentX = x + Math.cos(endAngle) * radius;
        this.currentY = y + Math.sin(endAngle) * radius;
    }

    /*
     * Draw arc between two points
     * @param {number} x1 - First point X
     * @param {number} y1 - First point Y
     * @param {number} x2 - Second point X
     * @param {number} y2 - Second point Y
     * @param {number} radius - Arc radius
     */
    arcTo(x1, y1, x2, y2, radius) {
        this.currentPath.push({ type: 'arcTo', x1, y1, x2, y2, radius });
        this.currentX = x2;
        this.currentY = y2;
    }

    /*
     * Add rectangle to path
     * @param {number} x - X coordinate
     * @param {number} y - Y coordinate
     * @param {number} width - Width
     * @param {number} height - Height
     */
    rect(x, y, width, height) {
        this.moveTo(x, y);
        this.lineTo(x + width, y);
        this.lineTo(x + width, y + height);
        this.lineTo(x, y + height);
        this.closePath();
    }

    /*
    * Fill the current path with a specific fill rule
    * @param {string} fillRule - 'nonzero' or 'evenodd'
    */
    fill(fillRule = 'nonzero') {
        this.renderPath(true, fillRule);
    }

    /*
    * Stroke the current path
    */
    stroke() {
        if (this.currentPath.length === 0) return;

        // Get path segments
        let segments = this.pathToSegments(this.currentPath);

        // Apply dashing if dash pattern is set
        if (this.state.lineDash.length > 0) {
            segments = this.applyDashesToSegments(segments);
        }

        // Draw each segment
        for (const segment of segments) {
            if (this.state.lineWidth > 1) {
                this.drawThickLine(segment.x1, segment.y1, segment.x2, segment.y2, this.state.lineWidth);
            } else {
                this.drawThinLine(segment.x1, segment.y1, segment.x2, segment.y2);
            }
        }

        // Handle line joins for non-dashed lines
        if (this.state.lineDash.length === 0 && this.state.lineJoin !== 'miter' && this.state.lineWidth > 1) {
            const originalSegments = this.pathToSegments(this.currentPath);
            for (let i = 1; i < originalSegments.length; i++) {
                const prevSegment = originalSegments[i - 1];
                const currentSegment = originalSegments[i];
                this.drawLineJoin(prevSegment, currentSegment, this.state.lineWidth);
            }
        }
    }

    /*
     * Render thick stroke for paths
     */
    renderThickStroke() {
        const segments = this.pathToSegments(this.currentPath);
        const lineWidth = this.state.lineWidth;

        // Draw each segment as a thick line
        for (let i = 0; i < segments.length; i++) {
            const segment = segments[i];
            this.drawThickLine(segment.x1, segment.y1, segment.x2, segment.y2, lineWidth);

            // Handle line joins
            if (i > 0 && this.state.lineJoin !== 'miter') {
                const prevSegment = segments[i - 1];
                this.drawLineJoin(prevSegment, segment, lineWidth);
            }
        }
    }

    /*
    * Both fill and stroke the current path
    */
    fillAndStroke() {
        this.fill();
        this.stroke();
    }

    /*
    * Clear the current path without rendering
    */
    clearPath() {
        this.currentPath = [];
        this.currentX = 0;
        this.currentY = 0;
        this.pathStartX = 0;
        this.pathStartY = 0;
    }

    /*
    * Render the current path
    * @param {boolean} fill - Whether to fill (true) or stroke (false)
    * @param {string} fillRule - Fill rule for filling ('nonzero' or 'evenodd')
    */
    renderPath(fill, fillRule = 'nonzero') {
        if (this.currentPath.length === 0) return;

        if (fill) {
            // For filling, we need to triangulate the path
            const triangles = this.triangulatePath(this.currentPath, fillRule);
            if (triangles.length > 0) {
                this.renderTriangles(triangles, this.state.fillStyle);
            }
        } else {
            // For stroking, convert path to line segments
            const segments = this.pathToSegments(this.currentPath);
            for (const segment of segments) {
                this.drawLine(segment.x1, segment.y1, segment.x2, segment.y2);
            }
        }
    }

    /*
     * Triangulate a path for filling
     * Uses ear clipping algorithm for simple polygons
     * @param {Array} path - Path commands
     * @return {Array} - Array of triangles (each triangle is 6 values: x1,y1,x2,y2,x3,y3)
     */
    triangulatePath(path) {
        // Convert path to polygon points
        const polygons = this.pathToPolygons(path);
        const triangles = [];

        for (const polygon of polygons) {
            if (polygon.length < 3) continue;

            // Simple ear clipping triangulation
            const polyTriangles = this.earClipping(polygon);
            triangles.push(...polyTriangles);
        }

        return triangles;
    }

    /*
     * Convert path commands to polygon point arrays
     * @param {Array} path - Path commands
     * @return {Array} - Array of polygons (each polygon is array of {x, y} points)
     */
    pathToPolygons(path) {
        const polygons = [];
        let currentPolygon = [];
        let currentX = 0, currentY = 0;
        let startX = 0, startY = 0;

        for (const command of path) {
            switch (command.type) {
                case 'moveTo':
                    // Start new polygon if current one has points
                    if (currentPolygon.length > 0) {
                        polygons.push([...currentPolygon]);
                        currentPolygon = [];
                    }
                    currentX = command.x;
                    currentY = command.y;
                    startX = command.x;
                    startY = command.y;
                    currentPolygon.push({ x: currentX, y: currentY });
                    break;

                case 'lineTo':
                    currentX = command.x;
                    currentY = command.y;
                    currentPolygon.push({ x: currentX, y: currentY });
                    break;

                case 'quadraticCurveTo':
                    // Approximate curve with line segments
                    const quadPoints = this.approximateQuadraticPoints(
                        currentX, currentY,
                        command.cpx, command.cpy,
                        command.x, command.y,
                        16 // number of segments
                    );
                    currentPolygon.push(...quadPoints.slice(1)); // Skip first point as it's current position
                    currentX = command.x;
                    currentY = command.y;
                    break;

                case 'bezierCurveTo':
                    // Approximate curve with line segments
                    const bezierPoints = this.approximateBezierPoints(
                        currentX, currentY,
                        command.cp1x, command.cp1y,
                        command.cp2x, command.cp2y,
                        command.x, command.y,
                        16 // number of segments
                    );
                    currentPolygon.push(...bezierPoints.slice(1)); // Skip first point
                    currentX = command.x;
                    currentY = command.y;
                    break;

                case 'arc':
                    const arcPoints = this.approximateArcPoints(
                        command.x, command.y,
                        command.radius,
                        command.startAngle,
                        command.endAngle,
                        command.counterclockwise,
                        32 // number of segments
                    );
                    if (arcPoints.length > 0) {
                        currentPolygon.push(...arcPoints);
                        const lastPoint = arcPoints[arcPoints.length - 1];
                        currentX = lastPoint.x;
                        currentY = lastPoint.y;
                    }
                    break;

                case 'close':
                    if (currentPolygon.length > 0) {
                        // Close the polygon by ensuring it ends where it started
                        const first = currentPolygon[0];
                        const last = currentPolygon[currentPolygon.length - 1];
                        if (Math.abs(first.x - last.x) > 0.001 || Math.abs(first.y - last.y) > 0.001) {
                            currentPolygon.push({ x: startX, y: startY });
                        }
                    }
                    currentX = startX;
                    currentY = startY;
                    break;
            }
        }

        // Add final polygon if it has points
        if (currentPolygon.length > 0) {
            polygons.push(currentPolygon);
        }

        return polygons;
    }

    /*
     * Simple ear clipping triangulation
     * @param {Array} polygon - Array of {x, y} points
     * @return {Array} - Array of triangles
     */
    earClipping(polygon) {
        if (polygon.length < 3) return [];
        if (polygon.length === 3) {
            return [polygon[0], polygon[1], polygon[2]];
        }

        const triangles = [];
        const vertices = [...polygon];

        // Remove consecutive duplicate points
        for (let i = vertices.length - 1; i >= 0; i--) {
            const current = vertices[i];
            const next = vertices[(i + 1) % vertices.length];
            if (Math.abs(current.x - next.x) < 0.001 && Math.abs(current.y - next.y) < 0.001) {
                vertices.splice(i, 1);
            }
        }

        if (vertices.length < 3) return [];

        // Simple fan triangulation for convex polygons
        // This is a simplified version - full ear clipping is more complex
        const center = vertices[0];
        for (let i = 1; i < vertices.length - 1; i++) {
            triangles.push(center, vertices[i], vertices[i + 1]);
        }

        return triangles;
    }

    /*
     * Render triangles to the screen
     * @param {Array} triangles - Array of triangle vertices
     * @param {Array} color - RGBA color array
     */
    renderTriangles(triangles, color) {
        const batch = this.batchBuffers.rectangles; // Reuse rectangle batch buffer

        for (let i = 0; i < triangles.length; i += 3) {
            const p1 = triangles[i];
            const p2 = triangles[i + 1];
            const p3 = triangles[i + 2];

            // Check if batch is full (need 3 vertices, but buffer expects quads)
            if (batch.currentVertices + 4 > batch.maxVertices) {
                this.flushRectangles();
                batch.currentVertices = 0;
                batch.currentIndices = 0;
            }

            // Transform triangle vertices
            const [x1, y1] = this.transformPoint(p1.x, p1.y);
            const [x2, y2] = this.transformPoint(p2.x, p2.y);
            const [x3, y3] = this.transformPoint(p3.x, p3.y);

            // Create a degenerate quad by duplicating the third vertex
            const vertexIndex = batch.currentVertices;

            // Add vertices (triangle + duplicate third point to make quad)
            batch.vertexData[vertexIndex * 2 + 0] = x1;
            batch.vertexData[vertexIndex * 2 + 1] = y1;
            batch.vertexData[vertexIndex * 2 + 2] = x2;
            batch.vertexData[vertexIndex * 2 + 3] = y2;
            batch.vertexData[vertexIndex * 2 + 4] = x3;
            batch.vertexData[vertexIndex * 2 + 5] = y3;
            batch.vertexData[vertexIndex * 2 + 6] = x3; // Duplicate third point
            batch.vertexData[vertexIndex * 2 + 7] = y3;

            // Apply global alpha to colors
            const finalColor = [
                color[0],
                color[1],
                color[2],
                color[3] * this.state.globalAlpha
            ];

            // Add colors for all 4 vertices
            for (let j = 0; j < 4; j++) {
                batch.colorData[(vertexIndex + j) * 4 + 0] = finalColor[0];
                batch.colorData[(vertexIndex + j) * 4 + 1] = finalColor[1];
                batch.colorData[(vertexIndex + j) * 4 + 2] = finalColor[2];
                batch.colorData[(vertexIndex + j) * 4 + 3] = finalColor[3];
            }

            // Add indices to form triangle (first 3 indices form the triangle)
            const indexBase = batch.currentVertices;
            const indexOffset = batch.currentIndices;
            batch.indexData[indexOffset + 0] = indexBase + 0;
            batch.indexData[indexOffset + 1] = indexBase + 1;
            batch.indexData[indexOffset + 2] = indexBase + 2;
            // Degenerate second triangle (all same point)
            batch.indexData[indexOffset + 3] = indexBase + 2;
            batch.indexData[indexOffset + 4] = indexBase + 3;
            batch.indexData[indexOffset + 5] = indexBase + 2;

            batch.currentVertices += 4;
            batch.currentIndices += 6;
        }
    }

    /*
     * Approximate quadratic curve as points
     */
    approximateQuadraticPoints(x0, y0, cx, cy, x1, y1, segments) {
        const points = [];
        for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const point = this.quadraticBezier(x0, y0, cx, cy, x1, y1, t);
            points.push({ x: point.x, y: point.y });
        }
        return points;
    }

    /*
     * Approximate cubic bezier curve as points
     */
    approximateBezierPoints(x0, y0, cx1, cy1, cx2, cy2, x1, y1, segments) {
        const points = [];
        for (let i = 0; i <= segments; i++) {
            const t = i / segments;
            const point = this.cubicBezier(x0, y0, cx1, cy1, cx2, cy2, x1, y1, t);
            points.push({ x: point.x, y: point.y });
        }
        return points;
    }

    /*
     * Approximate arc as points
     */
    approximateArcPoints(cx, cy, radius, startAngle, endAngle, counterclockwise, segments) {
        const points = [];

        let totalAngle = endAngle - startAngle;
        if (counterclockwise) {
            if (totalAngle > 0) totalAngle -= 2 * Math.PI;
        } else {
            if (totalAngle < 0) totalAngle += 2 * Math.PI;
        }

        const angleStep = totalAngle / segments;

        for (let i = 0; i <= segments; i++) {
            const angle = startAngle + angleStep * i;
            const x = cx + Math.cos(angle) * radius;
            const y = cy + Math.sin(angle) * radius;
            points.push({ x, y });
        }

        return points;
    }

    /*
    * Convert path to line segments (updated to use enhanced version)
    * @param {Array} path - Path commands
    * @return {Array} - Array of line segments
    */
    pathToSegments(path) {
        return this.pathToSegmentsEnhanced(path);
    }

    /*
     * Approximate quadratic curve with line segments
     */
    approximateQuadratic(x0, y0, cx, cy, x1, y1, segments) {
        const result = [];
        for (let i = 0; i < segments; i++) {
            const t1 = i / segments;
            const t2 = (i + 1) / segments;

            const p1 = this.quadraticBezier(x0, y0, cx, cy, x1, y1, t1);
            const p2 = this.quadraticBezier(x0, y0, cx, cy, x1, y1, t2);

            result.push({ x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y });
        }
        return result;
    }

    /*
     * Approximate cubic bezier curve with line segments
     */
    approximateBezier(x0, y0, cx1, cy1, cx2, cy2, x1, y1, segments) {
        const result = [];
        for (let i = 0; i < segments; i++) {
            const t1 = i / segments;
            const t2 = (i + 1) / segments;

            const p1 = this.cubicBezier(x0, y0, cx1, cy1, cx2, cy2, x1, y1, t1);
            const p2 = this.cubicBezier(x0, y0, cx1, cy1, cx2, cy2, x1, y1, t2);

            result.push({ x1: p1.x, y1: p1.y, x2: p2.x, y2: p2.y });
        }
        return result;
    }

    /*
     * Approximate arc with line segments
     */
    approximateArc(cx, cy, radius, startAngle, endAngle, counterclockwise, segments) {
        const result = [];

        let totalAngle = endAngle - startAngle;
        if (counterclockwise) {
            if (totalAngle > 0) totalAngle -= 2 * Math.PI;
        } else {
            if (totalAngle < 0) totalAngle += 2 * Math.PI;
        }

        const angleStep = totalAngle / segments;

        for (let i = 0; i < segments; i++) {
            const angle1 = startAngle + angleStep * i;
            const angle2 = startAngle + angleStep * (i + 1);

            const x1 = cx + Math.cos(angle1) * radius;
            const y1 = cy + Math.sin(angle1) * radius;
            const x2 = cx + Math.cos(angle2) * radius;
            const y2 = cy + Math.sin(angle2) * radius;

            result.push({ x1, y1, x2, y2 });
        }

        return result;
    }

    /*
     * Calculate point on quadratic bezier curve
     */
    quadraticBezier(x0, y0, cx, cy, x1, y1, t) {
        const u = 1 - t;
        const x = u * u * x0 + 2 * u * t * cx + t * t * x1;
        const y = u * u * y0 + 2 * u * t * cy + t * t * y1;
        return { x, y };
    }

    /*
     * Calculate point on cubic bezier curve
     */
    cubicBezier(x0, y0, cx1, cy1, cx2, cy2, x1, y1, t) {
        const u = 1 - t;
        const x = u * u * u * x0 + 3 * u * u * t * cx1 + 3 * u * t * t * cx2 + t * t * t * x1;
        const y = u * u * u * y0 + 3 * u * u * t * cy1 + 3 * u * t * t * cy2 + t * t * t * y1;
        return { x, y };
    }

    /*
     * Fill text (basic implementation)
     * @param {string} text - Text to draw
     * @param {number} x - X coordinate
     * @param {number} y - Y coordinate
     * @param {number} maxWidth - Maximum width (optional)
     */
    fillText(text, x, y, maxWidth) {
        this.renderText(text, x, y, maxWidth, true);
    }

    /*
     * Stroke text (basic implementation)
     * @param {string} text - Text to draw
     * @param {number} x - X coordinate
     * @param {number} y - Y coordinate
     * @param {number} maxWidth - Maximum width (optional)
     */
    strokeText(text, x, y, maxWidth) {
        this.renderText(text, x, y, maxWidth, false);
    }

    /*
    * Create or get cached font canvas for text rendering
    */
    getFontCanvas(font) {
        if (!this.fontCanvas) {
            this.fontCanvas = document.createElement('canvas');
            this.fontCtx = this.fontCanvas.getContext('2d');
        }

        // Set font on the 2D context
        this.fontCtx.font = font;
        return { canvas: this.fontCanvas, ctx: this.fontCtx };
    }

    /*
 * Render text to texture and draw
 */
    renderText(text, x, y, maxWidth, fill = true) {
        const { canvas, ctx } = this.getFontCanvas(this.state.font);

        // Measure text
        const metrics = ctx.measureText(text);
        let textWidth = metrics.width;

        // Handle max width
        if (maxWidth && textWidth > maxWidth) {
            const scale = maxWidth / textWidth;
            textWidth = maxWidth;
        }

        const textHeight = Math.abs(metrics.actualBoundingBoxAscent) + Math.abs(metrics.actualBoundingBoxDescent);

        // Resize canvas to fit text with some padding
        const padding = 4;
        canvas.width = Math.ceil(textWidth) + padding * 2;
        canvas.height = Math.ceil(textHeight) + padding * 2;

        // Reset context after resize
        ctx.font = this.state.font;
        ctx.textAlign = this.state.textAlign;
        ctx.textBaseline = this.state.textBaseline;

        // Set up rendering
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (fill) {
            const color = this.state.fillStyle;
            ctx.fillStyle = `rgba(${Math.floor(color[0] * 255)}, ${Math.floor(color[1] * 255)}, ${Math.floor(color[2] * 255)}, ${color[3] * this.state.globalAlpha})`;
            ctx.fillText(text, padding, padding + Math.abs(metrics.actualBoundingBoxAscent));
        } else {
            const color = this.state.strokeStyle;
            ctx.strokeStyle = `rgba(${Math.floor(color[0] * 255)}, ${Math.floor(color[1] * 255)}, ${Math.floor(color[2] * 255)}, ${color[3] * this.state.globalAlpha})`;
            ctx.lineWidth = this.state.lineWidth;
            ctx.strokeText(text, padding, padding + Math.abs(metrics.actualBoundingBoxAscent));
        }

        // Calculate final position based on text alignment
        let finalX = x;
        let finalY = y;

        // Adjust for text alignment
        switch (this.state.textAlign) {
            case 'center':
                finalX -= textWidth / 2;
                break;
            case 'right':
            case 'end':
                finalX -= textWidth;
                break;
        }

        // Adjust for text baseline
        switch (this.state.textBaseline) {
            case 'top':
                finalY -= Math.abs(metrics.actualBoundingBoxAscent);
                break;
            case 'middle':
                finalY -= textHeight / 2;
                break;
            case 'bottom':
                finalY += Math.abs(metrics.actualBoundingBoxDescent);
                break;
        }

        // Draw the text canvas as an image
        this.drawImage(canvas, finalX - padding, finalY - padding);
    }

    /*
     * Measure text width
     * @param {string} text - Text to measure
     * @return {object} - Text metrics
     */
    measureText(text) {
        const { ctx } = this.getFontCanvas(this.state.font);
        ctx.font = this.state.font;
        ctx.textAlign = this.state.textAlign;
        ctx.textBaseline = this.state.textBaseline;
        return ctx.measureText(text);
    }

    /*
     * Create linear gradient with addColorStop method
     * @param {number} x0 - Start x
     * @param {number} y0 - Start y
     * @param {number} x1 - End x
     * @param {number} y1 - End y
     * @return {object} - Gradient object with addColorStop method
     */
    createLinearGradient(x0, y0, x1, y1) {
        const gradient = {
            type: 'linear',
            x0, y0, x1, y1,
            colorStops: []
        };

        // Add addColorStop method to the gradient object
        gradient.addColorStop = (offset, color) => {
            gradient.colorStops.push({
                offset: Math.max(0, Math.min(1, offset)),
                color: this.parseColor(color)
            });
            // Sort by offset
            gradient.colorStops.sort((a, b) => a.offset - b.offset);
        };

        return gradient;
    }

    /*
     * Create radial gradient with addColorStop method
     * @param {number} x0 - Start center x
     * @param {number} y0 - Start center y
     * @param {number} r0 - Start radius
     * @param {number} x1 - End center x
     * @param {number} y1 - End center y
     * @param {number} r1 - End radius
     * @return {object} - Gradient object with addColorStop method
     */
    createRadialGradient(x0, y0, r0, x1, y1, r1) {
        const gradient = {
            type: 'radial',
            x0, y0, r0, x1, y1, r1,
            colorStops: []
        };

        // Add addColorStop method to the gradient object
        gradient.addColorStop = (offset, color) => {
            gradient.colorStops.push({
                offset: Math.max(0, Math.min(1, offset)),
                color: this.parseColor(color)
            });
            // Sort by offset
            gradient.colorStops.sort((a, b) => a.offset - b.offset);
        };

        return gradient;
    }

    /*
     * Create conic gradient with addColorStop method
     * @param {number} startAngle - Start angle in radians
     * @param {number} x - Center x
     * @param {number} y - Center y
     * @return {object} - Gradient object with addColorStop method
     */
    createConicGradient(startAngle, x, y) {
        const gradient = {
            type: 'conic',
            startAngle, x, y,
            colorStops: []
        };

        // Add addColorStop method to the gradient object
        gradient.addColorStop = (offset, color) => {
            gradient.colorStops.push({
                offset: Math.max(0, Math.min(1, offset)),
                color: this.parseColor(color)
            });
            // Sort by offset
            gradient.colorStops.sort((a, b) => a.offset - b.offset);
        };

        return gradient;
    }

    /*
     * Create pattern
     * @param {HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} image - Image for pattern
     * @param {string} repetition - 'repeat', 'repeat-x', 'repeat-y', 'no-repeat'
     * @return {object} - Pattern object
     */
    createPattern(image, repetition) {
        return {
            type: 'pattern',
            image,
            repetition
        };
    }

    /*
 * Check if point is inside path
 * @param {number} x - X coordinate of the point
 * @param {number} y - Y coordinate of the point
 * @param {string} fillRule - Fill rule ('nonzero' or 'evenodd')
 * @return {boolean} - True if point is inside path, false otherwise
 */
    isPointInPath(x, y, fillRule = 'nonzero') {
        if (this.currentPath.length === 0) return false;

        // Convert path to polygons
        const polygons = this.pathToPolygons(this.currentPath);

        // Transform the test point using inverse of current transform
        const [testX, testY] = this.inverseTransformPoint(x, y);

        // Test against each polygon
        for (const polygon of polygons) {
            if (polygon.length < 3) continue;

            if (fillRule === 'evenodd') {
                if (this.pointInPolygonEvenOdd(testX, testY, polygon)) {
                    return true;
                }
            } else {
                if (this.pointInPolygonNonZero(testX, testY, polygon)) {
                    return true;
                }
            }
        }

        return false;
    }

    /*
     * Check if point is inside stroke
     * @param {number} x - X coordinate of the point
     * @param {number} y - Y coordinate of the point
     * @return {boolean} - True if point is inside stroke, false otherwise
     */
    isPointInStroke(x, y) {
        if (this.currentPath.length === 0) return false;

        // Transform the test point using inverse of current transform
        const [testX, testY] = this.inverseTransformPoint(x, y);

        // Convert path to line segments
        const segments = this.pathToSegments(this.currentPath);
        const lineWidth = this.state.lineWidth;
        const halfWidth = lineWidth / 2;

        // Test against each line segment
        for (const segment of segments) {
            if (this.pointNearLineSegment(testX, testY, segment.x1, segment.y1, segment.x2, segment.y2, halfWidth)) {
                return true;
            }
        }

        return false;
    }

    /*
     * Transform point using inverse of current transformation matrix
     * @param {number} x - X coordinate
     * @param {number} y - Y coordinate
     * @return {Array} - Transformed coordinates
     */
    inverseTransformPoint(x, y) {
        const m = this.state.transform;

        // Calculate determinant
        const det = m[0] * m[4] - m[1] * m[3];

        if (Math.abs(det) < 1e-10) {
            // Matrix is singular, return original point
            return [x, y];
        }

        // Calculate inverse matrix elements
        const invDet = 1 / det;
        const a = m[4] * invDet;
        const b = -m[1] * invDet;
        const c = -m[3] * invDet;
        const d = m[0] * invDet;
        const e = (m[3] * m[5] - m[4] * m[2]) * invDet;
        const f = (m[1] * m[2] - m[0] * m[5]) * invDet;

        // Apply inverse transformation
        return [
            a * x + c * y + e,
            b * x + d * y + f
        ];
    }

    /*
     * Point-in-polygon test using even-odd rule
     * @param {number} x - Test point X
     * @param {number} y - Test point Y
     * @param {Array} polygon - Array of {x, y} points
     * @return {boolean} - True if point is inside polygon
     */
    pointInPolygonEvenOdd(x, y, polygon) {
        let inside = false;
        const n = polygon.length;

        for (let i = 0, j = n - 1; i < n; j = i++) {
            const xi = polygon[i].x;
            const yi = polygon[i].y;
            const xj = polygon[j].x;
            const yj = polygon[j].y;

            if (((yi > y) !== (yj > y)) &&
                (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                inside = !inside;
            }
        }

        return inside;
    }

    /*
     * Point-in-polygon test using non-zero winding rule
     * @param {number} x - Test point X
     * @param {number} y - Test point Y
     * @param {Array} polygon - Array of {x, y} points
     * @return {boolean} - True if point is inside polygon
     */
    pointInPolygonNonZero(x, y, polygon) {
        let winding = 0;
        const n = polygon.length;

        for (let i = 0; i < n; i++) {
            const j = (i + 1) % n;
            const xi = polygon[i].x;
            const yi = polygon[i].y;
            const xj = polygon[j].x;
            const yj = polygon[j].y;

            if (yi <= y) {
                if (yj > y) { // Upward crossing
                    if (this.isLeft(xi, yi, xj, yj, x, y) > 0) {
                        winding++;
                    }
                }
            } else {
                if (yj <= y) { // Downward crossing
                    if (this.isLeft(xi, yi, xj, yj, x, y) < 0) {
                        winding--;
                    }
                }
            }
        }

        return winding !== 0;
    }

    /*
     * Test if point is left of line segment
     * @param {number} x1 - Line start X
     * @param {number} y1 - Line start Y
     * @param {number} x2 - Line end X
     * @param {number} y2 - Line end Y
     * @param {number} px - Point X
     * @param {number} py - Point Y
     * @return {number} - Positive if left, negative if right, 0 if on line
     */
    isLeft(x1, y1, x2, y2, px, py) {
        return (x2 - x1) * (py - y1) - (px - x1) * (y2 - y1);
    }

    /*
     * Test if point is near a line segment (for stroke testing)
     * @param {number} px - Point X
     * @param {number} py - Point Y
     * @param {number} x1 - Line start X
     * @param {number} y1 - Line start Y
     * @param {number} x2 - Line end X
     * @param {number} y2 - Line end Y
     * @param {number} tolerance - Distance tolerance
     * @return {boolean} - True if point is within tolerance of line segment
     */
    pointNearLineSegment(px, py, x1, y1, x2, y2, tolerance) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const length = Math.sqrt(dx * dx + dy * dy);

        if (length === 0) {
            // Line segment is a point
            const dist = Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));
            return dist <= tolerance;
        }

        // Calculate the closest point on the line segment
        const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / (length * length)));
        const closestX = x1 + t * dx;
        const closestY = y1 + t * dy;

        // Calculate distance from point to closest point on segment
        const distance = Math.sqrt((px - closestX) * (px - closestX) + (py - closestY) * (py - closestY));

        return distance <= tolerance;
    }

    /*
     * Enhanced path to segments conversion that handles curves properly
     * @param {Array} path - Path commands
     * @return {Array} - Array of line segments with curve approximations
     */
    pathToSegmentsEnhanced(path) {
        const segments = [];
        let currentX = 0, currentY = 0;
        let startX = 0, startY = 0;

        for (const command of path) {
            switch (command.type) {
                case 'moveTo':
                    currentX = command.x;
                    currentY = command.y;
                    startX = command.x;
                    startY = command.y;
                    break;

                case 'lineTo':
                    segments.push({
                        x1: currentX, y1: currentY,
                        x2: command.x, y2: command.y,
                        type: 'line'
                    });
                    currentX = command.x;
                    currentY = command.y;
                    break;

                case 'quadraticCurveTo':
                    // Approximate curve with multiple line segments for better accuracy
                    const quadSegments = this.approximateQuadraticForTesting(
                        currentX, currentY,
                        command.cpx, command.cpy,
                        command.x, command.y,
                        20 // More segments for better accuracy
                    );
                    segments.push(...quadSegments);
                    currentX = command.x;
                    currentY = command.y;
                    break;

                case 'bezierCurveTo':
                    // Approximate curve with multiple line segments for better accuracy
                    const bezierSegments = this.approximateBezierForTesting(
                        currentX, currentY,
                        command.cp1x, command.cp1y,
                        command.cp2x, command.cp2y,
                        command.x, command.y,
                        20 // More segments for better accuracy
                    );
                    segments.push(...bezierSegments);
                    currentX = command.x;
                    currentY = command.y;
                    break;

                case 'arc':
                    const arcSegments = this.approximateArcForTesting(
                        command.x, command.y,
                        command.radius,
                        command.startAngle,
                        command.endAngle,
                        command.counterclockwise,
                        30 // More segments for circles
                    );
                    if (arcSegments.length > 0) {
                        // Connect to start of arc if needed
                        const firstPoint = arcSegments[0];
                        if (Math.abs(currentX - firstPoint.x1) > 0.001 || Math.abs(currentY - firstPoint.y1) > 0.001) {
                            segments.push({
                                x1: currentX, y1: currentY,
                                x2: firstPoint.x1, y2: firstPoint.y1,
                                type: 'line'
                            });
                        }
                        segments.push(...arcSegments);
                        const lastPoint = arcSegments[arcSegments.length - 1];
                        currentX = lastPoint.x2;
                        currentY = lastPoint.y2;
                    }
                    break;

                case 'close':
                    if (Math.abs(currentX - startX) > 0.001 || Math.abs(currentY - startY) > 0.001) {
                        segments.push({
                            x1: currentX, y1: currentY,
                            x2: startX, y2: startY,
                            type: 'line'
                        });
                    }
                    currentX = startX;
                    currentY = startY;
                    break;
            }
        }

        return segments;
    }

    /*
     * Approximate quadratic curve for testing (higher precision)
     */
    approximateQuadraticForTesting(x0, y0, cx, cy, x1, y1, segments) {
        const result = [];
        for (let i = 0; i < segments; i++) {
            const t1 = i / segments;
            const t2 = (i + 1) / segments;

            const p1 = this.quadraticBezier(x0, y0, cx, cy, x1, y1, t1);
            const p2 = this.quadraticBezier(x0, y0, cx, cy, x1, y1, t2);

            result.push({
                x1: p1.x, y1: p1.y,
                x2: p2.x, y2: p2.y,
                type: 'curve'
            });
        }
        return result;
    }

    /*
     * Approximate cubic bezier curve for testing (higher precision)
     */
    approximateBezierForTesting(x0, y0, cx1, cy1, cx2, cy2, x1, y1, segments) {
        const result = [];
        for (let i = 0; i < segments; i++) {
            const t1 = i / segments;
            const t2 = (i + 1) / segments;

            const p1 = this.cubicBezier(x0, y0, cx1, cy1, cx2, cy2, x1, y1, t1);
            const p2 = this.cubicBezier(x0, y0, cx1, cy1, cx2, cy2, x1, y1, t2);

            result.push({
                x1: p1.x, y1: p1.y,
                x2: p2.x, y2: p2.y,
                type: 'curve'
            });
        }
        return result;
    }

    /*
     * Approximate arc for testing (higher precision)
     */
    approximateArcForTesting(cx, cy, radius, startAngle, endAngle, counterclockwise, segments) {
        const result = [];

        let totalAngle = endAngle - startAngle;
        if (counterclockwise) {
            if (totalAngle > 0) totalAngle -= 2 * Math.PI;
        } else {
            if (totalAngle < 0) totalAngle += 2 * Math.PI;
        }

        const angleStep = totalAngle / segments;

        for (let i = 0; i < segments; i++) {
            const angle1 = startAngle + angleStep * i;
            const angle2 = startAngle + angleStep * (i + 1);

            const x1 = cx + Math.cos(angle1) * radius;
            const y1 = cy + Math.sin(angle1) * radius;
            const x2 = cx + Math.cos(angle2) * radius;
            const y2 = cy + Math.sin(angle2) * radius;

            result.push({
                x1, y1, x2, y2,
                type: 'arc'
            });
        }

        return result;
    }

    /*
     * Put image data
     * @param {ImageData} imageData - Image data to put
     * @param {number} dx - Destination x
     * @param {number} dy - Destination y
     */
    putImageData(imageData, dx, dy, dirtyX = 0, dirtyY = 0, dirtyWidth, dirtyHeight) {
        // Handle dirty rectangle parameters
        dirtyWidth = dirtyWidth || imageData.width;
        dirtyHeight = dirtyHeight || imageData.height;

        // Create temporary canvas with just the dirty region
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = dirtyWidth;
        tempCanvas.height = dirtyHeight;
        const tempCtx = tempCanvas.getContext('2d');

        // Create ImageData for dirty region
        const dirtyImageData = tempCtx.createImageData(dirtyWidth, dirtyHeight);

        // Copy dirty region data
        for (let y = 0; y < dirtyHeight; y++) {
            for (let x = 0; x < dirtyWidth; x++) {
                const srcIdx = ((dirtyY + y) * imageData.width + (dirtyX + x)) * 4;
                const dstIdx = (y * dirtyWidth + x) * 4;

                dirtyImageData.data[dstIdx] = imageData.data[srcIdx];
                dirtyImageData.data[dstIdx + 1] = imageData.data[srcIdx + 1];
                dirtyImageData.data[dstIdx + 2] = imageData.data[srcIdx + 2];
                dirtyImageData.data[dstIdx + 3] = imageData.data[srcIdx + 3];
            }
        }

        tempCtx.putImageData(dirtyImageData, 0, 0);
        this.drawImage(tempCanvas, dx + dirtyX, dy + dirtyY);
    }

    /*
    * Get image data from the WebGL framebuffer
    * Reads pixel data from the specified region of the canvas
    * @param {number} sx - Source x coordinate (top-left origin)
    * @param {number} sy - Source y coordinate (top-left origin)
    * @param {number} sw - Source width
    * @param {number} sh - Source height
    * @return {ImageData} - ImageData object containing RGBA pixel data
    */
    getImageData(sx, sy, sw, sh) {
        if (!this.gl) {
            throw new Error('WebGL context not available');
        }

        // Ensure all pending draws are flushed to the framebuffer
        this.flush();

        // Clamp coordinates to canvas bounds
        sx = Math.max(0, Math.min(sx, this.width));
        sy = Math.max(0, Math.min(sy, this.height));
        sw = Math.max(0, Math.min(sw, this.width - sx));
        sh = Math.max(0, Math.min(sh, this.height - sy));

        if (sw === 0 || sh === 0) {
            return new ImageData(0, 0);
        }

        // WebGL uses bottom-left origin, so flip Y
        const glY = this.height - sy - sh;

        // Create array to hold pixel data (RGBA)
        const pixels = new Uint8Array(sw * sh * 4);

        // Bind the default framebuffer (0)
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);

        // Read pixels from the framebuffer
        this.gl.readPixels(sx, glY, sw, sh, this.gl.RGBA, this.gl.UNSIGNED_BYTE, pixels);

        // Create ImageData (this handles the RGBA format)
        const imageData = new ImageData(new Uint8ClampedArray(pixels), sw, sh);

        // Check for WebGL errors
        this.checkGLError('getImageData');

        return imageData;
    }

    /*
 * Get the entire canvas as a data URL (e.g., for saving or displaying)
 * @param {string} type - MIME type (default: 'image/png')
 * @param {number} quality - Quality for JPEG (0-1, ignored for PNG)
 * @return {string} - Data URL string
 */
    toDataURL(type = 'image/png', quality = 1.0) {
        // Get the full canvas image data
        const imageData = this.getImageData(0, 0, this.width, this.height);

        // Create a temporary 2D canvas to convert ImageData to data URL
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = this.width;
        tempCanvas.height = this.height;
        const tempCtx = tempCanvas.getContext('2d');

        // Put the image data onto the temp canvas
        tempCtx.putImageData(imageData, 0, 0);

        // Get the data URL
        return tempCanvas.toDataURL(type, quality);
    }

    /*
     * Get the entire canvas as a blob (e.g., for downloading or uploading)
     * @param {string} type - MIME type (default: 'image/png')
     * @param {number} quality - Quality for JPEG (0-1, ignored for PNG)
     * @return {Promise<Blob>} - Promise resolving to a Blob
     */
    toBlob(type = 'image/png', quality = 1.0) {
        return new Promise((resolve, reject) => {
            // Get the full canvas image data
            const imageData = this.getImageData(0, 0, this.width, this.height);

            // Create a temporary 2D canvas
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = this.width;
            tempCanvas.height = this.height;
            const tempCtx = tempCanvas.getContext('2d');

            // Put the image data onto the temp canvas
            tempCtx.putImageData(imageData, 0, 0);

            // Convert to blob
            tempCanvas.toBlob(resolve, type, quality);
        });
    }

    /*
     * Create image data
     * @param {number} width - Width
     * @param {number} height - Height
     * @return {ImageData} - New image data
     */
    createImageData(width, height) {
        return new ImageData(width, height);
    }

    /*
    * Set transform matrix directly
    * @param {number} a - Horizontal scaling
    * @param {number} b - Horizontal skewing
    * @param {number} c - Vertical skewing
    * @param {number} d - Vertical scaling
    * @param {number} e - Horizontal translation
    * @param {number} f - Vertical translation
    */
    setTransform(a, b, c, d, e, f) {
        this.state.transform = [
            a, c, e,
            b, d, f,
            0, 0, 1
        ];
    }

    /*
     * Get current transform matrix
     * @return {DOMMatrix} - Current transformation matrix as DOMMatrix
     */
    getTransform() {
        const m = this.state.transform;
        // Convert from 3x3 matrix to DOMMatrix (2D transform)
        return new DOMMatrix([
            m[0], m[3], m[1], m[4], m[2], m[5]
        ]);
    }

    /*
     * Set transform from DOMMatrix
     * @param {DOMMatrix} matrix - Transform matrix to set
     */
    setTransformMatrix(matrix) {
        this.state.transform = [
            matrix.a, matrix.c, matrix.e,
            matrix.b, matrix.d, matrix.f,
            0, 0, 1
        ];
    }

    /*
     * Get current transform as array (a, b, c, d, e, f)
     * @return {Array} - Transform values [a, b, c, d, e, f]
     */
    getTransformArray() {
        const m = this.state.transform;
        return [m[0], m[3], m[1], m[4], m[2], m[5]];
    }

    /*
     * Create identity matrix
     * @return {DOMMatrix} - Identity transform matrix
     */
    createIdentityTransform() {
        return new DOMMatrix();
    }

    /*
    * Transform matrix multiplication
    * @param {number} a - Horizontal scaling
    * @param {number} b - Horizontal skewing
    * @param {number} c - Vertical skewing
    * @param {number} d - Vertical scaling
    * @param {number} e - Horizontal translation
    * @param {number} f - Vertical translation
    */
    transform(a, b, c, d, e, f) {
        const transformMatrix = [
            a, c, e,
            b, d, f,
            0, 0, 1
        ];
        this.state.transform = this.multiplyMatrix(this.state.transform, transformMatrix);
    }

    /*
    * Reset transform to identity matrix
    */
    resetTransform() {
        this.state.transform = this.createIdentityMatrix();
    }

    /*
        * Translate the canvas
        * Applies a translation transformation to the current state
        * @param {number} x - X translation
        * @param {number} y - Y translation
    */
    translate(x, y) {
        const translateMatrix = [
            1, 0, x,
            0, 1, y,
            0, 0, 1
        ];
        this.state.transform = this.multiplyMatrix(this.state.transform, translateMatrix);
    }

    /*
        * Rotate the canvas
        * Applies a rotation transformation to the current state
        * @param {number} angle - Rotation angle in radians
    */
    rotate(angle) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const rotateMatrix = [
            cos, -sin, 0,
            sin, cos, 0,
            0, 0, 1
        ];
        this.state.transform = this.multiplyMatrix(this.state.transform, rotateMatrix);
    }

    /*
        * Scale the canvas
        * Applies a scaling transformation to the current state
        * @param {number} x - X scale factor
        * @param {number} y - Y scale factor (optional, defaults to x)
    */
    scale(x, y = x) {
        const scaleMatrix = [
            x, 0, 0,
            0, y, 0,
            0, 0, 1
        ];
        this.state.transform = this.multiplyMatrix(this.state.transform, scaleMatrix);
    }

    /*
    * Create clipping region from current path
    */
    clip() {
        // For now, store the current path as a clipping region
        // Full implementation would require stencil buffer or scissor test
        if (this.currentPath.length > 0) {
            this.state.clipPath = [...this.currentPath];
            // console.warn('clip() is partially implemented - full clipping requires stencil buffer');
        }
    }

    /*
    * Clear the current clipping region
    */
    resetClip() {
        this.state.clipPath = null;
    }

    /*
        * Add a custom shader program
        * Allows users to define their own shaders for advanced effects
        * @param {string} name - Name of the shader
        * @param {string} vertexShaderSource - GLSL source code for the vertex shader
        * @param {string} fragmentShaderSource - GLSL source code for the fragment shader
    */
    addShader(name, vertexShaderSource, fragmentShaderSource) {
        try {
            const program = this.createShaderProgram(vertexShaderSource, fragmentShaderSource);

            // Cache attribute and uniform locations for better performance
            const attributes = {};
            const uniforms = {};

            // Get all active attributes
            const numAttributes = this.gl.getProgramParameter(program, this.gl.ACTIVE_ATTRIBUTES);
            for (let i = 0; i < numAttributes; i++) {
                const info = this.gl.getActiveAttrib(program, i);
                if (info) {
                    const location = this.gl.getAttribLocation(program, info.name);
                    attributes[info.name] = location;
                }
            }

            // Get all active uniforms
            const numUniforms = this.gl.getProgramParameter(program, this.gl.ACTIVE_UNIFORMS);
            for (let i = 0; i < numUniforms; i++) {
                const info = this.gl.getActiveUniform(program, i);
                if (info) {
                    const location = this.gl.getUniformLocation(program, info.name);
                    uniforms[info.name] = location;
                }
            }

            this.shaders[name] = program;
            this.shaders[name].attributes = attributes;
            this.shaders[name].uniforms = uniforms;
            this.shaders[name].name = name; // Add name for debugging

            return program;
        } catch (error) {
            // console.error(`Failed to create shader "${name}":`, error);
            throw error;
        }
    }

    /*
        * Use a custom shader program
        * Sets the current shader program to the specified one
        * @param {string} name - Name of the shader to use
        * @return {WebGLProgram} - The shader program being used
    */
    useShader(name) {
        if (this.shaders[name]) {
            const program = this.shaders[name];
            this.gl.useProgram(program);
            this.currentShader = program; // Keep track of current shader
            return program;
        }
        throw new Error(`Shader "${name}" not found. Available shaders: ${Object.keys(this.shaders).join(', ')}`);
    }

    /*
 * Enhanced drawWithShader with context loss protection
 */
    drawWithShader(shaderName, vertices, indices = null, uniforms = {}, attributes = {}) {
        if (this.isContextLost()) {
            // console.warn('Skipping drawWithShader - WebGL context is lost');
            return;
        }

        try {
            const program = this.useShader(shaderName);
            const gl = this.gl;

            // Check if program is valid
            if (!program || !gl.isProgram(program)) {
                // console.error(`Invalid shader program: ${shaderName}`);
                return;
            }

            // Create vertex buffer if needed
            if (!this.customVertexBuffer) {
                this.customVertexBuffer = gl.createBuffer();
            }

            // Upload vertex data
            gl.bindBuffer(gl.ARRAY_BUFFER, this.customVertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.DYNAMIC_DRAW);

            // Set up position attribute (assuming it exists)
            if (program.attributes && program.attributes['a_position'] !== undefined) {
                gl.enableVertexAttribArray(program.attributes['a_position']);
                gl.vertexAttribPointer(program.attributes['a_position'], 2, gl.FLOAT, false, 0, 0);
            }

            // Set additional attributes
            Object.keys(attributes).forEach(name => {
                const location = program.attributes && program.attributes[name];
                if (location !== undefined && location >= 0) {
                    const data = attributes[name];
                    // Create buffer for this attribute
                    const buffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                    gl.bufferData(gl.ARRAY_BUFFER, data.data, gl.DYNAMIC_DRAW);

                    gl.enableVertexAttribArray(location);
                    gl.vertexAttribPointer(location, data.size, data.type || gl.FLOAT, false, 0, 0);
                }
            });

            // Set uniforms
            Object.keys(uniforms).forEach(name => {
                const location = program.uniforms && program.uniforms[name];
                if (location !== null && location !== undefined) {
                    const value = uniforms[name];
                    if (Array.isArray(value)) {
                        switch (value.length) {
                            case 1: gl.uniform1f(location, value[0]); break;
                            case 2: gl.uniform2f(location, value[0], value[1]); break;
                            case 3: gl.uniform3f(location, value[0], value[1], value[2]); break;
                            case 4: gl.uniform4f(location, value[0], value[1], value[2], value[3]); break;
                            default: // console.warn(`Unsupported uniform array length for ${name}`);
                        }
                    } else if (typeof value === 'number') {
                        gl.uniform1f(location, value);
                    } else {
                        // console.warn(`Unsupported uniform type for ${name}:`, typeof value);
                    }
                }
            });

            // Set common uniforms if they exist
            if (program.uniforms && program.uniforms['u_resolution']) {
                gl.uniform2f(program.uniforms['u_resolution'], this.width, this.height);
            }
            if (program.uniforms && program.uniforms['u_globalAlpha']) {
                gl.uniform1f(program.uniforms['u_globalAlpha'], this.state.globalAlpha);
            }

            // Draw
            if (indices) {
                // Create index buffer if needed
                if (!this.customIndexBuffer) {
                    this.customIndexBuffer = gl.createBuffer();
                }
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.customIndexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.DYNAMIC_DRAW);
                gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
            } else {
                gl.drawArrays(gl.TRIANGLES, 0, vertices.length / 2);
            }

            // Check for errors after drawing
            this.checkGLError(`drawWithShader(${shaderName})`);

        } catch (e) {
            // console.error(`Error in drawWithShader(${shaderName}):`, e);
            if (this.gl && this.gl.isContextLost()) {
                // console.warn('Context lost during drawWithShader');
                this.contextLost = true;
            }
        }
    }

    /*
    * Helper method to create a simple quad for shader testing
    * @param {number} x - X position
    * @param {number} y - Y position
    * @param {number} width - Width
    * @param {number} height - Height
    * @return {Object} - Vertices and indices for a quad
    */
    createQuad(x, y, width, height) {
        const vertices = new Float32Array([
            x, y,                    // Bottom-left
            x + width, y,            // Bottom-right
            x, y + height,           // Top-left
            x + width, y + height    // Top-right
        ]);

        const indices = new Uint16Array([
            0, 1, 2,    // First triangle
            1, 2, 3     // Second triangle
        ]);

        return { vertices, indices };
    }

    /*
     * List all available shaders
     * @return {Array} - Array of shader names
     */
    listShaders() {
        return Object.keys(this.shaders);
    }

    /*
    * Get shader info for debugging
    * @param {string} name - Shader name
    * @return {Object} - Shader information
    */
    getShaderInfo(name) {
        const program = this.shaders[name];
        if (!program) return null;

        return {
            name: name,
            attributes: Object.keys(program.attributes || {}),
            uniforms: Object.keys(program.uniforms || {}),
            program: program
        };
    }

    /*
    * Begin batch mode - call this before drawing many objects
    */
    beginBatch() {
        // This is just for semantic clarity - batching is always active
    }

    /*
    * End batch mode and flush everything
    */
    endBatch() {
        this.flush();
    }

    /*
    * Set a higher batch size for better performance
    */
    setBatchSize(size) {
        // Limit batch size to prevent memory issues that could cause context loss
        const maxSafeSize = 8000; // Reduced from potentially 10000+
        this.options.batchSize = Math.min(size, maxSafeSize);

        // console.log(`Batch size set to ${this.options.batchSize}`);

        // Recreate buffers with new size if WebGL is available
        if (this.gl && !this.isContextLost()) {
            this.safeWebGLOperation(() => {
                this.createBatchBuffers();
            }, 'batch buffer recreation');
        }
    }

    /*
    * Auto-adjust batch size based on performance
    */
    autoAdjustBatchSize() {
        if (this.contextLossCount > 2) {
            // If we've had multiple context losses, reduce batch size
            const newSize = Math.max(1000, this.options.batchSize * 0.7);
            // console.warn(`Reducing batch size to ${newSize} due to context instability`);
            this.setBatchSize(newSize);
        }
    }

    /*
    * Enhanced error checking with context loss detection
    */
    checkGLError(operation) {
        if (!this.gl || this.contextLost) return true;

        try {
            // First check if context is lost before calling getError
            if (this.gl.isContextLost()) {
                this.contextLost = true;
                this.clearResourcesOnContextLoss();
                return false;
            }

            const error = this.gl.getError();
            if (error !== this.gl.NO_ERROR) {
                let errorName = 'UNKNOWN_ERROR';
                switch (error) {
                    case this.gl.INVALID_ENUM: errorName = 'INVALID_ENUM'; break;
                    case this.gl.INVALID_VALUE: errorName = 'INVALID_VALUE'; break;
                    case this.gl.INVALID_OPERATION: errorName = 'INVALID_OPERATION'; break;
                    case this.gl.INVALID_FRAMEBUFFER_OPERATION: errorName = 'INVALID_FRAMEBUFFER_OPERATION'; break;
                    case this.gl.OUT_OF_MEMORY:
                        errorName = 'OUT_OF_MEMORY';
                        // OUT_OF_MEMORY can lead to context loss, so prepare for it
                        // console.warn('WebGL OUT_OF_MEMORY error - context loss may follow');
                        break;
                    case this.gl.CONTEXT_LOST_WEBGL:
                        errorName = 'CONTEXT_LOST_WEBGL';
                        this.contextLost = true;
                        this.clearResourcesOnContextLoss();
                        // console.error('WebGL context lost detected in checkGLError');
                        break;
                }

                // console.error(`WebGL error after ${operation}: ${errorName} (${error})`);
                return false;
            }
            return true;
        } catch (e) {
            // If getError itself throws, context is likely lost
            // console.warn('Error checking WebGL error state - context may be lost:', e);
            this.contextLost = true;
            this.clearResourcesOnContextLoss();
            return false;
        }
    }

    /*
     * Method to manually trigger context restore for testing
     */
    forceContextLoss() {
        if (this.loseContextExtension) {
            // console.log('Forcing context loss for testing...');
            this.loseContextExtension.loseContext();
        } else {
            // console.warn('WEBGL_lose_context extension not available');
        }
    }

    /*
     * Method to get context status
     */
    getContextStatus() {
        return {
            contextLost: this.contextLost,
            contextAvailable: !!this.gl,
            contextValid: this.gl && !this.gl.isContextLost(),
            contextLossCount: this.contextLossCount,
            disposing: this.disposing
        };
    }

    /**
     * Dispose of all WebGL resources and clean up
     * Call this when you're done with the canvas to prevent memory leaks
     */
    dispose() {
        // Stop animation loop
        this.stopAnimationLoop();

        // Clear frame timing
        this.frameTime = null;

        // Clean up post-processing resources
        if (this.gl && !this.isContextLost()) {
            try {
                // Delete framebuffers
                if (this.postProcessing.framebuffers) {
                    this.postProcessing.framebuffers.forEach(fb => {
                        if (this.gl.isFramebuffer(fb)) {
                            this.gl.deleteFramebuffer(fb);
                        }
                    });
                }

                // Delete temp textures
                if (this.postProcessing.tempTextures) {
                    this.postProcessing.tempTextures.forEach(tex => {
                        if (this.gl.isTexture(tex)) {
                            this.gl.deleteTexture(tex);
                        }
                    });
                }

                // Delete quad buffers
                if (this.postProcessing.quadBuffer && this.gl.isBuffer(this.postProcessing.quadBuffer)) {
                    this.gl.deleteBuffer(this.postProcessing.quadBuffer);
                }
                if (this.postProcessing.quadIndexBuffer && this.gl.isBuffer(this.postProcessing.quadIndexBuffer)) {
                    this.gl.deleteBuffer(this.postProcessing.quadIndexBuffer);
                }
            } catch (e) {
                // console.warn('Error during post-processing cleanup:', e);
            }
        }

        // Set flag to prevent further operations
        this.disposing = true;

        // Clear context monitoring
        if (this.contextHealthCheck) {
            clearInterval(this.contextHealthCheck);
            this.contextHealthCheck = null;
        }

        // Clear all timers
        this.clearAllTimers();

        // Cancel any running animation frames
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
            this.animationId = null;
        }

        // Only try to delete WebGL resources if context exists and is not lost
        if (this.gl && !this.isContextLost()) {
            try {
                // Flush any pending operations first
                this.flush();

                // Clean up batch buffers
                if (this.batchBuffers) {
                    Object.values(this.batchBuffers).forEach(batch => {
                        if (batch) {
                            if (batch.vertices && this.gl.isBuffer(batch.vertices)) this.gl.deleteBuffer(batch.vertices);
                            if (batch.colors && this.gl.isBuffer(batch.colors)) this.gl.deleteBuffer(batch.colors);
                            if (batch.indices && this.gl.isBuffer(batch.indices)) this.gl.deleteBuffer(batch.indices);
                            if (batch.centers && this.gl.isBuffer(batch.centers)) this.gl.deleteBuffer(batch.centers);
                            if (batch.radii && this.gl.isBuffer(batch.radii)) this.gl.deleteBuffer(batch.radii);
                            if (batch.texCoords && this.gl.isBuffer(batch.texCoords)) this.gl.deleteBuffer(batch.texCoords);
                        }
                    });
                }

                // Clean up custom buffers
                if (this.customVertexBuffer && this.gl.isBuffer(this.customVertexBuffer)) {
                    this.gl.deleteBuffer(this.customVertexBuffer);
                }
                if (this.customIndexBuffer && this.gl.isBuffer(this.customIndexBuffer)) {
                    this.gl.deleteBuffer(this.customIndexBuffer);
                }

                // Clean up shaders
                if (this.shaders) {
                    Object.values(this.shaders).forEach(shader => {
                        if (shader && this.gl.isProgram(shader)) {
                            this.gl.deleteProgram(shader);
                        }
                    });
                }

                // Clean up textures
                if (this.textureCache) {
                    this.textureCache.forEach((texture) => {
                        if (this.gl.isTexture(texture)) {
                            this.gl.deleteTexture(texture);
                        }
                    });
                }
            } catch (e) {
                // console.warn('Error during WebGL cleanup (context may be lost):', e);
            }
        }

        // Don't force context loss in dispose - let it happen naturally
        // Clear references
        this.gl = null;
        this.ctx = null;
        this.shaders = {};
        this.state = null;
        this.contextLost = false;
        this.disposing = false;

        // Clear other references...
        if (this.textureCache) this.textureCache.clear();
        if (this.fontCache) this.fontCache.clear();

        // console.log('WebGLCanvas disposed successfully');
    }

    /*
     * Add safeguard to all WebGL operations
     */
    safeWebGLOperation(operation, errorMessage = 'WebGL operation failed') {
        if (this.disposing) {
            return false;
        }

        if (this.isContextLost()) {
            //// console.warn(`Skipping ${errorMessage} - WebGL context is lost`);
            return false;
        }

        if (!this.gl) {
            //// console.warn(`Skipping ${errorMessage} - WebGL context not available`);
            return false;
        }

        try {
            // Check context health before operation
            if (this.gl.isContextLost()) {
                // console.warn(`Context lost before ${errorMessage}`);
                this.contextLost = true;
                this.clearResourcesOnContextLoss();
                return false;
            }

            const result = operation();

            // Check context health after operation (but be careful about getError)
            if (this.gl.isContextLost()) {
                // console.warn(`Context lost after ${errorMessage}`);
                this.contextLost = true;
                this.clearResourcesOnContextLoss();
                return false;
            } else {
                // Only check for errors if context is still valid
                this.checkGLError(errorMessage);
            }

            return result;
        } catch (e) {
            if (this.gl && this.gl.isContextLost()) {
                // console.warn(`Context lost during ${errorMessage}`);
                this.contextLost = true;
                this.clearResourcesOnContextLoss();
            } else {
                // console.error(`Error during ${errorMessage}:`, e);
            }
            return false;
        }
    }

    /*
        * Resize the canvas
        * Updates the canvas size and WebGL viewport
        * @param {number} width - New width of the canvas
        * @param {number} height - New height of the canvas
    */
    resize(width, height) {
        this.canvas.width = width;
        this.canvas.height = height;
        this.width = width;
        this.height = height;
        this.gl.viewport(0, 0, width, height);

        // Recreate post-processing framebuffers with new size
        if (this.postProcessing.enabled) {
            this.recreatePostProcessingFramebuffers();
        }
    }

    /*
     * Recreate framebuffers after resize
     */
    recreatePostProcessingFramebuffers() {
        const gl = this.gl;

        // Delete old framebuffers and textures
        this.postProcessing.framebuffers.forEach(fb => gl.deleteFramebuffer(fb));
        this.postProcessing.tempTextures.forEach(tex => gl.deleteTexture(tex));

        // Clear arrays
        this.postProcessing.framebuffers = [];
        this.postProcessing.tempTextures = [];

        // Recreate with new size
        this.createPostProcessingFramebuffers();
    }

    // Fullscreen functionality (keeping existing implementation)
    setupFullscreen() {
        // Create fullscreen button
        this.createFullscreenButton();

        // Listen for fullscreen changes
        document.addEventListener('fullscreenchange', () => this.handleFullscreenChange());
        document.addEventListener('webkitfullscreenchange', () => this.handleFullscreenChange());
        document.addEventListener('mozfullscreenchange', () => this.handleFullscreenChange());
        document.addEventListener('MSFullscreenChange', () => this.handleFullscreenChange());

        // Listen for escape key when canvas is focused
        this.canvas.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && this.isFullscreen) {
                e.preventDefault();
                e.stopPropagation();
                this.exitFullscreen();
            }
        });

        // Global escape key handler to prevent double-escape issue
        this.globalEscapeHandler = (e) => {
            if (e.key === 'Escape' && this.isFullscreen) {
                e.preventDefault();
                e.stopPropagation();
                this.exitFullscreen();
            }
        };
        document.addEventListener('keydown', this.globalEscapeHandler, true);
    }

    createFullscreenButton() {
        // Create a wrapper around the canvas if it doesn't exist
        let wrapper = this.canvas.parentElement;
        const needsWrapper = !wrapper || !wrapper.classList.contains('webgl-canvas-wrapper');

        if (needsWrapper) {
            wrapper = document.createElement('div');
            wrapper.className = 'webgl-canvas-wrapper';
            wrapper.style.cssText = `
                position: relative;
                display: inline-block;
                width: ${this.displayWidth || this.canvas.offsetWidth || this.canvas.width}px;
                height: ${this.displayHeight || this.canvas.offsetHeight || this.canvas.height}px;
                margin: 0;
                padding: 0;
            `;

            // Insert wrapper and move canvas into it
            this.canvas.parentNode.insertBefore(wrapper, this.canvas);
            wrapper.appendChild(this.canvas);
        }

        // Create the button
        this.fullscreenButton = document.createElement('button');
        this.fullscreenButton.className = 'webgl-fullscreen-btn';
        this.fullscreenButton.style.cssText = `
            position: absolute;
            bottom: 5px;
            right: 5px;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            padding: 6px;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            opacity: 0.7;
            margin: 0;
            box-sizing: border-box;
            line-height: 1;
        `;

        this.fullscreenButton.innerHTML = '⛶'; // Fullscreen icon
        this.fullscreenButton.title = 'Toggle Fullscreen (F11 or click)';

        // Button hover effects
        this.fullscreenButton.addEventListener('mouseenter', () => {
            this.fullscreenButton.style.background = 'rgba(102, 126, 234, 0.8)';
            this.fullscreenButton.style.transform = 'scale(1.1)';
            this.fullscreenButton.style.opacity = '1';
        });

        this.fullscreenButton.addEventListener('mouseleave', () => {
            this.fullscreenButton.style.background = 'rgba(0, 0, 0, 0.5)';
            this.fullscreenButton.style.transform = 'scale(1)';
            this.fullscreenButton.style.opacity = '0.7';
        });

        // Button click handler
        this.fullscreenButton.addEventListener('click', (e) => {
            e.stopPropagation();
            this.toggleFullscreen();
        });

        // Add button to wrapper
        wrapper.appendChild(this.fullscreenButton);

        // Store references
        this.wrapper = wrapper;
    }

    toggleFullscreen() {
        if (this.isFullscreen) {
            this.exitFullscreen();
        } else {
            this.enterFullscreen();
        }
    }

    enterFullscreen() {
        // Store original styles and dimensions
        this.originalStyle = {
            width: this.canvas.style.width,
            height: this.canvas.style.height,
            position: this.canvas.style.position,
            top: this.canvas.style.top,
            left: this.canvas.style.left,
            zIndex: this.canvas.style.zIndex,
            margin: this.canvas.style.margin,
            transform: this.canvas.style.transform
        };

        // Store original canvas dimensions (these stay the same for drawing)
        this.originalDimensions = {
            width: this.canvas.width,
            height: this.canvas.height,
            cssWidth: this.canvas.style.width,
            cssHeight: this.canvas.style.height
        };

        // Calculate scale to fit screen while maintaining aspect ratio
        const screenWidth = window.innerWidth;
        const screenHeight = window.innerHeight;
        const canvasAspect = this.canvas.width / this.canvas.height;
        const screenAspect = screenWidth / screenHeight;

        let scaledWidth, scaledHeight;

        if (canvasAspect > screenAspect) {
            // Canvas is wider than screen - fit to width
            scaledWidth = screenWidth;
            scaledHeight = screenWidth / canvasAspect;
        } else {
            // Canvas is taller than screen - fit to height
            scaledHeight = screenHeight;
            scaledWidth = screenHeight * canvasAspect;
        }

        // Center the canvas on screen
        const left = (screenWidth - scaledWidth) / 2;
        const top = (screenHeight - scaledHeight) / 2;

        // Apply fullscreen styles with scaling
        this.canvas.style.cssText += `
            position: fixed !important;
            top: ${top}px !important;
            left: ${left}px !important;
            width: ${scaledWidth}px !important;
            height: ${scaledHeight}px !important;
            z-index: 9999 !important;
            margin: 0 !important;
            border-radius: 0 !important;
            image-rendering: pixelated !important;
            image-rendering: -moz-crisp-edges !important;
            image-rendering: crisp-edges !important;
        `;

        // Update button position for fullscreen
        if (this.fullscreenButton) {
            this.fullscreenButton.style.position = 'fixed';
            this.fullscreenButton.style.bottom = '5px';
            this.fullscreenButton.style.right = '5px';
            this.fullscreenButton.style.zIndex = '10000';
        }

        // Update button icon
        this.fullscreenButton.innerHTML = '⛷'; // Exit fullscreen icon
        this.fullscreenButton.title = 'Exit Fullscreen (Esc or click)';

        this.isFullscreen = true;

        // Try to enter browser fullscreen if supported
        if (this.canvas.requestFullscreen) {
            this.canvas.requestFullscreen().catch(() => {
                // Fullscreen failed, but we still have our custom fullscreen
            });
        } else if (this.canvas.webkitRequestFullscreen) {
            this.canvas.webkitRequestFullscreen();
        } else if (this.canvas.mozRequestFullScreen) {
            this.canvas.mozRequestFullScreen();
        } else if (this.canvas.msRequestFullscreen) {
            this.canvas.msRequestFullscreen();
        }

        // Focus the canvas
        this.canvas.focus();

        // Dispatch custom event
        this.canvas.dispatchEvent(new CustomEvent('enterFullscreen'));
    }

    exitFullscreen() {
        // Restore original styles
        Object.keys(this.originalStyle).forEach(key => {
            this.canvas.style[key] = this.originalStyle[key] || '';
        });

        // Restore original dimensions from stored values
        this.canvas.width = this.originalDimensions.width;
        this.canvas.height = this.originalDimensions.height;
        this.width = this.originalDimensions.width;
        this.height = this.originalDimensions.height;

        // Restore CSS size if it was set
        if (this.originalDimensions.cssWidth) {
            this.canvas.style.width = this.originalDimensions.cssWidth;
        } else {
            this.canvas.style.width = '';
        }
        if (this.originalDimensions.cssHeight) {
            this.canvas.style.height = this.originalDimensions.cssHeight;
        } else {
            this.canvas.style.height = '';
        }

        // Update wrapper size if we have a wrapper
        if (this.wrapper && this.wrapper.classList.contains('webgl-canvas-wrapper')) {
            this.wrapper.style.width = `${this.displayWidth || this.canvas.offsetWidth || this.canvas.width}px`;
            this.wrapper.style.height = `${this.displayHeight || this.canvas.offsetHeight || this.canvas.height}px`;
        }

        // Update WebGL viewport
        this.gl.viewport(0, 0, this.width, this.height);

        // Restore button position
        if (this.fullscreenButton) {
            this.fullscreenButton.style.position = 'absolute';
            this.fullscreenButton.style.bottom = '5px';
            this.fullscreenButton.style.right = '5px';
            this.fullscreenButton.style.zIndex = '1000';
        }

        // Update button icon
        this.fullscreenButton.innerHTML = '⛶'; // Fullscreen icon
        this.fullscreenButton.title = 'Toggle Fullscreen (F11 or click)';

        this.isFullscreen = false;

        // Exit browser fullscreen
        if (document.exitFullscreen) {
            document.exitFullscreen().catch(() => { });
        } else if (document.webkitExitFullscreen) {
            document.webkitExitFullscreen();
        } else if (document.mozCancelFullScreen) {
            document.mozCancelFullScreen();
        } else if (document.msExitFullscreen) {
            document.msExitFullscreen();
        }

        // Dispatch custom event
        this.canvas.dispatchEvent(new CustomEvent('exitFullscreen'));
    }

    handleFullscreenChange() {
        // Check if we're still in browser fullscreen
        const isInBrowserFullscreen = !!(
            document.fullscreenElement ||
            document.webkitFullscreenElement ||
            document.mozFullScreenElement ||
            document.msFullscreenElement
        );

        // If browser fullscreen was exited but we're still in custom fullscreen
        if (!isInBrowserFullscreen && this.isFullscreen) {
            // Exit our custom fullscreen to stay in sync
            this.exitFullscreen();
        }
    }

    /**
     * Clean up resources and remove fullscreen elements
     * Call this when you're done with the canvas
     */
    cleanup() {
        // Remove global escape handler
        if (this.globalEscapeHandler) {
            document.removeEventListener('keydown', this.globalEscapeHandler, true);
        }

        // Remove fullscreen button
        if (this.fullscreenButton && this.fullscreenButton.parentNode) {
            this.fullscreenButton.parentNode.removeChild(this.fullscreenButton);
        }

        // If we created a wrapper, restore original structure
        if (this.wrapper && this.wrapper.classList.contains('webgl-canvas-wrapper')) {
            const parent = this.wrapper.parentNode;
            if (parent) {
                parent.insertBefore(this.canvas, this.wrapper);
                parent.removeChild(this.wrapper);
            }
        }

        // Clean up WebGL resources
        if (this.gl) {
            // Clean up batch buffers
            Object.values(this.batchBuffers).forEach(batch => {
                if (batch.vertices) this.gl.deleteBuffer(batch.vertices);
                if (batch.colors) this.gl.deleteBuffer(batch.colors);
                if (batch.indices) this.gl.deleteBuffer(batch.indices);
                if (batch.instanceData) this.gl.deleteBuffer(batch.instanceData);
            });

            // Clean up shaders
            Object.values(this.shaders).forEach(shader => {
                if (shader) this.gl.deleteProgram(shader);
            });
        }
    }
}

// Export for use
if (typeof module !== 'undefined' && module.exports) {
    module.exports = WebGLCanvas;
} else if (typeof window !== 'undefined') {
    window.WebGLCanvas = WebGLCanvas;
}

// src/core/matter-js/matter.min.js
/*!
 * matter-js 0.20.0 by @liabru
 * http://brm.io/matter-js/
 * License MIT
 */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("Matter",[],t):"object"==typeof exports?exports.Matter=t():e.Matter=t()}(this,(function(){return function(e){var t={};function n(o){if(t[o])return t[o].exports;var i=t[o]={i:o,l:!1,exports:{}};return e[o].call(i.exports,i,i.exports,n),i.l=!0,i.exports}return n.m=e,n.c=t,n.d=function(e,t,o){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:o})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var o=Object.create(null);if(n.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)n.d(o,i,function(t){return e[t]}.bind(null,i));return o},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=20)}([function(e,t){var n={};e.exports=n,function(){n._baseDelta=1e3/60,n._nextId=0,n._seed=0,n._nowStartTime=+new Date,n._warnedOnce={},n._decomp=null,n.extend=function(e,t){var o,i;"boolean"==typeof t?(o=2,i=t):(o=1,i=!0);for(var r=o;r<arguments.length;r++){var a=arguments[r];if(a)for(var s in a)i&&a[s]&&a[s].constructor===Object?e[s]&&e[s].constructor!==Object?e[s]=a[s]:(e[s]=e[s]||{},n.extend(e[s],i,a[s])):e[s]=a[s]}return e},n.clone=function(e,t){return n.extend({},t,e)},n.keys=function(e){if(Object.keys)return Object.keys(e);var t=[];for(var n in e)t.push(n);return t},n.values=function(e){var t=[];if(Object.keys){for(var n=Object.keys(e),o=0;o<n.length;o++)t.push(e[n[o]]);return t}for(var i in e)t.push(e[i]);return t},n.get=function(e,t,n,o){t=t.split(".").slice(n,o);for(var i=0;i<t.length;i+=1)e=e[t[i]];return e},n.set=function(e,t,o,i,r){var a=t.split(".").slice(i,r);return n.get(e,t,0,-1)[a[a.length-1]]=o,o},n.shuffle=function(e){for(var t=e.length-1;t>0;t--){var o=Math.floor(n.random()*(t+1)),i=e[t];e[t]=e[o],e[o]=i}return e},n.choose=function(e){return e[Math.floor(n.random()*e.length)]},n.isElement=function(e){return"undefined"!=typeof HTMLElement?e instanceof HTMLElement:!!(e&&e.nodeType&&e.nodeName)},n.isArray=function(e){return"[object Array]"===Object.prototype.toString.call(e)},n.isFunction=function(e){return"function"==typeof e},n.isPlainObject=function(e){return"object"==typeof e&&e.constructor===Object},n.isString=function(e){return"[object String]"===toString.call(e)},n.clamp=function(e,t,n){return e<t?t:e>n?n:e},n.sign=function(e){return e<0?-1:1},n.now=function(){if("undefined"!=typeof window&&window.performance){if(window.performance.now)return window.performance.now();if(window.performance.webkitNow)return window.performance.webkitNow()}return Date.now?Date.now():new Date-n._nowStartTime},n.random=function(t,n){return n=void 0!==n?n:1,(t=void 0!==t?t:0)+e()*(n-t)};var e=function(){return n._seed=(9301*n._seed+49297)%233280,n._seed/233280};n.colorToNumber=function(e){return 3==(e=e.replace("#","")).length&&(e=e.charAt(0)+e.charAt(0)+e.charAt(1)+e.charAt(1)+e.charAt(2)+e.charAt(2)),parseInt(e,16)},n.logLevel=1,n.log=function(){console&&n.logLevel>0&&n.logLevel<=3&&console.log.apply(console,["matter-js:"].concat(Array.prototype.slice.call(arguments)))},n.info=function(){console&&n.logLevel>0&&n.logLevel<=2&&console.info.apply(console,["matter-js:"].concat(Array.prototype.slice.call(arguments)))},n.warn=function(){console&&n.logLevel>0&&n.logLevel<=3&&console.warn.apply(console,["matter-js:"].concat(Array.prototype.slice.call(arguments)))},n.warnOnce=function(){var e=Array.prototype.slice.call(arguments).join(" ");n._warnedOnce[e]||(n.warn(e),n._warnedOnce[e]=!0)},n.deprecated=function(e,t,o){e[t]=n.chain((function(){n.warnOnce("🔅 deprecated 🔅",o)}),e[t])},n.nextId=function(){return n._nextId++},n.indexOf=function(e,t){if(e.indexOf)return e.indexOf(t);for(var n=0;n<e.length;n++)if(e[n]===t)return n;return-1},n.map=function(e,t){if(e.map)return e.map(t);for(var n=[],o=0;o<e.length;o+=1)n.push(t(e[o]));return n},n.topologicalSort=function(e){var t=[],o=[],i=[];for(var r in e)o[r]||i[r]||n._topologicalSort(r,o,i,e,t);return t},n._topologicalSort=function(e,t,o,i,r){var a=i[e]||[];o[e]=!0;for(var s=0;s<a.length;s+=1){var l=a[s];o[l]||(t[l]||n._topologicalSort(l,t,o,i,r))}o[e]=!1,t[e]=!0,r.push(e)},n.chain=function(){for(var e=[],t=0;t<arguments.length;t+=1){var n=arguments[t];n._chained?e.push.apply(e,n._chained):e.push(n)}var o=function(){for(var t,n=new Array(arguments.length),o=0,i=arguments.length;o<i;o++)n[o]=arguments[o];for(o=0;o<e.length;o+=1){var r=e[o].apply(t,n);void 0!==r&&(t=r)}return t};return o._chained=e,o},n.chainPathBefore=function(e,t,o){return n.set(e,t,n.chain(o,n.get(e,t)))},n.chainPathAfter=function(e,t,o){return n.set(e,t,n.chain(n.get(e,t),o))},n.setDecomp=function(e){n._decomp=e},n.getDecomp=function(){var e=n._decomp;try{e||"undefined"==typeof window||(e=window.decomp),e||"undefined"==typeof global||(e=global.decomp)}catch(t){e=null}return e}}()},function(e,t){var n={};e.exports=n,n.create=function(e){var t={min:{x:0,y:0},max:{x:0,y:0}};return e&&n.update(t,e),t},n.update=function(e,t,n){e.min.x=1/0,e.max.x=-1/0,e.min.y=1/0,e.max.y=-1/0;for(var o=0;o<t.length;o++){var i=t[o];i.x>e.max.x&&(e.max.x=i.x),i.x<e.min.x&&(e.min.x=i.x),i.y>e.max.y&&(e.max.y=i.y),i.y<e.min.y&&(e.min.y=i.y)}n&&(n.x>0?e.max.x+=n.x:e.min.x+=n.x,n.y>0?e.max.y+=n.y:e.min.y+=n.y)},n.contains=function(e,t){return t.x>=e.min.x&&t.x<=e.max.x&&t.y>=e.min.y&&t.y<=e.max.y},n.overlaps=function(e,t){return e.min.x<=t.max.x&&e.max.x>=t.min.x&&e.max.y>=t.min.y&&e.min.y<=t.max.y},n.translate=function(e,t){e.min.x+=t.x,e.max.x+=t.x,e.min.y+=t.y,e.max.y+=t.y},n.shift=function(e,t){var n=e.max.x-e.min.x,o=e.max.y-e.min.y;e.min.x=t.x,e.max.x=t.x+n,e.min.y=t.y,e.max.y=t.y+o}},function(e,t){var n={};e.exports=n,n.create=function(e,t){return{x:e||0,y:t||0}},n.clone=function(e){return{x:e.x,y:e.y}},n.magnitude=function(e){return Math.sqrt(e.x*e.x+e.y*e.y)},n.magnitudeSquared=function(e){return e.x*e.x+e.y*e.y},n.rotate=function(e,t,n){var o=Math.cos(t),i=Math.sin(t);n||(n={});var r=e.x*o-e.y*i;return n.y=e.x*i+e.y*o,n.x=r,n},n.rotateAbout=function(e,t,n,o){var i=Math.cos(t),r=Math.sin(t);o||(o={});var a=n.x+((e.x-n.x)*i-(e.y-n.y)*r);return o.y=n.y+((e.x-n.x)*r+(e.y-n.y)*i),o.x=a,o},n.normalise=function(e){var t=n.magnitude(e);return 0===t?{x:0,y:0}:{x:e.x/t,y:e.y/t}},n.dot=function(e,t){return e.x*t.x+e.y*t.y},n.cross=function(e,t){return e.x*t.y-e.y*t.x},n.cross3=function(e,t,n){return(t.x-e.x)*(n.y-e.y)-(t.y-e.y)*(n.x-e.x)},n.add=function(e,t,n){return n||(n={}),n.x=e.x+t.x,n.y=e.y+t.y,n},n.sub=function(e,t,n){return n||(n={}),n.x=e.x-t.x,n.y=e.y-t.y,n},n.mult=function(e,t){return{x:e.x*t,y:e.y*t}},n.div=function(e,t){return{x:e.x/t,y:e.y/t}},n.perp=function(e,t){return{x:(t=!0===t?-1:1)*-e.y,y:t*e.x}},n.neg=function(e){return{x:-e.x,y:-e.y}},n.angle=function(e,t){return Math.atan2(t.y-e.y,t.x-e.x)},n._temp=[n.create(),n.create(),n.create(),n.create(),n.create(),n.create()]},function(e,t,n){var o={};e.exports=o;var i=n(2),r=n(0);o.create=function(e,t){for(var n=[],o=0;o<e.length;o++){var i=e[o],r={x:i.x,y:i.y,index:o,body:t,isInternal:!1};n.push(r)}return n},o.fromPath=function(e,t){var n=[];return e.replace(/L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/gi,(function(e,t,o){n.push({x:parseFloat(t),y:parseFloat(o)})})),o.create(n,t)},o.centre=function(e){for(var t,n,r,a=o.area(e,!0),s={x:0,y:0},l=0;l<e.length;l++)r=(l+1)%e.length,t=i.cross(e[l],e[r]),n=i.mult(i.add(e[l],e[r]),t),s=i.add(s,n);return i.div(s,6*a)},o.mean=function(e){for(var t={x:0,y:0},n=0;n<e.length;n++)t.x+=e[n].x,t.y+=e[n].y;return i.div(t,e.length)},o.area=function(e,t){for(var n=0,o=e.length-1,i=0;i<e.length;i++)n+=(e[o].x-e[i].x)*(e[o].y+e[i].y),o=i;return t?n/2:Math.abs(n)/2},o.inertia=function(e,t){for(var n,o,r=0,a=0,s=e,l=0;l<s.length;l++)o=(l+1)%s.length,r+=(n=Math.abs(i.cross(s[o],s[l])))*(i.dot(s[o],s[o])+i.dot(s[o],s[l])+i.dot(s[l],s[l])),a+=n;return t/6*(r/a)},o.translate=function(e,t,n){n=void 0!==n?n:1;var o,i=e.length,r=t.x*n,a=t.y*n;for(o=0;o<i;o++)e[o].x+=r,e[o].y+=a;return e},o.rotate=function(e,t,n){if(0!==t){var o,i,r,a,s=Math.cos(t),l=Math.sin(t),c=n.x,u=n.y,d=e.length;for(a=0;a<d;a++)i=(o=e[a]).x-c,r=o.y-u,o.x=c+(i*s-r*l),o.y=u+(i*l+r*s);return e}},o.contains=function(e,t){for(var n,o=t.x,i=t.y,r=e.length,a=e[r-1],s=0;s<r;s++){if(n=e[s],(o-a.x)*(n.y-a.y)+(i-a.y)*(a.x-n.x)>0)return!1;a=n}return!0},o.scale=function(e,t,n,r){if(1===t&&1===n)return e;var a,s;r=r||o.centre(e);for(var l=0;l<e.length;l++)a=e[l],s=i.sub(a,r),e[l].x=r.x+s.x*t,e[l].y=r.y+s.y*n;return e},o.chamfer=function(e,t,n,o,a){t="number"==typeof t?[t]:t||[8],n=void 0!==n?n:-1,o=o||2,a=a||14;for(var s=[],l=0;l<e.length;l++){var c=e[l-1>=0?l-1:e.length-1],u=e[l],d=e[(l+1)%e.length],p=t[l<t.length?l:t.length-1];if(0!==p){var f=i.normalise({x:u.y-c.y,y:c.x-u.x}),v=i.normalise({x:d.y-u.y,y:u.x-d.x}),m=Math.sqrt(2*Math.pow(p,2)),y=i.mult(r.clone(f),p),g=i.normalise(i.mult(i.add(f,v),.5)),x=i.sub(u,i.mult(g,m)),h=n;-1===n&&(h=1.75*Math.pow(p,.32)),(h=r.clamp(h,o,a))%2==1&&(h+=1);for(var b=Math.acos(i.dot(f,v))/h,S=0;S<h;S++)s.push(i.add(i.rotate(y,b*S),x))}else s.push(u)}return s},o.clockwiseSort=function(e){var t=o.mean(e);return e.sort((function(e,n){return i.angle(t,e)-i.angle(t,n)})),e},o.isConvex=function(e){var t,n,o,i,r=0,a=e.length;if(a<3)return null;for(t=0;t<a;t++)if(o=(t+2)%a,i=(e[n=(t+1)%a].x-e[t].x)*(e[o].y-e[n].y),(i-=(e[n].y-e[t].y)*(e[o].x-e[n].x))<0?r|=1:i>0&&(r|=2),3===r)return!1;return 0!==r||null},o.hull=function(e){var t,n,o=[],r=[];for((e=e.slice(0)).sort((function(e,t){var n=e.x-t.x;return 0!==n?n:e.y-t.y})),n=0;n<e.length;n+=1){for(t=e[n];r.length>=2&&i.cross3(r[r.length-2],r[r.length-1],t)<=0;)r.pop();r.push(t)}for(n=e.length-1;n>=0;n-=1){for(t=e[n];o.length>=2&&i.cross3(o[o.length-2],o[o.length-1],t)<=0;)o.pop();o.push(t)}return o.pop(),r.pop(),o.concat(r)}},function(e,t,n){var o={};e.exports=o;var i=n(3),r=n(2),a=n(7),s=n(0),l=n(1),c=n(11);!function(){o._timeCorrection=!0,o._inertiaScale=4,o._nextCollidingGroupId=1,o._nextNonCollidingGroupId=-1,o._nextCategory=1,o._baseDelta=1e3/60,o.create=function(t){var n={id:s.nextId(),type:"body",label:"Body",parts:[],plugin:{},angle:0,vertices:i.fromPath("L 0 0 L 40 0 L 40 40 L 0 40"),position:{x:0,y:0},force:{x:0,y:0},torque:0,positionImpulse:{x:0,y:0},constraintImpulse:{x:0,y:0,angle:0},totalContacts:0,speed:0,angularSpeed:0,velocity:{x:0,y:0},angularVelocity:0,isSensor:!1,isStatic:!1,isSleeping:!1,motion:0,sleepThreshold:60,density:.001,restitution:0,friction:.1,frictionStatic:.5,frictionAir:.01,collisionFilter:{category:1,mask:4294967295,group:0},slop:.05,timeScale:1,render:{visible:!0,opacity:1,strokeStyle:null,fillStyle:null,lineWidth:null,sprite:{xScale:1,yScale:1,xOffset:0,yOffset:0}},events:null,bounds:null,chamfer:null,circleRadius:0,positionPrev:null,anglePrev:0,parent:null,axes:null,area:0,mass:0,inertia:0,deltaTime:1e3/60,_original:null},o=s.extend(n,t);return e(o,t),o},o.nextGroup=function(e){return e?o._nextNonCollidingGroupId--:o._nextCollidingGroupId++},o.nextCategory=function(){return o._nextCategory=o._nextCategory<<1,o._nextCategory};var e=function(e,t){t=t||{},o.set(e,{bounds:e.bounds||l.create(e.vertices),positionPrev:e.positionPrev||r.clone(e.position),anglePrev:e.anglePrev||e.angle,vertices:e.vertices,parts:e.parts||[e],isStatic:e.isStatic,isSleeping:e.isSleeping,parent:e.parent||e}),i.rotate(e.vertices,e.angle,e.position),c.rotate(e.axes,e.angle),l.update(e.bounds,e.vertices,e.velocity),o.set(e,{axes:t.axes||e.axes,area:t.area||e.area,mass:t.mass||e.mass,inertia:t.inertia||e.inertia});var n=e.isStatic?"#14151f":s.choose(["#f19648","#f5d259","#f55a3c","#063e7b","#ececd1"]),a=e.isStatic?"#555":"#ccc",u=e.isStatic&&null===e.render.fillStyle?1:0;e.render.fillStyle=e.render.fillStyle||n,e.render.strokeStyle=e.render.strokeStyle||a,e.render.lineWidth=e.render.lineWidth||u,e.render.sprite.xOffset+=-(e.bounds.min.x-e.position.x)/(e.bounds.max.x-e.bounds.min.x),e.render.sprite.yOffset+=-(e.bounds.min.y-e.position.y)/(e.bounds.max.y-e.bounds.min.y)};o.set=function(e,t,n){var i;for(i in"string"==typeof t&&(i=t,(t={})[i]=n),t)if(Object.prototype.hasOwnProperty.call(t,i))switch(n=t[i],i){case"isStatic":o.setStatic(e,n);break;case"isSleeping":a.set(e,n);break;case"mass":o.setMass(e,n);break;case"density":o.setDensity(e,n);break;case"inertia":o.setInertia(e,n);break;case"vertices":o.setVertices(e,n);break;case"position":o.setPosition(e,n);break;case"angle":o.setAngle(e,n);break;case"velocity":o.setVelocity(e,n);break;case"angularVelocity":o.setAngularVelocity(e,n);break;case"speed":o.setSpeed(e,n);break;case"angularSpeed":o.setAngularSpeed(e,n);break;case"parts":o.setParts(e,n);break;case"centre":o.setCentre(e,n);break;default:e[i]=n}},o.setStatic=function(e,t){for(var n=0;n<e.parts.length;n++){var o=e.parts[n];t?(o.isStatic||(o._original={restitution:o.restitution,friction:o.friction,mass:o.mass,inertia:o.inertia,density:o.density,inverseMass:o.inverseMass,inverseInertia:o.inverseInertia}),o.restitution=0,o.friction=1,o.mass=o.inertia=o.density=1/0,o.inverseMass=o.inverseInertia=0,o.positionPrev.x=o.position.x,o.positionPrev.y=o.position.y,o.anglePrev=o.angle,o.angularVelocity=0,o.speed=0,o.angularSpeed=0,o.motion=0):o._original&&(o.restitution=o._original.restitution,o.friction=o._original.friction,o.mass=o._original.mass,o.inertia=o._original.inertia,o.density=o._original.density,o.inverseMass=o._original.inverseMass,o.inverseInertia=o._original.inverseInertia,o._original=null),o.isStatic=t}},o.setMass=function(e,t){var n=e.inertia/(e.mass/6);e.inertia=n*(t/6),e.inverseInertia=1/e.inertia,e.mass=t,e.inverseMass=1/e.mass,e.density=e.mass/e.area},o.setDensity=function(e,t){o.setMass(e,t*e.area),e.density=t},o.setInertia=function(e,t){e.inertia=t,e.inverseInertia=1/e.inertia},o.setVertices=function(e,t){t[0].body===e?e.vertices=t:e.vertices=i.create(t,e),e.axes=c.fromVertices(e.vertices),e.area=i.area(e.vertices),o.setMass(e,e.density*e.area);var n=i.centre(e.vertices);i.translate(e.vertices,n,-1),o.setInertia(e,o._inertiaScale*i.inertia(e.vertices,e.mass)),i.translate(e.vertices,e.position),l.update(e.bounds,e.vertices,e.velocity)},o.setParts=function(e,t,n){var r;for(t=t.slice(0),e.parts.length=0,e.parts.push(e),e.parent=e,r=0;r<t.length;r++){var a=t[r];a!==e&&(a.parent=e,e.parts.push(a))}if(1!==e.parts.length){if(n=void 0===n||n){var s=[];for(r=0;r<t.length;r++)s=s.concat(t[r].vertices);i.clockwiseSort(s);var l=i.hull(s),c=i.centre(l);o.setVertices(e,l),i.translate(e.vertices,c)}var u=o._totalProperties(e);e.area=u.area,e.parent=e,e.position.x=u.centre.x,e.position.y=u.centre.y,e.positionPrev.x=u.centre.x,e.positionPrev.y=u.centre.y,o.setMass(e,u.mass),o.setInertia(e,u.inertia),o.setPosition(e,u.centre)}},o.setCentre=function(e,t,n){n?(e.positionPrev.x+=t.x,e.positionPrev.y+=t.y,e.position.x+=t.x,e.position.y+=t.y):(e.positionPrev.x=t.x-(e.position.x-e.positionPrev.x),e.positionPrev.y=t.y-(e.position.y-e.positionPrev.y),e.position.x=t.x,e.position.y=t.y)},o.setPosition=function(e,t,n){var o=r.sub(t,e.position);n?(e.positionPrev.x=e.position.x,e.positionPrev.y=e.position.y,e.velocity.x=o.x,e.velocity.y=o.y,e.speed=r.magnitude(o)):(e.positionPrev.x+=o.x,e.positionPrev.y+=o.y);for(var a=0;a<e.parts.length;a++){var s=e.parts[a];s.position.x+=o.x,s.position.y+=o.y,i.translate(s.vertices,o),l.update(s.bounds,s.vertices,e.velocity)}},o.setAngle=function(e,t,n){var o=t-e.angle;n?(e.anglePrev=e.angle,e.angularVelocity=o,e.angularSpeed=Math.abs(o)):e.anglePrev+=o;for(var a=0;a<e.parts.length;a++){var s=e.parts[a];s.angle+=o,i.rotate(s.vertices,o,e.position),c.rotate(s.axes,o),l.update(s.bounds,s.vertices,e.velocity),a>0&&r.rotateAbout(s.position,o,e.position,s.position)}},o.setVelocity=function(e,t){var n=e.deltaTime/o._baseDelta;e.positionPrev.x=e.position.x-t.x*n,e.positionPrev.y=e.position.y-t.y*n,e.velocity.x=(e.position.x-e.positionPrev.x)/n,e.velocity.y=(e.position.y-e.positionPrev.y)/n,e.speed=r.magnitude(e.velocity)},o.getVelocity=function(e){var t=o._baseDelta/e.deltaTime;return{x:(e.position.x-e.positionPrev.x)*t,y:(e.position.y-e.positionPrev.y)*t}},o.getSpeed=function(e){return r.magnitude(o.getVelocity(e))},o.setSpeed=function(e,t){o.setVelocity(e,r.mult(r.normalise(o.getVelocity(e)),t))},o.setAngularVelocity=function(e,t){var n=e.deltaTime/o._baseDelta;e.anglePrev=e.angle-t*n,e.angularVelocity=(e.angle-e.anglePrev)/n,e.angularSpeed=Math.abs(e.angularVelocity)},o.getAngularVelocity=function(e){return(e.angle-e.anglePrev)*o._baseDelta/e.deltaTime},o.getAngularSpeed=function(e){return Math.abs(o.getAngularVelocity(e))},o.setAngularSpeed=function(e,t){o.setAngularVelocity(e,s.sign(o.getAngularVelocity(e))*t)},o.translate=function(e,t,n){o.setPosition(e,r.add(e.position,t),n)},o.rotate=function(e,t,n,i){if(n){var r=Math.cos(t),a=Math.sin(t),s=e.position.x-n.x,l=e.position.y-n.y;o.setPosition(e,{x:n.x+(s*r-l*a),y:n.y+(s*a+l*r)},i),o.setAngle(e,e.angle+t,i)}else o.setAngle(e,e.angle+t,i)},o.scale=function(e,t,n,r){var a=0,s=0;r=r||e.position;for(var u=0;u<e.parts.length;u++){var d=e.parts[u];i.scale(d.vertices,t,n,r),d.axes=c.fromVertices(d.vertices),d.area=i.area(d.vertices),o.setMass(d,e.density*d.area),i.translate(d.vertices,{x:-d.position.x,y:-d.position.y}),o.setInertia(d,o._inertiaScale*i.inertia(d.vertices,d.mass)),i.translate(d.vertices,{x:d.position.x,y:d.position.y}),u>0&&(a+=d.area,s+=d.inertia),d.position.x=r.x+(d.position.x-r.x)*t,d.position.y=r.y+(d.position.y-r.y)*n,l.update(d.bounds,d.vertices,e.velocity)}e.parts.length>1&&(e.area=a,e.isStatic||(o.setMass(e,e.density*a),o.setInertia(e,s))),e.circleRadius&&(t===n?e.circleRadius*=t:e.circleRadius=null)},o.update=function(e,t){var n=(t=(void 0!==t?t:1e3/60)*e.timeScale)*t,a=o._timeCorrection?t/(e.deltaTime||t):1,u=1-e.frictionAir*(t/s._baseDelta),d=(e.position.x-e.positionPrev.x)*a,p=(e.position.y-e.positionPrev.y)*a;e.velocity.x=d*u+e.force.x/e.mass*n,e.velocity.y=p*u+e.force.y/e.mass*n,e.positionPrev.x=e.position.x,e.positionPrev.y=e.position.y,e.position.x+=e.velocity.x,e.position.y+=e.velocity.y,e.deltaTime=t,e.angularVelocity=(e.angle-e.anglePrev)*u*a+e.torque/e.inertia*n,e.anglePrev=e.angle,e.angle+=e.angularVelocity;for(var f=0;f<e.parts.length;f++){var v=e.parts[f];i.translate(v.vertices,e.velocity),f>0&&(v.position.x+=e.velocity.x,v.position.y+=e.velocity.y),0!==e.angularVelocity&&(i.rotate(v.vertices,e.angularVelocity,e.position),c.rotate(v.axes,e.angularVelocity),f>0&&r.rotateAbout(v.position,e.angularVelocity,e.position,v.position)),l.update(v.bounds,v.vertices,e.velocity)}},o.updateVelocities=function(e){var t=o._baseDelta/e.deltaTime,n=e.velocity;n.x=(e.position.x-e.positionPrev.x)*t,n.y=(e.position.y-e.positionPrev.y)*t,e.speed=Math.sqrt(n.x*n.x+n.y*n.y),e.angularVelocity=(e.angle-e.anglePrev)*t,e.angularSpeed=Math.abs(e.angularVelocity)},o.applyForce=function(e,t,n){var o=t.x-e.position.x,i=t.y-e.position.y;e.force.x+=n.x,e.force.y+=n.y,e.torque+=o*n.y-i*n.x},o._totalProperties=function(e){for(var t={mass:0,area:0,inertia:0,centre:{x:0,y:0}},n=1===e.parts.length?0:1;n<e.parts.length;n++){var o=e.parts[n],i=o.mass!==1/0?o.mass:1;t.mass+=i,t.area+=o.area,t.inertia+=o.inertia,t.centre=r.add(t.centre,r.mult(o.position,i))}return t.centre=r.div(t.centre,t.mass),t}}()},function(e,t,n){var o={};e.exports=o;var i=n(0);o.on=function(e,t,n){for(var o,i=t.split(" "),r=0;r<i.length;r++)o=i[r],e.events=e.events||{},e.events[o]=e.events[o]||[],e.events[o].push(n);return n},o.off=function(e,t,n){if(t){"function"==typeof t&&(n=t,t=i.keys(e.events).join(" "));for(var o=t.split(" "),r=0;r<o.length;r++){var a=e.events[o[r]],s=[];if(n&&a)for(var l=0;l<a.length;l++)a[l]!==n&&s.push(a[l]);e.events[o[r]]=s}}else e.events={}},o.trigger=function(e,t,n){var o,r,a,s,l=e.events;if(l&&i.keys(l).length>0){n||(n={}),o=t.split(" ");for(var c=0;c<o.length;c++)if(a=l[r=o[c]]){(s=i.clone(n,!1)).name=r,s.source=e;for(var u=0;u<a.length;u++)a[u].apply(e,[s])}}}},function(e,t,n){var o={};e.exports=o;var i=n(5),r=n(0),a=n(1),s=n(4);o.create=function(e){return r.extend({id:r.nextId(),type:"composite",parent:null,isModified:!1,bodies:[],constraints:[],composites:[],label:"Composite",plugin:{},cache:{allBodies:null,allConstraints:null,allComposites:null}},e)},o.setModified=function(e,t,n,i){if(e.isModified=t,t&&e.cache&&(e.cache.allBodies=null,e.cache.allConstraints=null,e.cache.allComposites=null),n&&e.parent&&o.setModified(e.parent,t,n,i),i)for(var r=0;r<e.composites.length;r++){var a=e.composites[r];o.setModified(a,t,n,i)}},o.add=function(e,t){var n=[].concat(t);i.trigger(e,"beforeAdd",{object:t});for(var a=0;a<n.length;a++){var s=n[a];switch(s.type){case"body":if(s.parent!==s){r.warn("Composite.add: skipped adding a compound body part (you must add its parent instead)");break}o.addBody(e,s);break;case"constraint":o.addConstraint(e,s);break;case"composite":o.addComposite(e,s);break;case"mouseConstraint":o.addConstraint(e,s.constraint)}}return i.trigger(e,"afterAdd",{object:t}),e},o.remove=function(e,t,n){var r=[].concat(t);i.trigger(e,"beforeRemove",{object:t});for(var a=0;a<r.length;a++){var s=r[a];switch(s.type){case"body":o.removeBody(e,s,n);break;case"constraint":o.removeConstraint(e,s,n);break;case"composite":o.removeComposite(e,s,n);break;case"mouseConstraint":o.removeConstraint(e,s.constraint)}}return i.trigger(e,"afterRemove",{object:t}),e},o.addComposite=function(e,t){return e.composites.push(t),t.parent=e,o.setModified(e,!0,!0,!1),e},o.removeComposite=function(e,t,n){var i=r.indexOf(e.composites,t);if(-1!==i){var a=o.allBodies(t);o.removeCompositeAt(e,i);for(var s=0;s<a.length;s++)a[s].sleepCounter=0}if(n)for(s=0;s<e.composites.length;s++)o.removeComposite(e.composites[s],t,!0);return e},o.removeCompositeAt=function(e,t){return e.composites.splice(t,1),o.setModified(e,!0,!0,!1),e},o.addBody=function(e,t){return e.bodies.push(t),o.setModified(e,!0,!0,!1),e},o.removeBody=function(e,t,n){var i=r.indexOf(e.bodies,t);if(-1!==i&&(o.removeBodyAt(e,i),t.sleepCounter=0),n)for(var a=0;a<e.composites.length;a++)o.removeBody(e.composites[a],t,!0);return e},o.removeBodyAt=function(e,t){return e.bodies.splice(t,1),o.setModified(e,!0,!0,!1),e},o.addConstraint=function(e,t){return e.constraints.push(t),o.setModified(e,!0,!0,!1),e},o.removeConstraint=function(e,t,n){var i=r.indexOf(e.constraints,t);if(-1!==i&&o.removeConstraintAt(e,i),n)for(var a=0;a<e.composites.length;a++)o.removeConstraint(e.composites[a],t,!0);return e},o.removeConstraintAt=function(e,t){return e.constraints.splice(t,1),o.setModified(e,!0,!0,!1),e},o.clear=function(e,t,n){if(n)for(var i=0;i<e.composites.length;i++)o.clear(e.composites[i],t,!0);return t?e.bodies=e.bodies.filter((function(e){return e.isStatic})):e.bodies.length=0,e.constraints.length=0,e.composites.length=0,o.setModified(e,!0,!0,!1),e},o.allBodies=function(e){if(e.cache&&e.cache.allBodies)return e.cache.allBodies;for(var t=[].concat(e.bodies),n=0;n<e.composites.length;n++)t=t.concat(o.allBodies(e.composites[n]));return e.cache&&(e.cache.allBodies=t),t},o.allConstraints=function(e){if(e.cache&&e.cache.allConstraints)return e.cache.allConstraints;for(var t=[].concat(e.constraints),n=0;n<e.composites.length;n++)t=t.concat(o.allConstraints(e.composites[n]));return e.cache&&(e.cache.allConstraints=t),t},o.allComposites=function(e){if(e.cache&&e.cache.allComposites)return e.cache.allComposites;for(var t=[].concat(e.composites),n=0;n<e.composites.length;n++)t=t.concat(o.allComposites(e.composites[n]));return e.cache&&(e.cache.allComposites=t),t},o.get=function(e,t,n){var i,r;switch(n){case"body":i=o.allBodies(e);break;case"constraint":i=o.allConstraints(e);break;case"composite":i=o.allComposites(e).concat(e)}return i?0===(r=i.filter((function(e){return e.id.toString()===t.toString()}))).length?null:r[0]:null},o.move=function(e,t,n){return o.remove(e,t),o.add(n,t),e},o.rebase=function(e){for(var t=o.allBodies(e).concat(o.allConstraints(e)).concat(o.allComposites(e)),n=0;n<t.length;n++)t[n].id=r.nextId();return e},o.translate=function(e,t,n){for(var i=n?o.allBodies(e):e.bodies,r=0;r<i.length;r++)s.translate(i[r],t);return e},o.rotate=function(e,t,n,i){for(var r=Math.cos(t),a=Math.sin(t),l=i?o.allBodies(e):e.bodies,c=0;c<l.length;c++){var u=l[c],d=u.position.x-n.x,p=u.position.y-n.y;s.setPosition(u,{x:n.x+(d*r-p*a),y:n.y+(d*a+p*r)}),s.rotate(u,t)}return e},o.scale=function(e,t,n,i,r){for(var a=r?o.allBodies(e):e.bodies,l=0;l<a.length;l++){var c=a[l],u=c.position.x-i.x,d=c.position.y-i.y;s.setPosition(c,{x:i.x+u*t,y:i.y+d*n}),s.scale(c,t,n)}return e},o.bounds=function(e){for(var t=o.allBodies(e),n=[],i=0;i<t.length;i+=1){var r=t[i];n.push(r.bounds.min,r.bounds.max)}return a.create(n)}},function(e,t,n){var o={};e.exports=o;var i=n(4),r=n(5),a=n(0);o._motionWakeThreshold=.18,o._motionSleepThreshold=.08,o._minBias=.9,o.update=function(e,t){for(var n=t/a._baseDelta,r=o._motionSleepThreshold,s=0;s<e.length;s++){var l=e[s],c=i.getSpeed(l),u=i.getAngularSpeed(l),d=c*c+u*u;if(0===l.force.x&&0===l.force.y){var p=Math.min(l.motion,d),f=Math.max(l.motion,d);l.motion=o._minBias*p+(1-o._minBias)*f,l.sleepThreshold>0&&l.motion<r?(l.sleepCounter+=1,l.sleepCounter>=l.sleepThreshold/n&&o.set(l,!0)):l.sleepCounter>0&&(l.sleepCounter-=1)}else o.set(l,!1)}},o.afterCollisions=function(e){for(var t=o._motionSleepThreshold,n=0;n<e.length;n++){var i=e[n];if(i.isActive){var r=i.collision,a=r.bodyA.parent,s=r.bodyB.parent;if(!(a.isSleeping&&s.isSleeping||a.isStatic||s.isStatic)&&(a.isSleeping||s.isSleeping)){var l=a.isSleeping&&!a.isStatic?a:s,c=l===a?s:a;!l.isStatic&&c.motion>t&&o.set(l,!1)}}}},o.set=function(e,t){var n=e.isSleeping;t?(e.isSleeping=!0,e.sleepCounter=e.sleepThreshold,e.positionImpulse.x=0,e.positionImpulse.y=0,e.positionPrev.x=e.position.x,e.positionPrev.y=e.position.y,e.anglePrev=e.angle,e.speed=0,e.angularSpeed=0,e.motion=0,n||r.trigger(e,"sleepStart")):(e.isSleeping=!1,e.sleepCounter=0,n&&r.trigger(e,"sleepEnd"))}},function(e,t,n){var o={};e.exports=o;var i,r,a,s=n(3),l=n(9);i=[],r={overlap:0,axis:null},a={overlap:0,axis:null},o.create=function(e,t){return{pair:null,collided:!1,bodyA:e,bodyB:t,parentA:e.parent,parentB:t.parent,depth:0,normal:{x:0,y:0},tangent:{x:0,y:0},penetration:{x:0,y:0},supports:[null,null],supportCount:0}},o.collides=function(e,t,n){if(o._overlapAxes(r,e.vertices,t.vertices,e.axes),r.overlap<=0)return null;if(o._overlapAxes(a,t.vertices,e.vertices,t.axes),a.overlap<=0)return null;var i,c,u=n&&n.table[l.id(e,t)];u?i=u.collision:((i=o.create(e,t)).collided=!0,i.bodyA=e.id<t.id?e:t,i.bodyB=e.id<t.id?t:e,i.parentA=i.bodyA.parent,i.parentB=i.bodyB.parent),e=i.bodyA,t=i.bodyB,c=r.overlap<a.overlap?r:a;var d=i.normal,p=i.tangent,f=i.penetration,v=i.supports,m=c.overlap,y=c.axis,g=y.x,x=y.y;g*(t.position.x-e.position.x)+x*(t.position.y-e.position.y)>=0&&(g=-g,x=-x),d.x=g,d.y=x,p.x=-x,p.y=g,f.x=g*m,f.y=x*m,i.depth=m;var h=o._findSupports(e,t,d,1),b=0;if(s.contains(e.vertices,h[0])&&(v[b++]=h[0]),s.contains(e.vertices,h[1])&&(v[b++]=h[1]),b<2){var S=o._findSupports(t,e,d,-1);s.contains(t.vertices,S[0])&&(v[b++]=S[0]),b<2&&s.contains(t.vertices,S[1])&&(v[b++]=S[1])}return 0===b&&(v[b++]=h[0]),i.supportCount=b,i},o._overlapAxes=function(e,t,n,o){var i,r,a,s,l,c,u=t.length,d=n.length,p=t[0].x,f=t[0].y,v=n[0].x,m=n[0].y,y=o.length,g=Number.MAX_VALUE,x=0;for(l=0;l<y;l++){var h=o[l],b=h.x,S=h.y,w=p*b+f*S,A=v*b+m*S,P=w,B=A;for(c=1;c<u;c+=1)(s=t[c].x*b+t[c].y*S)>P?P=s:s<w&&(w=s);for(c=1;c<d;c+=1)(s=n[c].x*b+n[c].y*S)>B?B=s:s<A&&(A=s);if((i=(r=P-A)<(a=B-w)?r:a)<g&&(g=i,x=l,i<=0))break}e.axis=o[x],e.overlap=g},o._findSupports=function(e,t,n,o){var r,a,s,l=t.vertices,c=l.length,u=e.position.x,d=e.position.y,p=n.x*o,f=n.y*o,v=l[0],m=v,y=p*(u-m.x)+f*(d-m.y);for(s=1;s<c;s+=1)(a=p*(u-(m=l[s]).x)+f*(d-m.y))<y&&(y=a,v=m);return y=p*(u-(r=l[(c+v.index-1)%c]).x)+f*(d-r.y),p*(u-(m=l[(v.index+1)%c]).x)+f*(d-m.y)<y?(i[0]=v,i[1]=m,i):(i[0]=v,i[1]=r,i)}},function(e,t,n){var o={};e.exports=o;var i=n(16);o.create=function(e,t){var n=e.bodyA,r=e.bodyB,a={id:o.id(n,r),bodyA:n,bodyB:r,collision:e,contacts:[i.create(),i.create()],contactCount:0,separation:0,isActive:!0,isSensor:n.isSensor||r.isSensor,timeCreated:t,timeUpdated:t,inverseMass:0,friction:0,frictionStatic:0,restitution:0,slop:0};return o.update(a,e,t),a},o.update=function(e,t,n){var o=t.supports,i=t.supportCount,r=e.contacts,a=t.parentA,s=t.parentB;e.isActive=!0,e.timeUpdated=n,e.collision=t,e.separation=t.depth,e.inverseMass=a.inverseMass+s.inverseMass,e.friction=a.friction<s.friction?a.friction:s.friction,e.frictionStatic=a.frictionStatic>s.frictionStatic?a.frictionStatic:s.frictionStatic,e.restitution=a.restitution>s.restitution?a.restitution:s.restitution,e.slop=a.slop>s.slop?a.slop:s.slop,e.contactCount=i,t.pair=e;var l=o[0],c=r[0],u=o[1],d=r[1];d.vertex!==l&&c.vertex!==u||(r[1]=c,r[0]=c=d,d=r[1]),c.vertex=l,d.vertex=u},o.setActive=function(e,t,n){t?(e.isActive=!0,e.timeUpdated=n):(e.isActive=!1,e.contactCount=0)},o.id=function(e,t){return e.id<t.id?e.id.toString(36)+":"+t.id.toString(36):t.id.toString(36)+":"+e.id.toString(36)}},function(e,t,n){var o={};e.exports=o;var i=n(3),r=n(2),a=n(7),s=n(1),l=n(11),c=n(0);o._warming=.4,o._torqueDampen=1,o._minLength=1e-6,o.create=function(e){var t=e;t.bodyA&&!t.pointA&&(t.pointA={x:0,y:0}),t.bodyB&&!t.pointB&&(t.pointB={x:0,y:0});var n=t.bodyA?r.add(t.bodyA.position,t.pointA):t.pointA,o=t.bodyB?r.add(t.bodyB.position,t.pointB):t.pointB,i=r.magnitude(r.sub(n,o));t.length=void 0!==t.length?t.length:i,t.id=t.id||c.nextId(),t.label=t.label||"Constraint",t.type="constraint",t.stiffness=t.stiffness||(t.length>0?1:.7),t.damping=t.damping||0,t.angularStiffness=t.angularStiffness||0,t.angleA=t.bodyA?t.bodyA.angle:t.angleA,t.angleB=t.bodyB?t.bodyB.angle:t.angleB,t.plugin={};var a={visible:!0,lineWidth:2,strokeStyle:"#ffffff",type:"line",anchors:!0};return 0===t.length&&t.stiffness>.1?(a.type="pin",a.anchors=!1):t.stiffness<.9&&(a.type="spring"),t.render=c.extend(a,t.render),t},o.preSolveAll=function(e){for(var t=0;t<e.length;t+=1){var n=e[t],o=n.constraintImpulse;n.isStatic||0===o.x&&0===o.y&&0===o.angle||(n.position.x+=o.x,n.position.y+=o.y,n.angle+=o.angle)}},o.solveAll=function(e,t){for(var n=c.clamp(t/c._baseDelta,0,1),i=0;i<e.length;i+=1){var r=e[i],a=!r.bodyA||r.bodyA&&r.bodyA.isStatic,s=!r.bodyB||r.bodyB&&r.bodyB.isStatic;(a||s)&&o.solve(e[i],n)}for(i=0;i<e.length;i+=1)a=!(r=e[i]).bodyA||r.bodyA&&r.bodyA.isStatic,s=!r.bodyB||r.bodyB&&r.bodyB.isStatic,a||s||o.solve(e[i],n)},o.solve=function(e,t){var n=e.bodyA,i=e.bodyB,a=e.pointA,s=e.pointB;if(n||i){n&&!n.isStatic&&(r.rotate(a,n.angle-e.angleA,a),e.angleA=n.angle),i&&!i.isStatic&&(r.rotate(s,i.angle-e.angleB,s),e.angleB=i.angle);var l=a,c=s;if(n&&(l=r.add(n.position,a)),i&&(c=r.add(i.position,s)),l&&c){var u=r.sub(l,c),d=r.magnitude(u);d<o._minLength&&(d=o._minLength);var p,f,v,m,y,g=(d-e.length)/d,x=e.stiffness>=1||0===e.length?e.stiffness*t:e.stiffness*t*t,h=e.damping*t,b=r.mult(u,g*x),S=(n?n.inverseMass:0)+(i?i.inverseMass:0),w=S+((n?n.inverseInertia:0)+(i?i.inverseInertia:0));if(h>0){var A=r.create();v=r.div(u,d),y=r.sub(i&&r.sub(i.position,i.positionPrev)||A,n&&r.sub(n.position,n.positionPrev)||A),m=r.dot(v,y)}n&&!n.isStatic&&(f=n.inverseMass/S,n.constraintImpulse.x-=b.x*f,n.constraintImpulse.y-=b.y*f,n.position.x-=b.x*f,n.position.y-=b.y*f,h>0&&(n.positionPrev.x-=h*v.x*m*f,n.positionPrev.y-=h*v.y*m*f),p=r.cross(a,b)/w*o._torqueDampen*n.inverseInertia*(1-e.angularStiffness),n.constraintImpulse.angle-=p,n.angle-=p),i&&!i.isStatic&&(f=i.inverseMass/S,i.constraintImpulse.x+=b.x*f,i.constraintImpulse.y+=b.y*f,i.position.x+=b.x*f,i.position.y+=b.y*f,h>0&&(i.positionPrev.x+=h*v.x*m*f,i.positionPrev.y+=h*v.y*m*f),p=r.cross(s,b)/w*o._torqueDampen*i.inverseInertia*(1-e.angularStiffness),i.constraintImpulse.angle+=p,i.angle+=p)}}},o.postSolveAll=function(e){for(var t=0;t<e.length;t++){var n=e[t],c=n.constraintImpulse;if(!(n.isStatic||0===c.x&&0===c.y&&0===c.angle)){a.set(n,!1);for(var u=0;u<n.parts.length;u++){var d=n.parts[u];i.translate(d.vertices,c),u>0&&(d.position.x+=c.x,d.position.y+=c.y),0!==c.angle&&(i.rotate(d.vertices,c.angle,n.position),l.rotate(d.axes,c.angle),u>0&&r.rotateAbout(d.position,c.angle,n.position,d.position)),s.update(d.bounds,d.vertices,n.velocity)}c.angle*=o._warming,c.x*=o._warming,c.y*=o._warming}}},o.pointAWorld=function(e){return{x:(e.bodyA?e.bodyA.position.x:0)+(e.pointA?e.pointA.x:0),y:(e.bodyA?e.bodyA.position.y:0)+(e.pointA?e.pointA.y:0)}},o.pointBWorld=function(e){return{x:(e.bodyB?e.bodyB.position.x:0)+(e.pointB?e.pointB.x:0),y:(e.bodyB?e.bodyB.position.y:0)+(e.pointB?e.pointB.y:0)}},o.currentLength=function(e){var t=(e.bodyA?e.bodyA.position.x:0)+(e.pointA?e.pointA.x:0),n=(e.bodyA?e.bodyA.position.y:0)+(e.pointA?e.pointA.y:0),o=t-((e.bodyB?e.bodyB.position.x:0)+(e.pointB?e.pointB.x:0)),i=n-((e.bodyB?e.bodyB.position.y:0)+(e.pointB?e.pointB.y:0));return Math.sqrt(o*o+i*i)}},function(e,t,n){var o={};e.exports=o;var i=n(2),r=n(0);o.fromVertices=function(e){for(var t={},n=0;n<e.length;n++){var o=(n+1)%e.length,a=i.normalise({x:e[o].y-e[n].y,y:e[n].x-e[o].x}),s=0===a.y?1/0:a.x/a.y;t[s=s.toFixed(3).toString()]=a}return r.values(t)},o.rotate=function(e,t){if(0!==t)for(var n=Math.cos(t),o=Math.sin(t),i=0;i<e.length;i++){var r,a=e[i];r=a.x*n-a.y*o,a.y=a.x*o+a.y*n,a.x=r}}},function(e,t,n){var o={};e.exports=o;var i=n(3),r=n(0),a=n(4),s=n(1),l=n(2);o.rectangle=function(e,t,n,o,s){s=s||{};var l={label:"Rectangle Body",position:{x:e,y:t},vertices:i.fromPath("L 0 0 L "+n+" 0 L "+n+" "+o+" L 0 "+o)};if(s.chamfer){var c=s.chamfer;l.vertices=i.chamfer(l.vertices,c.radius,c.quality,c.qualityMin,c.qualityMax),delete s.chamfer}return a.create(r.extend({},l,s))},o.trapezoid=function(e,t,n,o,s,l){l=l||{},s>=1&&r.warn("Bodies.trapezoid: slope parameter must be < 1.");var c,u=n*(s*=.5),d=u+(1-2*s)*n,p=d+u;c=s<.5?"L 0 0 L "+u+" "+-o+" L "+d+" "+-o+" L "+p+" 0":"L 0 0 L "+d+" "+-o+" L "+p+" 0";var f={label:"Trapezoid Body",position:{x:e,y:t},vertices:i.fromPath(c)};if(l.chamfer){var v=l.chamfer;f.vertices=i.chamfer(f.vertices,v.radius,v.quality,v.qualityMin,v.qualityMax),delete l.chamfer}return a.create(r.extend({},f,l))},o.circle=function(e,t,n,i,a){i=i||{};var s={label:"Circle Body",circleRadius:n};a=a||25;var l=Math.ceil(Math.max(10,Math.min(a,n)));return l%2==1&&(l+=1),o.polygon(e,t,l,n,r.extend({},s,i))},o.polygon=function(e,t,n,s,l){if(l=l||{},n<3)return o.circle(e,t,s,l);for(var c=2*Math.PI/n,u="",d=.5*c,p=0;p<n;p+=1){var f=d+p*c,v=Math.cos(f)*s,m=Math.sin(f)*s;u+="L "+v.toFixed(3)+" "+m.toFixed(3)+" "}var y={label:"Polygon Body",position:{x:e,y:t},vertices:i.fromPath(u)};if(l.chamfer){var g=l.chamfer;y.vertices=i.chamfer(y.vertices,g.radius,g.quality,g.qualityMin,g.qualityMax),delete l.chamfer}return a.create(r.extend({},y,l))},o.fromVertices=function(e,t,n,o,c,u,d,p){var f,v,m,y,g,x,h,b,S,w,A=r.getDecomp();for(f=Boolean(A&&A.quickDecomp),o=o||{},m=[],c=void 0!==c&&c,u=void 0!==u?u:.01,d=void 0!==d?d:10,p=void 0!==p?p:.01,r.isArray(n[0])||(n=[n]),S=0;S<n.length;S+=1)if(g=n[S],!(y=i.isConvex(g))&&!f&&r.warnOnce("Bodies.fromVertices: Install the 'poly-decomp' library and use Common.setDecomp or provide 'decomp' as a global to decompose concave vertices."),y||!f)g=y?i.clockwiseSort(g):i.hull(g),m.push({position:{x:e,y:t},vertices:g});else{var P=g.map((function(e){return[e.x,e.y]}));A.makeCCW(P),!1!==u&&A.removeCollinearPoints(P,u),!1!==p&&A.removeDuplicatePoints&&A.removeDuplicatePoints(P,p);var B=A.quickDecomp(P);for(x=0;x<B.length;x++){var M=B[x].map((function(e){return{x:e[0],y:e[1]}}));d>0&&i.area(M)<d||m.push({position:i.centre(M),vertices:M})}}for(x=0;x<m.length;x++)m[x]=a.create(r.extend(m[x],o));if(c)for(x=0;x<m.length;x++){var _=m[x];for(h=x+1;h<m.length;h++){var C=m[h];if(s.overlaps(_.bounds,C.bounds)){var k=_.vertices,I=C.vertices;for(b=0;b<_.vertices.length;b++)for(w=0;w<C.vertices.length;w++){var T=l.magnitudeSquared(l.sub(k[(b+1)%k.length],I[w])),R=l.magnitudeSquared(l.sub(k[b],I[(w+1)%I.length]));T<5&&R<5&&(k[b].isInternal=!0,I[w].isInternal=!0)}}}}return m.length>1?(v=a.create(r.extend({parts:m.slice(0)},o)),a.setPosition(v,{x:e,y:t}),v):m[0]}},function(e,t,n){var o={};e.exports=o;var i=n(0),r=n(8);o.create=function(e){return i.extend({bodies:[],collisions:[],pairs:null},e)},o.setBodies=function(e,t){e.bodies=t.slice(0)},o.clear=function(e){e.bodies=[],e.collisions=[]},o.collisions=function(e){var t,n,i=e.pairs,a=e.bodies,s=a.length,l=o.canCollide,c=r.collides,u=e.collisions,d=0;for(a.sort(o._compareBoundsX),t=0;t<s;t++){var p=a[t],f=p.bounds,v=p.bounds.max.x,m=p.bounds.max.y,y=p.bounds.min.y,g=p.isStatic||p.isSleeping,x=p.parts.length,h=1===x;for(n=t+1;n<s;n++){var b=a[n];if((C=b.bounds).min.x>v)break;if(!(m<C.min.y||y>C.max.y)&&(!g||!b.isStatic&&!b.isSleeping)&&l(p.collisionFilter,b.collisionFilter)){var S=b.parts.length;if(h&&1===S)(M=c(p,b,i))&&(u[d++]=M);else for(var w=S>1?1:0,A=x>1?1:0;A<x;A++)for(var P=p.parts[A],B=(f=P.bounds,w);B<S;B++){var M,_=b.parts[B],C=_.bounds;f.min.x>C.max.x||f.max.x<C.min.x||f.max.y<C.min.y||f.min.y>C.max.y||(M=c(P,_,i))&&(u[d++]=M)}}}}return u.length!==d&&(u.length=d),u},o.canCollide=function(e,t){return e.group===t.group&&0!==e.group?e.group>0:0!=(e.mask&t.category)&&0!=(t.mask&e.category)},o._compareBoundsX=function(e,t){return e.bounds.min.x-t.bounds.min.x}},function(e,t,n){var o={};e.exports=o;var i=n(0);o.create=function(e){var t={};return e||i.log("Mouse.create: element was undefined, defaulting to document.body","warn"),t.element=e||document.body,t.absolute={x:0,y:0},t.position={x:0,y:0},t.mousedownPosition={x:0,y:0},t.mouseupPosition={x:0,y:0},t.offset={x:0,y:0},t.scale={x:1,y:1},t.wheelDelta=0,t.button=-1,t.pixelRatio=parseInt(t.element.getAttribute("data-pixel-ratio"),10)||1,t.sourceEvents={mousemove:null,mousedown:null,mouseup:null,mousewheel:null},t.mousemove=function(e){var n=o._getRelativeMousePosition(e,t.element,t.pixelRatio);e.changedTouches&&(t.button=0,e.preventDefault()),t.absolute.x=n.x,t.absolute.y=n.y,t.position.x=t.absolute.x*t.scale.x+t.offset.x,t.position.y=t.absolute.y*t.scale.y+t.offset.y,t.sourceEvents.mousemove=e},t.mousedown=function(e){var n=o._getRelativeMousePosition(e,t.element,t.pixelRatio);e.changedTouches?(t.button=0,e.preventDefault()):t.button=e.button,t.absolute.x=n.x,t.absolute.y=n.y,t.position.x=t.absolute.x*t.scale.x+t.offset.x,t.position.y=t.absolute.y*t.scale.y+t.offset.y,t.mousedownPosition.x=t.position.x,t.mousedownPosition.y=t.position.y,t.sourceEvents.mousedown=e},t.mouseup=function(e){var n=o._getRelativeMousePosition(e,t.element,t.pixelRatio);e.changedTouches&&e.preventDefault(),t.button=-1,t.absolute.x=n.x,t.absolute.y=n.y,t.position.x=t.absolute.x*t.scale.x+t.offset.x,t.position.y=t.absolute.y*t.scale.y+t.offset.y,t.mouseupPosition.x=t.position.x,t.mouseupPosition.y=t.position.y,t.sourceEvents.mouseup=e},t.mousewheel=function(e){t.wheelDelta=Math.max(-1,Math.min(1,e.wheelDelta||-e.detail)),e.preventDefault(),t.sourceEvents.mousewheel=e},o.setElement(t,t.element),t},o.setElement=function(e,t){e.element=t,t.addEventListener("mousemove",e.mousemove,{passive:!0}),t.addEventListener("mousedown",e.mousedown,{passive:!0}),t.addEventListener("mouseup",e.mouseup,{passive:!0}),t.addEventListener("wheel",e.mousewheel,{passive:!1}),t.addEventListener("touchmove",e.mousemove,{passive:!1}),t.addEventListener("touchstart",e.mousedown,{passive:!1}),t.addEventListener("touchend",e.mouseup,{passive:!1})},o.clearSourceEvents=function(e){e.sourceEvents.mousemove=null,e.sourceEvents.mousedown=null,e.sourceEvents.mouseup=null,e.sourceEvents.mousewheel=null,e.wheelDelta=0},o.setOffset=function(e,t){e.offset.x=t.x,e.offset.y=t.y,e.position.x=e.absolute.x*e.scale.x+e.offset.x,e.position.y=e.absolute.y*e.scale.y+e.offset.y},o.setScale=function(e,t){e.scale.x=t.x,e.scale.y=t.y,e.position.x=e.absolute.x*e.scale.x+e.offset.x,e.position.y=e.absolute.y*e.scale.y+e.offset.y},o._getRelativeMousePosition=function(e,t,n){var o,i,r=t.getBoundingClientRect(),a=document.documentElement||document.body.parentNode||document.body,s=void 0!==window.pageXOffset?window.pageXOffset:a.scrollLeft,l=void 0!==window.pageYOffset?window.pageYOffset:a.scrollTop,c=e.changedTouches;return c?(o=c[0].pageX-r.left-s,i=c[0].pageY-r.top-l):(o=e.pageX-r.left-s,i=e.pageY-r.top-l),{x:o/(t.clientWidth/(t.width||t.clientWidth)*n),y:i/(t.clientHeight/(t.height||t.clientHeight)*n)}}},function(e,t,n){var o={};e.exports=o;var i=n(0);o._registry={},o.register=function(e){if(o.isPlugin(e)||i.warn("Plugin.register:",o.toString(e),"does not implement all required fields."),e.name in o._registry){var t=o._registry[e.name],n=o.versionParse(e.version).number,r=o.versionParse(t.version).number;n>r?(i.warn("Plugin.register:",o.toString(t),"was upgraded to",o.toString(e)),o._registry[e.name]=e):n<r?i.warn("Plugin.register:",o.toString(t),"can not be downgraded to",o.toString(e)):e!==t&&i.warn("Plugin.register:",o.toString(e),"is already registered to different plugin object")}else o._registry[e.name]=e;return e},o.resolve=function(e){return o._registry[o.dependencyParse(e).name]},o.toString=function(e){return"string"==typeof e?e:(e.name||"anonymous")+"@"+(e.version||e.range||"0.0.0")},o.isPlugin=function(e){return e&&e.name&&e.version&&e.install},o.isUsed=function(e,t){return e.used.indexOf(t)>-1},o.isFor=function(e,t){var n=e.for&&o.dependencyParse(e.for);return!e.for||t.name===n.name&&o.versionSatisfies(t.version,n.range)},o.use=function(e,t){if(e.uses=(e.uses||[]).concat(t||[]),0!==e.uses.length){for(var n=o.dependencies(e),r=i.topologicalSort(n),a=[],s=0;s<r.length;s+=1)if(r[s]!==e.name){var l=o.resolve(r[s]);l?o.isUsed(e,l.name)||(o.isFor(l,e)||(i.warn("Plugin.use:",o.toString(l),"is for",l.for,"but installed on",o.toString(e)+"."),l._warned=!0),l.install?l.install(e):(i.warn("Plugin.use:",o.toString(l),"does not specify an install function."),l._warned=!0),l._warned?(a.push("🔶 "+o.toString(l)),delete l._warned):a.push("✅ "+o.toString(l)),e.used.push(l.name)):a.push("❌ "+r[s])}a.length>0&&i.info(a.join("  "))}else i.warn("Plugin.use:",o.toString(e),"does not specify any dependencies to install.")},o.dependencies=function(e,t){var n=o.dependencyParse(e),r=n.name;if(!(r in(t=t||{}))){e=o.resolve(e)||e,t[r]=i.map(e.uses||[],(function(t){o.isPlugin(t)&&o.register(t);var r=o.dependencyParse(t),a=o.resolve(t);return a&&!o.versionSatisfies(a.version,r.range)?(i.warn("Plugin.dependencies:",o.toString(a),"does not satisfy",o.toString(r),"used by",o.toString(n)+"."),a._warned=!0,e._warned=!0):a||(i.warn("Plugin.dependencies:",o.toString(t),"used by",o.toString(n),"could not be resolved."),e._warned=!0),r.name}));for(var a=0;a<t[r].length;a+=1)o.dependencies(t[r][a],t);return t}},o.dependencyParse=function(e){return i.isString(e)?(/^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-+]+)?))?$/.test(e)||i.warn("Plugin.dependencyParse:",e,"is not a valid dependency string."),{name:e.split("@")[0],range:e.split("@")[1]||"*"}):{name:e.name,range:e.range||e.version}},o.versionParse=function(e){var t=/^(\*)|(\^|~|>=|>)?\s*((\d+)\.(\d+)\.(\d+))(-[0-9A-Za-z-+]+)?$/;t.test(e)||i.warn("Plugin.versionParse:",e,"is not a valid version or range.");var n=t.exec(e),o=Number(n[4]),r=Number(n[5]),a=Number(n[6]);return{isRange:Boolean(n[1]||n[2]),version:n[3],range:e,operator:n[1]||n[2]||"",major:o,minor:r,patch:a,parts:[o,r,a],prerelease:n[7],number:1e8*o+1e4*r+a}},o.versionSatisfies=function(e,t){t=t||"*";var n=o.versionParse(t),i=o.versionParse(e);if(n.isRange){if("*"===n.operator||"*"===e)return!0;if(">"===n.operator)return i.number>n.number;if(">="===n.operator)return i.number>=n.number;if("~"===n.operator)return i.major===n.major&&i.minor===n.minor&&i.patch>=n.patch;if("^"===n.operator)return n.major>0?i.major===n.major&&i.number>=n.number:n.minor>0?i.minor===n.minor&&i.patch>=n.patch:i.patch===n.patch}return e===t||"*"===e}},function(e,t){var n={};e.exports=n,n.create=function(e){return{vertex:e,normalImpulse:0,tangentImpulse:0}}},function(e,t,n){var o={};e.exports=o;var i=n(7),r=n(18),a=n(13),s=n(19),l=n(5),c=n(6),u=n(10),d=n(0),p=n(4);o._deltaMax=1e3/60,o.create=function(e){e=e||{};var t=d.extend({positionIterations:6,velocityIterations:4,constraintIterations:2,enableSleeping:!1,events:[],plugin:{},gravity:{x:0,y:1,scale:.001},timing:{timestamp:0,timeScale:1,lastDelta:0,lastElapsed:0,lastUpdatesPerFrame:0}},e);return t.world=e.world||c.create({label:"World"}),t.pairs=e.pairs||s.create(),t.detector=e.detector||a.create(),t.detector.pairs=t.pairs,t.grid={buckets:[]},t.world.gravity=t.gravity,t.broadphase=t.grid,t.metrics={},t},o.update=function(e,t){var n,p=d.now(),f=e.world,v=e.detector,m=e.pairs,y=e.timing,g=y.timestamp;t>o._deltaMax&&d.warnOnce("Matter.Engine.update: delta argument is recommended to be less than or equal to",o._deltaMax.toFixed(3),"ms."),t=void 0!==t?t:d._baseDelta,t*=y.timeScale,y.timestamp+=t,y.lastDelta=t;var x={timestamp:y.timestamp,delta:t};l.trigger(e,"beforeUpdate",x);var h=c.allBodies(f),b=c.allConstraints(f);for(f.isModified&&(a.setBodies(v,h),c.setModified(f,!1,!1,!0)),e.enableSleeping&&i.update(h,t),o._bodiesApplyGravity(h,e.gravity),t>0&&o._bodiesUpdate(h,t),l.trigger(e,"beforeSolve",x),u.preSolveAll(h),n=0;n<e.constraintIterations;n++)u.solveAll(b,t);u.postSolveAll(h);var S=a.collisions(v);s.update(m,S,g),e.enableSleeping&&i.afterCollisions(m.list),m.collisionStart.length>0&&l.trigger(e,"collisionStart",{pairs:m.collisionStart,timestamp:y.timestamp,delta:t});var w=d.clamp(20/e.positionIterations,0,1);for(r.preSolvePosition(m.list),n=0;n<e.positionIterations;n++)r.solvePosition(m.list,t,w);for(r.postSolvePosition(h),u.preSolveAll(h),n=0;n<e.constraintIterations;n++)u.solveAll(b,t);for(u.postSolveAll(h),r.preSolveVelocity(m.list),n=0;n<e.velocityIterations;n++)r.solveVelocity(m.list,t);return o._bodiesUpdateVelocities(h),m.collisionActive.length>0&&l.trigger(e,"collisionActive",{pairs:m.collisionActive,timestamp:y.timestamp,delta:t}),m.collisionEnd.length>0&&l.trigger(e,"collisionEnd",{pairs:m.collisionEnd,timestamp:y.timestamp,delta:t}),o._bodiesClearForces(h),l.trigger(e,"afterUpdate",x),e.timing.lastElapsed=d.now()-p,e},o.merge=function(e,t){if(d.extend(e,t),t.world){e.world=t.world,o.clear(e);for(var n=c.allBodies(e.world),r=0;r<n.length;r++){var a=n[r];i.set(a,!1),a.id=d.nextId()}}},o.clear=function(e){s.clear(e.pairs),a.clear(e.detector)},o._bodiesClearForces=function(e){for(var t=e.length,n=0;n<t;n++){var o=e[n];o.force.x=0,o.force.y=0,o.torque=0}},o._bodiesApplyGravity=function(e,t){var n=void 0!==t.scale?t.scale:.001,o=e.length;if((0!==t.x||0!==t.y)&&0!==n)for(var i=0;i<o;i++){var r=e[i];r.isStatic||r.isSleeping||(r.force.y+=r.mass*t.y*n,r.force.x+=r.mass*t.x*n)}},o._bodiesUpdate=function(e,t){for(var n=e.length,o=0;o<n;o++){var i=e[o];i.isStatic||i.isSleeping||p.update(i,t)}},o._bodiesUpdateVelocities=function(e){for(var t=e.length,n=0;n<t;n++)p.updateVelocities(e[n])}},function(e,t,n){var o={};e.exports=o;var i=n(3),r=n(0),a=n(1);o._restingThresh=2,o._restingThreshTangent=Math.sqrt(6),o._positionDampen=.9,o._positionWarming=.8,o._frictionNormalMultiplier=5,o._frictionMaxStatic=Number.MAX_VALUE,o.preSolvePosition=function(e){var t,n,o,i=e.length;for(t=0;t<i;t++)(n=e[t]).isActive&&(o=n.contactCount,n.collision.parentA.totalContacts+=o,n.collision.parentB.totalContacts+=o)},o.solvePosition=function(e,t,n){var i,a,s,l,c,u,d,p,f=o._positionDampen*(n||1),v=r.clamp(t/r._baseDelta,0,1),m=e.length;for(i=0;i<m;i++)(a=e[i]).isActive&&!a.isSensor&&(l=(s=a.collision).parentA,c=s.parentB,u=s.normal,a.separation=s.depth+u.x*(c.positionImpulse.x-l.positionImpulse.x)+u.y*(c.positionImpulse.y-l.positionImpulse.y));for(i=0;i<m;i++)(a=e[i]).isActive&&!a.isSensor&&(l=(s=a.collision).parentA,c=s.parentB,u=s.normal,p=a.separation-a.slop*v,(l.isStatic||c.isStatic)&&(p*=2),l.isStatic||l.isSleeping||(d=f/l.totalContacts,l.positionImpulse.x+=u.x*p*d,l.positionImpulse.y+=u.y*p*d),c.isStatic||c.isSleeping||(d=f/c.totalContacts,c.positionImpulse.x-=u.x*p*d,c.positionImpulse.y-=u.y*p*d))},o.postSolvePosition=function(e){for(var t=o._positionWarming,n=e.length,r=i.translate,s=a.update,l=0;l<n;l++){var c=e[l],u=c.positionImpulse,d=u.x,p=u.y,f=c.velocity;if(c.totalContacts=0,0!==d||0!==p){for(var v=0;v<c.parts.length;v++){var m=c.parts[v];r(m.vertices,u),s(m.bounds,m.vertices,f),m.position.x+=d,m.position.y+=p}c.positionPrev.x+=d,c.positionPrev.y+=p,d*f.x+p*f.y<0?(u.x=0,u.y=0):(u.x*=t,u.y*=t)}}},o.preSolveVelocity=function(e){var t,n,o=e.length;for(t=0;t<o;t++){var i=e[t];if(i.isActive&&!i.isSensor){var r=i.contacts,a=i.contactCount,s=i.collision,l=s.parentA,c=s.parentB,u=s.normal,d=s.tangent;for(n=0;n<a;n++){var p=r[n],f=p.vertex,v=p.normalImpulse,m=p.tangentImpulse;if(0!==v||0!==m){var y=u.x*v+d.x*m,g=u.y*v+d.y*m;l.isStatic||l.isSleeping||(l.positionPrev.x+=y*l.inverseMass,l.positionPrev.y+=g*l.inverseMass,l.anglePrev+=l.inverseInertia*((f.x-l.position.x)*g-(f.y-l.position.y)*y)),c.isStatic||c.isSleeping||(c.positionPrev.x-=y*c.inverseMass,c.positionPrev.y-=g*c.inverseMass,c.anglePrev-=c.inverseInertia*((f.x-c.position.x)*g-(f.y-c.position.y)*y))}}}}},o.solveVelocity=function(e,t){var n,i,a,s,l=t/r._baseDelta,c=l*l*l,u=-o._restingThresh*l,d=o._restingThreshTangent,p=o._frictionNormalMultiplier*l,f=o._frictionMaxStatic,v=e.length;for(a=0;a<v;a++){var m=e[a];if(m.isActive&&!m.isSensor){var y=m.collision,g=y.parentA,x=y.parentB,h=y.normal.x,b=y.normal.y,S=y.tangent.x,w=y.tangent.y,A=m.inverseMass,P=m.friction*m.frictionStatic*p,B=m.contacts,M=m.contactCount,_=1/M,C=g.position.x-g.positionPrev.x,k=g.position.y-g.positionPrev.y,I=g.angle-g.anglePrev,T=x.position.x-x.positionPrev.x,R=x.position.y-x.positionPrev.y,D=x.angle-x.anglePrev;for(s=0;s<M;s++){var V=B[s],E=V.vertex,L=E.x-g.position.x,F=E.y-g.position.y,O=E.x-x.position.x,H=E.y-x.position.y,q=C-F*I-(T-H*D),j=k+L*I-(R+O*D),U=h*q+b*j,W=S*q+w*j,N=m.separation+U,G=Math.min(N,1),z=(G=N<0?0:G)*P;W<-z||W>z?(i=W>0?W:-W,(n=m.friction*(W>0?1:-1)*c)<-i?n=-i:n>i&&(n=i)):(n=W,i=f);var X=L*b-F*h,Q=O*b-H*h,Y=_/(A+g.inverseInertia*X*X+x.inverseInertia*Q*Q),Z=(1+m.restitution)*U*Y;if(n*=Y,U<u)V.normalImpulse=0;else{var $=V.normalImpulse;V.normalImpulse+=Z,V.normalImpulse>0&&(V.normalImpulse=0),Z=V.normalImpulse-$}if(W<-d||W>d)V.tangentImpulse=0;else{var J=V.tangentImpulse;V.tangentImpulse+=n,V.tangentImpulse<-i&&(V.tangentImpulse=-i),V.tangentImpulse>i&&(V.tangentImpulse=i),n=V.tangentImpulse-J}var K=h*Z+S*n,ee=b*Z+w*n;g.isStatic||g.isSleeping||(g.positionPrev.x+=K*g.inverseMass,g.positionPrev.y+=ee*g.inverseMass,g.anglePrev+=(L*ee-F*K)*g.inverseInertia),x.isStatic||x.isSleeping||(x.positionPrev.x-=K*x.inverseMass,x.positionPrev.y-=ee*x.inverseMass,x.anglePrev-=(O*ee-H*K)*x.inverseInertia)}}}}},function(e,t,n){var o={};e.exports=o;var i=n(9),r=n(0);o.create=function(e){return r.extend({table:{},list:[],collisionStart:[],collisionActive:[],collisionEnd:[]},e)},o.update=function(e,t,n){var o,r,a,s=i.update,l=i.create,c=i.setActive,u=e.table,d=e.list,p=d.length,f=p,v=e.collisionStart,m=e.collisionEnd,y=e.collisionActive,g=t.length,x=0,h=0,b=0;for(a=0;a<g;a++)(r=(o=t[a]).pair)?(r.isActive&&(y[b++]=r),s(r,o,n)):(u[(r=l(o,n)).id]=r,v[x++]=r,d[f++]=r);for(f=0,p=d.length,a=0;a<p;a++)(r=d[a]).timeUpdated>=n?d[f++]=r:(c(r,!1,n),r.collision.bodyA.sleepCounter>0&&r.collision.bodyB.sleepCounter>0?d[f++]=r:(m[h++]=r,delete u[r.id]));d.length!==f&&(d.length=f),v.length!==x&&(v.length=x),m.length!==h&&(m.length=h),y.length!==b&&(y.length=b)},o.clear=function(e){return e.table={},e.list.length=0,e.collisionStart.length=0,e.collisionActive.length=0,e.collisionEnd.length=0,e}},function(e,t,n){var o=e.exports=n(21);o.Axes=n(11),o.Bodies=n(12),o.Body=n(4),o.Bounds=n(1),o.Collision=n(8),o.Common=n(0),o.Composite=n(6),o.Composites=n(22),o.Constraint=n(10),o.Contact=n(16),o.Detector=n(13),o.Engine=n(17),o.Events=n(5),o.Grid=n(23),o.Mouse=n(14),o.MouseConstraint=n(24),o.Pair=n(9),o.Pairs=n(19),o.Plugin=n(15),o.Query=n(25),o.Render=n(26),o.Resolver=n(18),o.Runner=n(27),o.SAT=n(28),o.Sleeping=n(7),o.Svg=n(29),o.Vector=n(2),o.Vertices=n(3),o.World=n(30),o.Engine.run=o.Runner.run,o.Common.deprecated(o.Engine,"run","Engine.run ➤ use Matter.Runner.run(engine) instead")},function(e,t,n){var o={};e.exports=o;var i=n(15),r=n(0);o.name="matter-js",o.version="0.20.0",o.uses=[],o.used=[],o.use=function(){i.use(o,Array.prototype.slice.call(arguments))},o.before=function(e,t){return e=e.replace(/^Matter./,""),r.chainPathBefore(o,e,t)},o.after=function(e,t){return e=e.replace(/^Matter./,""),r.chainPathAfter(o,e,t)}},function(e,t,n){var o={};e.exports=o;var i=n(6),r=n(10),a=n(0),s=n(4),l=n(12),c=a.deprecated;o.stack=function(e,t,n,o,r,a,l){for(var c,u=i.create({label:"Stack"}),d=e,p=t,f=0,v=0;v<o;v++){for(var m=0,y=0;y<n;y++){var g=l(d,p,y,v,c,f);if(g){var x=g.bounds.max.y-g.bounds.min.y,h=g.bounds.max.x-g.bounds.min.x;x>m&&(m=x),s.translate(g,{x:.5*h,y:.5*x}),d=g.bounds.max.x+r,i.addBody(u,g),c=g,f+=1}else d+=r}p+=m+a,d=e}return u},o.chain=function(e,t,n,o,s,l){for(var c=e.bodies,u=1;u<c.length;u++){var d=c[u-1],p=c[u],f=d.bounds.max.y-d.bounds.min.y,v=d.bounds.max.x-d.bounds.min.x,m=p.bounds.max.y-p.bounds.min.y,y={bodyA:d,pointA:{x:v*t,y:f*n},bodyB:p,pointB:{x:(p.bounds.max.x-p.bounds.min.x)*o,y:m*s}},g=a.extend(y,l);i.addConstraint(e,r.create(g))}return e.label+=" Chain",e},o.mesh=function(e,t,n,o,s){var l,c,u,d,p,f=e.bodies;for(l=0;l<n;l++){for(c=1;c<t;c++)u=f[c-1+l*t],d=f[c+l*t],i.addConstraint(e,r.create(a.extend({bodyA:u,bodyB:d},s)));if(l>0)for(c=0;c<t;c++)u=f[c+(l-1)*t],d=f[c+l*t],i.addConstraint(e,r.create(a.extend({bodyA:u,bodyB:d},s))),o&&c>0&&(p=f[c-1+(l-1)*t],i.addConstraint(e,r.create(a.extend({bodyA:p,bodyB:d},s)))),o&&c<t-1&&(p=f[c+1+(l-1)*t],i.addConstraint(e,r.create(a.extend({bodyA:p,bodyB:d},s))))}return e.label+=" Mesh",e},o.pyramid=function(e,t,n,i,r,a,l){return o.stack(e,t,n,i,r,a,(function(t,o,a,c,u,d){var p=Math.min(i,Math.ceil(n/2)),f=u?u.bounds.max.x-u.bounds.min.x:0;if(!(c>p||a<(c=p-c)||a>n-1-c))return 1===d&&s.translate(u,{x:(a+(n%2==1?1:-1))*f,y:0}),l(e+(u?a*f:0)+a*r,o,a,c,u,d)}))},o.newtonsCradle=function(e,t,n,o,a){for(var s=i.create({label:"Newtons Cradle"}),c=0;c<n;c++){var u=l.circle(e+c*(1.9*o),t+a,o,{inertia:1/0,restitution:1,friction:0,frictionAir:1e-4,slop:1}),d=r.create({pointA:{x:e+c*(1.9*o),y:t},bodyB:u});i.addBody(s,u),i.addConstraint(s,d)}return s},c(o,"newtonsCradle","Composites.newtonsCradle ➤ moved to newtonsCradle example"),o.car=function(e,t,n,o,a){var c=s.nextGroup(!0),u=.5*-n+20,d=.5*n-20,p=i.create({label:"Car"}),f=l.rectangle(e,t,n,o,{collisionFilter:{group:c},chamfer:{radius:.5*o},density:2e-4}),v=l.circle(e+u,t+0,a,{collisionFilter:{group:c},friction:.8}),m=l.circle(e+d,t+0,a,{collisionFilter:{group:c},friction:.8}),y=r.create({bodyB:f,pointB:{x:u,y:0},bodyA:v,stiffness:1,length:0}),g=r.create({bodyB:f,pointB:{x:d,y:0},bodyA:m,stiffness:1,length:0});return i.addBody(p,f),i.addBody(p,v),i.addBody(p,m),i.addConstraint(p,y),i.addConstraint(p,g),p},c(o,"car","Composites.car ➤ moved to car example"),o.softBody=function(e,t,n,i,r,s,c,u,d,p){d=a.extend({inertia:1/0},d),p=a.extend({stiffness:.2,render:{type:"line",anchors:!1}},p);var f=o.stack(e,t,n,i,r,s,(function(e,t){return l.circle(e,t,u,d)}));return o.mesh(f,n,i,c,p),f.label="Soft Body",f},c(o,"softBody","Composites.softBody ➤ moved to softBody and cloth examples")},function(e,t,n){var o={};e.exports=o;var i=n(9),r=n(0),a=r.deprecated;o.create=function(e){return r.extend({buckets:{},pairs:{},pairsList:[],bucketWidth:48,bucketHeight:48},e)},o.update=function(e,t,n,i){var r,a,s,l,c,u=n.world,d=e.buckets,p=!1;for(r=0;r<t.length;r++){var f=t[r];if((!f.isSleeping||i)&&(!u.bounds||!(f.bounds.max.x<u.bounds.min.x||f.bounds.min.x>u.bounds.max.x||f.bounds.max.y<u.bounds.min.y||f.bounds.min.y>u.bounds.max.y))){var v=o._getRegion(e,f);if(!f.region||v.id!==f.region.id||i){f.region&&!i||(f.region=v);var m=o._regionUnion(v,f.region);for(a=m.startCol;a<=m.endCol;a++)for(s=m.startRow;s<=m.endRow;s++){l=d[c=o._getBucketId(a,s)];var y=a>=v.startCol&&a<=v.endCol&&s>=v.startRow&&s<=v.endRow,g=a>=f.region.startCol&&a<=f.region.endCol&&s>=f.region.startRow&&s<=f.region.endRow;!y&&g&&g&&l&&o._bucketRemoveBody(e,l,f),(f.region===v||y&&!g||i)&&(l||(l=o._createBucket(d,c)),o._bucketAddBody(e,l,f))}f.region=v,p=!0}}}p&&(e.pairsList=o._createActivePairsList(e))},a(o,"update","Grid.update ➤ replaced by Matter.Detector"),o.clear=function(e){e.buckets={},e.pairs={},e.pairsList=[]},a(o,"clear","Grid.clear ➤ replaced by Matter.Detector"),o._regionUnion=function(e,t){var n=Math.min(e.startCol,t.startCol),i=Math.max(e.endCol,t.endCol),r=Math.min(e.startRow,t.startRow),a=Math.max(e.endRow,t.endRow);return o._createRegion(n,i,r,a)},o._getRegion=function(e,t){var n=t.bounds,i=Math.floor(n.min.x/e.bucketWidth),r=Math.floor(n.max.x/e.bucketWidth),a=Math.floor(n.min.y/e.bucketHeight),s=Math.floor(n.max.y/e.bucketHeight);return o._createRegion(i,r,a,s)},o._createRegion=function(e,t,n,o){return{id:e+","+t+","+n+","+o,startCol:e,endCol:t,startRow:n,endRow:o}},o._getBucketId=function(e,t){return"C"+e+"R"+t},o._createBucket=function(e,t){return e[t]=[]},o._bucketAddBody=function(e,t,n){var o,r=e.pairs,a=i.id,s=t.length;for(o=0;o<s;o++){var l=t[o];if(!(n.id===l.id||n.isStatic&&l.isStatic)){var c=a(n,l),u=r[c];u?u[2]+=1:r[c]=[n,l,1]}}t.push(n)},o._bucketRemoveBody=function(e,t,n){var o,a=e.pairs,s=i.id;t.splice(r.indexOf(t,n),1);var l=t.length;for(o=0;o<l;o++){var c=a[s(n,t[o])];c&&(c[2]-=1)}},o._createActivePairsList=function(e){var t,n,o=e.pairs,i=r.keys(o),a=i.length,s=[];for(n=0;n<a;n++)(t=o[i[n]])[2]>0?s.push(t):delete o[i[n]];return s}},function(e,t,n){var o={};e.exports=o;var i=n(3),r=n(7),a=n(14),s=n(5),l=n(13),c=n(10),u=n(6),d=n(0),p=n(1);o.create=function(e,t){var n=(e?e.mouse:null)||(t?t.mouse:null);n||(e&&e.render&&e.render.canvas?n=a.create(e.render.canvas):t&&t.element?n=a.create(t.element):(n=a.create(),d.warn("MouseConstraint.create: options.mouse was undefined, options.element was undefined, may not function as expected")));var i={type:"mouseConstraint",mouse:n,element:null,body:null,constraint:c.create({label:"Mouse Constraint",pointA:n.position,pointB:{x:0,y:0},length:.01,stiffness:.1,angularStiffness:1,render:{strokeStyle:"#90EE90",lineWidth:3}}),collisionFilter:{category:1,mask:4294967295,group:0}},r=d.extend(i,t);return s.on(e,"beforeUpdate",(function(){var t=u.allBodies(e.world);o.update(r,t),o._triggerEvents(r)})),r},o.update=function(e,t){var n=e.mouse,o=e.constraint,a=e.body;if(0===n.button){if(o.bodyB)r.set(o.bodyB,!1),o.pointA=n.position;else for(var c=0;c<t.length;c++)if(a=t[c],p.contains(a.bounds,n.position)&&l.canCollide(a.collisionFilter,e.collisionFilter))for(var u=a.parts.length>1?1:0;u<a.parts.length;u++){var d=a.parts[u];if(i.contains(d.vertices,n.position)){o.pointA=n.position,o.bodyB=e.body=a,o.pointB={x:n.position.x-a.position.x,y:n.position.y-a.position.y},o.angleB=a.angle,r.set(a,!1),s.trigger(e,"startdrag",{mouse:n,body:a});break}}}else o.bodyB=e.body=null,o.pointB=null,a&&s.trigger(e,"enddrag",{mouse:n,body:a})},o._triggerEvents=function(e){var t=e.mouse,n=t.sourceEvents;n.mousemove&&s.trigger(e,"mousemove",{mouse:t}),n.mousedown&&s.trigger(e,"mousedown",{mouse:t}),n.mouseup&&s.trigger(e,"mouseup",{mouse:t}),a.clearSourceEvents(t)}},function(e,t,n){var o={};e.exports=o;var i=n(2),r=n(8),a=n(1),s=n(12),l=n(3);o.collides=function(e,t){for(var n=[],o=t.length,i=e.bounds,s=r.collides,l=a.overlaps,c=0;c<o;c++){var u=t[c],d=u.parts.length,p=1===d?0:1;if(l(u.bounds,i))for(var f=p;f<d;f++){var v=u.parts[f];if(l(v.bounds,i)){var m=s(v,e);if(m){n.push(m);break}}}}return n},o.ray=function(e,t,n,r){r=r||1e-100;for(var a=i.angle(t,n),l=i.magnitude(i.sub(t,n)),c=.5*(n.x+t.x),u=.5*(n.y+t.y),d=s.rectangle(c,u,l,r,{angle:a}),p=o.collides(d,e),f=0;f<p.length;f+=1){var v=p[f];v.body=v.bodyB=v.bodyA}return p},o.region=function(e,t,n){for(var o=[],i=0;i<e.length;i++){var r=e[i],s=a.overlaps(r.bounds,t);(s&&!n||!s&&n)&&o.push(r)}return o},o.point=function(e,t){for(var n=[],o=0;o<e.length;o++){var i=e[o];if(a.contains(i.bounds,t))for(var r=1===i.parts.length?0:1;r<i.parts.length;r++){var s=i.parts[r];if(a.contains(s.bounds,t)&&l.contains(s.vertices,t)){n.push(i);break}}}return n}},function(e,t,n){var o={};e.exports=o;var i=n(4),r=n(0),a=n(6),s=n(1),l=n(5),c=n(2),u=n(14);!function(){var e,t;"undefined"!=typeof window&&(e=window.requestAnimationFrame||window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame||window.msRequestAnimationFrame||function(e){window.setTimeout((function(){e(r.now())}),1e3/60)},t=window.cancelAnimationFrame||window.mozCancelAnimationFrame||window.webkitCancelAnimationFrame||window.msCancelAnimationFrame),o._goodFps=30,o._goodDelta=1e3/60,o.create=function(e){var t={engine:null,element:null,canvas:null,mouse:null,frameRequestId:null,timing:{historySize:60,delta:0,deltaHistory:[],lastTime:0,lastTimestamp:0,lastElapsed:0,timestampElapsed:0,timestampElapsedHistory:[],engineDeltaHistory:[],engineElapsedHistory:[],engineUpdatesHistory:[],elapsedHistory:[]},options:{width:800,height:600,pixelRatio:1,background:"#14151f",wireframeBackground:"#14151f",wireframeStrokeStyle:"#bbb",hasBounds:!!e.bounds,enabled:!0,wireframes:!0,showSleeping:!0,showDebug:!1,showStats:!1,showPerformance:!1,showBounds:!1,showVelocity:!1,showCollisions:!1,showSeparations:!1,showAxes:!1,showPositions:!1,showAngleIndicator:!1,showIds:!1,showVertexNumbers:!1,showConvexHulls:!1,showInternalEdges:!1,showMousePosition:!1}},n=r.extend(t,e);return n.canvas&&(n.canvas.width=n.options.width||n.canvas.width,n.canvas.height=n.options.height||n.canvas.height),n.mouse=e.mouse,n.engine=e.engine,n.canvas=n.canvas||p(n.options.width,n.options.height),n.context=n.canvas.getContext("2d"),n.textures={},n.bounds=n.bounds||{min:{x:0,y:0},max:{x:n.canvas.width,y:n.canvas.height}},n.controller=o,n.options.showBroadphase=!1,1!==n.options.pixelRatio&&o.setPixelRatio(n,n.options.pixelRatio),r.isElement(n.element)&&n.element.appendChild(n.canvas),n},o.run=function(t){!function i(r){t.frameRequestId=e(i),n(t,r),o.world(t,r),t.context.setTransform(t.options.pixelRatio,0,0,t.options.pixelRatio,0,0),(t.options.showStats||t.options.showDebug)&&o.stats(t,t.context,r),(t.options.showPerformance||t.options.showDebug)&&o.performance(t,t.context,r),t.context.setTransform(1,0,0,1,0,0)}()},o.stop=function(e){t(e.frameRequestId)},o.setPixelRatio=function(e,t){var n=e.options,o=e.canvas;"auto"===t&&(t=f(o)),n.pixelRatio=t,o.setAttribute("data-pixel-ratio",t),o.width=n.width*t,o.height=n.height*t,o.style.width=n.width+"px",o.style.height=n.height+"px"},o.setSize=function(e,t,n){e.options.width=t,e.options.height=n,e.bounds.max.x=e.bounds.min.x+t,e.bounds.max.y=e.bounds.min.y+n,1!==e.options.pixelRatio?o.setPixelRatio(e,e.options.pixelRatio):(e.canvas.width=t,e.canvas.height=n)},o.lookAt=function(e,t,n,o){o=void 0===o||o,t=r.isArray(t)?t:[t],n=n||{x:0,y:0};for(var i={min:{x:1/0,y:1/0},max:{x:-1/0,y:-1/0}},a=0;a<t.length;a+=1){var s=t[a],l=s.bounds?s.bounds.min:s.min||s.position||s,c=s.bounds?s.bounds.max:s.max||s.position||s;l&&c&&(l.x<i.min.x&&(i.min.x=l.x),c.x>i.max.x&&(i.max.x=c.x),l.y<i.min.y&&(i.min.y=l.y),c.y>i.max.y&&(i.max.y=c.y))}var d=i.max.x-i.min.x+2*n.x,p=i.max.y-i.min.y+2*n.y,f=e.canvas.height,v=e.canvas.width/f,m=d/p,y=1,g=1;m>v?g=m/v:y=v/m,e.options.hasBounds=!0,e.bounds.min.x=i.min.x,e.bounds.max.x=i.min.x+d*y,e.bounds.min.y=i.min.y,e.bounds.max.y=i.min.y+p*g,o&&(e.bounds.min.x+=.5*d-d*y*.5,e.bounds.max.x+=.5*d-d*y*.5,e.bounds.min.y+=.5*p-p*g*.5,e.bounds.max.y+=.5*p-p*g*.5),e.bounds.min.x-=n.x,e.bounds.max.x-=n.x,e.bounds.min.y-=n.y,e.bounds.max.y-=n.y,e.mouse&&(u.setScale(e.mouse,{x:(e.bounds.max.x-e.bounds.min.x)/e.canvas.width,y:(e.bounds.max.y-e.bounds.min.y)/e.canvas.height}),u.setOffset(e.mouse,e.bounds.min))},o.startViewTransform=function(e){var t=e.bounds.max.x-e.bounds.min.x,n=e.bounds.max.y-e.bounds.min.y,o=t/e.options.width,i=n/e.options.height;e.context.setTransform(e.options.pixelRatio/o,0,0,e.options.pixelRatio/i,0,0),e.context.translate(-e.bounds.min.x,-e.bounds.min.y)},o.endViewTransform=function(e){e.context.setTransform(e.options.pixelRatio,0,0,e.options.pixelRatio,0,0)},o.world=function(e,t){var n,i=r.now(),d=e.engine,p=d.world,f=e.canvas,v=e.context,y=e.options,g=e.timing,x=a.allBodies(p),h=a.allConstraints(p),b=y.wireframes?y.wireframeBackground:y.background,S=[],w=[],A={timestamp:d.timing.timestamp};if(l.trigger(e,"beforeRender",A),e.currentBackground!==b&&m(e,b),v.globalCompositeOperation="source-in",v.fillStyle="transparent",v.fillRect(0,0,f.width,f.height),v.globalCompositeOperation="source-over",y.hasBounds){for(n=0;n<x.length;n++){var P=x[n];s.overlaps(P.bounds,e.bounds)&&S.push(P)}for(n=0;n<h.length;n++){var B=h[n],M=B.bodyA,_=B.bodyB,C=B.pointA,k=B.pointB;M&&(C=c.add(M.position,B.pointA)),_&&(k=c.add(_.position,B.pointB)),C&&k&&((s.contains(e.bounds,C)||s.contains(e.bounds,k))&&w.push(B))}o.startViewTransform(e),e.mouse&&(u.setScale(e.mouse,{x:(e.bounds.max.x-e.bounds.min.x)/e.options.width,y:(e.bounds.max.y-e.bounds.min.y)/e.options.height}),u.setOffset(e.mouse,e.bounds.min))}else w=h,S=x,1!==e.options.pixelRatio&&e.context.setTransform(e.options.pixelRatio,0,0,e.options.pixelRatio,0,0);!y.wireframes||d.enableSleeping&&y.showSleeping?o.bodies(e,S,v):(y.showConvexHulls&&o.bodyConvexHulls(e,S,v),o.bodyWireframes(e,S,v)),y.showBounds&&o.bodyBounds(e,S,v),(y.showAxes||y.showAngleIndicator)&&o.bodyAxes(e,S,v),y.showPositions&&o.bodyPositions(e,S,v),y.showVelocity&&o.bodyVelocity(e,S,v),y.showIds&&o.bodyIds(e,S,v),y.showSeparations&&o.separations(e,d.pairs.list,v),y.showCollisions&&o.collisions(e,d.pairs.list,v),y.showVertexNumbers&&o.vertexNumbers(e,S,v),y.showMousePosition&&o.mousePosition(e,e.mouse,v),o.constraints(w,v),y.hasBounds&&o.endViewTransform(e),l.trigger(e,"afterRender",A),g.lastElapsed=r.now()-i},o.stats=function(e,t,n){for(var o=e.engine,i=o.world,r=a.allBodies(i),s=0,l=0,c=0;c<r.length;c+=1)s+=r[c].parts.length;var u={Part:s,Body:r.length,Cons:a.allConstraints(i).length,Comp:a.allComposites(i).length,Pair:o.pairs.list.length};for(var d in t.fillStyle="#0e0f19",t.fillRect(l,0,302.5,44),t.font="12px Arial",t.textBaseline="top",t.textAlign="right",u){var p=u[d];t.fillStyle="#aaa",t.fillText(d,l+55,8),t.fillStyle="#eee",t.fillText(p,l+55,26),l+=55}},o.performance=function(e,t){var n=e.engine,i=e.timing,a=i.deltaHistory,s=i.elapsedHistory,l=i.timestampElapsedHistory,c=i.engineDeltaHistory,u=i.engineUpdatesHistory,p=i.engineElapsedHistory,f=n.timing.lastUpdatesPerFrame,v=n.timing.lastDelta,m=d(a),y=d(s),g=d(c),x=d(u),h=d(p),b=d(l)/m||0,S=Math.round(m/v),w=1e3/m||0,A=10,P=69;t.fillStyle="#0e0f19",t.fillRect(0,50,442,34),o.status(t,A,P,60,4,a.length,Math.round(w)+" fps",w/o._goodFps,(function(e){return a[e]/m-1})),o.status(t,82,P,60,4,c.length,v.toFixed(2)+" dt",o._goodDelta/v,(function(e){return c[e]/g-1})),o.status(t,154,P,60,4,u.length,f+" upf",Math.pow(r.clamp(x/S||1,0,1),4),(function(e){return u[e]/x-1})),o.status(t,226,P,60,4,p.length,h.toFixed(2)+" ut",1-f*h/o._goodFps,(function(e){return p[e]/h-1})),o.status(t,298,P,60,4,s.length,y.toFixed(2)+" rt",1-y/o._goodFps,(function(e){return s[e]/y-1})),o.status(t,370,P,60,4,l.length,b.toFixed(2)+" x",b*b*b,(function(e){return(l[e]/a[e]/b||0)-1}))},o.status=function(e,t,n,o,i,a,s,l,c){e.strokeStyle="#888",e.fillStyle="#444",e.lineWidth=1,e.fillRect(t,n+7,o,1),e.beginPath(),e.moveTo(t,n+7-i*r.clamp(.4*c(0),-2,2));for(var u=0;u<o;u+=1)e.lineTo(t+u,n+7-(u<a?i*r.clamp(.4*c(u),-2,2):0));e.stroke(),e.fillStyle="hsl("+r.clamp(25+95*l,0,120)+",100%,60%)",e.fillRect(t,n-7,4,4),e.font="12px Arial",e.textBaseline="middle",e.textAlign="right",e.fillStyle="#eee",e.fillText(s,t+o,n-5)},o.constraints=function(e,t){for(var n=t,o=0;o<e.length;o++){var i=e[o];if(i.render.visible&&i.pointA&&i.pointB){var a,s,l=i.bodyA,u=i.bodyB;if(a=l?c.add(l.position,i.pointA):i.pointA,"pin"===i.render.type)n.beginPath(),n.arc(a.x,a.y,3,0,2*Math.PI),n.closePath();else{if(s=u?c.add(u.position,i.pointB):i.pointB,n.beginPath(),n.moveTo(a.x,a.y),"spring"===i.render.type)for(var d,p=c.sub(s,a),f=c.perp(c.normalise(p)),v=Math.ceil(r.clamp(i.length/5,12,20)),m=1;m<v;m+=1)d=m%2==0?1:-1,n.lineTo(a.x+p.x*(m/v)+f.x*d*4,a.y+p.y*(m/v)+f.y*d*4);n.lineTo(s.x,s.y)}i.render.lineWidth&&(n.lineWidth=i.render.lineWidth,n.strokeStyle=i.render.strokeStyle,n.stroke()),i.render.anchors&&(n.fillStyle=i.render.strokeStyle,n.beginPath(),n.arc(a.x,a.y,3,0,2*Math.PI),n.arc(s.x,s.y,3,0,2*Math.PI),n.closePath(),n.fill())}}},o.bodies=function(e,t,n){var o,i,r,a,s=n,l=(e.engine,e.options),c=l.showInternalEdges||!l.wireframes;for(r=0;r<t.length;r++)if((o=t[r]).render.visible)for(a=o.parts.length>1?1:0;a<o.parts.length;a++)if((i=o.parts[a]).render.visible){if(l.showSleeping&&o.isSleeping?s.globalAlpha=.5*i.render.opacity:1!==i.render.opacity&&(s.globalAlpha=i.render.opacity),i.render.sprite&&i.render.sprite.texture&&!l.wireframes){var u=i.render.sprite,d=v(e,u.texture);s.translate(i.position.x,i.position.y),s.rotate(i.angle),s.drawImage(d,d.width*-u.xOffset*u.xScale,d.height*-u.yOffset*u.yScale,d.width*u.xScale,d.height*u.yScale),s.rotate(-i.angle),s.translate(-i.position.x,-i.position.y)}else{if(i.circleRadius)s.beginPath(),s.arc(i.position.x,i.position.y,i.circleRadius,0,2*Math.PI);else{s.beginPath(),s.moveTo(i.vertices[0].x,i.vertices[0].y);for(var p=1;p<i.vertices.length;p++)!i.vertices[p-1].isInternal||c?s.lineTo(i.vertices[p].x,i.vertices[p].y):s.moveTo(i.vertices[p].x,i.vertices[p].y),i.vertices[p].isInternal&&!c&&s.moveTo(i.vertices[(p+1)%i.vertices.length].x,i.vertices[(p+1)%i.vertices.length].y);s.lineTo(i.vertices[0].x,i.vertices[0].y),s.closePath()}l.wireframes?(s.lineWidth=1,s.strokeStyle=e.options.wireframeStrokeStyle,s.stroke()):(s.fillStyle=i.render.fillStyle,i.render.lineWidth&&(s.lineWidth=i.render.lineWidth,s.strokeStyle=i.render.strokeStyle,s.stroke()),s.fill())}s.globalAlpha=1}},o.bodyWireframes=function(e,t,n){var o,i,r,a,s,l=n,c=e.options.showInternalEdges;for(l.beginPath(),r=0;r<t.length;r++)if((o=t[r]).render.visible)for(s=o.parts.length>1?1:0;s<o.parts.length;s++){for(i=o.parts[s],l.moveTo(i.vertices[0].x,i.vertices[0].y),a=1;a<i.vertices.length;a++)!i.vertices[a-1].isInternal||c?l.lineTo(i.vertices[a].x,i.vertices[a].y):l.moveTo(i.vertices[a].x,i.vertices[a].y),i.vertices[a].isInternal&&!c&&l.moveTo(i.vertices[(a+1)%i.vertices.length].x,i.vertices[(a+1)%i.vertices.length].y);l.lineTo(i.vertices[0].x,i.vertices[0].y)}l.lineWidth=1,l.strokeStyle=e.options.wireframeStrokeStyle,l.stroke()},o.bodyConvexHulls=function(e,t,n){var o,i,r,a=n;for(a.beginPath(),i=0;i<t.length;i++)if((o=t[i]).render.visible&&1!==o.parts.length){for(a.moveTo(o.vertices[0].x,o.vertices[0].y),r=1;r<o.vertices.length;r++)a.lineTo(o.vertices[r].x,o.vertices[r].y);a.lineTo(o.vertices[0].x,o.vertices[0].y)}a.lineWidth=1,a.strokeStyle="rgba(255,255,255,0.2)",a.stroke()},o.vertexNumbers=function(e,t,n){var o,i,r,a=n;for(o=0;o<t.length;o++){var s=t[o].parts;for(r=s.length>1?1:0;r<s.length;r++){var l=s[r];for(i=0;i<l.vertices.length;i++)a.fillStyle="rgba(255,255,255,0.2)",a.fillText(o+"_"+i,l.position.x+.8*(l.vertices[i].x-l.position.x),l.position.y+.8*(l.vertices[i].y-l.position.y))}}},o.mousePosition=function(e,t,n){var o=n;o.fillStyle="rgba(255,255,255,0.8)",o.fillText(t.position.x+"  "+t.position.y,t.position.x+5,t.position.y-5)},o.bodyBounds=function(e,t,n){var o=n,i=(e.engine,e.options);o.beginPath();for(var r=0;r<t.length;r++){if(t[r].render.visible)for(var a=t[r].parts,s=a.length>1?1:0;s<a.length;s++){var l=a[s];o.rect(l.bounds.min.x,l.bounds.min.y,l.bounds.max.x-l.bounds.min.x,l.bounds.max.y-l.bounds.min.y)}}i.wireframes?o.strokeStyle="rgba(255,255,255,0.08)":o.strokeStyle="rgba(0,0,0,0.1)",o.lineWidth=1,o.stroke()},o.bodyAxes=function(e,t,n){var o,i,r,a,s=n,l=(e.engine,e.options);for(s.beginPath(),i=0;i<t.length;i++){var c=t[i],u=c.parts;if(c.render.visible)if(l.showAxes)for(r=u.length>1?1:0;r<u.length;r++)for(o=u[r],a=0;a<o.axes.length;a++){var d=o.axes[a];s.moveTo(o.position.x,o.position.y),s.lineTo(o.position.x+20*d.x,o.position.y+20*d.y)}else for(r=u.length>1?1:0;r<u.length;r++)for(o=u[r],a=0;a<o.axes.length;a++)s.moveTo(o.position.x,o.position.y),s.lineTo((o.vertices[0].x+o.vertices[o.vertices.length-1].x)/2,(o.vertices[0].y+o.vertices[o.vertices.length-1].y)/2)}l.wireframes?(s.strokeStyle="indianred",s.lineWidth=1):(s.strokeStyle="rgba(255, 255, 255, 0.4)",s.globalCompositeOperation="overlay",s.lineWidth=2),s.stroke(),s.globalCompositeOperation="source-over"},o.bodyPositions=function(e,t,n){var o,i,r,a,s=n,l=(e.engine,e.options);for(s.beginPath(),r=0;r<t.length;r++)if((o=t[r]).render.visible)for(a=0;a<o.parts.length;a++)i=o.parts[a],s.arc(i.position.x,i.position.y,3,0,2*Math.PI,!1),s.closePath();for(l.wireframes?s.fillStyle="indianred":s.fillStyle="rgba(0,0,0,0.5)",s.fill(),s.beginPath(),r=0;r<t.length;r++)(o=t[r]).render.visible&&(s.arc(o.positionPrev.x,o.positionPrev.y,2,0,2*Math.PI,!1),s.closePath());s.fillStyle="rgba(255,165,0,0.8)",s.fill()},o.bodyVelocity=function(e,t,n){var o=n;o.beginPath();for(var r=0;r<t.length;r++){var a=t[r];if(a.render.visible){var s=i.getVelocity(a);o.moveTo(a.position.x,a.position.y),o.lineTo(a.position.x+s.x,a.position.y+s.y)}}o.lineWidth=3,o.strokeStyle="cornflowerblue",o.stroke()},o.bodyIds=function(e,t,n){var o,i,r=n;for(o=0;o<t.length;o++)if(t[o].render.visible){var a=t[o].parts;for(i=a.length>1?1:0;i<a.length;i++){var s=a[i];r.font="12px Arial",r.fillStyle="rgba(255,255,255,0.5)",r.fillText(s.id,s.position.x+10,s.position.y-10)}}},o.collisions=function(e,t,n){var o,i,r,a,s=n,l=e.options;for(s.beginPath(),r=0;r<t.length;r++)if((o=t[r]).isActive)for(i=o.collision,a=0;a<o.contactCount;a++){var c=o.contacts[a].vertex;s.rect(c.x-1.5,c.y-1.5,3.5,3.5)}for(l.wireframes?s.fillStyle="rgba(255,255,255,0.7)":s.fillStyle="orange",s.fill(),s.beginPath(),r=0;r<t.length;r++)if((o=t[r]).isActive&&(i=o.collision,o.contactCount>0)){var u=o.contacts[0].vertex.x,d=o.contacts[0].vertex.y;2===o.contactCount&&(u=(o.contacts[0].vertex.x+o.contacts[1].vertex.x)/2,d=(o.contacts[0].vertex.y+o.contacts[1].vertex.y)/2),i.bodyB===i.supports[0].body||!0===i.bodyA.isStatic?s.moveTo(u-8*i.normal.x,d-8*i.normal.y):s.moveTo(u+8*i.normal.x,d+8*i.normal.y),s.lineTo(u,d)}l.wireframes?s.strokeStyle="rgba(255,165,0,0.7)":s.strokeStyle="orange",s.lineWidth=1,s.stroke()},o.separations=function(e,t,n){var o,i,r,a,s,l=n,c=e.options;for(l.beginPath(),s=0;s<t.length;s++)if((o=t[s]).isActive){r=(i=o.collision).bodyA;var u=1;(a=i.bodyB).isStatic||r.isStatic||(u=.5),a.isStatic&&(u=0),l.moveTo(a.position.x,a.position.y),l.lineTo(a.position.x-i.penetration.x*u,a.position.y-i.penetration.y*u),u=1,a.isStatic||r.isStatic||(u=.5),r.isStatic&&(u=0),l.moveTo(r.position.x,r.position.y),l.lineTo(r.position.x+i.penetration.x*u,r.position.y+i.penetration.y*u)}c.wireframes?l.strokeStyle="rgba(255,165,0,0.5)":l.strokeStyle="orange",l.stroke()},o.inspector=function(e,t){e.engine;var n,o=e.selected,i=e.render,r=i.options;if(r.hasBounds){var a=i.bounds.max.x-i.bounds.min.x,s=i.bounds.max.y-i.bounds.min.y,l=a/i.options.width,c=s/i.options.height;t.scale(1/l,1/c),t.translate(-i.bounds.min.x,-i.bounds.min.y)}for(var u=0;u<o.length;u++){var d=o[u].data;switch(t.translate(.5,.5),t.lineWidth=1,t.strokeStyle="rgba(255,165,0,0.9)",t.setLineDash([1,2]),d.type){case"body":n=d.bounds,t.beginPath(),t.rect(Math.floor(n.min.x-3),Math.floor(n.min.y-3),Math.floor(n.max.x-n.min.x+6),Math.floor(n.max.y-n.min.y+6)),t.closePath(),t.stroke();break;case"constraint":var p=d.pointA;d.bodyA&&(p=d.pointB),t.beginPath(),t.arc(p.x,p.y,10,0,2*Math.PI),t.closePath(),t.stroke()}t.setLineDash([]),t.translate(-.5,-.5)}null!==e.selectStart&&(t.translate(.5,.5),t.lineWidth=1,t.strokeStyle="rgba(255,165,0,0.6)",t.fillStyle="rgba(255,165,0,0.1)",n=e.selectBounds,t.beginPath(),t.rect(Math.floor(n.min.x),Math.floor(n.min.y),Math.floor(n.max.x-n.min.x),Math.floor(n.max.y-n.min.y)),t.closePath(),t.stroke(),t.fill(),t.translate(-.5,-.5)),r.hasBounds&&t.setTransform(1,0,0,1,0,0)};var n=function(e,t){var n=e.engine,i=e.timing,r=i.historySize,a=n.timing.timestamp;i.delta=t-i.lastTime||o._goodDelta,i.lastTime=t,i.timestampElapsed=a-i.lastTimestamp||0,i.lastTimestamp=a,i.deltaHistory.unshift(i.delta),i.deltaHistory.length=Math.min(i.deltaHistory.length,r),i.engineDeltaHistory.unshift(n.timing.lastDelta),i.engineDeltaHistory.length=Math.min(i.engineDeltaHistory.length,r),i.timestampElapsedHistory.unshift(i.timestampElapsed),i.timestampElapsedHistory.length=Math.min(i.timestampElapsedHistory.length,r),i.engineUpdatesHistory.unshift(n.timing.lastUpdatesPerFrame),i.engineUpdatesHistory.length=Math.min(i.engineUpdatesHistory.length,r),i.engineElapsedHistory.unshift(n.timing.lastElapsed),i.engineElapsedHistory.length=Math.min(i.engineElapsedHistory.length,r),i.elapsedHistory.unshift(i.lastElapsed),i.elapsedHistory.length=Math.min(i.elapsedHistory.length,r)},d=function(e){for(var t=0,n=0;n<e.length;n+=1)t+=e[n];return t/e.length||0},p=function(e,t){var n=document.createElement("canvas");return n.width=e,n.height=t,n.oncontextmenu=function(){return!1},n.onselectstart=function(){return!1},n},f=function(e){var t=e.getContext("2d");return(window.devicePixelRatio||1)/(t.webkitBackingStorePixelRatio||t.mozBackingStorePixelRatio||t.msBackingStorePixelRatio||t.oBackingStorePixelRatio||t.backingStorePixelRatio||1)},v=function(e,t){var n=e.textures[t];return n||((n=e.textures[t]=new Image).src=t,n)},m=function(e,t){var n=t;/(jpg|gif|png)$/.test(t)&&(n="url("+t+")"),e.canvas.style.background=n,e.canvas.style.backgroundSize="contain",e.currentBackground=t}}()},function(e,t,n){var o={};e.exports=o;var i=n(5),r=n(17),a=n(0);!function(){o._maxFrameDelta=1e3/15,o._frameDeltaFallback=1e3/60,o._timeBufferMargin=1.5,o._elapsedNextEstimate=1,o._smoothingLowerBound=.1,o._smoothingUpperBound=.9,o.create=function(e){var t=a.extend({delta:1e3/60,frameDelta:null,frameDeltaSmoothing:!0,frameDeltaSnapping:!0,frameDeltaHistory:[],frameDeltaHistorySize:100,frameRequestId:null,timeBuffer:0,timeLastTick:null,maxUpdates:null,maxFrameTime:1e3/30,lastUpdatesDeferred:0,enabled:!0},e);return t.fps=0,t},o.run=function(e,t){return e.timeBuffer=o._frameDeltaFallback,function n(i){e.frameRequestId=o._onNextFrame(e,n),i&&e.enabled&&o.tick(e,t,i)}(),e},o.tick=function(t,n,s){var l=a.now(),c=t.delta,u=0,d=s-t.timeLastTick;if((!d||!t.timeLastTick||d>Math.max(o._maxFrameDelta,t.maxFrameTime))&&(d=t.frameDelta||o._frameDeltaFallback),t.frameDeltaSmoothing){t.frameDeltaHistory.push(d),t.frameDeltaHistory=t.frameDeltaHistory.slice(-t.frameDeltaHistorySize);var p=t.frameDeltaHistory.slice(0).sort(),f=t.frameDeltaHistory.slice(p.length*o._smoothingLowerBound,p.length*o._smoothingUpperBound);d=e(f)||d}t.frameDeltaSnapping&&(d=1e3/Math.round(1e3/d)),t.frameDelta=d,t.timeLastTick=s,t.timeBuffer+=t.frameDelta,t.timeBuffer=a.clamp(t.timeBuffer,0,t.frameDelta+c*o._timeBufferMargin),t.lastUpdatesDeferred=0;var v=t.maxUpdates||Math.ceil(t.maxFrameTime/c),m={timestamp:n.timing.timestamp};i.trigger(t,"beforeTick",m),i.trigger(t,"tick",m);for(var y=a.now();c>0&&t.timeBuffer>=c*o._timeBufferMargin;){i.trigger(t,"beforeUpdate",m),r.update(n,c),i.trigger(t,"afterUpdate",m),t.timeBuffer-=c,u+=1;var g=a.now()-l,x=a.now()-y,h=g+o._elapsedNextEstimate*x/u;if(u>=v||h>t.maxFrameTime){t.lastUpdatesDeferred=Math.round(Math.max(0,t.timeBuffer/c-o._timeBufferMargin));break}}n.timing.lastUpdatesPerFrame=u,i.trigger(t,"afterTick",m),t.frameDeltaHistory.length>=100&&(t.lastUpdatesDeferred&&Math.round(t.frameDelta/c)>v?a.warnOnce("Matter.Runner: runner reached runner.maxUpdates, see docs."):t.lastUpdatesDeferred&&a.warnOnce("Matter.Runner: runner reached runner.maxFrameTime, see docs."),void 0!==t.isFixed&&a.warnOnce("Matter.Runner: runner.isFixed is now redundant, see docs."),(t.deltaMin||t.deltaMax)&&a.warnOnce("Matter.Runner: runner.deltaMin and runner.deltaMax were removed, see docs."),0!==t.fps&&a.warnOnce("Matter.Runner: runner.fps was replaced by runner.delta, see docs."))},o.stop=function(e){o._cancelNextFrame(e)},o._onNextFrame=function(e,t){if("undefined"==typeof window||!window.requestAnimationFrame)throw new Error("Matter.Runner: missing required global window.requestAnimationFrame.");return e.frameRequestId=window.requestAnimationFrame(t),e.frameRequestId},o._cancelNextFrame=function(e){if("undefined"==typeof window||!window.cancelAnimationFrame)throw new Error("Matter.Runner: missing required global window.cancelAnimationFrame.");window.cancelAnimationFrame(e.frameRequestId)};var e=function(e){for(var t=0,n=e.length,o=0;o<n;o+=1)t+=e[o];return t/n||0}}()},function(e,t,n){var o={};e.exports=o;var i=n(8),r=n(0).deprecated;o.collides=function(e,t){return i.collides(e,t)},r(o,"collides","SAT.collides ➤ replaced by Collision.collides")},function(e,t,n){var o={};e.exports=o;n(1);var i=n(0);o.pathToVertices=function(e,t){"undefined"==typeof window||"SVGPathSeg"in window||i.warn("Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.");var n,r,a,s,l,c,u,d,p,f,v,m=[],y=0,g=0,x=0;t=t||15;var h=function(e,t,n){var o=n%2==1&&n>1;if(!p||e!=p.x||t!=p.y){p&&o?(f=p.x,v=p.y):(f=0,v=0);var i={x:f+e,y:v+t};!o&&p||(p=i),m.push(i),g=f+e,x=v+t}},b=function(e){var t=e.pathSegTypeAsLetter.toUpperCase();if("Z"!==t){switch(t){case"M":case"L":case"T":case"C":case"S":case"Q":g=e.x,x=e.y;break;case"H":g=e.x;break;case"V":x=e.y}h(g,x,e.pathSegType)}};for(o._svgPathToAbsolute(e),a=e.getTotalLength(),c=[],n=0;n<e.pathSegList.numberOfItems;n+=1)c.push(e.pathSegList.getItem(n));for(u=c.concat();y<a;){if((l=c[e.getPathSegAtLength(y)])!=d){for(;u.length&&u[0]!=l;)b(u.shift());d=l}switch(l.pathSegTypeAsLetter.toUpperCase()){case"C":case"T":case"S":case"Q":case"A":s=e.getPointAtLength(y),h(s.x,s.y,0)}y+=t}for(n=0,r=u.length;n<r;++n)b(u[n]);return m},o._svgPathToAbsolute=function(e){for(var t,n,o,i,r,a,s=e.pathSegList,l=0,c=0,u=s.numberOfItems,d=0;d<u;++d){var p=s.getItem(d),f=p.pathSegTypeAsLetter;if(/[MLHVCSQTA]/.test(f))"x"in p&&(l=p.x),"y"in p&&(c=p.y);else switch("x1"in p&&(o=l+p.x1),"x2"in p&&(r=l+p.x2),"y1"in p&&(i=c+p.y1),"y2"in p&&(a=c+p.y2),"x"in p&&(l+=p.x),"y"in p&&(c+=p.y),f){case"m":s.replaceItem(e.createSVGPathSegMovetoAbs(l,c),d);break;case"l":s.replaceItem(e.createSVGPathSegLinetoAbs(l,c),d);break;case"h":s.replaceItem(e.createSVGPathSegLinetoHorizontalAbs(l),d);break;case"v":s.replaceItem(e.createSVGPathSegLinetoVerticalAbs(c),d);break;case"c":s.replaceItem(e.createSVGPathSegCurvetoCubicAbs(l,c,o,i,r,a),d);break;case"s":s.replaceItem(e.createSVGPathSegCurvetoCubicSmoothAbs(l,c,r,a),d);break;case"q":s.replaceItem(e.createSVGPathSegCurvetoQuadraticAbs(l,c,o,i),d);break;case"t":s.replaceItem(e.createSVGPathSegCurvetoQuadraticSmoothAbs(l,c),d);break;case"a":s.replaceItem(e.createSVGPathSegArcAbs(l,c,p.r1,p.r2,p.angle,p.largeArcFlag,p.sweepFlag),d);break;case"z":case"Z":l=t,c=n}"M"!=f&&"m"!=f||(t=l,n=c)}}},function(e,t,n){var o={};e.exports=o;var i=n(6);n(0);o.create=i.create,o.add=i.add,o.remove=i.remove,o.clear=i.clear,o.addComposite=i.addComposite,o.addBody=i.addBody,o.addConstraint=i.addConstraint}])}));

// src/core/matter-js/PhysicsManager.js
/**
 * PhysicsManager - Manages the physics world and integrates with the game engine
 */
class PhysicsManager {
    constructor() {
        // Create Matter.js engine and world
        this.engine = Matter.Engine.create({
            enableSleeping: true
        });

        this.world = this.engine.world;

        // Configure world properties
        this.world.gravity.y = 0; // Default gravity (Off, we will process gravity per RigidBody)
        this.gravity = { x: 0, y: 1 }; // Custom gravity vector

        // Track all physics bodies and their associated game objects
        this.bodies = new Map(); // Maps Matter.js bodies to game objects
        this.gameObjectBodies = new Map(); // Maps game objects to physics bodies

        // Debug drawing options
        this.debugDraw = false;
        this.wireframes = true;

        // Performance settings
        this.fixedTimeStep = 1000 / 60; // 60 updates per second
        this.timeAccumulator = 0;

        // Wake up bodies without gravity on collision
        Matter.Events.on(this.engine, 'collisionStart', event => {
            event.pairs.forEach(pair => {
                [pair.bodyA, pair.bodyB].forEach(body => {
                    if (body.ignoreGravity && body.isSleeping) {
                        Matter.Sleeping.set(body, false);
                    }
                });
            });
        });

        console.log("Physics manager initialized");
    }

    /**
     * Set the gravity for the physics world
     * @param {number} x - X component of gravity
     * @param {number} y - Y component of gravity
     */
    setGravity(x, y) {
        this.world.gravity.x = x;
        this.world.gravity.y = y;
    }

    /**
     * Update physics world - called every frame
     * @param {number} deltaTime - Time in seconds since last frame
     */
    update(deltaTime) {
        // Use fixed timestep for more stable physics
        this.timeAccumulator += deltaTime * 1000; // Convert to ms

        // Clamp max steps per frame to avoid spiral of death
        const maxSteps = 5;
        let steps = 0;

        while (this.timeAccumulator >= this.fixedTimeStep && steps < maxSteps) {
            Matter.Engine.update(this.engine, this.fixedTimeStep);

            // Custom gravity application per body
            const gravity = this.gravity;
            this.bodies.forEach((gameObject, body) => {
                // Only apply gravity if body is dynamic, not static, and not ignoring gravity
                if (!body.isStatic && !body.ignoreGravity) {
                    // Apply gravity force: F = m * g
                    const force = {
                        x: body.mass * gravity.x * 0.001,
                        y: body.mass * gravity.y * 0.001
                    };
                    Matter.Body.applyForce(body, body.position, force);
                }
            });
            this.timeAccumulator -= this.fixedTimeStep;
            steps++;
        }

        // If too much time accumulated, drop the remainder to avoid spiral
        if (steps === maxSteps) {
            this.timeAccumulator = 0;
        }

        // Update game object positions based on physics bodies
        this.syncPhysicsBodies();
    }

    /**
     * Synchronize game object transforms with physics body positions
     */
    syncPhysicsBodies() {
        if (!this.bodies || this.bodies.size === 0) return;

        this.bodies.forEach((gameObject, body) => {
            if (!gameObject || !body) return;

            // Skip colliders that are managed by their own module
            if (body.plugin && body.plugin.isCollider) return;

            // Only update if the body is dynamic or kinematic
            if (!body.isStatic) {
                // Update position from physics body
                gameObject.position.x = body.position.x;
                gameObject.position.y = body.position.y;

                // Update rotation (Matter.js uses radians)
                gameObject.angle = body.angle * (180 / Math.PI);
            } else if (gameObject.rigidbody && gameObject.rigidbody.bodyNeedsUpdate) {
                // Update static body position if game object moved
                Matter.Body.setPosition(body, gameObject.position);
                Matter.Body.setAngle(body, gameObject.angle * (Math.PI / 180));
                gameObject.rigidbody.bodyNeedsUpdate = false;
            }
        });
    }

    /**
     * Register a body with the physics world and associate it with a game object
     * @param {Matter.Body} body - Physics body to register
     * @param {GameObject} gameObject - GameObject that owns this body
     */
    registerBody(body, gameObject) {
        if (!body || !gameObject) {
            console.warn("PhysicsManager.registerBody: Missing body or gameObject");
            return;
        }

        // Ensure maps are initialized
        if (!this.bodies) this.bodies = new Map();
        if (!this.gameObjectBodies) this.gameObjectBodies = new Map();

        try {
            // Store the mapping between body and game object
            this.bodies.set(body, gameObject);
            this.gameObjectBodies.set(gameObject, body);

            // Add body to the physics world if not already added
            if (this.engine && this.engine.world && !this.engine.world.bodies.includes(body)) {
                Matter.Composite.add(this.engine.world, body);
            }

            // Ensure static bodies are really static
            if (body.isStatic) {
                Matter.Body.setStatic(body, true);
            }
        } catch (error) {
            console.error("Error in PhysicsManager.registerBody:", error);
        }
    }

    /**
     * Remove a physics body from the world
     * @param {Matter.Body} body - The physics body to remove
     */
    removeBody(body) {
        if (body) {
            Matter.Composite.remove(this.world, body);
            this.bodies.delete(body);
        }
    }

    /**
     * Draw debug visualization of the physics world
     * @param {CanvasRenderingContext2D} ctx - The canvas rendering context
     */
    drawDebug(ctx) {
        if (!this.debugDraw) return;

        // Save context state
        ctx.save();

        // Render all bodies
        const bodies = Matter.Composite.allBodies(this.world);

        ctx.beginPath();

        for (let i = 0; i < bodies.length; i++) {
            const body = bodies[i];
            const vertices = body.vertices;

            ctx.moveTo(vertices[0].x, vertices[0].y);

            for (let j = 1; j < vertices.length; j++) {
                ctx.lineTo(vertices[j].x, vertices[j].y);
            }

            ctx.lineTo(vertices[0].x, vertices[0].y);
        }

        ctx.lineWidth = 1;
        ctx.strokeStyle = '#22ff22';
        ctx.stroke();

        // Render constraints
        const constraints = Matter.Composite.allConstraints(this.world);

        ctx.beginPath();

        for (let i = 0; i < constraints.length; i++) {
            const constraint = constraints[i];
            if (!constraint.render.visible) continue;

            const bodyA = constraint.bodyA;
            const bodyB = constraint.bodyB;
            const pointA = constraint.pointA;
            const pointB = constraint.pointB;

            // Point coordinates
            let pAx, pAy, pBx, pBy;

            // Calculate points
            if (bodyA) {
                pAx = bodyA.position.x + pointA.x;
                pAy = bodyA.position.y + pointA.y;
            } else {
                pAx = pointA.x;
                pAy = pointA.y;
            }

            if (bodyB) {
                pBx = bodyB.position.x + pointB.x;
                pBy = bodyB.position.y + pointB.y;
            } else {
                pBx = pointB.x;
                pBy = pointB.y;
            }

            ctx.moveTo(pAx, pAy);
            ctx.lineTo(pBx, pBy);
        }

        ctx.lineWidth = 1;
        ctx.strokeStyle = '#ff8822';
        ctx.stroke();

        // Restore context state
        ctx.restore();
    }

    /**
     * Reset the physics world
     */
    reset() {
        // Get all game objects linked to physics bodies before clearing
        const objectsToReset = new Map();
        this.bodies.forEach((gameObject, body) => {
            // Store the original position and rotation if they need to be reset
            objectsToReset.set(gameObject.id, {
                gameObject,
                originalPosition: gameObject.getOriginalPosition ? gameObject.getOriginalPosition() : gameObject.position.clone(),
                originalRotation: gameObject.originalRotation || 0
            });
        });

        // Clear all bodies and constraints
        Matter.Composite.clear(this.world);
        this.bodies.clear();

        // Reset positions of affected game objects
        objectsToReset.forEach(data => {
            // Reset to original position and rotation if available
            data.gameObject.position = data.originalPosition;
            data.gameObject.angle = data.originalRotation;
        });
    }
}

// src/MelodiCode/js/audio-engine.js
class AudioEngine {
    constructor() {
        this.audioContext = null;
        this.masterGain = null;
        this.compressor = null;
        this.limiter = null;
        this.reverb = null;
        this.eq = {
            low: null,
            mid: null,
            high: null
        };
        this.isPlaying = false;
        this.currentTime = 0;
        this.bpm = 120;
        this.samples = new Map();
        this.activeBlocks = new Map();
        this.scheduleTime = 0;
        this.lookAhead = 25.0; // milliseconds
        this.scheduleAheadTime = 0.1; // seconds
        this.nextNoteTime = 0.0;
        this.timerID = null;
        this.activeSources = new Set();

        this.initializeAudio();
        this.loadBuiltInSamples();
    }

    async initializeAudio() {
        try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

            // Create master output chain
            this.setupMasterChain();

            console.log('Audio engine initialized successfully');
        } catch (error) {
            console.error('Failed to initialize audio context:', error);
        }
    }

    setupMasterChain() {
        // Master gain
        this.masterGain = this.audioContext.createGain();
        this.masterGain.gain.value = 0.5;

        // EQ
        this.eq.low = this.audioContext.createBiquadFilter();
        this.eq.low.type = 'lowshelf';
        this.eq.low.frequency.value = 320;
        this.eq.low.gain.value = 0;

        this.eq.mid = this.audioContext.createBiquadFilter();
        this.eq.mid.type = 'peaking';
        this.eq.mid.frequency.value = 1000;
        this.eq.mid.Q.value = 1;
        this.eq.mid.gain.value = 0;

        this.eq.high = this.audioContext.createBiquadFilter();
        this.eq.high.type = 'highshelf';
        this.eq.high.frequency.value = 3200;
        this.eq.high.gain.value = 0;

        // Compressor
        this.compressor = this.audioContext.createDynamicsCompressor();
        this.compressor.threshold.value = -20;
        this.compressor.knee.value = 40;
        this.compressor.ratio.value = 12;
        this.compressor.attack.value = 0.003;
        this.compressor.release.value = 0.25;

        // Limiter (another compressor with harder settings)
        this.limiter = this.audioContext.createDynamicsCompressor();
        this.limiter.threshold.value = -3;
        this.limiter.knee.value = 0;
        this.limiter.ratio.value = 20;
        this.limiter.attack.value = 0.001;
        this.limiter.release.value = 0.01;

        // Reverb
        this.createReverb();

        // Connect the chain
        this.eq.low.connect(this.eq.mid);
        this.eq.mid.connect(this.eq.high);
        this.eq.high.connect(this.compressor);
        this.compressor.connect(this.limiter);
        this.limiter.connect(this.reverb);
        this.reverb.connect(this.masterGain);
        this.masterGain.connect(this.audioContext.destination);
    }

    async createReverb() {
        const reverbTime = 2;
        const sampleRate = this.audioContext.sampleRate;
        const length = sampleRate * reverbTime;
        const impulse = this.audioContext.createBuffer(2, length, sampleRate);

        for (let channel = 0; channel < 2; channel++) {
            const channelData = impulse.getChannelData(channel);
            for (let i = 0; i < length; i++) {
                const decay = Math.pow(1 - i / length, 2);
                channelData[i] = (Math.random() * 2 - 1) * decay;
            }
        }

        this.reverb = this.audioContext.createConvolver();
        this.reverb.buffer = impulse;

        // Create wet/dry control
        this.reverbGain = this.audioContext.createGain();
        this.reverbGain.gain.value = 0.2;
        this.dryGain = this.audioContext.createGain();
        this.dryGain.gain.value = 0.8;

        // Reconnect reverb properly
        this.reverb.disconnect();
        this.reverb = this.audioContext.createGain(); // Use gain node for now, will improve later
    }

    async loadBuiltInSamples() {
        const builtInSamples = {
            // Drum kit
            'kick': await this.generateKick(),
            'snare': await this.generateSnare(),
            'hihat': await this.generateHiHat(),
            'hihat_open': await this.generateOpenHiHat(),
            'crash': await this.generateCrash(),
            'ride': await this.generateRide(),
            'tom_high': await this.generateTom(200),
            'tom_mid': await this.generateTom(150),
            'tom_low': await this.generateTom(100),
            'clap': await this.generateClap(),

            // Bass sounds
            'bass_low': await this.generateBass(55), // A1
            'bass_mid': await this.generateBass(110), // A2
            'bass_high': await this.generateBass(220), // A3
            'sub_bass': await this.generateSubBass(41), // E1
            'bass_pluck': await this.generateBassPluck(82), // E2

            // Lead sounds
            'lead_1': await this.generateLead(440), // A4
            'lead_2': await this.generateLead2(440),
            'lead_bright': await this.generateBrightLead(880),
            'lead_soft': await this.generateSoftLead(440),

            // Pad sounds
            'pad_1': await this.generatePad(220), // A3
            'pad_warm': await this.generateWarmPad(220),
            'pad_strings': await this.generateStringPad(330),
            'pad_choir': await this.generateChoirPad(440),

            // Percussion
            'shaker': await this.generateShaker(),
            'tambourine': await this.generateTambourine(),
            'cowbell': await this.generateCowbell(),
            'woodblock': await this.generateWoodblock(),
            'triangle': await this.generateWoodblock(), // Using woodblock for triangle sound

            // FX sounds
            'whoosh': await this.generateWhoosh(),
            'zap': await this.generateZap(),
            'drop': await this.generateDrop(),
            'rise': await this.generateRise()
        };

        for (const [name, buffer] of Object.entries(builtInSamples)) {
            this.samples.set(name, buffer);
        }
    }

    getBuiltInSampleNames() {
        // Return only the built-in sample names (not imported ones)
        return [
            'kick', 'snare', 'hihat', 'hihat_open', 'crash', 'ride',
            'tom_high', 'tom_mid', 'tom_low', 'clap', 'triangle',
            'bass_low', 'bass_mid', 'bass_high', 'sub_bass', 'bass_pluck',
            'lead_1', 'lead_2', 'lead_bright', 'lead_soft',
            'pad_1', 'pad_warm', 'pad_strings', 'pad_choir',
            'shaker', 'tambourine', 'cowbell', 'woodblock',
            'whoosh', 'zap', 'drop', 'rise'
        ];
    }

    async generateOpenHiHat() {
        const sampleRate = this.audioContext.sampleRate;
        const duration = 0.3;
        const length = sampleRate * duration;
        const buffer = this.audioContext.createBuffer(1, length, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            const envelope = Math.exp(-t * 8);
            const noise = (Math.random() * 2 - 1);
            // High-pass filter simulation with less aggressive filtering
            const filtered = i > 0 ? noise - 0.7 * data[i - 1] : noise;
            data[i] = filtered * envelope * 0.5;
        }

        return buffer;
    }

    async generateCrash() {
        const sampleRate = this.audioContext.sampleRate;
        const duration = 2.0;
        const length = sampleRate * duration;
        const buffer = this.audioContext.createBuffer(1, length, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            const envelope = Math.exp(-t * 2);
            const noise = (Math.random() * 2 - 1);
            // Metallic resonance
            const metallic = Math.sin(2 * Math.PI * 3000 * t * Math.random()) * 0.3;
            data[i] = (noise + metallic) * envelope * 0.6;
        }

        return buffer;
    }

    async generateRide() {
        const sampleRate = this.audioContext.sampleRate;
        const duration = 1.5;
        const length = sampleRate * duration;
        const buffer = this.audioContext.createBuffer(1, length, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            const envelope = Math.exp(-t * 1.5);
            const bell = Math.sin(2 * Math.PI * 2000 * t) * 0.4;
            const shimmer = (Math.random() * 2 - 1) * 0.3;
            data[i] = (bell + shimmer) * envelope * 0.5;
        }

        return buffer;
    }

    async generateTom(frequency) {
        const sampleRate = this.audioContext.sampleRate;
        const duration = 0.8;
        const length = sampleRate * duration;
        const buffer = this.audioContext.createBuffer(1, length, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            const envelope = Math.exp(-t * 8);
            const pitch = frequency * Math.exp(-t * 3);
            const tone = Math.sin(2 * Math.PI * pitch * t);
            const noise = (Math.random() * 2 - 1) * 0.1;
            data[i] = (tone + noise) * envelope * 0.7;
        }

        return buffer;
    }

    async generateClap() {
        const sampleRate = this.audioContext.sampleRate;
        const duration = 0.2;
        const length = sampleRate * duration;
        const buffer = this.audioContext.createBuffer(1, length, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            // Multiple quick bursts to simulate hand clap
            const burst1 = t < 0.01 ? 1 : 0;
            const burst2 = (t >= 0.02 && t < 0.03) ? 0.8 : 0;
            const burst3 = (t >= 0.04 && t < 0.05) ? 0.6 : 0;
            const envelope = burst1 + burst2 + burst3;
            const noise = (Math.random() * 2 - 1);
            data[i] = noise * envelope * 0.6;
        }

        return buffer;
    }

    async generateSubBass(frequency) {
        const sampleRate = this.audioContext.sampleRate;
        const duration = 1.5;
        const length = sampleRate * duration;
        const buffer = this.audioContext.createBuffer(1, length, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            const envelope = Math.exp(-t * 1.5);
            const fundamental = Math.sin(2 * Math.PI * frequency * t);
            const subharmonic = Math.sin(2 * Math.PI * frequency * 0.5 * t) * 0.5;
            data[i] = (fundamental + subharmonic) * envelope * 0.8;
        }

        return buffer;
    }

    async generateBassPluck(frequency) {
        const sampleRate = this.audioContext.sampleRate;
        const duration = 0.6;
        const length = sampleRate * duration;
        const buffer = this.audioContext.createBuffer(1, length, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            const envelope = Math.exp(-t * 8);
            const saw = 2 * ((frequency * t) % 1) - 1;
            const filter = 1 - t * 2; // Simple low-pass
            data[i] = saw * envelope * filter * 0.6;
        }

        return buffer;
    }

    async generateLead2(frequency) {
        const sampleRate = this.audioContext.sampleRate;
        const duration = 0.8;
        const length = sampleRate * duration;
        const buffer = this.audioContext.createBuffer(1, length, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            const envelope = Math.exp(-t * 2);
            const square = Math.sign(Math.sin(2 * Math.PI * frequency * t));
            const pwm = Math.sign(Math.sin(2 * Math.PI * frequency * t * (1 + 0.3 * Math.sin(t * 10))));
            data[i] = (square * 0.6 + pwm * 0.4) * envelope * 0.4;
        }

        return buffer;
    }

    async generateBrightLead(frequency) {
        const sampleRate = this.audioContext.sampleRate;
        const duration = 0.6;
        const length = sampleRate * duration;
        const buffer = this.audioContext.createBuffer(1, length, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            const envelope = Math.exp(-t * 4);
            const saw = 2 * ((frequency * t) % 1) - 1;
            const harmonic = Math.sin(2 * Math.PI * frequency * 3 * t) * 0.3;
            data[i] = (saw + harmonic) * envelope * 0.5;
        }

        return buffer;
    }

    async generateSoftLead(frequency) {
        const sampleRate = this.audioContext.sampleRate;
        const duration = 1.0;
        const length = sampleRate * duration;
        const buffer = this.audioContext.createBuffer(1, length, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            const envelope = Math.exp(-t * 1.5);
            const sine = Math.sin(2 * Math.PI * frequency * t);
            const vibrato = Math.sin(2 * Math.PI * 5 * t) * 0.1;
            data[i] = sine * (1 + vibrato) * envelope * 0.4;
        }

        return buffer;
    }

    async generateWarmPad(frequency) {
        const sampleRate = this.audioContext.sampleRate;
        const duration = 3.0;
        const length = sampleRate * duration;
        const buffer = this.audioContext.createBuffer(1, length, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            const envelope = 1 - Math.exp(-t * 3);
            const fundamental = Math.sin(2 * Math.PI * frequency * t);
            const third = Math.sin(2 * Math.PI * frequency * 1.25 * t) * 0.3;
            const fifth = Math.sin(2 * Math.PI * frequency * 1.5 * t) * 0.2;
            data[i] = (fundamental + third + fifth) * envelope * 0.25;
        }

        return buffer;
    }

    async generateStringPad(frequency) {
        const sampleRate = this.audioContext.sampleRate;
        const duration = 2.5;
        const length = sampleRate * duration;
        const buffer = this.audioContext.createBuffer(1, length, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            const envelope = 1 - Math.exp(-t * 4);
            const saw = 2 * ((frequency * t) % 1) - 1;
            const filter = Math.exp(-t * 0.5); // Gradual filter sweep
            data[i] = saw * envelope * filter * 0.3;
        }

        return buffer;
    }

    async generateChoirPad(frequency) {
        const sampleRate = this.audioContext.sampleRate;
        const duration = 3.0;
        const length = sampleRate * duration;
        const buffer = this.audioContext.createBuffer(1, length, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            const envelope = 1 - Math.exp(-t * 2);
            // Multiple sine waves for choir-like effect
            const voice1 = Math.sin(2 * Math.PI * frequency * t);
            const voice2 = Math.sin(2 * Math.PI * frequency * 1.02 * t) * 0.8;
            const voice3 = Math.sin(2 * Math.PI * frequency * 0.98 * t) * 0.8;
            const formant = Math.sin(2 * Math.PI * frequency * 2.5 * t) * 0.2;
            data[i] = (voice1 + voice2 + voice3 + formant) * envelope * 0.2;
        }

        return buffer;
    }

    async generateShaker() {
        const sampleRate = this.audioContext.sampleRate;
        const duration = 0.15;
        const length = sampleRate * duration;
        const buffer = this.audioContext.createBuffer(1, length, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            const envelope = Math.exp(-t * 20);
            const noise = (Math.random() * 2 - 1);
            // High frequency emphasis
            const filtered = i > 0 ? noise - 0.5 * data[i - 1] : noise;
            data[i] = filtered * envelope * 0.3;
        }

        return buffer;
    }

    async generateTambourine() {
        const sampleRate = this.audioContext.sampleRate;
        const duration = 0.4;
        const length = sampleRate * duration;
        const buffer = this.audioContext.createBuffer(1, length, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            const envelope = Math.exp(-t * 10);
            const jingle = Math.sin(2 * Math.PI * 2000 * t * (1 + Math.sin(t * 50))) * 0.5;
            const shake = (Math.random() * 2 - 1) * 0.3;
            data[i] = (jingle + shake) * envelope * 0.4;
        }

        return buffer;
    }

    async generateCowbell() {
        const sampleRate = this.audioContext.sampleRate;
        const duration = 0.3;
        const length = sampleRate * duration;
        const buffer = this.audioContext.createBuffer(1, length, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            const envelope = Math.exp(-t * 15);
            const bell1 = Math.sin(2 * Math.PI * 800 * t);
            const bell2 = Math.sin(2 * Math.PI * 900 * t) * 0.7;
            data[i] = (bell1 + bell2) * envelope * 0.5;
        }

        return buffer;
    }

    async generateWoodblock() {
        const sampleRate = this.audioContext.sampleRate;
        const duration = 0.1;
        const length = sampleRate * duration;
        const buffer = this.audioContext.createBuffer(1, length, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            const envelope = Math.exp(-t * 50);
            const click = Math.sin(2 * Math.PI * 1500 * t);
            const thump = Math.sin(2 * Math.PI * 300 * t) * 0.3;
            data[i] = (click + thump) * envelope * 0.6;
        }

        return buffer;
    }

    async generateWhoosh() {
        const sampleRate = this.audioContext.sampleRate;
        const duration = 1.0;
        const length = sampleRate * duration;
        const buffer = this.audioContext.createBuffer(1, length, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            const envelope = Math.sin(Math.PI * t / duration);
            const noise = (Math.random() * 2 - 1);
            const sweep = 1 - t; // High to low frequency emphasis
            data[i] = noise * envelope * sweep * 0.4;
        }

        return buffer;
    }

    async generateZap() {
        const sampleRate = this.audioContext.sampleRate;
        const duration = 0.2;
        const length = sampleRate * duration;
        const buffer = this.audioContext.createBuffer(1, length, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            const envelope = Math.exp(-t * 10);
            const freq = 2000 * Math.exp(-t * 5);
            const zap = Math.sin(2 * Math.PI * freq * t);
            const noise = (Math.random() * 2 - 1) * 0.2;
            data[i] = (zap + noise) * envelope * 0.5;
        }

        return buffer;
    }

    async generateDrop() {
        const sampleRate = this.audioContext.sampleRate;
        const duration = 0.8;
        const length = sampleRate * duration;
        const buffer = this.audioContext.createBuffer(1, length, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            const envelope = 1 - t / duration;
            const freq = 800 * Math.exp(-t * 3);
            const drop = Math.sin(2 * Math.PI * freq * t);
            data[i] = drop * envelope * 0.6;
        }

        return buffer;
    }

    async generateRise() {
        const sampleRate = this.audioContext.sampleRate;
        const duration = 1.5;
        const length = sampleRate * duration;
        const buffer = this.audioContext.createBuffer(1, length, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            const envelope = t / duration;
            const freq = 100 * Math.exp(t * 2);
            const rise = Math.sin(2 * Math.PI * freq * t);
            const noise = (Math.random() * 2 - 1) * 0.1;
            data[i] = (rise + noise) * envelope * 0.4;
        }

        return buffer;
    }

    async generateKick() {
        const sampleRate = this.audioContext.sampleRate;
        const duration = 0.4;
        const length = Math.floor(sampleRate * duration);
        const buffer = this.audioContext.createBuffer(1, length, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;

            // Deep pitch drop for subby thump
            const freq = 110 * Math.pow(0.2, t / 0.18); // drops from 110Hz to ~22Hz
            const lowEnv = Math.exp(-t * 12);
            const low = Math.sin(2 * Math.PI * freq * t) * lowEnv;

            // Very subtle mid for body (not clicky)
            const midEnv = Math.exp(-t * 30);
            const mid = Math.sin(2 * Math.PI * 180 * t) * midEnv * 0.18;

            // Extremely short, soft click for attack
            const clickEnv = Math.exp(-t * 400);
            const click = Math.sin(2 * Math.PI * 2000 * t) * clickEnv * 0.08;

            // No metallic or rimshot overtones!
            data[i] = (low + mid + click) * 0.98;
        }

        return buffer;
    }

    async generateSnare() {
        const sampleRate = this.audioContext.sampleRate;
        const duration = 0.3;
        const length = sampleRate * duration;
        const buffer = this.audioContext.createBuffer(1, length, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            const envelope = Math.exp(-t * 15);
            const tone = Math.sin(2 * Math.PI * 200 * t) * 0.3;
            const noise = (Math.random() * 2 - 1) * 0.7;
            data[i] = (tone + noise) * envelope * 0.6;
        }

        return buffer;
    }

    async generateHiHat() {
        const sampleRate = this.audioContext.sampleRate;
        const duration = 0.1;
        const length = sampleRate * duration;
        const buffer = this.audioContext.createBuffer(1, length, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            const envelope = Math.exp(-t * 40);
            const noise = (Math.random() * 2 - 1);
            // High-pass filter simulation
            const filtered = i > 0 ? noise - 0.9 * data[i - 1] : noise;
            data[i] = filtered * envelope * 0.4;
        }

        return buffer;
    }

    async generateBass(frequency) {
        const sampleRate = this.audioContext.sampleRate;
        const duration = 1.0;
        const length = sampleRate * duration;
        const buffer = this.audioContext.createBuffer(1, length, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            const envelope = Math.exp(-t * 2);
            const fundamental = Math.sin(2 * Math.PI * frequency * t);
            const harmonic = Math.sin(2 * Math.PI * frequency * 2 * t) * 0.3;
            const subHarmonic = Math.sin(2 * Math.PI * frequency * 0.5 * t) * 0.2;
            data[i] = (fundamental + harmonic + subHarmonic) * envelope * 0.7;
        }

        return buffer;
    }

    async generateLead(frequency) {
        const sampleRate = this.audioContext.sampleRate;
        const duration = 0.8;
        const length = sampleRate * duration;
        const buffer = this.audioContext.createBuffer(1, length, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            const envelope = Math.exp(-t * 3);
            const saw = 2 * ((frequency * t) % 1) - 1; // Sawtooth wave
            const square = Math.sign(Math.sin(2 * Math.PI * frequency * t)); // Square wave
            data[i] = (saw * 0.6 + square * 0.4) * envelope * 0.5;
        }

        return buffer;
    }

    async generatePad(frequency) {
        const sampleRate = this.audioContext.sampleRate;
        const duration = 2.0;
        const length = sampleRate * duration;
        const buffer = this.audioContext.createBuffer(1, length, sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < length; i++) {
            const t = i / sampleRate;
            const envelope = 1 - Math.exp(-t * 5); // Slow attack
            const fundamental = Math.sin(2 * Math.PI * frequency * t);
            const fifth = Math.sin(2 * Math.PI * frequency * 1.5 * t) * 0.4;
            const octave = Math.sin(2 * Math.PI * frequency * 2 * t) * 0.3;
            data[i] = (fundamental + fifth + octave) * envelope * 0.3;
        }

        return buffer;
    }

    playSample(sampleName, pitch = 1, timescale = 1, when = 0, volume = 1, pan = 0, outputNode = null) {
        if (!this.samples.has(sampleName)) {
            console.warn(`Sample '${sampleName}' not found`);
            return;
        }

        const buffer = this.samples.get(sampleName);
        const source = this.audioContext.createBufferSource();
        const gainNode = this.audioContext.createGain();
        const panNode = this.audioContext.createStereoPanner();

        source.buffer = buffer;
        source.playbackRate.value = pitch * timescale;
        panNode.pan.value = Math.max(-1, Math.min(1, pan));

        source.connect(gainNode);
        gainNode.connect(panNode);
        panNode.connect(outputNode || this.eq.low);

        source.gainNode = gainNode;

        const startTime = this.audioContext.currentTime + when;
        const sampleDuration = buffer.duration / (pitch * timescale);

        // Smooth envelope for samples - very short fade to prevent clicks
        const fadeTime = Math.min(0.002, sampleDuration * 0.02); // 2ms or 2% of sample duration

        gainNode.gain.setValueAtTime(0, startTime);
        gainNode.gain.linearRampToValueAtTime(volume, startTime + fadeTime);

        // Fade out near the end
        const fadeOutStart = startTime + sampleDuration - fadeTime;
        if (fadeOutStart > startTime + fadeTime) {
            gainNode.gain.setValueAtTime(volume, fadeOutStart);
            gainNode.gain.linearRampToValueAtTime(0, startTime + sampleDuration);
        }

        source.start(startTime);

        // Track active sources
        this.activeSources.add(source);
        source.addEventListener('ended', () => {
            this.activeSources.delete(source);
        });

        return source;
    }

    generateTone(frequency, duration = 1, waveType = 'sine', when = 0, volume = 1, pan = 0, outputNode = null) {
        // Validate inputs
        if (!frequency || isNaN(frequency) || frequency <= 0) {
            console.warn(`Invalid frequency: ${frequency}, using 440 Hz`);
            frequency = 440;
        }

        if (!duration || isNaN(duration) || duration <= 0) {
            console.warn(`Invalid duration: ${duration}, using 1 second`);
            duration = 1;
        }

        if (!volume || isNaN(volume) || volume < 0) {
            volume = 0.5;
        }

        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        const panNode = this.audioContext.createStereoPanner();

        oscillator.type = waveType;
        oscillator.frequency.value = frequency;
        panNode.pan.value = Math.max(-1, Math.min(1, pan));

        oscillator.connect(gainNode);
        gainNode.connect(panNode);
        panNode.connect(outputNode || this.eq.low);

        const startTime = this.audioContext.currentTime + when;
        const endTime = startTime + duration;

        // Smooth envelope to prevent clicks - shorter fade times for less noticeable effect
        const fadeTime = Math.min(0.003, duration * 0.05); // 3ms or 5% of duration, whichever is smaller

        gainNode.gain.setValueAtTime(0, startTime);
        gainNode.gain.linearRampToValueAtTime(volume, startTime + fadeTime);
        gainNode.gain.setValueAtTime(volume, endTime - fadeTime);
        gainNode.gain.linearRampToValueAtTime(0, endTime);

        // Track active sources
        this.activeSources.add(oscillator);
        oscillator.addEventListener('ended', () => {
            this.activeSources.delete(oscillator);
        });

        oscillator.start(startTime);
        oscillator.stop(endTime);

        return oscillator;
    }

    noteToFrequency(note) {
        const noteMap = {
            'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3, 'E': 4, 'F': 5,
            'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8, 'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11
        };

        // Convert to uppercase for case-insensitive matching
        const upperNote = note.toUpperCase();
        const match = upperNote.match(/^([A-G][#B]?)(\d+)$/);
        if (!match) {
            console.warn(`Invalid note format: ${note}, defaulting to A4`);
            return 440; // Default to A4
        }

        const noteName = match[1];
        const octave = parseInt(match[2]);

        // Validate octave range
        if (isNaN(octave) || octave < 0 || octave > 10) {
            console.warn(`Invalid octave: ${octave}, defaulting to A4`);
            return 440;
        }

        const noteNumber = noteMap[noteName];
        if (noteNumber === undefined) {
            console.warn(`Invalid note name: ${noteName}, defaulting to A4`);
            return 440;
        }

        // A4 = 440 Hz, MIDI note 69
        const midiNumber = (octave + 1) * 12 + noteNumber;
        const frequency = 440 * Math.pow(2, (midiNumber - 69) / 12);

        // Validate frequency range
        if (isNaN(frequency) || frequency <= 0 || frequency > 20000) {
            console.warn(`Invalid frequency calculated: ${frequency}, defaulting to A4`);
            return 440;
        }

        return frequency;
    }

    setMasterVolume(value) {
        if (this.masterGain) {
            this.masterGain.gain.value = value / 100;
        }
    }

    setEQ(band, value) {
        if (this.eq[band]) {
            this.eq[band].gain.value = value;
        }
    }

    setCompressor(threshold) {
        if (this.compressor) {
            this.compressor.threshold.value = threshold;
        }
    }

    setLimiter(threshold) {
        if (this.limiter) {
            this.limiter.threshold.value = threshold;
        }
    }

    setReverb(wetness) {
        // This is a simplified version - in a real implementation,
        // you'd need a proper wet/dry mix
        if (this.reverbGain) {
            this.reverbGain.gain.value = wetness / 100;
            this.dryGain.gain.value = (100 - wetness) / 100;
        }
    }

    async loadAudioFile(file) {
        try {
            const arrayBuffer = await file.arrayBuffer();
            const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
            const fileName = file.name.replace(/\.[^/.]+$/, ""); // Remove extension
            this.samples.set(fileName, audioBuffer);
            return fileName;
        } catch (error) {
            console.error('Error loading audio file:', error);
            throw error;
        }
    }

    scheduler() {
        while (this.nextNoteTime < this.audioContext.currentTime + this.scheduleAheadTime) {
            // This would be called by the code interpreter to schedule notes
            this.nextNoteTime += 60.0 / this.bpm / 4; // 16th notes
        }
        this.timerID = setTimeout(() => this.scheduler(), this.lookAhead);
    }

    play() {
        if (this.audioContext.state === 'suspended') {
            this.audioContext.resume();
        }

        this.isPlaying = true;
        this.nextNoteTime = this.audioContext.currentTime;
        this.scheduler();
    }

    pause() {
        this.isPlaying = false;
        if (this.timerID) {
            clearTimeout(this.timerID);
            this.timerID = null;
        }
    }

    stop() {
        this.pause();
        this.currentTime = 0;
        this.nextNoteTime = 0;

        // Stop all active sources
        this.activeSources.forEach(source => {
            try {
                source.stop();
            } catch (e) {
                // Source might already be stopped
            }
        });
        this.activeSources.clear();

        // Stop all playing sources
        this.activeBlocks.clear();

        // Stop text-to-speech
        if (typeof speechSynthesis !== 'undefined') {
            speechSynthesis.cancel();
        }
    }

    async exportWAV(duration = 10) {
        if (!window.codeInterpreter) {
            throw new Error('Code interpreter not available');
        }

        // Get current code
        const code = window.editor.getValue();
        if (!code.trim()) {
            throw new Error('No code to export');
        }

        // Parse code to update blocks
        window.codeInterpreter.parse(code);

        // Estimate duration using the interpreter
        let estimatedDuration = 10;
        try {
            estimatedDuration = window.codeInterpreter.estimateDuration('main');
            console.log('Estimated duration:', estimatedDuration);
            if (!estimatedDuration || isNaN(estimatedDuration) || estimatedDuration < 1) {
                estimatedDuration = 10;
            }
        } catch (e) {
            estimatedDuration = 10;
        }
        // Add a buffer to avoid cutting off reverb/tails
        const TAIL_SECONDS = 5;
        estimatedDuration += TAIL_SECONDS;

        // Create offline context for rendering
        const offlineContext = new OfflineAudioContext(
            2, // stereo
            estimatedDuration * this.audioContext.sampleRate,
            this.audioContext.sampleRate
        );

        try {
            // Parse and execute the code in offline context
            await this.renderCodeToOfflineContext(code, offlineContext, estimatedDuration);

            // Render the audio
            const renderedBuffer = await offlineContext.startRendering();
            return this.audioBufferToWAV(renderedBuffer);
        } catch (error) {
            console.error('Error exporting WAV:', error);
            throw error;
        }
    }

    async renderCodeToOfflineContext(code, offlineContext, duration) {
        // Create offline versions of audio nodes
        const offlineMasterGain = offlineContext.createGain();
        offlineMasterGain.gain.value = this.masterGain.gain.value;
        offlineMasterGain.connect(offlineContext.destination);

        // Create offline EQ
        const offlineEQ = {
            low: offlineContext.createBiquadFilter(),
            mid: offlineContext.createBiquadFilter(),
            high: offlineContext.createBiquadFilter()
        };

        // Copy EQ settings
        offlineEQ.low.type = 'lowshelf';
        offlineEQ.low.frequency.value = 320;
        offlineEQ.low.gain.value = this.eq.low.gain.value;

        offlineEQ.mid.type = 'peaking';
        offlineEQ.mid.frequency.value = 1000;
        offlineEQ.mid.Q.value = 1;
        offlineEQ.mid.gain.value = this.eq.mid.gain.value;

        offlineEQ.high.type = 'highshelf';
        offlineEQ.high.frequency.value = 3200;
        offlineEQ.high.gain.value = this.eq.high.gain.value;

        // Connect EQ chain
        offlineEQ.low.connect(offlineEQ.mid);
        offlineEQ.mid.connect(offlineEQ.high);
        offlineEQ.high.connect(offlineMasterGain);

        // Parse the code using the same interpreter as the live playback
        try {
            window.codeInterpreter.parse(code);
        } catch (error) {
            console.error('Failed to parse code for export:', error);
            throw new Error('Invalid MelodiCode syntax: ' + error.message);
        }

        // Create a temporary audio engine instance for offline rendering
        const offlineEngine = this.createOfflineAudioEngine(offlineContext, offlineEQ.low);

        // Execute the code using the interpreter's actual execute method
        await this.executeCodeOffline(offlineEngine, duration);
    }

    createOfflineAudioEngine(offlineContext, outputNode) {
        // Track the current scheduling time for offline rendering
        let offlineCurrentTime = 0;

        const offlineEngine = {
            audioContext: offlineContext,
            masterGain: { gain: { value: this.masterGain.gain.value } },
            eq: { low: outputNode },
            samples: this.samples,
            noteToFrequency: this.noteToFrequency.bind(this),
            bpm: this.bpm,
            isPlaying: true,
            currentTime: 0,
            nextNoteTime: 0,
            scheduleAheadTime: 0.1,
            activeSources: new Set(),
            activeBlocks: new Map(),
            // ADD REVERB SUPPORT FOR OFFLINE
            reverb: this.reverb ? { buffer: this.reverb.buffer } : null,

            // Override the audioContext currentTime property
            audioContext: offlineContext,
            offlineCurrentTime: 0,

            playSample: (sampleName, pitch = 1, timescale = 1, when = 0, volume = 1, pan = 0, outputNode = null) => {
                // Use the offline current time plus the when parameter
                const absoluteWhen = offlineCurrentTime + when;
                console.log(`Playing sample '${sampleName}' at offline time ${absoluteWhen} (currentTime: ${offlineCurrentTime}, when: ${when})`);
                return this.playOfflineSample(sampleName, offlineContext, outputNode || offlineEngine.eq.low, absoluteWhen, pitch, timescale, volume);
            },

            generateTone: (frequency, duration = 1, waveType = 'sine', when = 0, volume = 1, pan = 0, outputNode = null) => {
                // Use the offline current time plus the when parameter, ensuring it's never negative
                const absoluteWhen = Math.max(0, offlineCurrentTime + when);
                console.log(`Generating tone ${frequency}Hz at offline time ${absoluteWhen} (currentTime: ${offlineCurrentTime}, when: ${when})`);
                return this.generateOfflineTone(frequency, duration, offlineContext, outputNode || offlineEngine.eq.low, absoluteWhen, waveType, volume);
            },

            // Mock scheduler that advances time
            scheduler: () => {
                offlineCurrentTime += 60.0 / offlineEngine.bpm / 16; // Advance by 1/16 note
                console.log(`Offline scheduler advanced time to: ${offlineCurrentTime}`);
            },

            // Mock methods that might be called
            setMasterVolume: () => { },
            setEQ: () => { },
            setCompressor: () => { },
            setLimiter: () => { },
            setReverb: () => { },
            play: () => { },
            pause: () => { },
            stop: () => { }
        };

        // Patch the interpreter's executeBlock method for offline rendering
        offlineEngine.executeBlock = async (blockName, startTime = 0, globalParams = {}) => {
            if (!window.codeInterpreter.blocks.has(blockName)) {
                console.warn(`Block '${blockName}' not found`);
                return 0;
            }

            const commands = window.codeInterpreter.blocks.get(blockName);
            let currentTime = 0;

            // --- OFFLINE EFFECT CHAIN START ---
            let effectInputNode = offlineEngine.eq.low; // Default output
            if (window.codeInterpreter.effects.has(blockName)) {
                const effects = window.codeInterpreter.effects.get(blockName);
                let currentNode = offlineEngine.eq.low; // Start with default output

                // Build effect chain from last to first (reverse order)
                for (let i = effects.length - 1; i >= 0; i--) {
                    const effect = effects[i];
                    let effectNode = null;
                    let wetGain = null;
                    let dryGain = null;

                    if (effect.type === 'reverb') {
                        effectNode = offlineContext.createConvolver();
                        if (offlineEngine.reverb && offlineEngine.reverb.buffer) {
                            effectNode.buffer = offlineEngine.reverb.buffer;
                        }

                        // Create wet/dry mix
                        wetGain = offlineContext.createGain();
                        dryGain = offlineContext.createGain();
                        const wetAmount = parseFloat(effect.params[0]) || 0.3;
                        wetGain.gain.value = wetAmount;
                        dryGain.gain.value = 1 - wetAmount;

                        // Connect: input -> [dry path, wet path] -> output
                        effectNode.connect(wetGain);
                        wetGain.connect(currentNode);
                        dryGain.connect(currentNode);

                        // Create input splitter
                        const splitter = offlineContext.createGain();
                        splitter.connect(effectNode); // to wet
                        splitter.connect(dryGain);    // to dry

                        currentNode = splitter;

                    } else if (effect.type === 'delay') {
                        effectNode = offlineContext.createDelay(1); // Max 1 second delay
                        const delayTime = parseFloat(effect.params[0]) || 0.3;
                        const feedback = parseFloat(effect.params[1]) || 0.3;
                        const wetAmount = parseFloat(effect.params[2]) || 0.3;

                        effectNode.delayTime.value = delayTime;

                        // Create feedback loop
                        const feedbackGain = offlineContext.createGain();
                        feedbackGain.gain.value = feedback;
                        effectNode.connect(feedbackGain);
                        feedbackGain.connect(effectNode);

                        // Create wet/dry mix
                        wetGain = offlineContext.createGain();
                        dryGain = offlineContext.createGain();
                        wetGain.gain.value = wetAmount;
                        dryGain.gain.value = 1 - wetAmount;

                        effectNode.connect(wetGain);
                        wetGain.connect(currentNode);
                        dryGain.connect(currentNode);

                        const splitter = offlineContext.createGain();
                        splitter.connect(effectNode);
                        splitter.connect(dryGain);

                        currentNode = splitter;

                    } else if (effect.type === 'filter') {
                        effectNode = offlineContext.createBiquadFilter();
                        const filterType = effect.params[0] || 'lowpass';
                        const frequency = parseFloat(effect.params[1]) || 1000;
                        const q = parseFloat(effect.params[2]) || 1;

                        effectNode.type = filterType;
                        effectNode.frequency.value = frequency;
                        effectNode.Q.value = q;

                        effectNode.connect(currentNode);
                        currentNode = effectNode;

                    } else if (effect.type === 'distortion') {
                        effectNode = offlineContext.createWaveShaper();
                        const amount = parseFloat(effect.params[0]) || 10;
                        const samples = 44100;
                        const curve = new Float32Array(samples);
                        const deg = Math.PI / 180;

                        for (let i = 0; i < samples; i++) {
                            const x = (i * 2) / samples - 1;
                            curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
                        }

                        effectNode.curve = curve;
                        effectNode.oversample = '4x';

                        effectNode.connect(currentNode);
                        currentNode = effectNode;

                    } else if (effect.type === 'chorus') {
                        // Simple chorus using multiple delays
                        const rate = parseFloat(effect.params[0]) || 1;
                        const depth = parseFloat(effect.params[1]) || 0.002;
                        const wetAmount = parseFloat(effect.params[2]) || 0.3;

                        const delay1 = offlineContext.createDelay(0.1);
                        const delay2 = offlineContext.createDelay(0.1);
                        const lfo1 = offlineContext.createOscillator();
                        const lfo2 = offlineContext.createOscillator();
                        const lfoGain1 = offlineContext.createGain();
                        const lfoGain2 = offlineContext.createGain();

                        lfo1.frequency.value = rate;
                        lfo2.frequency.value = rate * 1.1; // Slightly different rate
                        lfoGain1.gain.value = depth;
                        lfoGain2.gain.value = depth;

                        lfo1.connect(lfoGain1);
                        lfo2.connect(lfoGain2);
                        lfoGain1.connect(delay1.delayTime);
                        lfoGain2.connect(delay2.delayTime);

                        delay1.delayTime.value = 0.01;
                        delay2.delayTime.value = 0.015;

                        wetGain = offlineContext.createGain();
                        dryGain = offlineContext.createGain();
                        wetGain.gain.value = wetAmount;
                        dryGain.gain.value = 1 - wetAmount;

                        const chorusMix = offlineContext.createGain();
                        delay1.connect(chorusMix);
                        delay2.connect(chorusMix);
                        chorusMix.connect(wetGain);
                        wetGain.connect(currentNode);
                        dryGain.connect(currentNode);

                        const splitter = offlineContext.createGain();
                        splitter.connect(delay1);
                        splitter.connect(delay2);
                        splitter.connect(dryGain);

                        lfo1.start();
                        lfo2.start();

                        currentNode = splitter;
                    }
                }

                effectInputNode = currentNode;
            }
            // --- OFFLINE EFFECT CHAIN END ---

            // Execute block commands with effect support
            let i = 0;
            while (i < commands.length) {
                const command = commands[i];
                const parts = command.split(/\s+/);
                const cmd = parts[0];

                if (cmd === 'if') {
                    const result = await window.codeInterpreter.executeIf(parts, startTime + currentTime, commands, i);
                    currentTime += result.duration;
                    i = result.nextIndex;
                } else if (cmd === 'for') {
                    const result = await window.codeInterpreter.executeFor(parts, startTime + currentTime, commands, i);
                    currentTime += result.duration;
                    i = result.nextIndex;
                } else if (cmd === 'pattern') {
                    const duration = await window.codeInterpreter.executePattern(parts, startTime + currentTime, effectInputNode);
                    currentTime += duration;
                    i++;
                } else if (cmd === 'sequence') {
                    const duration = await window.codeInterpreter.executeSequence(parts, startTime + currentTime, effectInputNode);
                    currentTime += duration;
                    i++;
                } else {
                    // Execute command with effect input node
                    const duration = await this.executeOfflineCommand(command, startTime + currentTime, effectInputNode, offlineEngine);
                    currentTime += duration;
                    i++;
                }
            }

            offlineEngine.offlineCurrentTime += currentTime;
            return currentTime;
        };

        return offlineEngine;
    }

    async executeOfflineCommand(command, startTime, effectInputNode, offlineEngine) {
        const parts = command.split(/\s+/);
        const cmd = parts[0];

        switch (cmd) {
            case 'sample':
                const sampleName = parts[1];
                const pitch = parseFloat(parts[2]) || 1;
                const timescale = parseFloat(parts[3]) || 1;
                const volume = parseFloat(parts[4]) || 0.8;

                // Check if it's a custom sample
                if (window.codeInterpreter.customSamples.has(sampleName)) {
                    const commands = window.codeInterpreter.customSamples.get(sampleName);
                    await Promise.all(commands.map(command =>
                        this.executeOfflineCommand(command, startTime, effectInputNode, offlineEngine)
                    ));
                    return 0;
                }

                return this.playOfflineSample(sampleName, offlineEngine.audioContext, effectInputNode, startTime, pitch, timescale, volume);

            case 'tone':
                const noteOrFreq = parts[1];
                let duration = parseFloat(parts[2]) || 1;
                const waveType = parts[3] || 'sine';
                const toneVolume = parseFloat(parts[4]) || 0.8;

                // Convert duration based on BPM
                const durationInSeconds = duration * (60 / offlineEngine.bpm);

                let frequency;
                if (isNaN(noteOrFreq)) {
                    frequency = this.noteToFrequency(noteOrFreq);
                } else {
                    frequency = parseFloat(noteOrFreq);
                }

                this.generateOfflineTone(frequency, durationInSeconds, offlineEngine.audioContext, effectInputNode, startTime, waveType, toneVolume);
                return durationInSeconds;

            case 'slide':
                return this.executeOfflineSlide(parts, startTime, effectInputNode, offlineEngine);

            case 'sidechain':
                return this.executeOfflineSidechain(parts, startTime, effectInputNode, offlineEngine);

            case 'pattern':
                return this.executeOfflinePattern(parts, startTime, effectInputNode, offlineEngine);

            case 'sequence':
                return this.executeOfflineSequence(parts, startTime, effectInputNode, offlineEngine);

            case 'play':
                return this.executeOfflinePlay(parts, startTime, effectInputNode, offlineEngine);

            case 'playasync':
                return this.executeOfflinePlayAsync(parts, startTime, effectInputNode, offlineEngine);

            case 'loop':
                return this.executeOfflineLoop(parts, startTime, effectInputNode, offlineEngine);

            case 'loopasync':
                return this.executeOfflineLoopAsync(parts, startTime, effectInputNode, offlineEngine);

            case 'wait':
                const waitDuration = parseFloat(parts[1]) || 0;
                return waitDuration * (60 / offlineEngine.bpm); // Convert beats to seconds

            case 'bpm':
                offlineEngine.bpm = parseFloat(parts[1]) || 120;
                return 0;

            case 'set':
                window.codeInterpreter.variables.set(parts[1], parseFloat(parts[2]) || 0);
                return 0;

            case 'tts':
                // For offline rendering, we can't use actual TTS, so we estimate duration and add silence
                console.warn('TTS not supported in offline rendering, adding estimated silence');

                // Extract text and estimate duration (same logic as in CodeInterpreter.executeTTS)
                let text = '';
                let paramStartIndex = 1;

                if (parts[1] && parts[1].startsWith('"')) {
                    const quotedText = [];
                    for (let i = 1; i < parts.length; i++) {
                        quotedText.push(parts[i]);
                        if (parts[i].endsWith('"')) {
                            paramStartIndex = i + 1;
                            break;
                        }
                    }
                    text = quotedText.join(' ').replace(/"/g, '');
                } else {
                    text = parts[1] || 'Hello';
                    paramStartIndex = 2;
                }

                const rate = parseFloat(parts[paramStartIndex] || '1');
                const adjustedRate = rate * (offlineEngine.bpm / 120);
                const wordsPerMinute = 150 * adjustedRate;
                const wordCount = text.split(' ').length;
                const estimatedDuration = (wordCount / wordsPerMinute) * 60;

                return estimatedDuration;

            default:
                console.warn(`Unknown offline command: ${cmd}`);
                return 0;
        }
    }

    executeOfflineSlide(parts, startTime, effectInputNode, offlineEngine) {
        const key1 = parts[1];
        const key2 = parts[2];
        const timescale = parseFloat(parts[3]) || 1;
        const durationInSeconds = timescale * (60 / offlineEngine.bpm);

        // Optional: waveType, volume, pan
        const waveType = parts[4] || 'sine';
        const volume = parseFloat(parts[5]) || 0.8;
        const pan = parseFloat(parts[6]) || 0;

        // Support both note names and frequencies
        const freq1 = isNaN(key1) ? this.noteToFrequency(key1) : parseFloat(key1);
        const freq2 = isNaN(key2) ? this.noteToFrequency(key2) : parseFloat(key2);

        const ctx = offlineEngine.audioContext;
        const oscillator = ctx.createOscillator();
        const gainNode = ctx.createGain();
        const panNode = ctx.createStereoPanner();

        // Schedule the oscillator frequency changes
        oscillator.type = waveType;
        oscillator.frequency.setValueAtTime(freq1, startTime);
        oscillator.frequency.linearRampToValueAtTime(freq2, startTime + durationInSeconds);

        // Schedule the pan value
        panNode.pan.setValueAtTime(Math.max(-1, Math.min(1, pan)), startTime);

        // Smooth envelope
        const fadeTime = Math.min(0.003, durationInSeconds * 0.03);
        gainNode.gain.setValueAtTime(0, startTime);
        gainNode.gain.linearRampToValueAtTime(volume, startTime + fadeTime);
        gainNode.gain.setValueAtTime(volume, startTime + durationInSeconds - fadeTime);
        gainNode.gain.linearRampToValueAtTime(0, startTime + durationInSeconds);

        // Connect the audio graph
        oscillator.connect(gainNode);
        gainNode.connect(panNode);
        panNode.connect(effectInputNode);

        // Schedule the oscillator to start and stop
        oscillator.start(startTime);
        oscillator.stop(startTime + durationInSeconds);

        console.log(`Scheduled slide from ${freq1}Hz to ${freq2}Hz for ${durationInSeconds}s at time ${startTime}`);
        return durationInSeconds;
    }

    async executeOfflineSidechain(parts, startTime, effectInputNode, offlineEngine) {
        const block1 = parts[1]; // Block to be ducked
        const block2 = parts[2]; // Trigger block
        const amount = parseFloat(parts[3]);

        if (!window.codeInterpreter.blocks.has(block1) || !window.codeInterpreter.blocks.has(block2)) {
            console.warn(`One or both blocks not found: ${block1}, ${block2}`);
            return 0;
        }

        const ctx = offlineEngine.audioContext;

        // Create a gain node to control block1's volume
        const sidechainGain = ctx.createGain();
        sidechainGain.gain.value = 1; // Start at full volume

        // Connect sidechain gain to the output
        sidechainGain.connect(effectInputNode);

        // Calculate durations for both blocks
        const block1Duration = window.codeInterpreter.estimateDuration(block1);
        const block2Duration = window.codeInterpreter.estimateDuration(block2);

        // Use the longer duration, but ensure we have at least some playback time
        const maxDuration = Math.max(block1Duration, block2Duration, 4); // Minimum 4 seconds

        console.log(`Offline Sidechain: block1 (${block1}) duration: ${block1Duration}s, block2 (${block2}) duration: ${block2Duration}s, total: ${maxDuration}s`);

        // Get all trigger times from block2
        const triggerTimes = this.getOfflineTriggerTimes(block2, block2Duration, maxDuration, offlineEngine);
        console.log(`Offline Sidechain: Found ${triggerTimes.length} triggers at times:`, triggerTimes);

        // Schedule ducking automation
        const duckDuration = 0.15; // How long the duck lasts
        const attackTime = 0.01;   // How quickly it ducks

        triggerTimes.forEach((triggerTime, index) => {
            if (triggerTime < maxDuration) {
                const absoluteTime = startTime + triggerTime;

                console.log(`Scheduling offline duck ${index + 1} at ${triggerTime}s (absolute: ${absoluteTime}s)`);

                // Duck the gain
                sidechainGain.gain.cancelScheduledValues(absoluteTime);
                sidechainGain.gain.setValueAtTime(1, absoluteTime);
                sidechainGain.gain.linearRampToValueAtTime(1 - amount, absoluteTime + attackTime);
                sidechainGain.gain.linearRampToValueAtTime(1, absoluteTime + duckDuration);
            }
        });

        const allExecutionPromises = [];

        // Execute block1 (gets sidechained) through the sidechain gain
        if (block1Duration > 0 && block1Duration < maxDuration) {
            // Loop block1 to fill duration
            const loops = Math.ceil(maxDuration / block1Duration);
            for (let i = 0; i < loops; i++) {
                const loopStart = startTime + (i * block1Duration);
                if (loopStart < startTime + maxDuration) {
                    allExecutionPromises.push(this.executeOfflineBlock(block1, loopStart, sidechainGain, offlineEngine));
                }
            }
        } else {
            allExecutionPromises.push(this.executeOfflineBlock(block1, startTime, sidechainGain, offlineEngine));
        }

        // Execute block2 (triggers sidechain) directly to output
        if (block2Duration > 0 && block2Duration < maxDuration) {
            // Loop block2 to fill duration
            const loops = Math.ceil(maxDuration / block2Duration);
            for (let i = 0; i < loops; i++) {
                const loopStart = startTime + (i * block2Duration);
                if (loopStart < startTime + maxDuration) {
                    allExecutionPromises.push(this.executeOfflineBlock(block2, loopStart, effectInputNode, offlineEngine));
                }
            }
        } else {
            allExecutionPromises.push(this.executeOfflineBlock(block2, startTime, effectInputNode, offlineEngine));
        }

        await Promise.all(allExecutionPromises);
        return maxDuration;
    }

    getOfflineTriggerTimes(blockName, blockDuration, totalDuration, offlineEngine) {
        const commands = window.codeInterpreter.blocks.get(blockName);
        const triggers = [];

        const loopCount = blockDuration > 0 ? Math.ceil(totalDuration / blockDuration) : 1;

        for (let loop = 0; loop < loopCount; loop++) {
            const loopStart = loop * blockDuration;
            if (loopStart >= totalDuration) break;

            let time = 0;
            const beatDuration = 60 / offlineEngine.bpm;

            for (const command of commands) {
                const cmdParts = command.split(/\s+/);
                const cmd = cmdParts[0];

                if (cmd === 'sample') {
                    triggers.push(loopStart + time);
                } else if (cmd === 'tone') {
                    triggers.push(loopStart + time);
                    const duration = parseFloat(cmdParts[2] || '1') * beatDuration;
                    time += duration;
                } else if (cmd === 'slide') {
                    triggers.push(loopStart + time);
                    const duration = parseFloat(cmdParts[3] || '1') * beatDuration;
                    time += duration;
                } else if (cmd === 'wait') {
                    time += parseFloat(cmdParts[1]) * beatDuration;
                } else if (cmd === 'pattern') {
                    // Handle pattern triggers
                    for (let i = 2; i < cmdParts.length; i += 2) {
                        if (i + 1 < cmdParts.length) {
                            const patternStr = cmdParts[i + 1].replace(/"/g, '');
                            const steps = patternStr.split('-');
                            const stepDuration = beatDuration / 4;

                            for (let j = 0; j < steps.length; j++) {
                                if (steps[j].trim() === '1' || steps[j].trim() === 'x' || steps[j].trim() === 'X') {
                                    triggers.push(loopStart + time + (j * stepDuration));
                                }
                            }
                            time += steps.length * stepDuration;
                        }
                    }
                }
            }
        }

        return triggers;
    }

    async executeCodeOffline(offlineEngine, maxDuration) {
        // Temporarily replace the global audioEngine with our offline version
        const originalAudioEngine = window.audioEngine;
        const originalInterpreterEngine = window.codeInterpreter.audioEngine;
        window.audioEngine = offlineEngine;
        window.codeInterpreter.audioEngine = offlineEngine;

        try {
            console.log('Starting offline code execution...');

            // Use the interpreter's actual execute method
            if (window.codeInterpreter && typeof window.codeInterpreter.execute === 'function') {
                await window.codeInterpreter.execute();
            } else {
                console.warn('Code interpreter execute method not available');
                // Fallback: try to execute main block directly if available
                if (window.codeInterpreter && window.codeInterpreter.blocks) {
                    const mainBlock = window.codeInterpreter.blocks.get('main');
                    if (mainBlock) {
                        console.log('Executing main block as fallback');
                        await this.executeBlockFallback(mainBlock, offlineEngine);
                    }
                }
            }

            console.log('Offline code execution completed');
        } catch (error) {
            console.error('Error executing code for export:', error);
        } finally {
            // Restore the original audio engine
            window.audioEngine = originalAudioEngine;
            window.codeInterpreter.audioEngine = originalInterpreterEngine;
        }
    }

    async executeBlockFallback(block, offlineEngine) {
        console.log('Executing block fallback:', block);

        // Simple fallback - just play a test tone to verify the export works
        offlineEngine.generateTone(440, 1, 'sine', 0, 0.5);
        offlineEngine.generateTone(880, 1, 'sine', 1, 0.5);
        offlineEngine.playSample('kick', 1, 1, 2, 0.8);
    }

    async executeOfflineBlock(blockName, startTime, outputNode, offlineEngine) {
        if (!window.codeInterpreter.blocks.has(blockName)) {
            console.warn(`Block '${blockName}' not found for offline execution`);
            return 0;
        }

        const commands = window.codeInterpreter.blocks.get(blockName);
        let currentTime = 0;

        // Execute block commands
        let i = 0;
        while (i < commands.length) {
            const command = commands[i];
            const parts = command.split(/\s+/);
            const cmd = parts[0];

            if (cmd === 'if') {
                const result = await this.executeOfflineIf(parts, startTime + currentTime, commands, i, outputNode, offlineEngine);
                currentTime += result.duration;
                i = result.nextIndex;
            } else if (cmd === 'for') {
                const result = await this.executeOfflineFor(parts, startTime + currentTime, commands, i, outputNode, offlineEngine);
                currentTime += result.duration;
                i = result.nextIndex;
            } else {
                // Execute command with the specified output node
                const duration = await this.executeOfflineCommand(command, startTime + currentTime, outputNode, offlineEngine);
                currentTime += duration;
                i++;
            }
        }

        return currentTime;
    }

    async executeOfflinePattern(parts, startTime, effectInputNode, offlineEngine) {
        if (parts.length < 3 || parts.length % 2 !== 1) {
            console.warn('Pattern command requires pairs of a sample name and a pattern string.');
            return 0;
        }

        const patterns = [];
        // Loop through parts, taking a sample name and a pattern string as a pair
        for (let i = 1; i < parts.length; i += 2) {
            const sampleName = parts[i];
            const patternString = parts[i + 1].replace(/"/g, ''); // Remove quotes
            patterns.push({ name: sampleName, string: patternString });
        }

        if (patterns.length === 0) {
            return 0;
        }

        let maxLength = 0;
        const executionPromises = [];
        const stepDuration = (60 / offlineEngine.bpm) / 4; // 16th notes

        // Process each pattern definition
        for (const pattern of patterns) {
            const steps = pattern.string.split('-');
            if (steps.length > maxLength) {
                maxLength = steps.length;
            }

            for (let i = 0; i < steps.length; i++) {
                const step = steps[i].trim();
                if (step === '1' || step === 'x' || step === 'X') {
                    const hitTime = startTime + (i * stepDuration);
                    // Schedule the sample play
                    executionPromises.push(
                        this.executeOfflineCommand(`sample ${pattern.name}`, hitTime, effectInputNode, offlineEngine)
                    );
                }
            }
        }

        // Wait for all sample scheduling commands to be initiated
        await Promise.all(executionPromises);

        // The total duration is determined by the longest pattern
        return maxLength * stepDuration;
    }

    async executeOfflineSequence(parts, startTime, effectInputNode, offlineEngine) {
        const sampleName = parts[1];
        const steps = parts.slice(2);

        let currentTime = 0;
        const stepDuration = (60 / offlineEngine.bpm) / 4;

        for (let i = 0; i < steps.length; i++) {
            const step = steps[i];
            if (step !== '-' && step !== '0') {
                await this.executeOfflineCommand(`sample ${step}`, startTime + currentTime, effectInputNode, offlineEngine);
            }
            currentTime += stepDuration;
        }

        return currentTime;
    }

    async executeOfflinePlay(parts, startTime, effectInputNode, offlineEngine) {
        const blockNames = [];
        const params = {};

        // Parse block names and parameters
        for (let i = 1; i < parts.length; i++) {
            if (parts[i].includes('=')) {
                const [key, value] = parts[i].split('=');
                params[key] = parseFloat(value);
            } else {
                blockNames.push(parts[i]);
            }
        }

        if (blockNames.length === 0) {
            return 0;
        }

        // Estimate durations for all blocks
        const blockDurations = blockNames.map(name => ({
            name,
            duration: window.codeInterpreter.estimateDuration(name)
        }));

        // Find the maximum duration among all blocks
        const maxDuration = Math.max(...blockDurations.map(b => b.duration), 0);

        if (maxDuration === 0) {
            // If max duration is 0, just play all blocks once simultaneously
            const promises = blockNames.map(blockName => this.executeOfflineBlock(blockName, startTime, effectInputNode, offlineEngine));
            await Promise.all(promises);
            return 0;
        }

        const allExecutionPromises = [];

        // Schedule all block executions - shorter blocks loop to match longest
        blockDurations.forEach(blockInfo => {
            const { name, duration } = blockInfo;

            if (duration <= 0) {
                // Play once if duration is 0
                allExecutionPromises.push(this.executeOfflineBlock(name, startTime, effectInputNode, offlineEngine));
            } else {
                // Loop the block to fill the maxDuration
                const loopCount = Math.ceil(maxDuration / duration);

                for (let i = 0; i < loopCount; i++) {
                    const loopStartTime = startTime + (i * duration);
                    // Ensure we don't schedule past the max duration
                    if (loopStartTime < startTime + maxDuration) {
                        allExecutionPromises.push(this.executeOfflineBlock(name, loopStartTime, effectInputNode, offlineEngine));
                    }
                }
            }
        });

        // Wait for all scheduled blocks to complete their execution logic
        await Promise.all(allExecutionPromises);

        // The total duration of the play command is the duration of the longest block
        return maxDuration;
    }

    async executeOfflinePlayAsync(parts, startTime, effectInputNode, offlineEngine) {
        // For offline rendering, playasync behaves the same as play since we're not in real-time
        return this.executeOfflinePlay(parts, startTime, effectInputNode, offlineEngine);
    }

    async executeOfflineLoop(parts, startTime, effectInputNode, offlineEngine) {
        const count = parseInt(parts[1]);
        const blockNames = parts.slice(2);

        // Validate block names
        for (const blockName of blockNames) {
            if (!window.codeInterpreter.blocks.has(blockName)) {
                console.warn(`Block '${blockName}' not found`);
                return 0;
            }
        }

        // Estimate durations for all blocks
        const blockDurations = blockNames.map(name => ({
            name,
            duration: window.codeInterpreter.estimateDuration(name)
        }));

        // Find the maximum duration among all blocks in one iteration
        const maxIterationDuration = Math.max(...blockDurations.map(b => b.duration), 0);

        if (maxIterationDuration === 0) {
            // If all blocks have 0 duration, just play them count times
            let totalDuration = 0;
            for (let i = 0; i < count; i++) {
                const promises = blockNames.map(blockName =>
                    this.executeOfflineBlock(blockName, startTime + totalDuration, effectInputNode, offlineEngine)
                );
                await Promise.all(promises);
            }
            return 0;
        }

        const allExecutionPromises = [];
        let totalDuration = 0;

        // For each iteration of the loop
        for (let iteration = 0; iteration < count; iteration++) {
            const iterationStartTime = startTime + totalDuration;

            // Schedule all blocks for this iteration - shorter blocks loop within the iteration
            blockDurations.forEach(blockInfo => {
                const { name, duration } = blockInfo;

                if (duration <= 0) {
                    // Play once if duration is 0
                    allExecutionPromises.push(this.executeOfflineBlock(name, iterationStartTime, effectInputNode, offlineEngine));
                } else {
                    // Loop the block to fill the maxIterationDuration
                    const loopCount = Math.ceil(maxIterationDuration / duration);

                    for (let i = 0; i < loopCount; i++) {
                        const loopStartTime = iterationStartTime + (i * duration);
                        // Ensure we don't schedule past the iteration's max duration
                        if (loopStartTime < iterationStartTime + maxIterationDuration) {
                            allExecutionPromises.push(this.executeOfflineBlock(name, loopStartTime, effectInputNode, offlineEngine));
                        }
                    }
                }
            });

            totalDuration += maxIterationDuration;
        }

        // Wait for all scheduled blocks to complete their execution logic
        await Promise.all(allExecutionPromises);

        return totalDuration;
    }

    async executeOfflineLoopAsync(parts, startTime, effectInputNode, offlineEngine) {
        // For offline rendering, loopasync behaves the same as loop since we're not in real-time
        return this.executeOfflineLoop(parts, startTime, effectInputNode, offlineEngine);
    }

    async executeOfflineIf(parts, startTime, commands, currentIndex, effectInputNode, offlineEngine) {
        const variable = parts[1];
        const operator = parts[2];
        const value = window.codeInterpreter.parseValue(parts[3]);
        const varValue = window.codeInterpreter.parseValue(variable);

        let condition = false;
        switch (operator) {
            case '>': condition = varValue > value; break;
            case '<': condition = varValue < value; break;
            case '==': condition = varValue == value; break;
            case '!=': condition = varValue != value; break;
            case '>=': condition = varValue >= value; break;
            case '<=': condition = varValue <= value; break;
        }

        // Find matching endif
        let endifIndex = this.findMatchingEndOffline(commands, currentIndex, 'if', 'endif');

        if (condition) {
            // Execute commands between if and endif
            return await this.executeOfflineCommandBlock(commands, currentIndex + 1, endifIndex, startTime, effectInputNode, offlineEngine);
        }

        return { duration: 0, nextIndex: endifIndex + 1 };
    }

    async executeOfflineFor(parts, startTime, commands, currentIndex, effectInputNode, offlineEngine) {
        const variable = parts[1];
        const start = window.codeInterpreter.parseValue(parts[2]);
        const end = window.codeInterpreter.parseValue(parts[3]);

        let totalDuration = 0;
        const endforIndex = this.findMatchingEndOffline(commands, currentIndex, 'for', 'endfor');

        for (let i = start; i <= end; i++) {
            window.codeInterpreter.variables.set(variable, i);
            const result = await this.executeOfflineCommandBlock(commands, currentIndex + 1, endforIndex, startTime + totalDuration, effectInputNode, offlineEngine);
            totalDuration += result.duration;
        }

        return { duration: totalDuration, nextIndex: endforIndex + 1 };
    }

    async executeOfflineCommandBlock(commands, startIndex, endIndex, startTime, effectInputNode, offlineEngine) {
        let currentTime = 0;
        let i = startIndex;

        while (i < endIndex) {
            const command = commands[i];
            const parts = command.split(/\s+/);
            const cmd = parts[0];

            // Handle control flow commands
            if (cmd === 'if') {
                const result = await this.executeOfflineIf(parts, startTime + currentTime, commands, i, effectInputNode, offlineEngine);
                currentTime += result.duration;
                i = result.nextIndex;
            } else if (cmd === 'for') {
                const result = await this.executeOfflineFor(parts, startTime + currentTime, commands, i, effectInputNode, offlineEngine);
                currentTime += result.duration;
                i = result.nextIndex;
            } else if (cmd === 'endif' || cmd === 'endfor') {
                // These should be handled by their respective start commands
                i++;
            } else {
                // Regular commands
                const duration = await this.executeOfflineCommand(command, startTime + currentTime, effectInputNode, offlineEngine);
                currentTime += duration;
                i++;
            }
        }

        return { duration: currentTime };
    }

    findMatchingEndOffline(commands, startIndex, startKeyword, endKeyword) {
        let depth = 1;
        for (let i = startIndex + 1; i < commands.length; i++) {
            const cmd = commands[i].split(/\s+/)[0];
            if (cmd === startKeyword) depth++;
            if (cmd === endKeyword) depth--;
            if (depth === 0) return i;
        }
        return commands.length - 1;
    }

    async playOfflineSample(sampleName, offlineContext, outputNode, when, pitch = 1, timescale = 1, volume = 1) {
        if (!this.samples.has(sampleName)) {
            console.warn(`Sample '${sampleName}' not found for export`);
            return;
        }

        const buffer = this.samples.get(sampleName);
        const source = offlineContext.createBufferSource();
        const gainNode = offlineContext.createGain();

        source.buffer = buffer;
        source.playbackRate.value = pitch * timescale;
        gainNode.gain.value = volume;

        source.connect(gainNode);
        gainNode.connect(outputNode);

        // Schedule the sample to start at the specified time
        source.start(when);

        console.log(`Scheduled sample '${sampleName}' at time ${when} with pitch ${pitch} and timescale ${timescale}`);
        return source;
    }

    generateOfflineTone(frequency, duration, offlineContext, outputNode, when, waveType = 'sine', volume = 1) {
        const oscillator = offlineContext.createOscillator();
        const gainNode = offlineContext.createGain();

        oscillator.type = waveType;
        oscillator.frequency.value = frequency;
        gainNode.gain.value = 0;

        oscillator.connect(gainNode);
        gainNode.connect(outputNode);

        // Ensure startTime is never negative
        const startTime = Math.max(0, when);
        const endTime = startTime + duration;

        // ADSR envelope with safe time values
        gainNode.gain.setValueAtTime(0, startTime);
        gainNode.gain.linearRampToValueAtTime(volume * 0.5, Math.max(startTime + 0.01, startTime + duration * 0.1));
        gainNode.gain.linearRampToValueAtTime(volume * 0.4, Math.max(startTime + 0.1, endTime - duration * 0.1));
        gainNode.gain.setValueAtTime(volume * 0.3, Math.max(endTime - 0.1, endTime - duration * 0.1));
        gainNode.gain.exponentialRampToValueAtTime(0.001, endTime);

        // Schedule the tone to start and stop at the specified times
        oscillator.start(startTime);
        oscillator.stop(endTime);

        console.log(`Scheduled tone ${frequency}Hz for ${duration}s at time ${startTime}`);
        return oscillator;
    }

    audioBufferToWAV(buffer) {
        const length = buffer.length;
        const numberOfChannels = buffer.numberOfChannels;
        const sampleRate = buffer.sampleRate;
        const arrayBuffer = new ArrayBuffer(44 + length * numberOfChannels * 2);
        const view = new DataView(arrayBuffer);

        // WAV header
        const writeString = (offset, string) => {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        };

        writeString(0, 'RIFF');
        view.setUint32(4, 36 + length * numberOfChannels * 2, true);
        writeString(8, 'WAVE');
        writeString(12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, numberOfChannels, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * numberOfChannels * 2, true);
        view.setUint16(32, numberOfChannels * 2, true);
        view.setUint16(34, 16, true);
        writeString(36, 'data');
        view.setUint32(40, length * numberOfChannels * 2, true);

        // Convert float samples to 16-bit PCM
        let offset = 44;
        for (let i = 0; i < length; i++) {
            for (let channel = 0; channel < numberOfChannels; channel++) {
                const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                view.setInt16(offset, sample * 0x7FFF, true);
                offset += 2;
            }
        }

        return new Blob([arrayBuffer], { type: 'audio/wav' });
    }

    getAnalyserData() {
        if (!this.analyser) {
            this.analyser = this.audioContext.createAnalyser();
            this.analyser.fftSize = 256;
            this.masterGain.connect(this.analyser);
        }

        const bufferLength = this.analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        this.analyser.getByteFrequencyData(dataArray);
        return dataArray;
    }

    getWaveformData() {
        if (!this.analyser) return null;
        
        const bufferLength = this.analyser.fftSize;
        const dataArray = new Uint8Array(bufferLength);
        this.analyser.getByteTimeDomainData(dataArray);
        return dataArray;
    }
}

// Global audio engine instance
window.audioEngine = new AudioEngine();


// src/MelodiCode/js/code-interpreter.js
class CodeInterpreter {
    constructor(audioEngine) {
        this.audioEngine = audioEngine;
        this.blocks = new Map();
        this.globalCommands = [];
        this.variables = new Map();
        this.isRunning = false;
        this.currentPosition = 0;
        this.loopStacks = new Map();
        this.effects = new Map();
        this.customSamples = new Map();
        this.activeUtterances = [];

        // Default values
        this.defaultVolume = 0.8;
        this.defaultPan = 0;
        this.defaultPitch = 1;
        this.defaultTimescale = 1;
        this.bpm = 120; // Default BPM
        this.beatDuration = 60 / this.bpm;

        this.forLoopStacks = new Map();
        this.conditionalBlocks = new Map();
    }

    parse(code) {
        try {
            this.blocks.clear();
            this.globalCommands = [];
            this.variables.clear();
            this.customSamples.clear();
            this.effects.clear();

            // Remove comments (everything after // on each line)
            const lines = code.split('\n')
                .map(line => {
                    const idx = line.indexOf('//');
                    if (idx !== -1) {
                        return line.slice(0, idx).trim();
                    }
                    return line.trim();
                })
                .filter(line => line); // Remove empty lines

            // Split each line by semicolons and flatten into a single array of commands
            const allCommands = [];
            for (const line of lines) {
                if (line.startsWith('[') || line.startsWith('<') || line === '[end]' || line === '<end>') {
                    // Don't split block headers/endings by semicolon
                    allCommands.push(line);
                } else {
                    // Split by semicolon and add each non-empty command
                    const commands = line.split(';').map(cmd => cmd.trim()).filter(cmd => cmd);
                    allCommands.push(...commands);
                }
            }

            let currentBlock = null;
            let blockContent = [];
            let inCustomSample = false;
            let customSampleName = '';
            let blockEffects = [];

            for (let i = 0; i < allCommands.length; i++) {
                const line = allCommands[i].trim();

                // Custom sample block start: <blockName>
                if (line.startsWith('<') && line.endsWith('>') && line !== '<end>') {
                    inCustomSample = true;
                    customSampleName = line.slice(1, -1);
                    blockContent = [];
                    currentBlock = null; // Ensure we are not in a regular block
                    continue;
                }

                // Universal block end: handles both [end] and <end> for any block type
                if (line === '[end]' || line === '<end>') {
                    if (inCustomSample && customSampleName) {
                        this.customSamples.set(customSampleName, blockContent.slice());
                        inCustomSample = false;
                        customSampleName = '';
                        blockContent = [];
                    } else if (currentBlock) {
                        this.blocks.set(currentBlock, blockContent);
                        currentBlock = null;
                        blockContent = [];
                    }
                    continue;
                }

                if (inCustomSample) {
                    blockContent.push(line);
                    continue;
                }

                // Block start with effects: [block] (effect...) (effect2...)
                const blockHeaderMatch = line.match(/^\[([^\]]+)\](.*)$/);
                if (blockHeaderMatch && blockHeaderMatch[1].trim() !== 'end') {
                    const blockName = blockHeaderMatch[1].trim();
                    const effectsPart = blockHeaderMatch[2].trim();
                    blockEffects = [];
                    // Find all (effect ...) groups
                    const effectRegex = /\(([^\)]+)\)/g;
                    let match;
                    while ((match = effectRegex.exec(effectsPart)) !== null) {
                        const effectParts = match[1].trim().split(/\s+/);
                        const effectType = effectParts[0];
                        const params = effectParts.slice(1);
                        blockEffects.push({ type: effectType, params });
                    }
                    if (blockEffects.length > 0) {
                        this.effects.set(blockName, blockEffects);
                    }
                    currentBlock = blockName;
                    blockContent = [];
                    inCustomSample = false; // Ensure we are not in a custom sample block
                    continue;
                }

                // Block content or global command
                if (currentBlock) {
                    blockContent.push(line);
                } else {
                    this.globalCommands.push(line);
                }
            }

            return { success: true, message: 'Code parsed successfully' };
        } catch (error) {
            return { success: false, message: `Parse error: ${error.message}` };
        }
    }

    validate() {
        const errors = [];

        // Check for main block
        if (!this.blocks.has('main')) {
            errors.push('Warning: No [main] block found');
        }

        // Validate block syntax
        for (const [blockName, commands] of this.blocks) {
            for (let i = 0; i < commands.length; i++) {
                const command = commands[i];
                const validation = this.validateCommand(command);
                if (!validation.valid) {
                    errors.push(`Block '${blockName}', line ${i + 1}: ${validation.error}`);
                }
            }
        }

        // Validate global commands
        for (let i = 0; i < this.globalCommands.length; i++) {
            const command = this.globalCommands[i];
            const validation = this.validateCommand(command);
            if (!validation.valid) {
                errors.push(`Global command line ${i + 1}: ${validation.error}`);
            }
        }

        return {
            valid: errors.length === 0,
            errors: errors
        };
    }

    validateCommand(command) {
        const parts = command.split(/\s+/);
        const cmd = parts[0];

        switch (cmd) {
            case 'sample':
                if (parts.length < 2) {
                    return { valid: false, error: 'sample command requires at least sample name' };
                }
                break;
            case 'tone':
                if (parts.length < 2) {
                    return { valid: false, error: 'tone command requires at least frequency/note' };
                }
                break;
            case 'slide':
                if (parts.length < 4) {
                    return { valid: false, error: 'slide command requires key1, key2, and timescale' };
                }
                break;
            case 'sidechain':
                if (parts.length < 4) {
                    return { valid: false, error: 'sidechain command requires block1, block2, and amount' };
                }
                if (isNaN(parseFloat(parts[3])) || parseFloat(parts[3]) < 0 || parseFloat(parts[3]) > 1) {
                    return { valid: false, error: 'sidechain amount must be between 0 and 1' };
                }
                break;
            case 'wait':
                if (parts.length < 2) {
                    return { valid: false, error: 'wait command requires duration' };
                }
                if (isNaN(parseFloat(parts[1]))) {
                    return { valid: false, error: 'wait duration must be a number' };
                }
                break;
            case 'play':
            case 'playasync':
                if (parts.length < 2) {
                    return { valid: false, error: 'play command requires at least one block name' };
                }
                break;
            case 'bpm':
                if (parts.length < 2) {
                    return { valid: false, error: 'bpm command requires BPM value' };
                }
                if (isNaN(parseFloat(parts[1])) || parseFloat(parts[1]) <= 0) {
                    return { valid: false, error: 'BPM must be a positive number' };
                }
                break;
            case 'loop':
            case 'loopasync':
                if (parts.length < 3) {
                    return { valid: false, error: 'loop command requires count and at least one block name' };
                }
                if (isNaN(parseInt(parts[1]))) {
                    return { valid: false, error: 'loop count must be a number' };
                }
                break;
            case 'pattern':
                if (parts.length < 3) {
                    return { valid: false, error: 'pattern command requires name and pattern string' };
                }
                break;
            case 'sequence':
                if (parts.length < 3) {
                    return { valid: false, error: 'sequence command requires name and step pattern' };
                }
                break;
            case 'set':
                if (parts.length < 3) {
                    return { valid: false, error: 'set command requires variable name and value' };
                }
                break;
            case 'effect':
                if (parts.length < 3) {
                    return { valid: false, error: 'effect command requires effect type and parameters' };
                }
                const effectType = parts[1];
                const validEffects = ['reverb', 'delay', 'filter', 'distortion', 'chorus'];
                if (!validEffects.includes(effectType)) {
                    return { valid: false, error: `Unknown effect type: ${effectType}. Valid effects: ${validEffects.join(', ')}` };
                }
                break;
            case 'if':
                if (parts.length < 4) {
                    return { valid: false, error: 'if statement requires variable, operator, and value' };
                }
                break;
            case 'for':
                if (parts.length < 4) {
                    return { valid: false, error: 'for loop requires variable, start, and end values' };
                }
                break;
            case 'endif':
            case 'endfor':
                // No additional validation needed
                break;
            case 'tts':
                if (parts.length < 2) {
                    return { valid: false, error: 'tts command requires text' };
                }
                // Check if speechSynthesis is available
                if (typeof speechSynthesis === 'undefined') {
                    return { valid: false, error: 'Text-to-speech not supported in this browser' };
                }
                break;
            default:
                return { valid: false, error: `Unknown command: ${cmd}` };
        }

        return { valid: true };
    }

    async execute() {
        if (!this.audioEngine) {
            throw new Error('Audio engine not available');
        }

        this.isRunning = true;
        this.currentPosition = 0;

        try {
            // Execute global commands first
            for (const command of this.globalCommands) {
                if (!this.isRunning) break;
                await this.executeCommand(command, 0);
            }

            // If no global play commands, try to play main block
            if (this.globalCommands.length === 0 && this.blocks.has('main')) {
                await this.executeBlock('main', 0);
            }

        } catch (error) {
            console.error('Execution error:', error);
            throw error;
        }
    }

    async executeCommand(command, startTime, effectNodes = []) {
        const parts = command.split(/\s+/);
        const cmd = parts[0];

        switch (cmd) {
            case 'sample':
                return this.executeSample(parts, startTime, effectNodes);
            case 'tone':
                return this.executeTone(parts, startTime, effectNodes);
            case 'slide':
                return this.executeSlide(parts, startTime);
            case 'sidechain':
                return this.executeSidechain(parts, startTime);
            case 'wait':
                return this.executeWait(parts, startTime);
            case 'play':
                return this.executePlay(parts, startTime);
            case 'playasync':
                return this.executePlayAsync(parts, startTime);
            case 'loopasync':
                return this.executeLoopAsync(parts, startTime);
            case 'loop':
                return this.executeLoop(parts, startTime);
            case 'set':
                return this.executeSet(parts);
            case 'effect':
                return this.executeEffect(parts, startTime);
            case 'bpm':
                return this.executeBPM(parts);
            case 'pattern':
                return this.executePattern(parts, startTime);
            case 'sequence':
                return this.executeSequence(parts, startTime);
            case 'tts':
                return this.executeTTS(parts, startTime);
            default:
                console.warn(`Unknown command: ${cmd}`);
                return 0;
        }
    }

    executeBPM(parts) {
        const newBPM = parseFloat(parts[1]);
        this.bpm = newBPM;
        this.beatDuration = 60 / this.bpm;
        console.log(`BPM set to ${this.bpm}, beat duration: ${this.beatDuration}s`);
        return 0;
    }

    async executePattern(parts, startTime, effectNodes = []) {
        if (parts.length < 3 || parts.length % 2 !== 1) {
            console.warn('Pattern command requires pairs of a sample name and a pattern string.');
            return 0;
        }

        const patterns = [];
        // Loop through parts, taking a sample name and a pattern string as a pair
        for (let i = 1; i < parts.length; i += 2) {
            const sampleName = parts[i];
            const patternString = parts[i + 1].replace(/"/g, ''); // Remove quotes
            patterns.push({ name: sampleName, string: patternString });
        }

        if (patterns.length === 0) {
            return 0;
        }

        let maxLength = 0;
        const executionPromises = [];
        const stepDuration = this.beatDuration / 4; // 16th notes

        // Process each pattern definition
        for (const pattern of patterns) {
            const steps = pattern.string.split('-');
            if (steps.length > maxLength) {
                maxLength = steps.length;
            }

            for (let i = 0; i < steps.length; i++) {
                const step = steps[i].trim();
                if (step === '1' || step === 'x' || step === 'X') {
                    const hitTime = startTime + (i * stepDuration);
                    // Schedule the sample play, and run them in parallel
                    executionPromises.push(
                        this.executeCommand(`sample ${pattern.name}`, hitTime, effectNodes)
                    );
                }
            }
        }

        // Wait for all sample scheduling commands to be initiated
        await Promise.all(executionPromises);

        // The total duration is determined by the longest pattern
        return maxLength * stepDuration;
    }

    async executeSequence(parts, startTime, effectNodes = []) {
        const sampleName = parts[1];
        const steps = parts.slice(2);

        let currentTime = 0;
        const stepDuration = this.beatDuration / 4;

        for (let i = 0; i < steps.length; i++) {
            const step = steps[i];
            if (step !== '-' && step !== '0') {
                await this.executeCommand(`sample ${step}`, startTime + currentTime, effectNodes);
            }
            currentTime += stepDuration;
        }

        return currentTime;
    }

    async executeIf(parts, startTime, commands, currentIndex) {
        const variable = parts[1];
        const operator = parts[2];
        const value = this.parseValue(parts[3]);
        const varValue = this.parseValue(variable);

        let condition = false;
        switch (operator) {
            case '>': condition = varValue > value; break;
            case '<': condition = varValue < value; break;
            case '==': condition = varValue == value; break;
            case '!=': condition = varValue != value; break;
            case '>=': condition = varValue >= value; break;
            case '<=': condition = varValue <= value; break;
        }

        // Find matching endif
        let endifIndex = this.findMatchingEnd(commands, currentIndex, 'if', 'endif');

        if (condition) {
            // Execute commands between if and endif
            return await this.executeCommandBlock(commands, currentIndex + 1, endifIndex, startTime);
        }

        return { duration: 0, nextIndex: endifIndex + 1 };
    }

    async executeFor(parts, startTime, commands, currentIndex) {
        const variable = parts[1];
        const start = this.parseValue(parts[2]);
        const end = this.parseValue(parts[3]);

        let totalDuration = 0;
        const endforIndex = this.findMatchingEnd(commands, currentIndex, 'for', 'endfor');

        for (let i = start; i <= end; i++) {
            this.variables.set(variable, i);
            const result = await this.executeCommandBlock(commands, currentIndex + 1, endforIndex, startTime + totalDuration);
            totalDuration += result.duration;
        }

        return { duration: totalDuration, nextIndex: endforIndex + 1 };
    }

    async executeTTS(parts, startTime) {
        // Check if we're in offline rendering mode
        if (this.audioEngine && this.audioEngine.audioContext && this.audioEngine.audioContext.constructor.name === 'OfflineAudioContext') {
            // In offline mode, just return estimated duration without actual TTS
            console.warn('TTS not supported in offline rendering mode');

            // Extract text and estimate duration (same logic as below)
            let text = '';
            let paramStartIndex = 1;

            if (parts[1] && parts[1].startsWith('"')) {
                const quotedText = [];
                for (let i = 1; i < parts.length; i++) {
                    quotedText.push(parts[i]);
                    if (parts[i].endsWith('"')) {
                        paramStartIndex = i + 1;
                        break;
                    }
                }
                text = quotedText.join(' ').replace(/"/g, '');
            } else {
                text = parts[1] || 'Hello';
                paramStartIndex = 2;
            }

            const rate = this.parseValue(parts[paramStartIndex] || '1');
            const adjustedRate = rate * (this.bpm / 120);
            const wordsPerMinute = 150 * adjustedRate;
            const wordCount = text.split(' ').length;
            const estimatedDuration = (wordCount / wordsPerMinute) * 60;

            return estimatedDuration;
        }

        // Extract text (handle quoted strings)
        let text = '';
        let paramStartIndex = 1;

        // If text starts with quote, find the closing quote
        if (parts[1] && parts[1].startsWith('"')) {
            const quotedText = [];
            for (let i = 1; i < parts.length; i++) {
                quotedText.push(parts[i]);
                if (parts[i].endsWith('"')) {
                    paramStartIndex = i + 1;
                    break;
                }
            }
            text = quotedText.join(' ').replace(/"/g, '');
        } else {
            // Single word
            text = parts[1] || 'Hello';
            paramStartIndex = 2;
        }

        const rate = this.parseValue(parts[paramStartIndex] || '1');     // Speed (0.1 to 10)
        const pitch = this.parseValue(parts[paramStartIndex + 1] || '1'); // Pitch (0 to 2)
        const voiceIndex = parseInt(parts[paramStartIndex + 2] || '0');   // Voice ID

        // Adjust rate based on BPM if needed
        const adjustedRate = rate * (this.bpm / 120); // Scale with BPM

        // Calculate absolute timing based on audio context
        const audioContextTime = this.audioEngine.audioContext.currentTime;
        const absoluteStartTime = audioContextTime + startTime;

        // Create a simple unique identifier based on execution order and timing
        const executionId = Date.now() + Math.random();
        const ttsId = `tts_${executionId}`;

        // Initialize if needed
        if (!this.activeTTSCalls) {
            this.activeTTSCalls = new Set();
        }

        if (!this.pendingTTSTimeouts) {
            this.pendingTTSTimeouts = new Map();
        }

        console.log(`Starting TTS: "${text}" with ID: ${ttsId} scheduled for absolute time: ${absoluteStartTime} (current: ${audioContextTime}, offset: ${startTime})`);

        // Create speech synthesis utterance
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = Math.max(0.1, Math.min(10, adjustedRate));
        utterance.pitch = Math.max(0, Math.min(2, pitch));

        // Set voice if available
        const voices = speechSynthesis.getVoices();
        if (voices.length > 0 && voiceIndex < voices.length) {
            utterance.voice = voices[voiceIndex];
        }

        // Cleanup function
        const cleanup = () => {
            const index = this.activeUtterances.indexOf(utterance);
            if (index > -1) {
                this.activeUtterances.splice(index, 1);
            }
            this.activeTTSCalls.delete(ttsId);
            this.pendingTTSTimeouts.delete(ttsId);
            console.log(`Cleaned up TTS: "${text}" (${ttsId})`);
        };

        utterance.onend = () => {
            console.log(`TTS completed: "${text}" (${ttsId})`);
            cleanup();
        };

        utterance.onerror = (event) => {
            console.error(`SpeechSynthesis error for "${text}" (${ttsId}): ${event.error}`);
            cleanup();
        };

        // Add to tracking
        this.activeTTSCalls.add(ttsId);
        this.activeUtterances.push(utterance);

        // Use a more precise timing mechanism based on audio context
        const scheduleWithPreciseTiming = () => {
            const checkTime = () => {
                const currentTime = this.audioEngine.audioContext.currentTime;

                // Check if it's time to play (within 50ms tolerance)
                if (currentTime >= absoluteStartTime - 0.05) {
                    if (this.isRunning && this.activeTTSCalls.has(ttsId)) {
                        console.log(`Speaking: "${text}" (${ttsId}) at context time: ${currentTime} (target was: ${absoluteStartTime})`);
                        try {
                            speechSynthesis.speak(utterance);
                        } catch (error) {
                            console.error(`Failed to speak TTS "${text}":`, error);
                            cleanup();
                        }
                    } else {
                        console.log(`Skipping TTS "${text}" (${ttsId}) - execution stopped or already processed`);
                        cleanup();
                    }
                    return; // Stop checking
                }

                // Continue checking if we haven't reached the target time yet
                if (this.isRunning && this.activeTTSCalls.has(ttsId)) {
                    // Check again in 10ms
                    setTimeout(checkTime, 10);
                } else {
                    cleanup();
                }
            };

            // Start the timing check
            checkTime();
        };

        // Start the precise timing scheduler
        scheduleWithPreciseTiming();

        // Estimate duration (rough calculation)
        const wordsPerMinute = 150 * utterance.rate;
        const wordCount = text.split(' ').length;
        const estimatedDuration = (wordCount / wordsPerMinute) * 60;

        return estimatedDuration;
    }

    findMatchingEnd(commands, startIndex, startKeyword, endKeyword) {
        let depth = 1;
        for (let i = startIndex + 1; i < commands.length; i++) {
            const cmd = commands[i].split(/\s+/)[0];
            if (cmd === startKeyword) depth++;
            if (cmd === endKeyword) depth--;
            if (depth === 0) return i;
        }
        return commands.length - 1;
    }

    async executeCommandBlock(commands, startIndex, endIndex, startTime) {
        let currentTime = 0;
        let i = startIndex;

        while (i < endIndex) {
            const command = commands[i];
            const parts = command.split(/\s+/);
            const cmd = parts[0];

            // Handle control flow commands here, not in executeCommand
            if (cmd === 'if') {
                const result = await this.executeIf(parts, startTime + currentTime, commands, i);
                currentTime += result.duration;
                i = result.nextIndex;
            } else if (cmd === 'for') {
                const result = await this.executeFor(parts, startTime + currentTime, commands, i);
                currentTime += result.duration;
                i = result.nextIndex;
            } else if (cmd === 'endif' || cmd === 'endfor') {
                // These should be handled by their respective start commands
                i++;
            } else {
                // Regular commands
                const duration = await this.executeCommand(command, startTime + currentTime);
                currentTime += duration;
                i++;
            }
        }

        return { duration: currentTime };
    }

    async executeSample(parts, startTime, effectNodes = []) {
        const sampleName = parts[1];
        const pitch = this.parseValue(parts[2] || '1');
        const timescale = this.parseValue(parts[3] || '1');
        const volume = this.parseValue(parts[4] || this.defaultVolume);
        const pan = this.parseValue(parts[5] || this.defaultPan);

        // Parse additional parameters
        const params = this.parseParameters(parts.slice(6));

        // If sampleName is a custom sample block, play all commands in the block simultaneously
        if (this.customSamples.has(sampleName)) {
            const commands = this.customSamples.get(sampleName);
            // Run all commands in parallel at the same startTime
            await Promise.all(commands.map(command =>
                this.executeCommand(command, startTime, effectNodes)
            ));
            return 0;
        }

        // Connect to effect chain if present, otherwise use default output
        let outputNode = this.audioEngine.eq.low;
        if (effectNodes && typeof effectNodes.connect === 'function') {
            outputNode = effectNodes;
        } else if (effectNodes && effectNodes.length > 0) {
            outputNode = effectNodes[0];
        }

        this.audioEngine.playSample(
            sampleName,
            pitch,
            timescale,
            startTime,
            Math.max(0.001, Number(volume) * (params.volume || 1)),
            pan + (params.pan || 0),
            outputNode
        );

        return 0; // Samples don't add to timing by default
    }

    executeTone(parts, startTime, effectNodes = []) {
        const noteOrFreq = parts[1];
        let duration = this.parseValue(parts[2] || '1');
        const volume = this.parseValue(parts[4] || this.defaultVolume);
        const pan = this.parseValue(parts[5] || this.defaultPan);
        const waveType = parts[3] || 'sine';

        // Convert duration based on BPM (treat duration as beats)
        const durationInSeconds = duration * this.beatDuration;

        // Parse additional parameters
        const params = this.parseParameters(parts.slice(6));

        let frequency;
        if (isNaN(noteOrFreq)) {
            frequency = this.audioEngine.noteToFrequency(noteOrFreq);
        } else {
            frequency = parseFloat(noteOrFreq);
        }

        // Connect to effect chain if present, otherwise use default output
        let outputNode = this.audioEngine.eq.low;
        if (effectNodes && typeof effectNodes.connect === 'function') {
            outputNode = effectNodes;
        } else if (effectNodes && effectNodes.length > 0) {
            outputNode = effectNodes[0];
        }

        // Create oscillator and gain node for smooth envelope
        const ctx = this.audioEngine.audioContext;
        const oscillator = ctx.createOscillator();
        const gainNode = ctx.createGain();
        const panNode = ctx.createStereoPanner();

        oscillator.type = waveType;
        oscillator.frequency.value = frequency;
        panNode.pan.value = Math.max(-1, Math.min(1, pan + (params.pan || 0)));

        // Connect audio graph
        oscillator.connect(gainNode);
        gainNode.connect(panNode);
        panNode.connect(outputNode);

        // Calculate timing
        const s = ctx.currentTime + startTime;
        const e = s + durationInSeconds;

        // Smooth envelope to prevent clicks
        const fadeTime = Math.min(0.005, durationInSeconds * 0.1); // 5ms or 10% of duration, whichever is smaller
        const targetVolume = volume * (params.volume || 1);

        gainNode.gain.setValueAtTime(0, s);
        gainNode.gain.linearRampToValueAtTime(targetVolume, s + fadeTime);
        gainNode.gain.setValueAtTime(targetVolume, e - fadeTime);
        gainNode.gain.linearRampToValueAtTime(0, e);

        // Start and stop oscillator
        oscillator.start(s);
        oscillator.stop(e);

        // Track active sources
        this.audioEngine.activeSources.add(oscillator);
        oscillator.addEventListener('ended', () => {
            this.audioEngine.activeSources.delete(oscillator);
        });

        return durationInSeconds;
    }

    async executeSlide(parts, startTime) {
        const key1 = parts[1];
        const key2 = parts[2];
        const timescale = this.parseValue(parts[3] || '1');
        const durationInSeconds = timescale * this.beatDuration;

        // Optional: waveType, volume, pan
        const waveType = parts[4] || 'sine';
        const volume = this.parseValue(parts[5] || this.defaultVolume);
        const pan = this.parseValue(parts[6] || this.defaultPan);

        // Support both note names and frequencies
        const freq1 = isNaN(key1) ? this.audioEngine.noteToFrequency(key1) : parseFloat(key1);
        const freq2 = isNaN(key2) ? this.audioEngine.noteToFrequency(key2) : parseFloat(key2);

        const ctx = this.audioEngine.audioContext;
        const oscillator = ctx.createOscillator();
        const gainNode = ctx.createGain();
        const panNode = ctx.createStereoPanner();

        // Define the absolute start and end times for all scheduling
        const s = ctx.currentTime + startTime;
        const e = s + durationInSeconds;

        // Schedule the oscillator frequency changes
        oscillator.type = waveType;
        oscillator.frequency.setValueAtTime(freq1, s);
        oscillator.frequency.linearRampToValueAtTime(freq2, e);

        // Schedule the pan value
        panNode.pan.setValueAtTime(Math.max(-1, Math.min(1, pan)), s);

        // Smooth envelope - shorter fade times for slides
        const fadeTime = Math.min(0.003, durationInSeconds * 0.03); // 3ms or 3% of duration

        gainNode.gain.setValueAtTime(0, s);
        gainNode.gain.linearRampToValueAtTime(volume, s + fadeTime);
        gainNode.gain.setValueAtTime(volume, e - fadeTime);
        gainNode.gain.linearRampToValueAtTime(0, e);

        // Connect the audio graph
        oscillator.connect(gainNode);
        gainNode.connect(panNode);
        panNode.connect(this.audioEngine.eq.low);

        // Schedule the oscillator to start and stop
        oscillator.start(s);
        oscillator.stop(e);

        // Track active sources for stopping
        this.audioEngine.activeSources.add(oscillator);
        oscillator.addEventListener('ended', () => {
            this.audioEngine.activeSources.delete(oscillator);
        });

        return durationInSeconds;
    }

    async executeSidechain(parts, startTime) {
        const block1 = parts[1]; // Block to be ducked
        const block2 = parts[2]; // Trigger block
        const amount = parseFloat(parts[3]);

        if (!this.blocks.has(block1) || !this.blocks.has(block2)) {
            console.warn(`One or both blocks not found: ${block1}, ${block2}`);
            return 0;
        }

        const ctx = this.audioEngine.audioContext;

        // Create a gain node to control block1's volume
        const sidechainGain = ctx.createGain();
        sidechainGain.gain.value = 1; // Start at full volume

        // Create a compressor for more realistic sidechain effect
        const compressor = ctx.createDynamicsCompressor();
        compressor.threshold.value = -50;
        compressor.knee.value = 40;
        compressor.ratio.value = 20;
        compressor.attack.value = 0.003;
        compressor.release.value = 0.1;

        // Connect sidechain gain to compressor to output
        sidechainGain.connect(compressor);
        compressor.connect(this.audioEngine.eq.low);

        // Calculate durations for both blocks
        const block1Duration = this.estimateDuration(block1);
        const block2Duration = this.estimateDuration(block2);

        // Use the longer duration, but ensure we have at least some playback time
        const maxDuration = Math.max(block1Duration, block2Duration, 4); // Minimum 4 seconds

        console.log(`Sidechain: block1 (${block1}) duration: ${block1Duration}s, block2 (${block2}) duration: ${block2Duration}s, total: ${maxDuration}s`);

        // Override methods to route audio properly
        const originalPlaySample = this.audioEngine.playSample.bind(this.audioEngine);
        const originalExecuteTone = this.executeTone.bind(this);

        let currentExecutingBlock = null;

        // Create routing methods
        const sidechainPlaySample = (sampleName, pitch, timescale, when, volume, pan, outputNode) => {
            if (currentExecutingBlock === block1) {
                // Route block1 through sidechain gain
                return originalPlaySample(sampleName, pitch, timescale, when, volume, pan, sidechainGain);
            } else {
                // Block2 goes directly to output
                return originalPlaySample(sampleName, pitch, timescale, when, volume, pan, this.audioEngine.eq.low);
            }
        };

        const sidechainExecuteTone = (parts, startTime, effectNodes) => {
            if (currentExecutingBlock === block1) {
                // Route block1 tones through sidechain gain
                return originalExecuteTone.call(this, parts, startTime, [sidechainGain]);
            } else {
                // Block2 tones go directly to output
                return originalExecuteTone.call(this, parts, startTime, [this.audioEngine.eq.low]);
            }
        };

        // Analyze block2 for trigger detection
        const getTriggerTimes = (blockName, blockDuration, totalDuration) => {
            const commands = this.blocks.get(blockName);
            const triggers = [];

            const loopCount = blockDuration > 0 ? Math.ceil(totalDuration / blockDuration) : 1;

            for (let loop = 0; loop < loopCount; loop++) {
                const loopStart = loop * blockDuration;
                if (loopStart >= totalDuration) break;

                let time = 0;

                for (const command of commands) {
                    const cmdParts = command.split(/\s+/);
                    const cmd = cmdParts[0];

                    if (cmd === 'sample') {
                        triggers.push(loopStart + time);
                    } else if (cmd === 'tone') {
                        triggers.push(loopStart + time);
                        const duration = this.parseValue(cmdParts[2] || '1') * this.beatDuration;
                        time += duration;
                    } else if (cmd === 'slide') {
                        triggers.push(loopStart + time);
                        const duration = this.parseValue(cmdParts[3] || '1') * this.beatDuration;
                        time += duration;
                    } else if (cmd === 'wait') {
                        time += this.parseValue(cmdParts[1]) * this.beatDuration;
                    } else if (cmd === 'pattern') {
                        // Handle pattern triggers
                        for (let i = 2; i < cmdParts.length; i += 2) {
                            if (i + 1 < cmdParts.length) {
                                const patternStr = cmdParts[i + 1].replace(/"/g, '');
                                const steps = patternStr.split('-');
                                const stepDuration = this.beatDuration / 4;

                                for (let j = 0; j < steps.length; j++) {
                                    if (steps[j].trim() === '1' || steps[j].trim() === 'x' || steps[j].trim() === 'X') {
                                        triggers.push(loopStart + time + (j * stepDuration));
                                    }
                                }
                                time += steps.length * stepDuration;
                            }
                        }
                    }
                }
            }

            return triggers;
        };

        // Get all trigger times from block2
        const triggerTimes = getTriggerTimes(block2, block2Duration, maxDuration);
        console.log(`Sidechain: Found ${triggerTimes.length} triggers at times:`, triggerTimes);

        // Schedule ducking automation
        const duckDuration = 0.15; // How long the duck lasts
        const attackTime = 0.01;   // How quickly it ducks

        triggerTimes.forEach((triggerTime, index) => {
            if (triggerTime < maxDuration) {
                const absoluteTime = ctx.currentTime + startTime + triggerTime;

                console.log(`Scheduling duck ${index + 1} at ${triggerTime}s (absolute: ${absoluteTime}s)`);

                // Duck the gain
                sidechainGain.gain.cancelScheduledValues(absoluteTime);
                sidechainGain.gain.setValueAtTime(1, absoluteTime);
                sidechainGain.gain.linearRampToValueAtTime(1 - amount, absoluteTime + attackTime);
                sidechainGain.gain.linearRampToValueAtTime(1, absoluteTime + duckDuration);
            }
        });

        // Override the audio methods
        this.audioEngine.playSample = sidechainPlaySample;
        this.executeTone = sidechainExecuteTone;

        try {
            const promises = [];

            // Execute block1 (gets sidechained)
            currentExecutingBlock = block1;
            if (block1Duration > 0 && block1Duration < maxDuration) {
                // Loop block1 to fill duration
                const loops = Math.ceil(maxDuration / block1Duration);
                for (let i = 0; i < loops; i++) {
                    const loopStart = startTime + (i * block1Duration);
                    if (loopStart < startTime + maxDuration) {
                        promises.push(this.executeBlock(block1, loopStart));
                    }
                }
            } else {
                promises.push(this.executeBlock(block1, startTime));
            }

            // Execute block2 (triggers sidechain)
            currentExecutingBlock = block2;
            if (block2Duration > 0 && block2Duration < maxDuration) {
                // Loop block2 to fill duration
                const loops = Math.ceil(maxDuration / block2Duration);
                for (let i = 0; i < loops; i++) {
                    const loopStart = startTime + (i * block2Duration);
                    if (loopStart < startTime + maxDuration) {
                        promises.push(this.executeBlock(block2, loopStart));
                    }
                }
            } else {
                promises.push(this.executeBlock(block2, startTime));
            }

            await Promise.all(promises);
            return maxDuration;

        } finally {
            // Restore original methods
            this.audioEngine.playSample = originalPlaySample;
            this.executeTone = originalExecuteTone;
            currentExecutingBlock = null;
        }
    }

    executeWait(parts, startTime) {
        let duration = this.parseValue(parts[1]);
        // Convert wait duration based on BPM (treat as beats)
        return duration * this.beatDuration;
    }

    async executePlay(parts, startTime) {
        const blockNames = [];
        const params = {};

        // Parse block names and parameters
        for (let i = 1; i < parts.length; i++) {
            if (parts[i].includes('=')) {
                const [key, value] = parts[i].split('=');
                params[key] = this.parseValue(value);
            } else {
                blockNames.push(parts[i]);
            }
        }

        if (blockNames.length === 0) {
            return 0;
        }

        // Estimate durations for all blocks
        const blockDurations = blockNames.map(name => ({
            name,
            duration: this.estimateDuration(name)
        }));

        // Find the maximum duration among all blocks
        const maxDuration = Math.max(...blockDurations.map(b => b.duration), 0);

        if (maxDuration === 0) {
            // If max duration is 0, just play all blocks once simultaneously
            const promises = blockNames.map(blockName => this.executeBlock(blockName, startTime, params));
            await Promise.all(promises);
            return 0;
        }

        const allExecutionPromises = [];

        // Schedule all block executions - shorter blocks loop to match longest
        blockDurations.forEach(blockInfo => {
            const { name, duration } = blockInfo;

            if (duration <= 0) {
                // Play once if duration is 0
                allExecutionPromises.push(this.executeBlock(name, startTime, params));
            } else {
                // Loop the block to fill the maxDuration
                const loopCount = Math.ceil(maxDuration / duration);

                for (let i = 0; i < loopCount; i++) {
                    if (!this.isRunning) break;
                    const loopStartTime = startTime + (i * duration);
                    // Ensure we don't schedule past the max duration
                    if (loopStartTime < startTime + maxDuration) {
                        allExecutionPromises.push(this.executeBlock(name, loopStartTime, params));
                    }
                }
            }
        });

        // Wait for all scheduled blocks to complete their execution logic
        await Promise.all(allExecutionPromises);

        // The total duration of the play command is the duration of the longest block
        return maxDuration;
    }

    async executePlayAsync(parts, startTime) {
        const blockNames = [];
        const params = {};

        // Parse block names and parameters
        for (let i = 1; i < parts.length; i++) {
            if (parts[i].includes('=')) {
                const [key, value] = parts[i].split('=');
                params[key] = this.parseValue(value);
            } else {
                blockNames.push(parts[i]);
            }
        }

        if (blockNames.length === 0) {
            return 0;
        }

        // Start all blocks immediately without waiting for their completion
        // This runs asynchronously and doesn't block the timeline
        Promise.all(blockNames.map(blockName =>
            this.executeBlock(blockName, startTime, params)
        )).catch(error => {
            console.error('Async play error:', error);
        });

        // Return 0 duration so execution continues immediately
        return 0;
    }

    async executeLoopAsync(parts, startTime) {
        const count = parseInt(parts[1]);
        const blockNames = parts.slice(2);

        // Validate block names
        for (const blockName of blockNames) {
            if (!this.blocks.has(blockName)) {
                console.warn(`Block '${blockName}' not found`);
                return 0;
            }
        }

        // Start the async loop without waiting for completion
        // This runs asynchronously and doesn't block the timeline
        this.executeAsyncLoop(count, blockNames, startTime).catch(error => {
            console.error('Async loop error:', error);
        });

        // Return 0 duration so execution continues immediately
        return 0;
    }

    async executeAsyncLoop(count, blockNames, startTime) {
        // Estimate durations for all blocks
        const blockDurations = blockNames.map(name => ({
            name,
            duration: this.estimateDuration(name)
        }));

        // Find the maximum duration among all blocks in one iteration
        const maxIterationDuration = Math.max(...blockDurations.map(b => b.duration), 0);

        if (maxIterationDuration === 0) {
            // If all blocks have 0 duration, just play them count times
            for (let i = 0; i < count; i++) {
                if (!this.isRunning) break;
                const promises = blockNames.map(blockName =>
                    this.executeBlock(blockName, startTime)
                );
                await Promise.all(promises);
            }
            return;
        }

        const allExecutionPromises = [];
        let totalDuration = 0;

        // For each iteration of the loop
        for (let iteration = 0; iteration < count; iteration++) {
            if (!this.isRunning) break;

            const iterationStartTime = startTime + totalDuration;

            // Schedule all blocks for this iteration - shorter blocks loop within the iteration
            blockDurations.forEach(blockInfo => {
                const { name, duration } = blockInfo;

                if (duration <= 0) {
                    // Play once if duration is 0
                    allExecutionPromises.push(this.executeBlock(name, iterationStartTime));
                } else {
                    // Loop the block to fill the maxIterationDuration
                    const loopCount = Math.ceil(maxIterationDuration / duration);

                    for (let i = 0; i < loopCount; i++) {
                        if (!this.isRunning) break;
                        const loopStartTime = iterationStartTime + (i * duration);
                        // Ensure we don't schedule past the iteration's max duration
                        if (loopStartTime < iterationStartTime + maxIterationDuration) {
                            allExecutionPromises.push(this.executeBlock(name, loopStartTime));
                        }
                    }
                }
            });

            totalDuration += maxIterationDuration;
        }

        // Wait for all scheduled blocks to complete their execution logic
        await Promise.all(allExecutionPromises);
    }

    async executeLoop(parts, startTime) {
        const count = parseInt(parts[1]);
        const blockNames = parts.slice(2);

        // Validate block names
        for (const blockName of blockNames) {
            if (!this.blocks.has(blockName)) {
                console.warn(`Block '${blockName}' not found`);
                return 0;
            }
        }

        // Estimate durations for all blocks
        const blockDurations = blockNames.map(name => ({
            name,
            duration: this.estimateDuration(name)
        }));

        // Find the maximum duration among all blocks in one iteration
        const maxIterationDuration = Math.max(...blockDurations.map(b => b.duration), 0);

        if (maxIterationDuration === 0) {
            // If all blocks have 0 duration, just play them count times
            let totalDuration = 0;
            for (let i = 0; i < count; i++) {
                if (!this.isRunning) break;
                const promises = blockNames.map(blockName =>
                    this.executeBlock(blockName, startTime + totalDuration)
                );
                await Promise.all(promises);
            }
            return 0;
        }

        const allExecutionPromises = [];
        let totalDuration = 0;

        // For each iteration of the loop
        for (let iteration = 0; iteration < count; iteration++) {
            if (!this.isRunning) break;

            const iterationStartTime = startTime + totalDuration;

            // Schedule all blocks for this iteration - shorter blocks loop within the iteration
            blockDurations.forEach(blockInfo => {
                const { name, duration } = blockInfo;

                if (duration <= 0) {
                    // Play once if duration is 0
                    allExecutionPromises.push(this.executeBlock(name, iterationStartTime));
                } else {
                    // Loop the block to fill the maxIterationDuration
                    const loopCount = Math.ceil(maxIterationDuration / duration);

                    for (let i = 0; i < loopCount; i++) {
                        if (!this.isRunning) break;
                        const loopStartTime = iterationStartTime + (i * duration);
                        // Ensure we don't schedule past the iteration's max duration
                        if (loopStartTime < iterationStartTime + maxIterationDuration) {
                            allExecutionPromises.push(this.executeBlock(name, loopStartTime));
                        }
                    }
                }
            });

            totalDuration += maxIterationDuration;
        }

        // Wait for all scheduled blocks to complete their execution logic
        await Promise.all(allExecutionPromises);

        return totalDuration;
    }

    executeSet(parts) {
        const varName = parts[1];
        const value = this.parseValue(parts[2]);
        this.variables.set(varName, value);
        return 0;
    }

    executeEffect(parts, startTime) {
        const effectType = parts[1];
        const blockName = parts[2];
        const params = this.parseParameters(parts.slice(3));

        // Store effect for later application
        if (!this.effects.has(blockName)) {
            this.effects.set(blockName, []);
        }
        this.effects.get(blockName).push({ type: effectType, params: params });

        return 0;
    }

    async executeBlock(blockName, startTime, globalParams = {}) {
        if (!this.blocks.has(blockName)) {
            console.warn(`Block '${blockName}' not found`);
            return 0;
        }

        const commands = this.blocks.get(blockName);
        let currentTime = 0;

        // --- EFFECT CHAIN PATCH START ---
        let effectInputNode = this.audioEngine.eq.low; // Default output
        if (this.effects.has(blockName) && this.audioEngine) {
            const ctx = this.audioEngine.audioContext;
            const effects = this.effects.get(blockName);
            let currentNode = this.audioEngine.eq.low; // Start with default output

            // Build effect chain from last to first (reverse order)
            for (let i = effects.length - 1; i >= 0; i--) {
                const effect = effects[i];
                let effectNode = null;
                let wetGain = null;
                let dryGain = null;

                if (effect.type === 'reverb') {
                    effectNode = ctx.createConvolver();
                    if (this.audioEngine.reverb && this.audioEngine.reverb.buffer) {
                        effectNode.buffer = this.audioEngine.reverb.buffer;
                    }

                    // Create wet/dry mix
                    wetGain = ctx.createGain();
                    dryGain = ctx.createGain();
                    const wetAmount = parseFloat(effect.params[0]) || 0.3;
                    wetGain.gain.value = wetAmount;
                    dryGain.gain.value = 1 - wetAmount;

                    // Connect: input -> [dry path, wet path] -> output
                    effectNode.connect(wetGain);
                    wetGain.connect(currentNode);
                    dryGain.connect(currentNode);

                    // Create input splitter
                    const splitter = ctx.createGain();
                    splitter.connect(effectNode); // to wet
                    splitter.connect(dryGain);    // to dry

                    currentNode = splitter;

                } else if (effect.type === 'delay') {
                    effectNode = ctx.createDelay(1); // Max 1 second delay
                    const delayTime = parseFloat(effect.params[0]) || 0.3;
                    const feedback = parseFloat(effect.params[1]) || 0.3;
                    const wetAmount = parseFloat(effect.params[2]) || 0.3;

                    effectNode.delayTime.value = delayTime;

                    // Create feedback loop
                    const feedbackGain = ctx.createGain();
                    feedbackGain.gain.value = feedback;
                    effectNode.connect(feedbackGain);
                    feedbackGain.connect(effectNode);

                    // Create wet/dry mix
                    wetGain = ctx.createGain();
                    dryGain = ctx.createGain();
                    wetGain.gain.value = wetAmount;
                    dryGain.gain.value = 1 - wetAmount;

                    effectNode.connect(wetGain);
                    wetGain.connect(currentNode);
                    dryGain.connect(currentNode);

                    const splitter = ctx.createGain();
                    splitter.connect(effectNode);
                    splitter.connect(dryGain);

                    currentNode = splitter;

                } else if (effect.type === 'filter') {
                    effectNode = ctx.createBiquadFilter();
                    const filterType = effect.params[0] || 'lowpass';
                    const frequency = parseFloat(effect.params[1]) || 1000;
                    const q = parseFloat(effect.params[2]) || 1;

                    effectNode.type = filterType;
                    effectNode.frequency.value = frequency;
                    effectNode.Q.value = q;

                    effectNode.connect(currentNode);
                    currentNode = effectNode;

                } else if (effect.type === 'distortion') {
                    effectNode = ctx.createWaveShaper();
                    const amount = parseFloat(effect.params[0]) || 10;
                    const samples = 44100;
                    const curve = new Float32Array(samples);
                    const deg = Math.PI / 180;

                    for (let i = 0; i < samples; i++) {
                        const x = (i * 2) / samples - 1;
                        curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
                    }

                    effectNode.curve = curve;
                    effectNode.oversample = '4x';

                    effectNode.connect(currentNode);
                    currentNode = effectNode;

                } else if (effect.type === 'chorus') {
                    // Simple chorus using multiple delays
                    const rate = parseFloat(effect.params[0]) || 1;
                    const depth = parseFloat(effect.params[1]) || 0.002;
                    const wetAmount = parseFloat(effect.params[2]) || 0.3;

                    const delay1 = ctx.createDelay(0.1);
                    const delay2 = ctx.createDelay(0.1);
                    const lfo1 = ctx.createOscillator();
                    const lfo2 = ctx.createOscillator();
                    const lfoGain1 = ctx.createGain();
                    const lfoGain2 = ctx.createGain();

                    lfo1.frequency.value = rate;
                    lfo2.frequency.value = rate * 1.1; // Slightly different rate
                    lfoGain1.gain.value = depth;
                    lfoGain2.gain.value = depth;

                    lfo1.connect(lfoGain1);
                    lfo2.connect(lfoGain2);
                    lfoGain1.connect(delay1.delayTime);
                    lfoGain2.connect(delay2.delayTime);

                    delay1.delayTime.value = 0.01;
                    delay2.delayTime.value = 0.015;

                    wetGain = ctx.createGain();
                    dryGain = ctx.createGain();
                    wetGain.gain.value = wetAmount;
                    dryGain.gain.value = 1 - wetAmount;

                    const chorusMix = ctx.createGain();
                    delay1.connect(chorusMix);
                    delay2.connect(chorusMix);
                    chorusMix.connect(wetGain);
                    wetGain.connect(currentNode);
                    dryGain.connect(currentNode);

                    const splitter = ctx.createGain();
                    splitter.connect(delay1);
                    splitter.connect(delay2);
                    splitter.connect(dryGain);

                    lfo1.start();
                    lfo2.start();

                    currentNode = splitter;
                }
            }

            effectInputNode = currentNode;
        }
        // --- EFFECT CHAIN PATCH END ---

        // Store original BPM to restore later
        const originalBPM = this.bpm;
        const originalBeatDuration = this.beatDuration;

        try {
            // Process commands with control flow awareness
            let i = 0;
            while (i < commands.length) {
                const command = commands[i];
                const parts = command.split(/\s+/);
                const cmd = parts[0];

                if (cmd === 'if') {
                    const result = await this.executeIf(parts, startTime + currentTime, commands, i);
                    currentTime += result.duration;
                    i = result.nextIndex;
                } else if (cmd === 'for') {
                    const result = await this.executeFor(parts, startTime + currentTime, commands, i);
                    currentTime += result.duration;
                    i = result.nextIndex;
                } else if (cmd === 'pattern') {
                    const duration = await this.executePattern(parts, startTime + currentTime, effectInputNode);
                    currentTime += duration;
                    i++;
                } else if (cmd === 'sequence') {
                    const duration = await this.executeSequence(parts, startTime + currentTime, effectInputNode);
                    currentTime += duration;
                    i++;
                } else {
                    const duration = await this.executeCommand(command, startTime + currentTime, effectInputNode);
                    currentTime += duration;
                    i++;
                }
            }
        } finally {
            // Restore original BPM after block execution
            this.bpm = originalBPM;
            this.beatDuration = originalBeatDuration;
        }

        return currentTime;
    }

    findMatchingEndInArray(commands, startIndex, startKeyword, endKeyword) {
        let depth = 1;
        for (let i = startIndex + 1; i < commands.length; i++) {
            const parts = commands[i].split(/\s+/);
            const cmd = parts[0];
            if (cmd === startKeyword) depth++;
            if (cmd === endKeyword) depth--;
            if (depth === 0) return i;
        }
        return commands.length - 1;
    }

    parseValue(value) {
        if (typeof value === 'number') return value;
        if (typeof value !== 'string') return 0;

        // Check if it's a variable
        if (this.variables.has(value)) {
            return this.variables.get(value);
        }

        // Try to parse as number
        const num = parseFloat(value);
        return isNaN(num) ? 0 : num;
    }

    parseParameters(parts) {
        const params = {};
        for (const part of parts) {
            if (part.includes('=')) {
                const [key, value] = part.split('=');
                params[key] = this.parseValue(value);
            }
        }
        return params;
    }

    stop() {
        this.isRunning = false;
        this.currentPosition = 0;
        this.activeUtterances.length = 0; // Clear any referenced utterances

        // Clear all active TTS calls
        if (this.activeTTSCalls) {
            this.activeTTSCalls.clear();
        }

        // Clear all scheduled TTS (legacy)
        if (this.scheduledTTS) {
            this.scheduledTTS.clear();
        }

        // Clear all pending TTS timeouts
        if (this.pendingTTSTimeouts) {
            for (const [ttsId, timeoutId] of this.pendingTTSTimeouts) {
                clearTimeout(timeoutId);
            }
            this.pendingTTSTimeouts.clear();
        }

        // Clear legacy pendingTTS timeout
        if (this.pendingTTS) {
            clearTimeout(this.pendingTTS);
            this.pendingTTS = null;
        }

        // Stop audio engine
        if (this.audioEngine) {
            this.audioEngine.stop();
        }

        // Stop text-to-speech when stopping code execution
        if (typeof speechSynthesis !== 'undefined') {
            speechSynthesis.cancel();
        }

        console.log('Code execution stopped and TTS cleared');
    }

    getBlockInfo(blockName) {
        if (!this.blocks.has(blockName)) {
            return null;
        }

        const commands = this.blocks.get(blockName);
        const info = {
            name: blockName,
            commands: commands.length,
            samples: [],
            tones: [],
            duration: 0
        };

        let estimatedDuration = 0;
        for (const command of commands) {
            const parts = command.split(/\s+/);
            const cmd = parts[0];

            switch (cmd) {
                case 'sample':
                    info.samples.push(parts[1]);
                    break;
                case 'tone':
                    info.tones.push(parts[1]);
                    const duration = this.parseValue(parts[2] || '1');
                    estimatedDuration += duration;
                    break;
                case 'wait':
                    estimatedDuration += this.parseValue(parts[1]);
                    break;
            }
        }

        info.duration = estimatedDuration;
        return info;
    }

    estimateDuration(blockName = 'main', visited = new Set()) {
        if (!this.blocks.has(blockName)) return 0;
        if (visited.has(blockName)) return 0;
        visited.add(blockName);

        let totalBeats = 0;
        let bpm = this.bpm;
        let beatDuration = 60 / bpm;

        const commands = this.blocks.get(blockName);
        for (let i = 0; i < commands.length; i++) {
            const command = commands[i];
            const parts = command.split(/\s+/);
            const cmd = parts[0];

            switch (cmd) {
                case 'wait':
                    totalBeats += parseFloat(parts[1]) || 0;
                    break;
                case 'tone':
                case 'slide':
                    totalBeats += parseFloat(parts[2]) || 1;
                    break;
                case 'bpm':
                    bpm = parseFloat(parts[1]) || bpm;
                    beatDuration = 60 / bpm;
                    break;
                case 'play': {
                    let maxDuration = 0;
                    for (let j = 1; j < parts.length; j++) {
                        if (!parts[j].includes('=')) {
                            const blockDuration = this.estimateDuration(parts[j], new Set(visited));
                            maxDuration = Math.max(maxDuration, blockDuration);
                        }
                    }
                    totalBeats += maxDuration / beatDuration;
                    break;
                }
                case 'loop': {
                    const count = parseInt(parts[1]) || 1;
                    let maxIterationDuration = 0;
                    for (let j = 2; j < parts.length; j++) {
                        const blockDuration = this.estimateDuration(parts[j], new Set(visited));
                        maxIterationDuration = Math.max(maxIterationDuration, blockDuration);
                    }
                    totalBeats += (maxIterationDuration / beatDuration) * count;
                    break;
                }
                case 'pattern':
                    const patternSteps = parts.slice(2).join(' ').split('-').length;
                    totalBeats += (patternSteps * 0.25); // 16th notes
                    break;
                case 'sequence':
                    const sequenceSteps = parts.length - 2;
                    totalBeats += (sequenceSteps * 0.25); // 16th notes
                    break;
                case 'if':
                    // Find matching endif and estimate inner block duration
                    const endifIdx = this.findMatchingEnd(commands, i, 'if', 'endif');
                    // Rough estimation - assume condition is true
                    for (let j = i + 1; j < endifIdx; j++) {
                        const innerCmd = commands[j].split(/\s+/)[0];
                        if (innerCmd === 'wait') {
                            totalBeats += parseFloat(commands[j].split(/\s+/)[1]) || 0;
                        } else if (innerCmd === 'tone' || innerCmd === 'slide') {
                            totalBeats += parseFloat(commands[j].split(/\s+/)[2]) || 1;
                        }
                    }
                    i = endifIdx; // Skip to endif
                    break;
                case 'for':
                    const forStart = parseInt(parts[2]) || 1;
                    const forEnd = parseInt(parts[3]) || 1;
                    const iterations = Math.max(1, forEnd - forStart + 1);
                    const endforIdx = this.findMatchingEnd(commands, i, 'for', 'endfor');
                    // Estimate inner block duration and multiply by iterations
                    let forDuration = 0;
                    for (let j = i + 1; j < endforIdx; j++) {
                        const innerCmd = commands[j].split(/\s+/)[0];
                        if (innerCmd === 'wait') {
                            forDuration += parseFloat(commands[j].split(/\s+/)[1]) || 0;
                        } else if (innerCmd === 'tone' || innerCmd === 'slide') {
                            forDuration += parseFloat(commands[j].split(/\s+/)[2]) || 1;
                        }
                    }
                    totalBeats += forDuration * iterations;
                    i = endforIdx; // Skip to endfor
                    break;
            }
        }
        return totalBeats * beatDuration;
    }

    getAllBlocks() {
        const blocks = [];
        for (const [name, commands] of this.blocks) {
            blocks.push(this.getBlockInfo(name));
        }
        return blocks;
    }

    beatsToSeconds(beats) {
        return beats * this.beatDuration;
    }

    formatCode() {
        let formatted = '';

        // Format global commands
        if (this.globalCommands.length > 0) {
            formatted += '// Global Commands\n';
            for (const command of this.globalCommands) {
                formatted += command + '\n';
            }
            formatted += '\n';
        }

        // Format blocks
        for (const [blockName, commands] of this.blocks) {
            formatted += `[${blockName}]\n`;
            for (const command of commands) {
                formatted += '    ' + command + '\n';
            }
            formatted += '[end]\n\n';
        }

        return formatted.trim();
    }

    getDocumentation() {
        return `
MelodiCode Syntax Reference:

BLOCKS:
[block_name]
    commands...
[end]

<sample_block_name>
    commands...
<end>

COMMANDS:
sample <name> [pitch] [timescale] [volume] [pan] [params...]
    - Play an audio sample
    - pitch: playback speed multiplier (default: 1)
    - timescale: time stretch (default: 1)
    - volume: 0-1 (default: 0.8)
    - pan: -1 to 1 (default: 0)

tone <frequency|note> [duration] [waveType] [volume] [pan]
    - Generate a tone
    - frequency: Hz or note (C4, A#3, etc.)
    - duration: beats (default: 1)
    - waveType: sine, square, sawtooth, triangle (default: sine)
    - volume: 0-1 (default: 0.8)
    - pan: -1 to 1 (default: 0)

slide <key1> <key2> <timescale> [waveType] [volume] [pan]
    - Play a tone at key1 and slide to key2 over timescale beats (BPM-based)
    - Example: slide C4 G4 2 sawtooth 0.7 0

wait <duration>
    - Pause for specified seconds

bpm <value>
    - Set the tempo in beats per minute (default: 120)
    - Example: bpm 140

play <block1> [block2...] [params...]
    - Play one or more blocks simultaneously
    - params: volume=0.8, pan=0, etc.

loop <count> <block_name>
    - Repeat a block specified number of times

set <variable> <value>
    - Set a variable value

effect <type> <block> [params...]
    - Apply effect to a block

TIMING HELPERS:
- Use beatsToSeconds() method in custom code
- BPM affects overall timing calculations

EXAMPLES:
[main]
bpm 130
sample kick 1 1
wait 0.5
tone C4 0.5
slide C4 G4 2
[end]

play main volume=0.8 pan=0
        `;
    }
}

// Global code interpreter instance
window.codeInterpreter = new CodeInterpreter(window.audioEngine);


// src/MelodiCode/MelodiCode.js
/**
 * MelodiCode Integration for Dark Matter JS Game Engine
 * Provides audio capabilities through code-based music/sound generation
 */
class MelodiCode {
    constructor() {
        this.audioEngine = null;
        this.codeInterpreter = null;
        this.isInitialized = false;
        this.isPlaying = false;
        
        // Initialize the audio components
        this.init();
    }

    async init() {
        try {
            // Initialize audio engine if available
            if (window.audioEngine) {
                this.audioEngine = window.audioEngine;
            } else {
                console.warn('MelodiCode: AudioEngine not found, some features may not work');
            }

            // Initialize code interpreter if available
            if (window.codeInterpreter) {
                this.codeInterpreter = window.codeInterpreter;
            } else {
                console.warn('MelodiCode: CodeInterpreter not found, some features may not work');
            }

            this.isInitialized = true;
            console.log('MelodiCode initialized successfully');
        } catch (error) {
            console.error('Failed to initialize MelodiCode:', error);
        }
    }

    /**
     * Play MelodiCode script
     * @param {string} code - MelodiCode script to execute
     * @param {Object} options - Optional parameters
     * @returns {Promise} - Resolves when playback starts
     */
    async play(code, options = {}) {
        if (!this.isInitialized) {
            console.warn('MelodiCode not initialized, attempting to initialize...');
            await this.init();
        }

        if (!this.codeInterpreter || !this.audioEngine) {
            console.error('MelodiCode: Required components not available');
            return false;
        }

        try {
            // Parse the code
            this.codeInterpreter.parse(code);
            
            // Validate the code
            const validation = this.codeInterpreter.validate();
            if (!validation.valid) {
                console.error('MelodiCode validation errors:', validation.errors);
                return false;
            }

            // Set BPM if provided
            if (options.bpm) {
                this.codeInterpreter.bpm = options.bpm;
                this.codeInterpreter.beatDuration = 60 / options.bpm;
            }

            // Execute the code
            await this.codeInterpreter.execute();
            this.isPlaying = true;
            
            console.log('MelodiCode playback started');
            return true;
        } catch (error) {
            console.error('Error playing MelodiCode:', error);
            return false;
        }
    }

    /**
     * Stop current playback
     */
    stop() {
        if (this.codeInterpreter) {
            this.codeInterpreter.stop();
            this.isPlaying = false;
            console.log('MelodiCode playback stopped');
        }
    }

    /**
     * Play a simple beat pattern
     * @param {string} pattern - Beat pattern (e.g., "kick snare kick snare")
     * @param {number} bpm - Beats per minute
     */
    playBeat(pattern, bpm = 120) {
        const code = `
bpm ${bpm}

[main]
    pattern ${pattern}
[end]
play main
`;
        return this.play(code);
    }

    /**
     * Play a simple melody
     * @param {Array} notes - Array of note names (e.g., ["C4", "D4", "E4"])
     * @param {number} duration - Duration per note in beats
     * @param {number} bpm - Beats per minute
     */
    playMelody(notes, duration = 1, bpm = 120) {
        const noteCommands = notes.map(note => `tone ${note} ${duration}`).join('\n    ');
        const code = `
bpm ${bpm}

[main]
    ${noteCommands}
[end]
play main
`;
        return this.play(code);
    }

    /**
     * Play a single sample
     * @param {string} sampleName - Name of the sample to play
     * @param {Object} options - Optional parameters (pitch, volume, etc.)
     */
    playSample(sampleName, options = {}) {
        const pitch = options.pitch || 1;
        const timescale = options.timescale || 1;
        const volume = options.volume || 0.8;
        const pan = options.pan || 0;

        const code = `
[main]
    sample ${sampleName} ${pitch} ${timescale} ${volume} ${pan}
[end]
play main
`;
        return this.play(code);
    }

    /**
     * Play a tone
     * @param {string|number} frequency - Note name or frequency
     * @param {number} duration - Duration in beats
     * @param {string} waveType - Wave type (sine, square, sawtooth, triangle)
     * @param {Object} options - Optional parameters
     */
    playTone(frequency, duration = 1, waveType = 'sine', options = {}) {
        const volume = options.volume || 0.8;
        const pan = options.pan || 0;
        const bpm = options.bpm || 120;

        const code = `
bpm ${bpm}

[main]
    tone ${frequency} ${duration} ${waveType} ${volume} ${pan}
[end]

play main
`;
        return this.play(code);
    }

    /**
     * Get available sample names
     * @returns {Array} Array of available sample names
     */
    getAvailableSamples() {
        if (this.audioEngine && typeof this.audioEngine.getBuiltInSampleNames === 'function') {
            return this.audioEngine.getBuiltInSampleNames();
        }
        return [];
    }

    /**
     * Set master volume
     * @param {number} volume - Volume level (0-1)
     */
    setMasterVolume(volume) {
        if (this.audioEngine && typeof this.audioEngine.setMasterVolume === 'function') {
            this.audioEngine.setMasterVolume(volume);
        }
    }

    /**
     * Check if MelodiCode is currently playing
     * @returns {boolean}
     */
    getIsPlaying() {
        return this.isPlaying;
    }

    /**
     * Export current audio as WAV
     * @param {number} duration - Duration to export in seconds
     * @returns {Promise<Blob>} WAV audio blob
     */
    async exportWAV(duration = 10) {
        if (this.audioEngine && typeof this.audioEngine.exportWAV === 'function') {
            return await this.audioEngine.exportWAV(duration);
        }
        throw new Error('Export functionality not available');
    }
}

// Make MelodiCode available globally
window.MelodiCode = MelodiCode;
window.melodicode = new MelodiCode();

// src/core/Module.js
/**
 * Module - Base class for all game object modules
 * 
 * Modules can be attached to GameObjects to extend their functionality.
 * Each module goes through a specific lifecycle and can override methods
 * to implement custom behavior at different stages.
 * 
 * Lifecycle:
 * 1. preload - Called before the game starts, used for loading assets
 * 2. start - Called once when the module is first activated
 * 3. beginLoop - Called at the start of each frame
 * 4. loop - Called every frame (main update logic)
 * 5. endLoop - Called at the end of each frame
 * 6. draw - Called when the module should render
 * 7. onDestroy - Called when the module is being destroyed
 * 
 * 
 * NOTE: If you want to draw to a position relative to the viewport, you need to make sure
 * to set the gameObject's position to (0, 0) inside the module's loop method, to prevent any offset.
 * 
 * 
  ICON URL ADDITION(for module icon)
 class MyCustomModule extends Module {
    static iconUrl = 'path/to/icon.png';
    
    constructor() {
        super("MyCustomModule");
        // Module code
    }
}

class MyCustomModule extends Module {
    static iconClass = 'fa-star'; // Just the icon name
    // OR
    static iconClass = 'fas fa-star'; // Full class
    
    constructor() {
        super("MyCustomModule");
        // Module code
    }
}
 */
class Module {
    static allowMultiple = true; // Allow multiple instances of this module type
    static drawInEditor = true; // Whether this module should be drawn in the editor
    static namespace = "Core"; // Namespace for module categorization
    static description = "Base module class for game objects"; // Description of the module
    static iconClass = "fas fa-cube"; // Default icon class for the module

    /**
     * Create a new Module
     * @param {string} name - The name of this module instance
     */
    constructor(name = "Module") {
        this.type = this.constructor.name; // Module type

        /** @type {string} Name of the module */
        this.name = name;

        /** @type {GameObject} GameObject this module is attached to */
        this.gameObject = null;

        /** @type {boolean} Whether this module is active */
        this.enabled = true;

        this.ignoreGameObjectTransform = false; // If true, this module will not be affected by the gameObject's transform

        /** @type {Object} Custom properties for this module */
        this.properties = {};

        /** @type {Array<string>} Required modules for this module */
        this._requirements = [];
    }

    /**
     * Called before the game starts, used for loading assets
     * Override this to load resources needed by your module
     * @returns {Promise<void>}
     */
    async preload() {
        // Override in subclass to implement custom loading behavior
    }

    /**
     * Called once when the module is first activated
     * Use this for initialization logic
     */
    start() {
        // Override in subclass but provide safety
        if (!this.gameObject) {
            console.warn(`Module ${this.name} has no gameObject reference during start()`);
        }
    }

    /**
     * Called at the start of each frame
     * Useful for pre-update operations
     */
    beginLoop() {
        // Override in subclass to implement early frame behavior
    }

    /**
     * Called every frame (main update logic)
     * Use this for your main logic
     * @param {number} deltaTime - Time in seconds since the last frame
     */
    loop(deltaTime) {
        // Override in subclass but provide safety
        if (!this.gameObject) {
            console.warn(`Module ${this.name} has no gameObject reference during loop()`);
            this.enabled = false; // Disable to prevent further errors
        }
    }

    /**
     * Called at the end of each frame
     * Useful for post-update operations
     */
    endLoop() {
        // Override in subclass to implement late frame behavior  
    }

    /**
     * Called when the module should render
     * @param {CanvasRenderingContext2D} ctx - The canvas rendering context
     */
    draw(ctx) {
        // Override in subclass to implement rendering behavior
    }

    /**
     * Called when the module is being destroyed
     * Use this to clean up resources
     */
    onDestroy() {
        // Override in subclass to implement cleanup behavior
    }

    /**
     * Called when the module is attached to a GameObject
     * @param {GameObject} gameObject - The GameObject this module is attached to
     */
    onAttach(gameObject) {
        // This is called when the module is added to a GameObject
        // Override in subclasses if needed
    }

    onEnable() {
        // Called when the module is enabled
        // Override in subclasses if needed
    }

    onDisable() {
        // Called when the module is disabled
        // Override in subclasses if needed
    }

    /**
     * Define required modules for this module
     * Modules listed here will be automatically added before this module
     * @param {...string} moduleNames - List of module names required by this module
     */
    requires(...moduleNames) {
        if (!this._requirements) {
            this._requirements = [];
        }
        this._requirements.push(...moduleNames);
        return this;
    }

    /**
     * Require a single module for this module
     * @param {string} moduleName - The name of the module to require
     */
    requireModule(moduleName) {
        if (!this._requirements) {
            this._requirements = [];
        }
        this._requirements.push(moduleName);
    }

    require(moduleName) {
        this.requireModule(moduleName);
    }

    /**
     * Get all required modules for this module
     * @returns {Array<string>} Array of required module names
     */
    getRequirements() {
        return this._requirements || [];
    }

    /**
     * Get the world position of the attached GameObject
     * @returns {Vector2} World position 
     */
    getWorldPosition() {
        return this.gameObject ? this.gameObject.getWorldPosition() : new Vector2();
    }

    /**
     * Get the local position of the attached GameObject
     * @returns {Vector2} Local position
     */
    getLocalPosition() {
        return this.gameObject ? this.gameObject.position : new Vector2();
    }

    /**
     * Set the local position of the attached GameObject
     * @param {Vector2} position - New local position
     */
    setLocalPosition(position) {
        if (this.gameObject) {
            this.gameObject.position = position;
        }
    }

    set gameObject(go) {
        this._gameObject = go;

        // When a module's gameObject reference changes, we need to update
        // all internal properties that might reference the old gameObject
        if (go && this._previousGameObject && this._previousGameObject !== go) {
            this._updateInternalReferences(this._previousGameObject, go);
        }

        this._previousGameObject = go;
    }

    get gameObject() {
        return this._gameObject;
    }

    /**
     * Clone this module instance
     * @returns {Module} A new instance of this module with the same properties
     */
    clone(newGameObject = null) {
        // 1) create a fresh instance
        const cloned = new this.constructor(this.name);

        // Deep copy image asset and embedded image data
        if (this._image && this._isImageLoaded) {
            // If image is embedded, copy the data URL
            cloned._image = this._image;
            cloned._isImageLoaded = true;
            cloned._imageWidth = this._imageWidth;
            cloned._imageHeight = this._imageHeight;

            if (this.imageAsset && this.imageAsset.embedded) {
                cloned.imageAsset = {
                    path: null,
                    type: 'image',
                    embedded: true,
                    load: () => Promise.resolve(this._image)
                };
            } else if (this.imageAsset) {
                // Copy asset reference
                cloned.imageAsset = { ...this.imageAsset };
            }
        }

        // 2) copy all your own data except any gameObject pointers
        const keys = new Set([
            ...Object.getOwnPropertyNames(this),
            ...Object.keys(this)
        ]);
        keys.delete('gameObject');
        keys.delete('_gameObject');
        keys.delete('_previousGameObject');
        keys.delete('constructor');

        for (const key of keys) {
            const v = this[key];
            if (v == null || typeof v === 'function') {
                cloned[key] = v;
            }
            else if (Array.isArray(v)) {
                cloned[key] = v.map(item =>
                    (item && typeof item.clone === 'function')
                        ? item.clone()
                        : item
                );
            }
            else if (typeof v.clone === 'function') {
                cloned[key] = v.clone();
            }
            else if (typeof v === 'object') {
                cloned[key] = JSON.parse(JSON.stringify(v));
            }
            else {
                cloned[key] = v;
            }
        }

        // 3) reset any stale pointers
        cloned._gameObject = null;
        cloned._previousGameObject = null;

        // 4) if caller supplied an owner, bind now
        if (newGameObject) {
            cloned.attachTo(newGameObject);
        }

        return cloned;
    }

    /**
     * Helper: Deep clone an array
     * @private
     */
    deepCloneArray(arr) {
        if (!arr) return arr;

        return arr.map(item => {
            if (item === null || item === undefined || typeof item !== 'object') {
                return item;
            }
            else if (typeof item.clone === 'function') {
                return item.clone();
            }
            else if (Array.isArray(item)) {
                return this.deepCloneArray(item);
            }
            else if (!(item instanceof HTMLElement)) {
                return this.deepCloneObject(item);
            }
            return item;
        });
    }

    /**
     * Helper: Deep clone an object
     * @private
     */
    deepCloneObject(obj) {
        if (!obj) return obj;
        if (typeof obj.clone === 'function') return obj.clone();
        if (obj instanceof HTMLElement) return obj;

        const clone = Object.create(Object.getPrototypeOf(obj));

        for (const key in obj) {
            if (!Object.prototype.hasOwnProperty.call(obj, key)) continue;

            const value = obj[key];

            if (value === null || value === undefined || typeof value !== 'object') {
                clone[key] = value;
            }
            else if (typeof value.clone === 'function') {
                clone[key] = value.clone();
            }
            else if (Array.isArray(value)) {
                clone[key] = this.deepCloneArray(value);
            }
            else if (!(value instanceof HTMLElement)) {
                clone[key] = this.deepCloneObject(value);
            }
            else {
                clone[key] = value;
            }
        }

        return clone;
    }

    /**
     * Register a module class to be available in the Add Module dropdown
     * @param {Class} moduleClass - The module class to register
     */
    registerModuleClass(moduleClass) {
        if (!moduleClass || !(moduleClass.prototype instanceof Module)) {
            console.error('Not a valid module class:', moduleClass);
            return;
        }

        // Check if already registered
        const alreadyRegistered = this.availableModules.some(mod =>
            mod.name === moduleClass.name || mod === moduleClass);

        if (!alreadyRegistered) {
            this.availableModules.push(moduleClass);
            console.log(`Registered module: ${moduleClass.name}`);

            // Update the dropdown if it's open
            if (this.moduleDropdown &&
                this.moduleDropdown.style.display !== 'none') {
                this.populateModuleDropdown();
            }
        }
    }

    /**
     * Get the list of exposed properties that should be editable in the Inspector
     * @returns {Array<Object>} Array of property descriptors
     */
    getExposedProperties() {
        // Start with properties explicitly marked as exposed
        let exposed = this.exposedProperties || [];

        // Also include any properties in this.properties object
        for (const key in this.properties) {
            if (!exposed.some(prop => prop.name === key)) {
                exposed.push({
                    name: key,
                    type: typeof this.properties[key],
                    value: this.properties[key]
                });
            }
        }

        return exposed;
    }

    /**
     * Register a property to be exposed in the Inspector
     * @param {string} name - Property name
     * @param {string} type - Property type (string, number, boolean, etc.)
     * @param {any} defaultValue - Default value
     * @param {Object} options - Additional options (min, max, step, etc.)
     */
    exposeProperty(name, type, defaultValue, options = {}) {
        if (!this.exposedProperties) {
            this.exposedProperties = [];
        }

        this.exposedProperties.push({
            name,
            type,
            value: defaultValue,
            options
        });

        // Store the value in a private property with a different name
        // to avoid conflicts with getters/setters
        const privatePropName = `_${name}`;

        // Initialize the private property with the default value or current value
        if (this[privatePropName] === undefined) {
            this[privatePropName] = this[name] !== undefined ? this[name] : defaultValue;
        }

        // Create property accessor that uses the private property
        if (!Object.getOwnPropertyDescriptor(this, name)) {
            Object.defineProperty(this, name, {
                get: function () {
                    return this[privatePropName];
                },
                set: function (value) {
                    const oldValue = this[privatePropName];
                    this[privatePropName] = value;

                    // Call onChange handler if specified
                    const propDef = this.exposedProperties?.find(p => p.name === name);
                    if (propDef?.options?.onChange && oldValue !== value) {
                        propDef.options.onChange.call(this, value);
                    }
                },
                enumerable: true,
                configurable: true
            });
        }

        // Ensure the initial value is set properly
        if (this[name] !== this[privatePropName]) {
            this[name] = this[privatePropName];
        }
    }

    /**
     * Enable this module
     */
    enable() {
        this.enabled = true;
        this.onEnable();
    }

    /**
     * Disable this module
     */
    disable() {
        this.enabled = false;
        this.onDisable();
    }

    /**
     * Toggle this module's enabled state
     */
    toggle() {
        this.enabled = !this.enabled;

        if (this.enabled) {
            this.onEnable();
        } else {
            this.onDisable();
        }
    }

    /**
     * Get a module from the parent GameObject by type/class
     * @param {class} moduleType - The class/type of module to find
     * @returns {Module} The found module or null
     */
    getModule(moduleType) {
        if (!this.gameObject) return null;

        return this.gameObject.modules.find(module => module instanceof moduleType);
    }

    /**
     * Set a property value
     * @param {string} name - Property name
     * @param {any} value - New value
     */
    setProperty(name, value) {
        const privatePropName = `_${name}`;

        if (this.hasOwnProperty(privatePropName)) {
            // If we have a private property, use it
            this[privatePropName] = value;
        } else {
            // Otherwise set directly
            this[name] = value;
        }

        // Call onChange handler if specified in property options
        const propDef = this.exposedProperties?.find(p => p.name === name);
        if (propDef?.options?.onChange) {
            propDef.options.onChange.call(this, value);
        }
    }

    /**
     * Get a property value
     * @param {string} key - Property name
     * @param {any} defaultValue - Default value if property doesn't exist
     * @returns {any} The property value or default value
     */
    getProperty(name, defaultValue) {
        const privatePropName = `_${name}`;

        if (this.hasOwnProperty(privatePropName)) {
            // If we have a private property, use it
            return this[privatePropName];
        }

        // Otherwise get directly
        return this[name] !== undefined ? this[name] : defaultValue;
    }

    /**
     * Reassign this module to a new GameObject,
     * update internal refs and call onAttach.
     * @param {GameObject} newGameObject
     */
    attachTo(newGameObject) {
        // clear any stale pointer
        this._previousGameObject = null;
        // set the new owner
        this._gameObject = newGameObject;   // calls our setter
        // keep _previousGameObject in sync
        this._previousGameObject = newGameObject;

        if (typeof this.onAttach === 'function') {
            this.onAttach(newGameObject);
        }
    }

    /**
     * Serialize this module to JSON
     * @returns {Object} Serialized module data
     */
    toJSON() {
        // Basic module data
        const data = {
            name: this.name,
            type: this.constructor.name,
            enabled: this.enabled,
            requirements: this._requirements
        };

        // Serialize regular properties object
        data.properties = { ...this.properties };

        // Serialize exposed properties (both from exposedProperties and custom getters/setters)
        data.exposedValues = {};

        // Handle properties registered via exposeProperty
        if (Array.isArray(this.exposedProperties)) {
            for (const prop of this.exposedProperties) {
                const propName = prop.name;
                // Get the current value using our getter
                const value = this[propName];

                // Only serialize non-undefined values
                if (value !== undefined) {
                    // Special handling for objects that have their own toJSON method
                    if (value && typeof value === 'object' && typeof value.toJSON === 'function') {
                        data.exposedValues[propName] = value.toJSON();
                    } else if (value instanceof Vector2) {
                        // Special case for Vector2 objects
                        data.exposedValues[propName] = { x: value.x, y: value.y };
                    } else {
                        // For primitive values and regular objects
                        data.exposedValues[propName] = value;
                    }
                }
            }
        }

        // Allow subclasses to add their own serialization
        if (typeof this._serializeCustomData === 'function') {
            const customData = this._serializeCustomData();
            if (customData && typeof customData === 'object') {
                data.customData = customData;
            }
        }

        return data;
    }

    /**
     * Deserialize from JSON data
     * @param {Object} json - Serialized module data 
     */
    fromJSON(json) {
        if (!json) return this;

        // Restore basic properties
        this.name = json.name || this.name;
        this.enabled = json.enabled !== undefined ? json.enabled : this.enabled;
        this._requirements = json.requirements || this._requirements || [];

        // Restore regular properties object
        this.properties = json.properties || {};

        // Restore exposed property values
        if (json.exposedValues) {
            for (const propName in json.exposedValues) {
                const value = json.exposedValues[propName];

                // Handle Vector2 values
                if (value && typeof value === 'object' &&
                    'x' in value && 'y' in value &&
                    typeof this[propName] === 'object' &&
                    this[propName] instanceof Vector2) {
                    this[propName].x = value.x;
                    this[propName].y = value.y;
                }
                // Handle objects with fromJSON method
                else if (this[propName] &&
                    typeof this[propName] === 'object' &&
                    typeof this[propName].fromJSON === 'function' &&
                    value) {
                    this[propName].fromJSON(value);
                }
                // Regular values
                else {
                    // Use setProperty if available, otherwise set directly
                    if (typeof this.setProperty === 'function') {
                        this.setProperty(propName, value);
                    } else {
                        this[propName] = value;
                    }
                }
            }
        }

        // Allow subclasses to handle custom data
        if (json.customData && typeof this._deserializeCustomData === 'function') {
            this._deserializeCustomData(json.customData);
        }

        return this;
    }

    /**
     * Update all internal references to the old gameObject with the new one
     * @param {GameObject} oldGO - The old GameObject reference
     * @param {GameObject} newGO - The new GameObject reference
     */
    _updateInternalReferences(oldGO, newGO) {
        if (!oldGO || !newGO || oldGO === newGO) return;

        // Recursively scan all properties
        const scanObject = (obj) => {
            if (!obj || typeof obj !== 'object') return;

            // Skip DOM elements and functions
            if (obj instanceof HTMLElement) return;

            // Use a WeakSet to track visited objects to avoid circular references
            const visited = new WeakSet();

            const traverse = (o) => {
                if (!o || typeof o !== 'object' || visited.has(o)) return;
                visited.add(o);

                // Check all enumerable properties of the object
                for (const key in o) {
                    try {
                        const value = o[key];

                        // If the value is the old GameObject, replace it with the new one
                        if (value === oldGO) {
                            o[key] = newGO;
                            continue;
                        }

                        // Recursively traverse objects and arrays
                        if (value && typeof value === 'object' && !visited.has(value)) {
                            traverse(value);
                        }
                    } catch (err) {
                        // Some properties may not be accessible, just skip them
                    }
                }

                // Check non-enumerable properties as well (for properties defined with Object.defineProperty)
                const propNames = Object.getOwnPropertyNames(o);
                for (const propName of propNames) {
                    try {
                        if (propName === 'constructor' || propName === 'prototype' || propName === '__proto__') {
                            continue;
                        }

                        const desc = Object.getOwnPropertyDescriptor(o, propName);
                        if (desc && desc.get && !desc.configurable) {
                            // We can't modify non-configurable getters/setters
                            continue;
                        }

                        const value = o[propName];
                        if (value === oldGO) {
                            o[propName] = newGO;
                            continue;
                        }

                        if (value && typeof value === 'object' && !visited.has(value)) {
                            traverse(value);
                        }
                    } catch (err) {
                        // Some properties may not be accessible, just skip them
                    }
                }
            };

            traverse(obj);
        };

        // Check own properties first
        for (const key in this) {
            if (key !== 'gameObject' && key !== '_gameObject' && key !== '_previousGameObject') {
                const value = this[key];
                if (value === oldGO) {
                    this[key] = newGO;
                } else if (value && typeof value === 'object') {
                    scanObject(value);
                }
            }
        }
    }

    /**
     * Override in subclasses to serialize additional module-specific data
     * @protected
     * @returns {Object|null} Custom serialized data
     */
    _serializeCustomData() {
        return null; // Default implementation
    }

    /**
     * Override in subclasses to deserialize module-specific data
     * @protected
     * @param {Object} data - Custom data to deserialize
     */
    _deserializeCustomData(data) {
        // Default implementation does nothing
    }
}

// Make the Module class available globally
window.Module = Module;

// src/core/ModuleRegistry.js
/**
 * ModuleRegistry - Central registry for all module types available in the engine
 * Used for tracking available modules across the editor
 */
class ModuleRegistry {
    constructor() {
        this.modules = new Map();
        this.listeners = [];
    }

    /**
     * Register a module class with the registry
     * @param {Class} moduleClass - The module class to register
     * @returns {boolean} True if successfully registered
     */
    register(moduleClass) {
        if (!moduleClass || !(moduleClass.prototype instanceof Module)) {
            console.error('Cannot register invalid module class:', moduleClass);
            return false;
        }

        // Skip if already registered
        if (this.modules.has(moduleClass.name)) {
            return false;
        }

        // Register the module
        this.modules.set(moduleClass.name, moduleClass);
        console.log(`Registered module: ${moduleClass.name}`);
        
        // Notify listeners
        this.notifyListeners('register', moduleClass);
        return true;
    }

    /**
     * Unregister a module class
     * @param {string|Class} moduleNameOrClass - Module name or class to unregister
     * @returns {boolean} True if successfully unregistered
     */
    unregister(moduleNameOrClass) {
        const moduleName = typeof moduleNameOrClass === 'string' 
            ? moduleNameOrClass 
            : moduleNameOrClass.name;
        
        const moduleClass = this.modules.get(moduleName);
        if (!moduleClass) {
            return false;
        }
        
        this.modules.delete(moduleName);
        console.log(`Unregistered module: ${moduleName}`);
        
        // Notify listeners
        this.notifyListeners('unregister', moduleClass);
        return true;
    }

    /**
     * Get a module class by name
     * @param {string} name - Name of the module class
     * @returns {Class|null} The module class, or null if not found
     */
    getModuleClass(name) {
        return this.modules.get(name) || null;
    }

    /**
     * Get all registered module classes
     * @returns {Array<Class>} Array of module classes
     */
    getAllModules() {
        return Array.from(this.modules.values());
    }

    /**
     * Add a listener for registry events
     * @param {Function} callback - Callback function(event, moduleClass)
     */
    addListener(callback) {
        if (typeof callback === 'function' && !this.listeners.includes(callback)) {
            this.listeners.push(callback);
        }
    }

    /**
     * Remove a listener
     * @param {Function} callback - The callback to remove
     */
    removeListener(callback) {
        const index = this.listeners.indexOf(callback);
        if (index !== -1) {
            this.listeners.splice(index, 1);
        }
    }

    /**
     * Notify all listeners of an event
     * @param {string} eventName - Name of the event ('register', 'unregister')
     * @param {Class} moduleClass - The module class involved
     */
    notifyListeners(eventName, moduleClass) {
        this.listeners.forEach(callback => {
            try {
                callback(eventName, moduleClass);
            } catch (error) {
                console.error('Error in module registry listener:', error);
            }
        });
    }
}

// Create and export the global registry
window.moduleRegistry = new ModuleRegistry();

// src/core/ModuleReloader.js
/**
 * ModuleReloader - Handles dynamic reloading of modules without requiring browser refresh
 */
class ModuleReloader {
    constructor() {
        this.moduleRegistry = window.moduleRegistry || null;
        this.scriptCache = new Map(); // Store the latest script content
    }

    /**
     * Reload a specific module class from its script content
     * @param {string} className - The module class name
     * @param {string} scriptContent - The script content
     * @returns {boolean} Success status
     */
    reloadModuleClass(className, scriptContent) {
        try {
            if(className === 'EditorWindow' || className.endsWith('EditorWindow')) {
                //console.warn('EditorWindow classes should not be reloaded as modules:', className);
                return false;
            }
            // Cache the script content
            this.scriptCache.set(className, scriptContent);

            // Check for ES module syntax
            if (/^\s*(import|export)\s/m.test(scriptContent)) {
                console.error(`Module script for ${className} contains ES module syntax (import/export). Cannot reload dynamically.`);
                return false;
            }

            // Debug log the script content
            // console.log("Evaluating module script for", className, ":\n", scriptContent);

            // Wrap in IIFE to avoid leaking variables
            const wrappedScript = `
            try {
                (function() {
                    ${scriptContent}
                })();
                return ${className};
            } catch (error) {
                console.error("Error evaluating module script:", error);
                return null;
            }
        `;

            // Create a new function to evaluate the script in the global scope
            const scriptFunction = new Function(wrappedScript);

            // Execute the script to get the class
            const ModuleClass = scriptFunction();

            if (!ModuleClass) {
                console.error(`Failed to reload module ${className}: Script did not return a class`);
                return false;
            }

            // Register the class globally
            window[className] = ModuleClass;

            // Register with moduleRegistry if available
            if (this.moduleRegistry) {
                this.moduleRegistry.register(ModuleClass);
            } else {
                console.warn("ModuleRegistry not available, could not register updated module");
            }

            console.log(`Successfully reloaded module: ${className}`);
            return true;
        } catch (error) {
            console.error(`Error reloading module ${className}:`, error);
            return false;
        }
    }

    /**
     * Update all instances of a module type with new class implementation
     * @param {string} className - Module class name to update
     * @param {Array<GameObject>} gameObjects - Array of GameObjects to search through
     * @returns {number} Number of module instances updated
     */
    updateModuleInstances(className, gameObjects) {
        let updatedCount = 0;

        const ModuleClass = window[className];
        if (!ModuleClass) {
            console.error(`Cannot update instances of ${className}: Class not found`);
            return 0;
        }

        // Helper function to traverse the game object hierarchy
        const traverseAndUpdate = (objects) => {
            objects.forEach(obj => {
                // Find matching modules
                obj.modules.forEach((module, index) => {
                    if (module.constructor.name === className) {
                        // Store the module's current properties
                        const oldProps = {};
                        Object.keys(module).forEach(key => {
                            if (key !== 'constructor' && typeof module[key] !== 'function') {
                                oldProps[key] = module[key];
                            }
                        });

                        // Create a new module instance
                        const newModule = new ModuleClass();

                        // Copy over important references and properties
                        newModule.gameObject = obj;
                        newModule.enabled = module.enabled;
                        newModule.id = module.id; // Keep the same ID

                        // Copy over all other properties from old module
                        Object.keys(oldProps).forEach(key => {
                            if (key !== 'gameObject' && key !== 'constructor') {
                                newModule[key] = oldProps[key];
                            }
                        });

                        // Replace the module in the object's modules array
                        obj.modules[index] = newModule;
                        updatedCount++;
                    }
                });

                // Recursively process children
                if (obj.children && obj.children.length > 0) {
                    traverseAndUpdate(obj.children);
                }
            });
        };

        traverseAndUpdate(gameObjects);
        return updatedCount;
    }
}

// Create global instance
window.moduleReloader = new ModuleReloader();

// src/core/ModuleManager.js
/**
 * ModulesManager - Handles registration and initialization of modules
 */
class ModulesManager {
    constructor() {
        this.loadedModules = new Map();
        
        // Define core modules that should always be available
        this.coreModules = [
            'SpriteRenderer',
            'RigidBody', 
            'Collider',
            'BoundingBoxCollider',
            'DrawCircle',
            'DrawRectangle'
            //'BabylonRenderer'
        ];
    }

    /**
     * Initialize all core modules
     */
    initializeCoreModules() {
        console.log("Initializing core modules...");
        
        // Ensure moduleRegistry exists
        if (!window.moduleRegistry) {
            console.error("ModuleRegistry not found, modules cannot be loaded");
            return;
        }
        
        // Load core modules
        for (const moduleName of this.coreModules) {
            // Check if module constructor exists in window
            if (window[moduleName]) {
                console.log(`Registering core module: ${moduleName}`);
                window.moduleRegistry.register(window[moduleName]);
                this.loadedModules.set(moduleName, window[moduleName]);
            } else {
                console.error(`Core module not found: ${moduleName}`);
            }
        }
        
        console.log("Core modules initialized");
    }

    /**
     * Get available modules for adding to GameObjects
     * @returns {Array} Array of module names
     */
    getAvailableModules() {
        return Array.from(this.loadedModules.keys());
    }
    
    /**
     * Create a new instance of a module
     * @param {string} moduleName - The name of the module to create
     * @returns {Module|null} The created module or null if not found
     */
    createModule(moduleName) {
        const ModuleClass = this.loadedModules.get(moduleName);
        
        if (ModuleClass) {
            try {
                return new ModuleClass();
            } catch (error) {
                console.error(`Error creating module ${moduleName}:`, error);
                return null;
            }
        }
        
        return null;
    }
}

// Make the ModulesManager available globally
window.modulesManager = new ModulesManager();

// src/core/GameObject.js
class GameObject {
    constructor(name = "GameObject", engine = null) {
        this.name = name;
        this.position = new Vector2();
        this.size = new Vector2(50, 50); // Default size in pixels for collision detection
        this.useCollisions = false; // Whether to use collision detection
        this.origin = new Vector2(0.5, 0.5); // Centered by default
        this.scale = new Vector2(1, 1);
        this.angle = 0;
        this.depth = 0;
        this.depthToY = false; // Whether to adjust depth based on Y position
        this.visible = true;
        this.modules = [];
        this.children = [];
        this.parent = null;
        this.active = true;
        this.colliderWidth = this.size.x; // For collision detection
        this.colliderHeight = this.size.y; // For collision detection
        this.tags = [];
        this.selected = false; // Track if selected in editor
        this.expanded = false; // Track if expanded in hierarchy
        this.editorColor = this.generateRandomColor(); // Color in editor view
        this.id = crypto.randomUUID(); // Generate unique ID

        this.usePolygonCollision = false; // Enable polygon collision
        this.polygonPointCount = 3; // Number of points in the polygon
        this.polygonAngleOffset = 0; // Angle offset for polygon points
        this.polygonPoints = []; // Array of Vector2 points for polygon
        this.polygon = null; // Polygon instance

        this.engine = engine; // Reference to the engine instance, set when added to engine

        this.xd = 0; // X Position for drawing (for viewport offsets)
        this.yd = 0; // Y Position for drawing (for viewport offsets)

        this.collisionEnabled = true;  // Flag to enable/disable collision
        this.collisionLayer = 0;       // Collision layer for filtering
        this.collisionMask = 0xFFFF;   // Collision mask for filtering

        // Keep track of original position and rotation
        this.originalPosition = this.position.clone();
        this.originalRotation = this.angle;

        this.previousPosition = this.position.clone(); // For movement tracking

        if (this.usePolygonCollision) {
            this.generatePolygonPoints();
        }
    }

    getNearestObject(gameObjectName, maxRange = Infinity) {
        // Use global gameObjects array if available
        const eng = window.engine || this.engine || null;

        return eng.findNearestObjectByName(this.position.x, this.position.y, gameObjectName, maxRange);
    }

    generateRandomColor() {
        // Generate a semi-bright color for better visibility on dark backgrounds
        const hue = Math.floor(Math.random() * 360);
        return `hsl(${hue}, 70%, 60%)`;
    }

    // Track original position (useful when cloning)
    getOriginalPosition() {
        return this.originalPosition || this.position.clone();
    }

    async preload() {
        for (const module of this.modules) {
            try {
                if (module.enabled && module.preload) await module.preload();
            } catch (error) {
                console.error(`Error in module ${module.type || module.constructor.name} preload on ${this.name}:`, error);
            }
        }
        for (const child of this.children) {
            await child.preload();
        }
    }

    start() {
        if (!this.active) return;

        // Save initial position and rotation when the game starts
        this.originalPosition = this.position.clone();
        this.originalRotation = this.angle;

        // Initialize modules and children
        this.modules.forEach(module => {
            try {
                if (module.enabled && module.start) module.start();
            } catch (error) {
                console.error(`Error in module ${module.type || module.constructor.name} start on ${this.name}:`, error);
            }
        });
        this.children.forEach(child => child.start());
    }

    beginLoop() {
        if (!this.active) return;

        this.colliderWidth = this.size.x; // For collision detection
        this.colliderHeight = this.size.y; // For collision detection

        this.previousPosition = this.position.clone(); // For movement tracking

        this.modules.forEach(module => {
            try {
                if (module.enabled && module.beginLoop) module.beginLoop();
            } catch (error) {
                console.error(`Error in module ${module.type || module.constructor.name} beginLoop on ${this.name}:`, error);
            }
        });
        this.children.forEach(child => child.beginLoop());
    }

    loop(deltaTime) {
        if (!this.active) return;

        // Update depth based on Y position if enabled
        if (this.depthToY) {
            this.depth = Math.floor(this.position.y);
        }

        // Update polygon if enabled
        if (this.usePolygonCollision && this.polygon) {
            this.polygon.update(this.position.clone(), this.angle + this.polygonAngleOffset);
        }

        this.modules.forEach(module => {
            try {
                if (module.enabled && module.loop) module.loop(deltaTime);
            } catch (error) {
                console.error(`Error in module ${module.type || module.constructor.name} loop on ${this.name}:`, error);
            }
        });
        this.children.forEach(child => child.loop(deltaTime));
    }

    endLoop() {
        if (!this.active) return;
        this.modules.forEach(module => {
            try {
                if (module.enabled && module.endLoop) module.endLoop();
            } catch (error) {
                console.error(`Error in module ${module.type || module.constructor.name} endLoop on ${this.name}:`, error);
            }
        });
        this.children.forEach(child => child.endLoop());
    }

    /**
     * Draw this GameObject and its modules during runtime
     * @param {CanvasRenderingContext2D} ctx - The rendering context
     */
    draw(ctx) {
        if (!this.active || !this.visible) return;

        // PIXI rendering path
        if (window.engine && window.engine.usePixi && window.engine.pixiRenderer && ctx === window.engine.pixiRenderer) {
            // Ensure Pixi display object exists
            if (!this.pixiDisplayObject) {
                this.createPixiDisplayObject();
                window.engine.pixiRenderer.addDisplayObject(this.pixiDisplayObject);
            }
            this.updatePixiDisplayObject();

            // Draw modules that support Pixi rendering
            for (const module of this.modules) {
                if (module.enabled && typeof module.draw === 'function') {
                    try {
                        // If module supports Pixi, pass pixiDisplayObject or pixiRenderer
                        module.draw(ctx, this.pixiDisplayObject);
                    } catch (error) {
                        console.error(`Error in module ${module.type || module.constructor.name} draw (Pixi) on ${this.name}:`, error);
                    }
                }
            }

            // Draw children
            this.children.forEach(child => {
                if (child.active && child.visible) {
                    child.draw(ctx);
                }
            });

            return;
        }

        ctx.save();

        // Apply local transform
        const worldPos = this.getWorldPosition();
        const worldAngle = this.getWorldRotation();
        const worldScale = this.getWorldScale();

        ctx.translate(worldPos.x, worldPos.y);
        ctx.rotate(worldAngle * Math.PI / 180);
        ctx.scale(worldScale.x, worldScale.y);

        // Track if any module actually drew something
        let moduleDidDraw = false;

        // Always draw the fallback shape first to ensure object visibility
        //this.drawFallbackShape(ctx);

        // Draw modules
        for (const module of this.modules) {
            if (module.enabled && typeof module.draw === 'function') {
                try {
                    if (module.ignoreGameObjectTransform) {
                        ctx.restore(); // Remove transform
                        module.draw(ctx); // Draw in world space
                        ctx.save();
                        ctx.translate(worldPos.x, worldPos.y);
                        ctx.rotate(worldAngle * Math.PI / 180);
                        ctx.scale(worldScale.x, worldScale.y);
                    } else {
                        module.draw(ctx);
                    }
                    moduleDidDraw = true;
                } catch (error) {
                    console.error(`Error in module ${module.type || module.constructor.name} draw on ${this.name}:`, error);
                }
            }
        }

        ctx.restore();

        // Draw all children
        this.children.forEach(child => {
            if (child.active && child.visible) {
                child.draw(ctx);
            }
        });
    }

    /**
     * Draw representation of this GameObject in the editor
     * @param {CanvasRenderingContext2D} ctx - The rendering context
     */
    drawInEditor(ctx) {
        if (!this.active) return;

        // Draw this object
        ctx.save();

        // Apply transformations
        const worldPos = this.getWorldPosition();
        const worldAngle = this.getWorldRotation();
        const worldScale = this.getWorldScale();

        ctx.translate(worldPos.x, worldPos.y);
        ctx.rotate(worldAngle * Math.PI / 180);
        ctx.scale(worldScale.x, worldScale.y);

        // Check if any module has a draw method and can be drawn in editor
        let moduleDidDraw = false;

        // Draw modules that support rendering
        for (const module of this.modules) {
            // Check for modules that should draw in editor
            if (module.enabled && typeof module.draw === 'function') {
                try {
                    // Instead of trying to analyze the function code, let's use a pattern
                    // where modules can explicitly indicate if they should be drawn in editor

                    // Option 1: Check for module.drawInEditor flag
                    if (module.drawInEditor === false) {
                        continue;
                    }

                    // Option 2: Use a canvas measuring approach - detect if anything was drawn
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = 100;
                    tempCanvas.height = 100;
                    const tempCtx = tempCanvas.getContext('2d');

                    // Clear the temp canvas and save its state
                    tempCtx.clearRect(0, 0, tempCanvas.width, tempCanvas.height);
                    tempCtx.save();
                    tempCtx.translate(50, 50); // Center for drawing

                    // Get image data before drawing
                    const beforeData = tempCtx.getImageData(0, 0, 100, 100).data;

                    // Try to draw
                    module.draw(tempCtx);

                    // Get image data after drawing
                    const afterData = tempCtx.getImageData(0, 0, 100, 100).data;

                    // Check if anything changed
                    let hasDrawnSomething = false;
                    for (let i = 0; i < beforeData.length; i += 4) {
                        if (beforeData[i] !== afterData[i] ||
                            beforeData[i + 1] !== afterData[i + 1] ||
                            beforeData[i + 2] !== afterData[i + 2] ||
                            beforeData[i + 3] !== afterData[i + 3]) {
                            hasDrawnSomething = true;
                            break;
                        }
                    }

                    // Restore temp context
                    tempCtx.restore();

                    if (!hasDrawnSomething) {
                        continue; // Module's draw didn't change anything visually
                    }

                    // Now we know the module actually draws something, so use it in the main context
                    module.draw(ctx);
                    moduleDidDraw = true;
                } catch (error) {
                    console.error(`Error drawing module ${module.type || module.constructor.name} in editor:`, error);
                }
            }
        }

        // If no module drew anything, draw the default representation
        if (!moduleDidDraw) {
            // Draw square representation
            const size = 20; // Base size
            ctx.beginPath();
            ctx.rect(-size / 2, -size / 2, size, size);
            ctx.fillStyle = this.selected ? '#ffffff' : this.editorColor;
            ctx.fill();

            // Draw origin point
            ctx.beginPath();
            ctx.arc(0, 0, 2, 0, Math.PI * 2);
            ctx.fillStyle = '#ff0000';
            ctx.fill();
        }

        // Always draw the angle indicator line for better orientation
        const size = 20; // Base size for consistency with default representation
        const lineLength = size * 1.5; // Length of the line - 1.5x the size
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(lineLength, 0);
        ctx.strokeStyle = '#ffcc00'; // Distinct yellow color for angle line
        ctx.lineWidth = 2 / (this.editor?.camera?.zoom || 1);
        ctx.stroke();

        // Add arrowhead to angle line
        ctx.beginPath();
        ctx.moveTo(lineLength, 0);
        ctx.lineTo(lineLength - 5, -3);
        ctx.lineTo(lineLength - 5, 3);
        ctx.closePath();
        ctx.fillStyle = '#ffcc00';
        ctx.fill();

        if (!this.usePolygonCollision && this.useCollisions) {
            ctx.beginPath();
            ctx.rect(
                -this.size.x / 2,
                -this.size.y / 2,
                this.size.x,
                this.size.y
            );
            ctx.setLineDash([5, 3]); // Dashed line: 5px dash, 3px gap
            ctx.strokeStyle = "#00ff00";
            ctx.lineWidth = 1 / (this.editor?.camera?.zoom || 1);
            ctx.stroke();
            ctx.setLineDash([]); // Reset to solid for future drawing
        }

        if (this.usePolygonCollision && this.polygon) {
            ctx.save();
            ctx.setLineDash([5, 3]);
            // Apply polygonAngleOffset rotation
            ctx.rotate((this.polygonAngleOffset || 0) * Math.PI / 180);
            this.polygon.draw(ctx, "#00ff00");
            ctx.setLineDash([]);
            ctx.restore();
        }

        // Draw selection outline if selected
        if (this.selected) {
            // Draw either around the module bounds or the default square
            if (moduleDidDraw) {
                // Draw a slightly larger selection outline
                ctx.strokeStyle = '#00aaff';
                ctx.lineWidth = 2 / (this.editor?.camera?.zoom || 1);
                // A slightly larger rectangle than the typical module would draw
                // This is an approximation - ideally modules would report their bounds
                ctx.strokeRect(-size / 2, -size / 2, size, size);
            } else {
                ctx.strokeStyle = '#00aaff';
                ctx.lineWidth = 2 / (this.editor?.camera?.zoom || 1);
                ctx.strokeRect(-size / 2, -size / 2, size, size);
            }
        }

        ctx.restore();

        // Draw name (always upright)
        if (this.selected) {
            ctx.fillStyle = '#ffffff';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText(this.name, worldPos.x, worldPos.y - 25);
        }

        // Draw children
        this.children.forEach(child => {
            if (child.active) {
                child.drawInEditor(ctx);
            }
        });
    }

    /**
     * Get the bounding box of this GameObject in world coordinates
     * @returns {Object} The bounding box with x, y, width, height properties
     */
    getBoundingBox() {
        const worldPos = this.getWorldPosition();
        const worldScale = this.getWorldScale();
        const worldAngle = this.getWorldRotation();

        // Calculate the effective width and height
        const effectiveWidth = this.width * worldScale.x;
        const effectiveHeight = this.height * worldScale.y;

        // If there's no rotation, return a simple axis-aligned box
        if (worldAngle % 360 === 0) {
            return {
                x: worldPos.x - effectiveWidth / 2,
                y: worldPos.y - effectiveHeight / 2,
                width: effectiveWidth,
                height: effectiveHeight,
                rotation: 0
            };
        }

        // For rotated objects, return an oriented bounding box
        return {
            x: worldPos.x,
            y: worldPos.y,
            width: effectiveWidth,
            height: effectiveHeight,
            rotation: worldAngle
        };
    }

    /**
     * Draw a simple shape to represent the GameObject when no modules are drawing
     * @param {CanvasRenderingContext2D} ctx - The rendering context
     */
    drawFallbackShape(ctx) {
        // Draw circle representation
        const size = 10;
        ctx.beginPath();
        ctx.arc(0, 0, size, 0, Math.PI * 2);
        ctx.fillStyle = this.editorColor || '#ffffff';
        ctx.fill();
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.stroke();
    }

    onDestroy() {
        this.modules.forEach(module => {
            if (module.onDestroy) module.onDestroy();
        });
        this.children.forEach(child => child.onDestroy());
        window.engine.gameObjects = window.engine.gameObjects.filter(obj => obj !== this);
    }

    destroy() {
        this.onDestroy();
        // Additional cleanup logic (if any) goes here
    }

    /**
     * Check collision with any nearby GameObjects of a given name within a set range
     * @param {string} name - The name of GameObjects to check against
     * @param {number} range - The range (in pixels) to search for nearby objects
     * @param {Array<GameObject>} [gameObjects] - Optional array of all game objects to search (defaults to window.gameObjects)
     * @returns {GameObject|null} The first colliding GameObject found, or null if none
     */
    collidesWithNearby(name, range, gameObjects) {
        // Use global gameObjects array if not provided
        const allObjects = gameObjects || window.gameObjects || [];
        const myPos = this.getWorldPosition();

        for (const obj of allObjects) {
            if (
                obj !== this &&
                obj.name === name &&
                obj.active &&
                obj.visible &&
                obj.collisionEnabled
            ) {
                // Quick distance check
                const objPos = obj.getWorldPosition();
                const dx = objPos.x - myPos.x;
                const dy = objPos.y - myPos.y;
                if ((dx * dx + dy * dy) <= range * range) {
                    // Check collision
                    if (this.collidesWith(obj)) {
                        return obj;
                    }
                }
            }
        }
        return null;
    }

    /**
     * Check if this GameObject collides with another GameObject
     * @param {GameObject} other - The other GameObject to check collision with
     * @returns {boolean} True if colliding
     */
    collidesWith(other) {
        // Skip collision check if either object has collisions disabled
        if (!this.collisionEnabled || !other.collisionEnabled) {
            return false;
        }

        // Skip collision check if collision layers don't match
        if ((this.collisionLayer & other.collisionMask) === 0 &&
            (other.collisionLayer & this.collisionMask) === 0) {
            return false;
        }

        // Get bounding boxes
        const thisBox = this.getBoundingBox();
        const otherBox = other.getBoundingBox();

        // AABB collision check (ignoring rotation)
        return (
            thisBox.x < otherBox.x + otherBox.width &&
            thisBox.x + thisBox.width > otherBox.x &&
            thisBox.y < otherBox.y + otherBox.height &&
            thisBox.y + thisBox.height > otherBox.y
        );
    }

    /*
        Returns an array of all GameObjects this object is currently colliding with
    */
    checkForCollisions() {
        const collisions = [];
        const allObjects = window.engine.getAllObjects();

        allObjects.forEach(obj => {
            if (obj !== this && this.collidesWith(obj) && obj.collisionEnabled) {
                collisions.push(obj);
            }
        });

        return collisions;
    }

    /**
     * Set collision layer and mask
     * @param {number} layer - The collision layer this object belongs to
     * @param {number} mask - Bitmask of layers this object should collide with
     */
    setCollision(layer, mask = 0xFFFF) {
        this.collisionLayer = layer;
        this.collisionMask = mask;
    }

    /**
     * Enable or disable collision for this GameObject
     * @param {boolean} enabled - Whether collision should be enabled
     */
    setCollisionEnabled(enabled) {
        this.collisionEnabled = enabled;
    }

    /**
     * Check polygon collision with another GameObject
     * @param {GameObject} other
     * @returns {boolean}
     */
    collidesWithPolygon(other) {
        if (!this.usePolygonCollision || !other.usePolygonCollision) return false;
        if (!this.polygon || !other.polygon) return false;
        return this.polygon.collidesWith(other.polygon);
    }

    /**
     * Check if a point is inside this GameObject's polygon
     * @param {number} x
     * @param {number} y
     * @returns {boolean}
     */
    polygonContainsPoint(x, y) {
        if (!this.usePolygonCollision || !this.polygon) return false;
        return this.polygon.collisionPoint(x, y);
    }

    /**
     * Get all GameObjects this polygon collides with
     * @returns {Array<GameObject>}
     */
    checkPolygonCollisions() {
        if (!this.usePolygonCollision || !this.polygon) return [];
        const allObjects = window.engine.getAllObjects();
        return allObjects.filter(obj =>
            obj !== this &&
            obj.usePolygonCollision &&
            obj.polygon &&
            this.collidesWithPolygon(obj)
        );
    }

    generatePolygonPoints() {
        const count = Math.max(3, this.polygonPointCount);
        const radius = Math.max(this.size.x, this.size.y) / 2;
        this.polygonPoints = [];
        for (let i = 0; i < count; i++) {
            const angle = (2 * Math.PI * i) / count;
            const x = this.position.x + Math.cos(angle) * radius;
            const y = this.position.y + Math.sin(angle) * radius;
            // Points should be relative to (0,0), not this.position
            this.polygonPoints.push(new Vector2(x, y));
        }
        // Always center polygon at the GameObject's position
        this.polygon = new Polygon(this, this.position.clone(), ...this.polygonPoints.map(pt => pt.clone()));
    }

    /**
     * Add a module to this GameObject
     * @param {Module} module - The module to add
     * @returns {Module} The added module
     */
    addModule(module) {
        if (!module) return null;

        // Check if this type of module is already attached
        const cls = module.constructor;
        if (cls.allowMultiple === false) {
            const already = this.getModuleByType(cls.name);
            if (already) {
                console.warn(`Only one ${cls.name} allowed on a GameObject.`);
                return already;
            }
        }

        // Generate a unique ID for the module if it doesn't have one
        if (!module.id) {
            module.id = crypto.randomUUID ? crypto.randomUUID() : `m-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
        }

        // Add required modules first
        const requirements = module.getRequirements ? module.getRequirements() : [];
        for (const requiredName of requirements) {
            // Check if we already have this module
            const existingReq = this.getModuleByType(requiredName);
            if (!existingReq) {
                console.log(`Adding required module: ${requiredName} for ${module.constructor.name}`);

                // Try to get the module class
                let ModuleClass = null;

                // First try to get from registry
                if (window.moduleRegistry) {
                    ModuleClass = window.moduleRegistry.getModuleClass(requiredName);
                }

                // Fall back to global scope
                if (!ModuleClass && window[requiredName]) {
                    ModuleClass = window[requiredName];
                }

                if (ModuleClass) {
                    // Create a new instance and add it
                    const requiredModule = new ModuleClass();
                    this.addModule(requiredModule); // Recursive to handle nested requirements
                } else {
                    console.warn(`Required module ${requiredName} not found`);
                }
            }
        }

        // Set the gameObject reference
        module.gameObject = this;

        // Add to modules array
        this.modules.push(module);

        // Call onAttach
        if (typeof module.onAttach === 'function') {
            module.onAttach(this);
        }

        return module;
    }

    /**
     * Check for and add required modules
     * @param {Module} module - The module to check requirements for
     * @private
     */
    addRequiredModules(module) {
        // Get the requirements
        const requirements = module.getRequirements ? module.getRequirements() : [];

        // Process each requirement
        for (const requiredName of requirements) {
            // Check if we already have this required module
            const existing = this.getModuleByType(requiredName);

            if (!existing) {
                console.log(`Module ${module.constructor.name} requires ${requiredName}, adding it automatically`);

                // Find the module class from registry or global scope
                let ModuleClass = null;

                // Try to get from registry first
                if (window.moduleRegistry) {
                    ModuleClass = window.moduleRegistry.getModuleClass(requiredName);
                }

                // Fall back to global namespace
                if (!ModuleClass && window[requiredName]) {
                    ModuleClass = window[requiredName];
                }

                if (ModuleClass) {
                    // Create and add the required module
                    const requiredModule = new ModuleClass();

                    // Check if this required module itself has requirements
                    this.addRequiredModules(requiredModule);

                    // Add the module normally
                    requiredModule.gameObject = this;
                    requiredModule.id = crypto.randomUUID ? crypto.randomUUID() : `m-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
                    this.modules.push(requiredModule);

                    // Call onAttach
                    if (typeof requiredModule.onAttach === 'function') {
                        requiredModule.onAttach(this);
                    }
                } else {
                    console.warn(`Required module ${requiredName} not found, cannot add automatically`);
                }
            }
        }
    }

    /**
     * Get a module by type
     * @param {class} moduleType - The class/type of module to find
     * @returns {Module} The found module or null
     */
    getModule(moduleType) {
        // Handle module type as string
        if (typeof moduleType === 'string') {
            return this.modules.find(module =>
                module.constructor.name === moduleType ||
                module.type === moduleType
            );
        }

        // Handle module type as class
        if (typeof moduleType === 'function') {
            return this.modules.find(module => module instanceof moduleType);
        }

        // If moduleType is neither string nor function, return null
        return null;
    }

    /**
     * Reorder modules based on an array of module IDs
     * @param {Array<string>} moduleIds - Ordered array of module IDs
     */
    reorderModules(moduleIds) {
        if (!moduleIds || !moduleIds.length) return;

        // Create a new ordered modules array
        const orderedModules = [];

        // First add modules in the specified order
        for (const moduleId of moduleIds) {
            const module = this.getModuleById(moduleId);
            if (module) {
                orderedModules.push(module);
            }
        }

        // Add any remaining modules that weren't in the moduleIds array
        for (const module of this.modules) {
            if (!orderedModules.includes(module)) {
                orderedModules.push(module);
            }
        }

        // Replace the modules array with the ordered one
        this.modules = orderedModules;
    }

    /**
     * Get a module by type name
     * @param {string} typeName - The name of the module type to find
     * @returns {Module} The found module or null
     */
    getModuleByType(typeName) {
        return this.modules.find(module =>
            module.constructor.name === typeName ||
            module.type === typeName
        );
    }

    /**
     * Get a module by its ID
     * @param {string} id - The module ID
     * @returns {Module|null} The found module or null
     */
    getModuleById(id) {
        return this.modules.find(module => module.id === id) || null;
    }

    /**
     * Remove a module by reference
     * @param {Module} module - The module to remove
     * @returns {boolean} True if the module was removed
     */
    removeModule(module) {
        const index = this.modules.indexOf(module);
        if (index !== -1) {
            module.gameObject = null;
            this.modules.splice(index, 1);
            if (module.onDestroy) module.onDestroy();
            return true;
        }
        return false;
    }

    /**
     * Remove a module by type
     * @param {class} moduleType - The class/type of module to remove
     * @returns {boolean} True if a module was removed
     */
    removeModuleByType(moduleType) {
        const module = this.getModule(moduleType);
        if (module) {
            return this.removeModule(module);
        }
        return false;
    }

    /**
     * Add a child GameObject
     * @param {GameObject} child - The child to add
     * @returns {GameObject} The added child
     */
    addChild(child) {
        if (child.parent) {
            child.parent.removeChild(child);
        }
        child.parent = this;
        this.children.push(child);
        return child;
    }

    /**
     * Remove a child GameObject
     * @param {GameObject} child - The child to remove
     * @returns {boolean} True if the child was removed
     */
    removeChild(child) {
        const index = this.children.indexOf(child);
        if (index !== -1) {
            this.children.splice(index, 1);
            child.parent = null;
            return true;
        }
        return false;
    }

    /**
     * Set the active state of this GameObject
     * @param {boolean} value - Whether the GameObject should be active
     */
    setActive(value) {
        this.active = value;
    }

    /**
     * Toggle the active state of this GameObject
     */
    toggleActive() {
        this.active = !this.active;
    }

    /**
     * Add a tag to this GameObject
     * @param {string} tag - The tag to add
     */
    addTag(tag) {
        if (!this.tags.includes(tag)) {
            this.tags.push(tag);
        }
    }

    /**
     * Check if this GameObject has a specific tag
     * @param {string} tag - The tag to check for
     * @returns {boolean} True if the GameObject has the tag
     */
    hasTag(tag) {
        return this.tags.includes(tag);
    }

    /**
     * Remove a tag from this GameObject
     * @param {string} tag - The tag to remove
     */
    removeTag(tag) {
        const index = this.tags.indexOf(tag);
        if (index !== -1) {
            this.tags.splice(index, 1);
        }
    }

    /**
     * Find a child by name (including deep search through children)
     * @param {string} name - The name of the GameObject to find
     * @param {boolean} deep - Whether to search recursively through all children
     * @returns {GameObject|null} The found GameObject or null
     */
    findChild(name, deep = true) {
        // First, check direct children
        for (const child of this.children) {
            if (child.name === name) return child;
        }

        // If not found and deep search is enabled, search in children's children
        if (deep) {
            for (const child of this.children) {
                const found = child.findChild(name, true);
                if (found) return found;
            }
        }

        return null;
    }

    /**
     * Set the selection state of this GameObject
     * @param {boolean} selected - Whether the GameObject is selected
     */
    setSelected(selected) {
        this.selected = selected;
    }

    /**
     * Rename this GameObject
     * @param {string} newName - The new name
     */
    rename(newName) {
        this.name = newName;
    }

    /**
     * Get the world position of this GameObject
     * @returns {Vector2} The world position
     */
    getWorldPositionOriginal() {
        let worldPos = this.position.clone();
        if (this.parent) {
            const parentWorldPos = this.parent.getWorldPosition();
            worldPos = worldPos.rotate(this.parent.angle * Math.PI / 180);
            worldPos = worldPos.add(parentWorldPos);
        }
        return worldPos;
    }

    getWorldPosition() {
        let worldPos = this.position.clone();
        let currentParent = this.parent;
        let totalAngle = 0;

        // Accumulate rotation from all ancestors
        while (currentParent) {
            totalAngle += currentParent.angle;
            currentParent = currentParent.parent;
        }

        // Rotate local position by total ancestor angle
        worldPos = worldPos.rotate(totalAngle * Math.PI / 180);

        // Add world position of topmost parent (if any)
        if (this.parent) {
            worldPos = worldPos.add(this.parent.getWorldPosition());
        }

        // Round to 2 decimal places
        worldPos.x = Math.round(worldPos.x * 100) / 100;
        worldPos.y = Math.round(worldPos.y * 100) / 100;

        return worldPos;
    }

    /**
     * Convert a world position to local space
     * @param {Vector2} worldPosition - Position in world space
     * @returns {Vector2} Position in local space
     */
    worldToLocalPosition(worldPosition) {
        if (!this.parent) return worldPosition.subtract(this.position);

        const parentWorldPos = this.parent.getWorldPosition();
        let localToParent = worldPosition.subtract(parentWorldPos);
        localToParent = localToParent.rotate(-this.parent.angle * Math.PI / 180);
        return localToParent.subtract(this.position);
    }

    getWorldRotation() {
        let rotation = this.angle;
        let currentParent = this.parent;

        while (currentParent) {
            rotation += currentParent.angle;
            currentParent = currentParent.parent;
        }

        return rotation;
    }

    getWorldScale() {
        let scale = this.scale.clone();
        let currentParent = this.parent;

        while (currentParent) {
            scale.x *= currentParent.scale.x;
            scale.y *= currentParent.scale.y;
            currentParent = currentParent.parent;
        }

        return scale;
    }

    createPixiDisplayObject() {
        // Example: create a simple rectangle using PIXI.Graphics
        const graphics = new PIXI.Graphics();
        graphics.beginFill(0xffffff); // White fill
        graphics.drawRect(-this.size.x / 2, -this.size.y / 2, this.size.x, this.size.y);
        graphics.endFill();
        graphics.pivot.set(0, 0);
        graphics.x = this.position.x;
        graphics.y = this.position.y;
        graphics.rotation = this.angle * Math.PI / 180;
        graphics.scale.set(this.scale.x, this.scale.y);
        graphics.visible = this.visible;
        this.pixiDisplayObject = graphics;
        return graphics;
    }

    updatePixiDisplayObject() {
        if (!this.pixiDisplayObject) return;
        this.pixiDisplayObject.x = this.position.x;
        this.pixiDisplayObject.y = this.position.y;
        this.pixiDisplayObject.rotation = this.angle * Math.PI / 180;
        this.pixiDisplayObject.scale.set(this.scale.x, this.scale.y);
        this.pixiDisplayObject.visible = this.visible;
    }

    /**
     * Serialize this GameObject to JSON
     * @returns {Object} Serialized GameObject data
     */
    toJSON() {
        return {
            id: this.id, // Include the ID for reference
            name: this.name,
            position: { x: this.position.x, y: this.position.y },
            scale: { x: this.scale.x, y: this.scale.y },
            useCollisions: this.useCollisions,
            polygonPointCount: this.polygonPointCount,
            polygonPoints: this.polygonPoints.map(pt => ({ x: pt.x, y: pt.y })),
            usePolygonCollision: this.usePolygonCollision,
            polygon: this.polygon ? this.polygon.toJSON() : null,
            size: this.size ? { width: this.size.x, height: this.size.y } : { width: 50, height: 50 },
            colliderWidth: this.colliderWidth || 0,
            colliderHeight: this.colliderHeight || 0,
            angle: this.angle,
            depth: this.depth,
            active: this.active,
            editorColor: this.editorColor,
            visible: this.visible,
            tags: [...this.tags],
            collisionEnabled: this.collisionEnabled,
            collisionLayer: this.collisionLayer,
            collisionMask: this.collisionMask,
            modules: this.modules.map(module => ({
                type: module.constructor.name,
                id: module.id,
                data: module.toJSON ? module.toJSON() : {}
            })),
            children: this.children.map(child => child.toJSON())
        };
    }

    /**
     * Create a GameObject from serialized data
     * @param {Object} json - Serialized GameObject data
     * @returns {GameObject} The created GameObject
     */
    static fromJSON(json) {
        const obj = new GameObject(json.name);
        // Restore ID if available
        if (json.id) obj.id = json.id;

        obj.colliderWidth = json.colliderWidth || 0;
        obj.colliderHeight = json.colliderHeight || 0;

        obj.position = new Vector2(json.position.x, json.position.y);
        obj.useCollisions = json.useCollisions || false;
        obj.size = json.size ? new Vector2(json.size.width, json.size.height) : new Vector2(50, 50);
        // Restore scale if available
        if (json.scale) obj.scale = new Vector2(json.scale.x, json.scale.y);
        obj.editorColor = json.editorColor || obj.generateRandomColor();

        if (json.polygonPointCount !== undefined) {
            obj.polygonPointCount = json.polygonPointCount;
        }
        if (json.polygonPoints && Array.isArray(json.polygonPoints)) {
            obj.polygonPoints = json.polygonPoints.map(pt => new Vector2(pt.x, pt.y));
            // Pass parent, position, ...points
            obj.polygon = new Polygon(obj, obj.position.clone(), ...obj.polygonPoints.map(pt => pt.clone()));
        }

        if (json.usePolygonCollision !== undefined) {
            obj.usePolygonCollision = json.usePolygonCollision;
        }

        obj.angle = json.angle;
        obj.depth = json.depth;
        obj.active = json.active;
        if (json.visible !== undefined) obj.visible = json.visible;
        obj.tags = Array.isArray(json.tags) ? [...json.tags] : [];

        if (json.collisionEnabled !== undefined) obj.collisionEnabled = json.collisionEnabled;
        if (json.collisionLayer !== undefined) obj.collisionLayer = json.collisionLayer;
        if (json.collisionMask !== undefined) obj.collisionMask = json.collisionMask;

        // Add modules - with improved module class lookup
        if (json.modules && Array.isArray(json.modules)) {
            json.modules.forEach(moduleData => {
                // Try to get the module class from registry or window
                const moduleTypeName = moduleData.type;
                let ModuleClass = null;

                // Try module registry first
                if (window.moduleRegistry) {
                    ModuleClass = window.moduleRegistry.getModuleClass(moduleTypeName);
                }

                // Fall back to global scope with various naming conventions
                if (!ModuleClass) {
                    // Try PascalCase (standard naming convention)
                    if (window[moduleTypeName]) {
                        ModuleClass = window[moduleTypeName];
                    }
                    // If not found, try other possible variations to be more robust
                    else if (moduleTypeName) {
                        // Try camelCase variation
                        const camelCase = moduleTypeName.charAt(0).toLowerCase() + moduleTypeName.slice(1);
                        if (window[camelCase]) {
                            ModuleClass = window[camelCase];
                        }
                        // Try capitalized version
                        const capitalized = moduleTypeName.charAt(0).toUpperCase() + moduleTypeName.slice(1);
                        if (window[capitalized]) {
                            ModuleClass = window[capitalized];
                        }
                    }
                }

                if (ModuleClass) {
                    try {
                        // Create the module instance
                        const module = new ModuleClass();

                        // Restore the module's ID and type
                        if (moduleData.id) module.id = moduleData.id;
                        module.type = moduleTypeName; // Explicitly set type to what was saved

                        // Initialize from saved data if module has fromJSON method
                        if (moduleData.data && typeof module.fromJSON === 'function') {
                            module.fromJSON(moduleData.data);
                        } else if (moduleData.exposedValues) {
                            // Fall back to copying exposed values if no specific fromJSON method
                            for (const key in moduleData.exposedValues) {
                                if (key in module) {
                                    module[key] = moduleData.exposedValues[key];
                                }
                            }
                        }

                        // Add module to game object
                        obj.addModule(module);

                    } catch (error) {
                        console.error(`Error restoring module ${moduleTypeName}:`, error);
                        // Create a placeholder module to preserve data
                        createPlaceholderModule(obj, moduleData, moduleTypeName);
                    }
                } else {
                    console.warn(`Module class ${moduleTypeName} not found when restoring game object.`);
                    // Create a placeholder module to preserve data
                    createPlaceholderModule(obj, moduleData, moduleTypeName);
                }
            });
        }

        // Add children
        json.children.forEach(childJson => {
            const child = GameObject.fromJSON(childJson);
            obj.addChild(child);
        });

        // Now call start() on all modules to initialize physics bodies
        /*obj.modules.forEach(module => {
            if (typeof module.start === 'function') {
                try { module.start(); } catch (e) { console.error(e); }
            }
        });*/

        return obj;
    }

    /**
     * Copy properties from one module to another, with special handling for GameObject references
     * @param {Module} sourceModule - The source module to copy from
     * @param {Module} targetModule - The target module to copy to
     * @param {GameObject} newGameObject - The new GameObject that owns the target module
     */
    copyModuleProperties(sourceModule, targetModule, newGameObject) {
        // First, ensure we have all the necessary objects
        if (!sourceModule || !targetModule || !newGameObject) {
            console.warn("copyModuleProperties: Missing required arguments");
            return;
        }

        const originalGameObject = this; // Store reference to original GameObject

        // Get all property names (including non-enumerable ones)
        const propertyNames = new Set([
            ...Object.getOwnPropertyNames(sourceModule),
            ...Object.keys(sourceModule)
        ]);

        // Process each property
        for (const key of propertyNames) {
            try {
                // Skip special properties and functions
                if (key === 'id' || key === 'gameObject' || key === 'constructor' ||
                    key.startsWith('__') || typeof sourceModule[key] === 'function') {
                    continue;
                }

                // Get the source value
                const value = sourceModule[key];

                // Handle different value types
                if (value === null || value === undefined) {
                    targetModule[key] = value;
                }
                else if (value === originalGameObject) {
                    // Direct reference to the original GameObject
                    targetModule[key] = newGameObject;
                }
                else if (value === sourceModule.gameObject) {
                    // Another way to reference the original GameObject
                    targetModule[key] = newGameObject;
                }
                else if (value instanceof Vector2) {
                    // Deep clone Vector2 (or anything with a clone method)
                    targetModule[key] = value.clone();
                }
                else if (Array.isArray(value)) {
                    // Process arrays - create a new array for the clone
                    targetModule[key] = deepCloneArray(value, originalGameObject, newGameObject);
                }
                else if (typeof value === 'object' && value !== null &&
                    !(value instanceof HTMLElement)) {
                    // For any other objects that aren't DOM elements
                    if (typeof value.clone === 'function') {
                        // Use clone method if available
                        targetModule[key] = value.clone();
                    } else {
                        // Do a deep clone with reference replacement
                        targetModule[key] = deepCloneWithReplacements(value, originalGameObject, newGameObject);
                    }
                } else {
                    // For primitives, do direct assignment
                    targetModule[key] = value;
                }
            } catch (e) {
                console.warn(`Error cloning property ${key} in module ${sourceModule.constructor.name}:`, e);
            }
        }

        // Handle private properties for exposed properties
        if (Array.isArray(sourceModule.exposedProperties)) {
            for (const prop of sourceModule.exposedProperties) {
                const propName = prop.name;
                const privatePropName = `_${propName}`;

                // Copy the private property if it exists
                if (privatePropName in sourceModule) {
                    const privateValue = sourceModule[privatePropName];

                    if (privateValue === originalGameObject) {
                        targetModule[privatePropName] = newGameObject;
                    } else if (typeof privateValue === 'object' && privateValue !== null) {
                        if (typeof privateValue.clone === 'function') {
                            targetModule[privatePropName] = privateValue.clone();
                        } else {
                            targetModule[privatePropName] = deepCloneWithReplacements(
                                privateValue, originalGameObject, newGameObject
                            );
                        }
                    } else {
                        targetModule[privatePropName] = privateValue;
                    }
                }
            }
        }
    }

    deepCloneObject(obj, newGameObject) {
        if (!obj) return obj;

        try {
            // For DOM elements, return as-is
            if (obj instanceof HTMLElement) return obj;

            // For objects with clone method, use it
            if (typeof obj.clone === 'function') return obj.clone();

            const clone = {};

            for (const key in obj) {
                if (!Object.prototype.hasOwnProperty.call(obj, key)) continue;

                const value = obj[key];

                if (value === this || value === this.gameObject) {
                    clone[key] = newGameObject;
                } else if (value instanceof Vector2) {
                    clone[key] = value.clone();
                } else if (Array.isArray(value)) {
                    clone[key] = this.deepCloneArray(value, newGameObject);
                } else if (typeof value === 'object' && value !== null && !(value instanceof HTMLElement)) {
                    clone[key] = this.deepCloneObject(value, newGameObject);
                } else {
                    clone[key] = value;
                }
            }

            return clone;

        } catch (e) {
            console.warn("Failed to deep clone object:", e);
            return {}; // Return empty object as fallback
        }
    }

    /**
     * Deep clone an array, replacing GameObject references
     * @param {Array} arr - The array to clone
     * @param {GameObject} newGameObject - The new GameObject to use for replacements
     * @returns {Array} - Cloned array
     */
    deepCloneArray(arr, originalGameObject, newGameObject) {
        if (!arr) return arr;

        return arr.map(item => {
            if (item === originalGameObject || item === originalGameObject.gameObject) {
                return newGameObject;
            }
            else if (item === null || item === undefined || typeof item !== 'object') {
                return item; // Direct copy for primitives
            }
            else if (typeof item.clone === 'function') {
                return item.clone();
            }
            else if (Array.isArray(item)) {
                return this.deepCloneArray(item, originalGameObject, newGameObject);
            }
            else if (item instanceof HTMLElement) {
                return item; // Keep DOM references intact
            }
            else {
                return this.deepCloneWithReplacements(item, originalGameObject, newGameObject);
            }
        });
    }

    /**
     * Deep clone an object with GameObject reference replacements
     * @param {Object} obj - Object to clone
     * @param {GameObject} newGameObject - The new GameObject to use for replacements
     * @returns {Object} Cloned object
     */
    deepCloneWithReplacements(obj, originalGameObject, newGameObject) {
        if (!obj) return obj;
        if (obj === originalGameObject) return newGameObject;

        // Skip non-objects and DOM elements
        if (typeof obj !== 'object' || obj instanceof HTMLElement) return obj;

        // Handle special objects
        if (typeof obj.clone === 'function') return obj.clone();
        if (obj instanceof Date) return new Date(obj.getTime());

        // Handle arrays
        if (Array.isArray(obj)) {
            return this.deepCloneArray(obj, originalGameObject, newGameObject);
        }

        // Create a new object of the same type
        const clone = Object.create(Object.getPrototypeOf(obj));

        // Copy all properties with reference checks
        for (const key in obj) {
            if (!Object.prototype.hasOwnProperty.call(obj, key)) continue;

            const value = obj[key];

            if (value === originalGameObject || value === originalGameObject.gameObject) {
                // Replace GameObject references
                clone[key] = newGameObject;
            }
            else if (value === null || value === undefined || typeof value !== 'object') {
                // Direct copy for primitives and null/undefined
                clone[key] = value;
            }
            else if (typeof value.clone === 'function') {
                // Use clone method if available
                clone[key] = value.clone();
            }
            else if (value instanceof HTMLElement) {
                // Keep references to DOM elements intact
                clone[key] = value;
            }
            else if (Array.isArray(value)) {
                // Deep clone arrays
                clone[key] = this.deepCloneArray(value, originalGameObject, newGameObject);
            }
            else {
                // Deep clone other objects
                clone[key] = this.deepCloneWithReplacements(value, originalGameObject, newGameObject);
            }
        }

        return clone;
    }

    /**
     * Recursively replace missed GameObject references in the cloned module
     * @param {Object} obj - The module or object to scan
     * @param {GameObject} newGameObject - The new GameObject to use for replacements
     */
    replaceMissedReferences(obj, newGameObject) {
        if (!obj || typeof obj !== 'object') return;

        // Use a Set to track visited objects and avoid circular reference issues
        const visited = new Set();

        function scan(o) {
            if (!o || typeof o !== 'object' || visited.has(o)) return;
            visited.add(o);

            // Check all properties
            for (const key in o) {
                if (!Object.prototype.hasOwnProperty.call(o, key)) continue;
                if (key === 'gameObject') continue; // Skip the gameObject property itself

                const value = o[key];

                if (value === this) {
                    // Replace references to the original GameObject
                    o[key] = newGameObject;
                } else if (value && typeof value === 'object' && !visited.has(value)) {
                    // Recursively scan nested objects
                    scan(value);
                }
            }
        }

        scan.call(this, obj);
    }

    /**
     * Thoroughly scan an object to find and replace all references to the original GameObject
     * @param {Object} obj - The object to scan
     * @param {GameObject} originalObj - The original GameObject to replace
     * @param {GameObject} newObj - The replacement GameObject
     */
    deepScanAndReplaceAllReferences(obj, originalObj, newObj) {
        if (!obj || typeof obj !== 'object') return;

        // Use a WeakMap to track visited objects and avoid circular reference issues
        const visited = new WeakMap();

        const scan = (o) => {
            if (!o || typeof o !== 'object' || visited.has(o)) return;
            visited.set(o, true);

            // Check all properties recursively
            for (const key in o) {
                if (!Object.prototype.hasOwnProperty.call(o, key)) continue;

                const value = o[key];

                // Replace direct references
                if (value === originalObj || value === originalObj.gameObject) {
                    o[key] = newObj;
                    continue;
                }

                // Recursively scan objects and arrays
                if (typeof value === 'object' && value !== null && !visited.has(value)) {
                    scan(value);
                }
            }
        };

        scan(obj);
    }

    /**
     * Clone this GameObject, including all modules and children
     * @returns {GameObject} A deep copy of this GameObject
     */
    clone(addNameCopySuffix = true) {
        const originalGameObject = this;

        // Create new GameObject
        // Only add " (Copy)" if not already present
        let newName = this.name;
        if (addNameCopySuffix && !newName.trim().endsWith("(Copy)")) {
            newName += " (Copy)";
        }
        const cloned = GameObject.fromJSON(this.toJSON());

        cloned.name = newName;

        // Generate a new unique ID for the cloned GameObject
        cloned.id = crypto.randomUUID ? crypto.randomUUID() : `go-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;

        return cloned;

        // Copy basic properties
        /*cloned.position = this.position.clone();
        cloned.scale = this.scale.clone();
        cloned.size = this.size.clone();
        cloned.origin = this.origin.clone();
        cloned.angle = this.angle;
        cloned.depth = this.depth;
        cloned.active = this.active;
        cloned.visible = this.visible;
        cloned.tags = [...this.tags];
        cloned.editorColor = this.editorColor;
        cloned.collisionEnabled = this.collisionEnabled;
        cloned.collisionLayer = this.collisionLayer;
        cloned.collisionMask = this.collisionMask;

        // Copy original position if it exists
        if (this._originalPosition) {
            cloned._originalPosition = { x: this._originalPosition.x, y: this._originalPosition.y };
        }

        // Clone modules with proper reference handling
        for (const module of this.modules) {
            try {
                // First get the module class
                let ModuleClass = module.constructor;
                if (!ModuleClass && module.type) {
                    ModuleClass = window.moduleRegistry?.getModuleClass(module.type)
                        || window[module.type];
                }

                if (!ModuleClass) {
                    console.warn(`Could not find class for module type ${module.type}`);
                    createPlaceholderModule(cloned, { id: module.id, type: module.type }, module.type);
                    continue;
                }

                // Create a new module instance
                const clonedModule = new ModuleClass();

                // Generate a new unique ID for the cloned module
                clonedModule.id = crypto.randomUUID();

                // Store the module type explicitly
                clonedModule.type = module.type || ModuleClass.name;

                // IMPORTANT: Set the gameObject reference first so that 
                // fromJSON has the correct reference when restoring properties
                clonedModule.gameObject = cloned;

                // Now restore data from the original module
                const data = module.toJSON();
                if (data) {
                    clonedModule.fromJSON(data);
                }

                // Proper attachment
                clonedModule.attachTo(cloned);

                // Add the module to the cloned game object's modules array
                cloned.modules.push(clonedModule);

                // Call onAttach explicitly if it exists
                if (typeof clonedModule.onAttach === 'function') {
                    clonedModule.onAttach(cloned);
                }

                // Deep scan for any missed references
                deepScanAndReplaceReferences(clonedModule, originalGameObject, cloned);

            } catch (error) {
                console.error(`Error cloning module ${module.type || module.constructor?.name}:`, error);
            }
        }

        // Clone children recursively
        for (const child of this.children) {
            const clonedChild = child.clone();
            cloned.addChild(clonedChild);
        }

        // Final pass to catch any remaining references
        for (const module of cloned.modules) {
            // Replace any remaining references to the original GameObject
            deepScanAndReplaceAllReferences(module, originalGameObject, cloned);

            // Also check for private properties
            for (const key in module) {
                if (key.startsWith('_') && module[key] === originalGameObject) {
                    module[key] = cloned;
                }
            }
        }*/

        return cloned;
    }

}

function deepScanAndReplaceAllReferences(obj, originalObj, newObj) {
    if (!obj || typeof obj !== 'object') return;

    const visited = new WeakMap();

    const scan = (o) => {
        if (!o || typeof o !== 'object' || visited.has(o)) return;
        visited.set(o, true);

        for (const key in o) {
            if (!Object.prototype.hasOwnProperty.call(o, key)) continue;

            const value = o[key];

            if (value === originalObj || value === originalObj.gameObject) {
                console.log(`Replacing reference in ${o.constructor.name}.${key}`);
                o[key] = newObj;
            }

            if (typeof value === 'object' && value !== null && !visited.has(value)) {
                scan(value);
            }
        }
    };

    scan(obj);
}

/**
 * Helper to find available module class 
 * @param {string} moduleName - The module class name to find
 * @returns {Class|null} - The module class or null if not found
 */
function findModuleClass(moduleName) {
    if (!moduleName) return null;

    // Check registry first (most reliable source)
    if (window.moduleRegistry) {
        const moduleClass = window.moduleRegistry.getModuleClass(moduleName);
        if (moduleClass) return moduleClass;
    }

    // Try direct global lookup with original name
    if (window[moduleName]) return window[moduleName];

    // Try camelCase variation
    const camelCase = moduleName.charAt(0).toLowerCase() + moduleName.slice(1);
    if (window[camelCase]) return window[camelCase];

    // Try capitalized version
    const capitalized = moduleName.charAt(0).toUpperCase() + moduleName.slice(1);
    if (window[capitalized]) return window[capitalized];

    // Not found
    return null;
}

/**
 * Function to copy module properties (outside class to avoid 'this' context issues)
 */
function copyModuleProperties(sourceModule, targetModule, newGameObject, originalGameObject) {
    // First, ensure we have all the necessary objects
    if (!sourceModule || !targetModule || !newGameObject || !originalGameObject) {
        console.warn("copyModuleProperties: Missing required arguments");
        return;
    }

    // Get all property names (including non-enumerable ones)
    const propertyNames = new Set([
        ...Object.getOwnPropertyNames(sourceModule),
        ...Object.keys(sourceModule)
    ]);

    // Process each property
    for (const key of propertyNames) {
        try {
            // Skip special properties and functions
            if (key === 'id' || key === 'gameObject' || key === 'constructor' ||
                key.startsWith('__') || typeof sourceModule[key] === 'function') {
                continue;
            }

            // Get the source value
            const value = sourceModule[key];

            // Handle different value types
            if (value === null || value === undefined) {
                targetModule[key] = value;
            }
            else if (value === originalGameObject) {
                // Direct reference to the original GameObject
                targetModule[key] = newGameObject;
            }
            else if (value === sourceModule.gameObject) {
                // Another way to reference the original GameObject
                targetModule[key] = newGameObject;
            }
            else if (value instanceof Vector2) {
                // Deep clone Vector2 (or anything with a clone method)
                targetModule[key] = value.clone();
            }
            else if (Array.isArray(value)) {
                // Process arrays - create a new array for the clone
                targetModule[key] = deepCloneArray(value, originalGameObject, newGameObject);
            }
            else if (typeof value === 'object' && value !== null &&
                !(value instanceof HTMLElement)) {
                // For any other objects that aren't DOM elements
                if (typeof value.clone === 'function') {
                    // Use clone method if available
                    targetModule[key] = value.clone();
                } else {
                    // Do a deep clone with reference replacement
                    targetModule[key] = deepCloneWithReplacements(value, originalGameObject, newGameObject);
                }
            } else {
                // For primitives, do direct assignment
                targetModule[key] = value;
            }
        } catch (e) {
            console.warn(`Error cloning property ${key} in module ${sourceModule.constructor.name}:`, e);
        }
    }

    // Handle private properties for exposed properties
    if (Array.isArray(sourceModule.exposedProperties)) {
        for (const prop of sourceModule.exposedProperties) {
            const propName = prop.name;
            const privatePropName = `_${propName}`;

            // Copy the private property if it exists
            if (privatePropName in sourceModule) {
                const privateValue = sourceModule[privatePropName];

                if (privateValue === originalGameObject) {
                    targetModule[privatePropName] = newGameObject;
                } else if (typeof privateValue === 'object' && privateValue !== null) {
                    if (typeof privateValue.clone === 'function') {
                        targetModule[privatePropName] = privateValue.clone();
                    } else {
                        targetModule[privatePropName] = deepCloneWithReplacements(
                            privateValue, originalGameObject, newGameObject
                        );
                    }
                } else {
                    targetModule[privatePropName] = privateValue;
                }
            }
        }
    }

    targetModule.gameObject = newGameObject;
}

/**
 * Deep clone an array, replacing GameObject references (standalone function)
 */
function deepCloneArray(arr, originalGameObject, newGameObject) {
    if (!arr) return arr;

    return arr.map(item => {
        if (item === originalGameObject || item === originalGameObject.gameObject) {
            return newGameObject;
        }
        else if (item === null || item === undefined || typeof item !== 'object') {
            return item; // Direct copy for primitives
        }
        else if (typeof item.clone === 'function') {
            return item.clone();
        }
        else if (Array.isArray(item)) {
            return deepCloneArray(item, originalGameObject, newGameObject);
        }
        else if (item instanceof HTMLElement) {
            return item; // Keep DOM references intact
        }
        else {
            return deepCloneWithReplacements(item, originalGameObject, newGameObject);
        }
    });
}

/**
 * Deep clone an object with GameObject reference replacements (standalone function)
 */
function deepCloneWithReplacements(obj, originalGameObject, newGameObject) {
    if (!obj) return obj;
    if (obj === originalGameObject) return newGameObject;

    // Skip non-objects and DOM elements
    if (typeof obj !== 'object' || obj instanceof HTMLElement) return obj;

    // Handle special objects
    if (typeof obj.clone === 'function') return obj.clone();
    if (obj instanceof Date) return new Date(obj.getTime());

    // Handle arrays
    if (Array.isArray(obj)) {
        return deepCloneArray(obj, originalGameObject, newGameObject);
    }

    // Create a new object of the same type
    const clone = Object.create(Object.getPrototypeOf(obj));

    // Copy all properties with reference checks
    for (const key in obj) {
        if (!Object.prototype.hasOwnProperty.call(obj, key)) continue;

        const value = obj[key];

        if (value === originalGameObject || value === originalGameObject.gameObject) {
            // Replace GameObject references
            clone[key] = newGameObject;
        }
        else if (value === null || value === undefined || typeof value !== 'object') {
            // Direct copy for primitives and null/undefined
            clone[key] = value;
        }
        else if (typeof value.clone === 'function') {
            // Use clone method if available
            clone[key] = value.clone();
        }
        else if (value instanceof HTMLElement) {
            // Keep references to DOM elements intact
            clone[key] = value;
        }
        else if (Array.isArray(value)) {
            // Deep clone arrays
            clone[key] = deepCloneArray(value, originalGameObject, newGameObject);
        }
        else {
            // Deep clone other objects
            clone[key] = deepCloneWithReplacements(value, originalGameObject, newGameObject);
        }
    }

    return clone;
}

/**
 * Perform a deep scan of an object to find and replace all references to the original GameObject
 * @param {Object} obj - The object to scan
 * @param {GameObject} original - The original GameObject to replace
 * @param {GameObject} replacement - The replacement GameObject
 */
function deepScanAndReplaceReferences(obj, original, replacement) {
    if (!obj || typeof obj !== 'object') return;

    // Use a Set to track objects we've already visited to avoid circular references
    const visited = new Set();

    function _scan(o) {
        if (!o || typeof o !== 'object' || visited.has(o)) return;
        visited.add(o);

        // Check all properties of the object
        for (const key in o) {
            if (!o.hasOwnProperty(key)) continue;

            // Skip the 'gameObject' property as it's already set correctly
            if (key === 'gameObject') continue;

            const value = o[key];

            // If the value is a reference to the original GameObject, replace it
            if (value === original) {
                o[key] = replacement;
            }
            // Recursively scan objects
            else if (value && typeof value === 'object' && !visited.has(value)) {
                _scan(value);
            }
        }
    }

    _scan(obj);
}

/**
 * Deep clone an object while replacing references to the original GameObject with the cloned one
 * @param {Object} obj - The object to clone
 * @param {GameObject} originalGameObject - The original GameObject to replace references to
 * @param {GameObject} clonedGameObject - The new GameObject to replace references with
 * @returns {Object} - A deep clone with replaced references
 */
function deepCloneWithReferenceReplacement(obj, originalGameObject, clonedGameObject) {
    if (!obj || typeof obj !== 'object') return obj;

    // Handle null
    if (obj === null) return null;

    // Handle Date objects
    if (obj instanceof Date) return new Date(obj.getTime());

    // Handle GameObject references
    if (obj === originalGameObject) return clonedGameObject;

    // Handle Vector2 instances
    if (obj instanceof Vector2) return obj.clone();

    // Handle arrays
    if (Array.isArray(obj)) {
        return obj.map(item => {
            if (item === originalGameObject) return clonedGameObject;
            return deepCloneWithReferenceReplacement(item, originalGameObject, clonedGameObject);
        });
    }

    // Skip functions (they can't be reliably cloned)
    if (typeof obj === 'function') return undefined;

    // Handle objects with their own clone method
    if (typeof obj.clone === 'function') return obj.clone();

    // Handle regular objects - deep copy each property
    try {
        // For regular objects, create a new object of the same type
        const clone = Array.isArray(obj) ? [] : Object.create(Object.getPrototypeOf(obj));

        // Copy each property with reference replacement
        for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                if (obj[key] === originalGameObject) {
                    clone[key] = clonedGameObject;
                } else if (typeof obj[key] === 'object' && obj[key] !== null) {
                    clone[key] = deepCloneWithReferenceReplacement(obj[key], originalGameObject, clonedGameObject);
                } else {
                    clone[key] = obj[key];
                }
            }
        }

        return clone;
    } catch (e) {
        // Fallback to simpler approach for objects that cause errors
        console.warn("Error during deep clone, using simpler clone:", e);

        const simpleClone = {};
        for (const key in obj) {
            if (obj[key] === originalGameObject) {
                simpleClone[key] = clonedGameObject;
            } else if (typeof obj[key] !== 'function') {
                simpleClone[key] = obj[key];
            }
        }

        return simpleClone;
    }
}

/**
 * Replace all references to originalObj with newObj in the given object
 * @param {Object} obj - The object to search through
 * @param {Object} originalObj - The object to replace
 * @param {Object} newObj - The replacement object
 */
function replaceReferences(obj, originalObj, newObj) {
    if (!obj || typeof obj !== 'object' || originalObj === null || newObj === null) {
        return;
    }

    for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            if (obj[key] === originalObj) {
                obj[key] = newObj;
            } else if (typeof obj[key] === 'object' && obj[key] !== null) {
                replaceReferences(obj[key], originalObj, newObj);
            }
        }
    }
}

/**
 * Safely clone an object, handling non-serializable values like functions, and replacing gameObject references
 * @param {any} obj - The object to clone
 * @param {GameObject} originalGameObject - The original GameObject to replace references to
 * @param {GameObject} newGameObject - The new GameObject to replace references with
 * @returns {any} - A deep clone of the object
 */
function safeClone(obj, originalGameObject, newGameObject) {
    if (obj === null || obj === undefined) {
        return obj;
    }

    // Handle GameObject references
    if (originalGameObject && obj === originalGameObject) {
        return newGameObject;
    }

    // Handle primitive types
    if (typeof obj !== 'object' && typeof obj !== 'function') {
        return obj;
    }

    // Handle Vector2 objects
    if (obj instanceof Vector2) {
        return obj.clone();
    }

    // Handle Date objects
    if (obj instanceof Date) {
        return new Date(obj.getTime());
    }

    // Handle arrays with special item handling
    if (Array.isArray(obj)) {
        return obj.map(item => {
            if (originalGameObject && item === originalGameObject) {
                return newGameObject;
            }
            return safeClone(item, originalGameObject, newGameObject);
        });
    }

    // Skip functions - they can't be cloned reliably
    if (typeof obj === 'function') {
        return undefined;
    }

    // Handle objects that have their own clone method
    if (typeof obj.clone === 'function') {
        return obj.clone();
    }

    // For regular objects, create a new object and copy properties
    try {
        // Try using structuredClone first for performance
        const cloned = structuredClone(obj);

        // Still need to check for and replace gameObject references
        if (originalGameObject && newGameObject) {
            // Recursively search for references to replace
            replaceReferences(cloned, originalGameObject, newGameObject);
        }

        return cloned;
    } catch (e) {
        // Fall back to manual cloning when structuredClone fails
        const clonedObj = Array.isArray(obj) ? [] : {};

        for (const key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
                if (typeof obj[key] === 'function') {
                    // Skip functions - they can't be cloned reliably
                    continue;
                }

                // Replace GameObject references
                if (originalGameObject && obj[key] === originalGameObject) {
                    clonedObj[key] = newGameObject;
                } else {
                    clonedObj[key] = safeClone(obj[key], originalGameObject, newGameObject);
                }
            }
        }

        return clonedObj;
    }
}

function createPlaceholderModule(gameObj, moduleData, typeName) {
    try {
        // Check if Module class is available
        if (typeof Module === 'undefined') {
            console.error("Module base class not available for placeholder creation");
            return null;
        }

        // Create a basic module that preserves the data
        const placeholderModule = new Module(`${typeName || 'Unknown'} (Missing)`);
        placeholderModule.id = moduleData.id || crypto.randomUUID();
        placeholderModule.type = typeName || 'UnknownModule';
        placeholderModule.missingModule = true;
        placeholderModule.originalData = moduleData;
        placeholderModule.gameObject = gameObj;  // Make sure to set this reference

        // Add the placeholder module directly to avoid using addModule which could have side effects
        gameObj.modules.push(placeholderModule);

        console.warn(`Created placeholder for missing module: ${typeName}. Available modules: ${Array.from(window.moduleRegistry?.modules?.keys() || []).join(', ')
            }`);

        return placeholderModule;
    } catch (e) {
        console.error("Failed to create placeholder module:", e);
        return null;
    }
}

// src/core/InputManager.js
/**
 * InputManager - Handles keyboard, mouse and touch input
 * 
 * This is a global system that manages all input in a centralized way,
 * allowing modules to easily check for input states without adding their
 * own event listeners.
 */
class InputManager {
    constructor() {
        // Keyboard state tracking
        this.keys = {};          // Current key states (down/up)
        this.keysDown = {};      // Keys that went down this frame
        this.keysUp = {};        // Keys that went up this frame
        this.keysPressed = {};   // Keys that were pressed this frame (for continuous input)

        // Mouse state tracking
        this.mousePosition = new Vector2(0, 0);       // Current mouse position
        this.worldMousePosition = new Vector2(0, 0);  // Mouse position in world coordinates
        this.mouseButtons = {                         // Mouse button states
            left: false,
            middle: false,
            right: false
        };
        this.mouseButtonsDown = {                     // Mouse buttons that went down this frame
            left: false,
            middle: false,
            right: false
        };
        this.mouseButtonsUp = {                       // Mouse buttons that went up this frame
            left: false,
            middle: false,
            right: false
        };
        this.mouseWheel = 0;                          // Mouse wheel delta
        this.mouseMoveThisFrame = false;              // Whether the mouse moved this frame

        // Touch state tracking
        this.touches = {};                            // Current active touches
        this.touchesStarted = {};                     // Touches that started this frame
        this.touchesEnded = {};                       // Touches that ended this frame

        // Engine reference for coordinate transformations
        this.engine = null;

        // DOM element to attach listeners to
        this.targetElement = document;

        // Flag to indicate if input is enabled
        this.enabled = true;

        // Bind event handlers to preserve 'this' context
        this._handleKeyDown = this._handleKeyDown.bind(this);
        this._handleKeyUp = this._handleKeyUp.bind(this);
        this._handleMouseMove = this._handleMouseMove.bind(this);
        this._handleMouseDown = this._handleMouseDown.bind(this);
        this._handleMouseUp = this._handleMouseUp.bind(this);
        this._handleWheel = this._handleWheel.bind(this);
        this._handleTouchStart = this._handleTouchStart.bind(this);
        this._handleTouchMove = this._handleTouchMove.bind(this);
        this._handleTouchEnd = this._handleTouchEnd.bind(this);

        // Initialize
        this.initialize();
    }

    /**
     * Initialize the input manager and attach event listeners
     */
    initialize() {
        // Keyboard events
        window.addEventListener('keydown', this._handleKeyDown);
        window.addEventListener('keyup', this._handleKeyUp);

        // Mouse events
        this.targetElement.addEventListener('mousemove', this._handleMouseMove);
        this.targetElement.addEventListener('mousedown', this._handleMouseDown);
        this.targetElement.addEventListener('mouseup', this._handleMouseUp);
        this.targetElement.addEventListener('wheel', this._handleWheel);
        this.targetElement.addEventListener('contextmenu', (e) => {
            if (this.preventContextMenu) e.preventDefault();
        });

        // Touch events
        this.targetElement.addEventListener('touchstart', this._handleTouchStart);
        this.targetElement.addEventListener('touchmove', this._handleTouchMove);
        this.targetElement.addEventListener('touchend', this._handleTouchEnd);
        this.targetElement.addEventListener('touchcancel', this._handleTouchEnd);

        /*window.addEventListener('mousedown', this._handleMouseDown);
        window.addEventListener('mouseup', this._handleMouseUp);
        window.addEventListener('mousemove', this._handleMouseMove);
        window.addEventListener('wheel', this._handleWheel);
        window.addEventListener('contextmenu', (e) => {
            if (this.preventContextMenu) e.preventDefault();
        });*/

        console.log('InputManager initialized');
    }

    /**
     * Set the engine reference for coordinate transformations
     * @param {Engine} engine - The game engine
     */
    setEngine(engine) {
        this.engine = engine;
    }

    /**
     * Update input states (called at the beginning of each frame)
     */
    beginFrame() {
        // Reset frame-specific states
        this.keysDown = {};
        this.keysUp = {};
        this.mouseButtonsDown = { left: false, middle: false, right: false };
        this.mouseButtonsUp = { left: false, middle: false, right: false };
        this.mouseWheel = 0;
        this.mouseMoveThisFrame = false;
        this.touchesStarted = {};
        this.touchesEnded = {};
    }

    /**
     * Update input states (called at the end of each frame)
     */
    endFrame() {
        // Update pressed keys (held down)
        this.keysPressed = Object.assign({}, this.keys);
        // Update pressed mouse buttons (held down)
        //this.mouseButtonsPressed = Object.assign({}, this.mouseButtons);
        // Clear ended touches
        //this.touchesEnded = {};
        //this.touchesStarted = {};

        // Update world mouse position if engine is available
        if (this.engine && this.engine.ctx) {
            this.updateWorldMousePosition();
        }
    }

    /**
     * Update mouse position from event, handling canvas-relative coordinates
     * @private
     */
    _updateMousePosition(e) {
        // Always store the raw client coordinates
        const rawX = e.clientX;
        const rawY = e.clientY;

        // Convert to canvas-relative coordinates
        if (this.engine && this.engine.canvas) {
            const rect = this.engine.canvas.getBoundingClientRect();

            // Calculate canvas-relative position
            let canvasX = rawX - rect.left;
            let canvasY = rawY - rect.top;

            // Scale coordinates if canvas is scaled
            const scaleX = this.engine.canvas.width / rect.width;
            const scaleY = this.engine.canvas.height / rect.height;
            canvasX *= scaleX;
            canvasY *= scaleY;

            this.mousePosition.x = canvasX;
            this.mousePosition.y = canvasY;
        } else {
            // Fallback to raw coordinates
            this.mousePosition.x = rawX;
            this.mousePosition.y = rawY;
        }

        // Update world coordinates immediately
        this.updateWorldMousePosition();
    }

    /**
     * Convert screen mouse position to world coordinates
     */
    updateWorldMousePosition() {
        if (!this.engine || !this.engine.ctx) return;

        // Use the engine's screen to world conversion
        if (this.engine.screenToWorld) {
            const worldPos = this.engine.screenToWorld(this.mousePosition.x, this.mousePosition.y);
            this.worldMousePosition.x = worldPos.x;
            this.worldMousePosition.y = worldPos.y;
        } else {
            // Manual calculation if screenToWorld is not available
            // This takes into account viewport position, zoom, rotation, and shake
            const viewport = this.engine.viewport;
            if (viewport) {
                const centerX = this.engine.canvas.width / 2;
                const centerY = this.engine.canvas.height / 2;

                let worldX = this.mousePosition.x;
                let worldY = this.mousePosition.y;

                // Reverse rotation if viewport is rotated
                if (viewport.angle !== 0) {
                    const cos = Math.cos(-viewport.angle * Math.PI / 180);
                    const sin = Math.sin(-viewport.angle * Math.PI / 180);
                    const relativeX = worldX - centerX;
                    const relativeY = worldY - centerY;

                    worldX = centerX + (relativeX * cos - relativeY * sin);
                    worldY = centerY + (relativeX * sin + relativeY * cos);
                }

                // Reverse zoom transformation
                worldX = (worldX - centerX) / viewport.zoom + centerX;
                worldY = (worldY - centerY) / viewport.zoom + centerY;

                // Apply viewport position offset and reverse shake
                worldX = worldX + viewport.x - (viewport.shake?.x || 0);
                worldY = worldY + viewport.y - (viewport.shake?.y || 0);

                this.worldMousePosition.x = worldX;
                this.worldMousePosition.y = worldY;
            } else {
                // Fallback: copy canvas coordinates as world coordinates
                this.worldMousePosition.x = this.mousePosition.x;
                this.worldMousePosition.y = this.mousePosition.y;
            }
        }
    }

    // ----------------------
    // Keyboard Input Methods
    // ----------------------

    /**
     * Check if a key is currently down
     * @param {string} keyCode - The key code or name
     * @returns {boolean} True if the key is down
     */
    keyDown(keyCode) {
        return this.keys[keyCode.toLowerCase()] === true;
    }

    /**
     * Check if a key was pressed this frame
     * @param {string} keyCode - The key code or name
     * @returns {boolean} True if the key was pressed this frame
     */
    keyPressed(keyCode) {
        return this.keysDown[keyCode.toLowerCase()] === true;
    }

    /**
     * Check if a key was released this frame
     * @param {string} keyCode - The key code or name
     * @returns {boolean} True if the key was released this frame
     */
    keyReleased(keyCode) {
        return this.keysUp[keyCode.toLowerCase()] === true;
    }

    /**
     * Handle key down events
     * @private
     */
    _handleKeyDown(e) {
        if (!this.enabled) return;

        const key = e.key.toLowerCase();

        // Skip if already down (handles key repeat)
        if (!this.keys[key]) {
            this.keys[key] = true;
            this.keysDown[key] = true;
        }
    }

    /**
     * Handle key up events
     * @private
     */
    _handleKeyUp(e) {
        if (!this.enabled) return;

        const key = e.key.toLowerCase();
        this.keys[key] = false;
        this.keysUp[key] = true;
    }

    // -------------------
    // Mouse Input Methods
    // -------------------

    /**
     * Check if a mouse button is currently down
     * @param {string|number} button - Button to check ('left', 'middle', 'right' or button code)
     * @returns {boolean} True if the button is down
     */
    mouseDown(button) {
        if (typeof button === 'string') {
            return this.mouseButtons[button] === true;
        }

        switch (button) {
            case 0: return this.mouseButtons.left;
            case 1: return this.mouseButtons.middle;
            case 2: return this.mouseButtons.right;
            default: return false;
        }
    }

    /**
     * Check if a mouse button was pressed this frame
     * @param {string|number} button - Button to check ('left', 'middle', 'right' or button code)
     * @returns {boolean} True if the button was pressed this frame
     */
    mousePressed(button) {
        if (typeof button === 'string') {
            return this.mouseButtonsDown[button] === true;
        }

        switch (button) {
            case 0: return this.mouseButtonsDown.left;
            case 1: return this.mouseButtonsDown.middle;
            case 2: return this.mouseButtonsDown.right;
            default: return false;
        }
    }

    /**
     * Check if a mouse button was released this frame
     * @param {string|number} button - Button to check ('left', 'middle', 'right' or button code)
     * @returns {boolean} True if the button was released this frame
     */
    mouseReleased(button) {
        if (typeof button === 'string') {
            return this.mouseButtonsUp[button] === true;
        }

        switch (button) {
            case 0: return this.mouseButtonsUp.left;
            case 1: return this.mouseButtonsUp.middle;
            case 2: return this.mouseButtonsUp.right;
            default: return false;
        }
    }

    /**
     * Get the current mouse position
     * @param {boolean} worldSpace - If true, returns position in world coordinates
     * @returns {Vector2} The mouse position
     */
    getMousePosition(worldSpace = false) {
        return worldSpace ? this.worldMousePosition.clone() : this.mousePosition.clone();
    }

    /**
     * Check if the mouse moved this frame
     * @returns {boolean} True if the mouse moved this frame
     */
    didMouseMove() {
        return this.mouseMoveThisFrame;
    }

    /**
     * Get the mouse wheel delta
     * @returns {number} The mouse wheel delta
     */
    getMouseWheelDelta() {
        return this.mouseWheel;
    }

    /**
     * Handle mouse move events
     * @private
     */
    _handleMouseMove(e) {
        if (!this.enabled) return;

        this._updateMousePosition(e);
        this.mouseMoveThisFrame = true;
    }

    /**
     * Handle mouse down events
     * @private
     */
    _handleMouseDown(e) {
        if (!this.enabled) return;

        // Update mouse position first
        this._updateMousePosition(e);

        console.log('Mouse Down:', e.button, 'at screen:', e.clientX, e.clientY, 'canvas:', this.mousePosition.x, this.mousePosition.y, 'world:', this.worldMousePosition.x, this.worldMousePosition.y);

        switch (e.button) {
            case 0: // Left
                this.mouseButtons.left = true;
                this.mouseButtonsDown.left = true;
                break;
            case 1: // Middle
                this.mouseButtons.middle = true;
                this.mouseButtonsDown.middle = true;
                break;
            case 2: // Right
                this.mouseButtons.right = true;
                this.mouseButtonsDown.right = true;
                break;
        }
    }

    /**
     * Handle mouse up events
     * @private
     */
    _handleMouseUp(e) {
        if (!this.enabled) return;

        switch (e.button) {
            case 0: // Left
                this.mouseButtons.left = false;
                this.mouseButtonsUp.left = true;
                break;
            case 1: // Middle
                this.mouseButtons.middle = false;
                this.mouseButtonsUp.middle = true;
                break;
            case 2: // Right
                this.mouseButtons.right = false;
                this.mouseButtonsUp.right = true;
                break;
        }
    }

    /**
     * Handle mouse wheel events
     * @private
     */
    _handleWheel(e) {
        if (!this.enabled) return;

        this.mouseWheel = Math.sign(e.deltaY); // 1 for scroll down, -1 for scroll up
    }

    // -------------------
    // Touch Input Methods
    // -------------------

    /**
     * Handle touch start events
     * @private
     */
    _handleTouchStart(e) {
        if (!this.enabled) return;

        // Prevent default to avoid scrolling and other touch behaviors
        e.preventDefault();

        for (let i = 0; i < e.changedTouches.length; i++) {
            const touch = e.changedTouches[i];
            const id = touch.identifier;

            // Get canvas-relative coordinates
            let x = touch.clientX;
            let y = touch.clientY;

            // Convert to canvas coordinates
            if (this.engine && this.engine.canvas) {
                const rect = this.engine.canvas.getBoundingClientRect();
                x = touch.clientX - rect.left;
                y = touch.clientY - rect.top;

                // Scale coordinates if canvas is scaled
                const scaleX = this.engine.canvas.width / rect.width;
                const scaleY = this.engine.canvas.height / rect.height;
                x *= scaleX;
                y *= scaleY;
            } else {
                // Fallback: try to find game canvas
                const gameCanvas = document.getElementById('gameCanvas');
                const editorCanvas = document.getElementById('editorCanvas');
                const canvas = gameCanvas || editorCanvas;

                if (canvas) {
                    const rect = canvas.getBoundingClientRect();
                    x = touch.clientX - rect.left;
                    y = touch.clientY - rect.top;

                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    x *= scaleX;
                    y *= scaleY;
                }
            }

            this.touches[id] = {
                id,
                position: new Vector2(x, y),
                startPosition: new Vector2(x, y),
                startTime: Date.now(),
                moved: false,
                totalDistance: 0
            };

            this.touchesStarted[id] = this.touches[id];

            // For single touch, simulate mouse events
            if (Object.keys(this.touches).length === 1) {
                this.mousePosition.x = touch.clientX;
                this.mousePosition.y = touch.clientY;
                this.mouseMoveThisFrame = true;
                this.mouseButtons.left = true;
                this.mouseButtonsDown.left = true;
            }
        }
    }

    /**
     * Handle touch move events
     * @private
     */
    _handleTouchMove(e) {
        if (!this.enabled) return;

        // Prevent default to avoid scrolling
        e.preventDefault();

        for (let i = 0; i < e.changedTouches.length; i++) {
            const touch = e.changedTouches[i];
            const id = touch.identifier;

            if (this.touches[id]) {
                // Get canvas-relative coordinates
                let x = touch.clientX;
                let y = touch.clientY;

                // Convert to canvas coordinates
                if (this.engine && this.engine.canvas) {
                    const rect = this.engine.canvas.getBoundingClientRect();
                    x = touch.clientX - rect.left;
                    y = touch.clientY - rect.top;

                    // Scale coordinates if canvas is scaled
                    const scaleX = this.engine.canvas.width / rect.width;
                    const scaleY = this.engine.canvas.height / rect.height;
                    x *= scaleX;
                    y *= scaleY;
                } else {
                    // Fallback: try to find game canvas
                    const gameCanvas = document.getElementById('gameCanvas');
                    const editorCanvas = document.getElementById('editorCanvas');
                    const canvas = gameCanvas || editorCanvas;

                    if (canvas) {
                        const rect = canvas.getBoundingClientRect();
                        x = touch.clientX - rect.left;
                        y = touch.clientY - rect.top;

                        const scaleX = canvas.width / rect.width;
                        const scaleY = canvas.height / rect.height;
                        x *= scaleX;
                        y *= scaleY;
                    }
                }

                // Calculate movement distance
                const deltaX = x - this.touches[id].position.x;
                const deltaY = y - this.touches[id].position.y;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                // Update touch data
                this.touches[id].position.x = x;
                this.touches[id].position.y = y;
                this.touches[id].moved = true;
                this.touches[id].totalDistance += distance;

                // For single touch, simulate mouse events
                if (Object.keys(this.touches).length === 1) {
                    this.mousePosition.x = touch.clientX;
                    this.mousePosition.y = touch.clientY;
                    this.mouseMoveThisFrame = true;
                }
            }
        }
    }

    /**
     * Handle touch end events
     * @private
     */
    _handleTouchEnd(e) {
        if (!this.enabled) return;

        // Prevent default to avoid ghost clicks
        e.preventDefault();

        for (let i = 0; i < e.changedTouches.length; i++) {
            const touch = e.changedTouches[i];
            const id = touch.identifier;

            if (this.touches[id]) {
                // Calculate final position
                let x = touch.clientX;
                let y = touch.clientY;

                // Convert to canvas coordinates
                if (this.engine && this.engine.canvas) {
                    const rect = this.engine.canvas.getBoundingClientRect();
                    x = touch.clientX - rect.left;
                    y = touch.clientY - rect.top;

                    // Scale coordinates if canvas is scaled
                    const scaleX = this.engine.canvas.width / rect.width;
                    const scaleY = this.engine.canvas.height / rect.height;
                    x *= scaleX;
                    y *= scaleY;
                } else {
                    // Fallback: try to find game canvas
                    const gameCanvas = document.getElementById('gameCanvas');
                    const editorCanvas = document.getElementById('editorCanvas');
                    const canvas = gameCanvas || editorCanvas;

                    if (canvas) {
                        const rect = canvas.getBoundingClientRect();
                        x = touch.clientX - rect.left;
                        y = touch.clientY - rect.top;

                        const scaleX = canvas.width / rect.width;
                        const scaleY = canvas.height / rect.height;
                        x *= scaleX;
                        y *= scaleY;
                    }
                }

                // Update final position
                this.touches[id].position.x = x;
                this.touches[id].position.y = y;

                // Store ended touch
                this.touchesEnded[id] = Object.assign({}, this.touches[id]);
                delete this.touches[id];

                // Update mouse buttons for single touch
                if (Object.keys(this.touches).length === 0) {
                    this.mouseButtons.left = false;
                    this.mouseButtonsUp.left = true;
                }
            }
        }
    }

    /**
     * Get active touch points
     * @returns {Object} Map of active touches
     */
    getTouches() {
        return this.touches;
    }

    /**
     * Get the count of active touches
     * @returns {number} Number of active touches
     */
    getTouchCount() {
        return Object.keys(this.touches).length;
    }

    /**
     * Check if a tap occurred this frame
     * @returns {boolean} True if a tap occurred
     */
    isTapped() {
        for (const id in this.touchesEnded) {
            const touch = this.touchesEnded[id];
            const duration = touch.startTime ? Date.now() - touch.startTime : 0;

            // Check if it's a short tap (less than 300ms)
            if (duration < 300) {
                // Check if finger didn't move too much
                const distance = touch.position.distanceTo(touch.startPosition);
                if (distance < 20) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Check if a long press occurred this frame
     * @returns {boolean} True if a long press occurred
     */
    isLongPressed() {
        for (const id in this.touchesEnded) {
            const touch = this.touchesEnded[id];
            const duration = touch.startTime ? Date.now() - touch.startTime : 0;

            // Check if it's a long press (more than 500ms) with minimal movement
            if (duration > 500) {
                const distance = touch.position.distanceTo(touch.startPosition);
                if (distance < 30) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * Get pinch zoom data for two-finger gestures
     * @returns {Object|null} Pinch data or null if not pinching
     */
    getPinchData() {
        const touchIds = Object.keys(this.touches);
        if (touchIds.length !== 2) return null;

        const touch1 = this.touches[touchIds[0]];
        const touch2 = this.touches[touchIds[1]];

        const currentDistance = touch1.position.distanceTo(touch2.position);
        const startDistance = touch1.startPosition.distanceTo(touch2.startPosition);

        const centerX = (touch1.position.x + touch2.position.x) / 2;
        const centerY = (touch1.position.y + touch2.position.y) / 2;

        return {
            scale: currentDistance / startDistance,
            center: new Vector2(centerX, centerY),
            distance: currentDistance,
            startDistance: startDistance
        };
    }

    /**
     * Check if currently pinching (two fingers)
     * @returns {boolean} True if pinching
     */
    isPinching() {
        return Object.keys(this.touches).length === 2;
    }

    /**
     * Get swipe direction if a swipe occurred this frame
     * @returns {string|null} Direction ('up', 'down', 'left', 'right') or null
     */
    getSwipeDirection() {
        for (const id in this.touchesEnded) {
            const touch = this.touchesEnded[id];
            const duration = touch.startTime ? Date.now() - touch.startTime : 0;

            // Check if it's a quick swipe (less than 300ms) with significant movement
            if (duration < 300 && touch.totalDistance > 50) {
                const deltaX = touch.position.x - touch.startPosition.x;
                const deltaY = touch.position.y - touch.startPosition.y;

                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    return deltaX > 0 ? 'right' : 'left';
                } else {
                    return deltaY > 0 ? 'down' : 'up';
                }
            }
        }
        return null;
    }

    /**
     * Clean up and remove all event listeners
     */
    destroy() {
        window.removeEventListener('keydown', this._handleKeyDown);
        window.removeEventListener('keyup', this._handleKeyUp);

        this.targetElement.removeEventListener('mousemove', this._handleMouseMove);
        this.targetElement.removeEventListener('mousedown', this._handleMouseDown);
        this.targetElement.removeEventListener('mouseup', this._handleMouseUp);
        this.targetElement.removeEventListener('wheel', this._handleWheel);

        this.targetElement.removeEventListener('touchstart', this._handleTouchStart);
        this.targetElement.removeEventListener('touchmove', this._handleTouchMove);
        this.targetElement.removeEventListener('touchend', this._handleTouchEnd);
        this.targetElement.removeEventListener('touchcancel', this._handleTouchEnd);
    }

    /**
     * Enable input processing
     */
    enable() {
        this.enabled = true;
    }

    /**
     * Disable input processing
     */
    disable() {
        this.enabled = false;

        // Clear all input states
        this.keys = {};
        this.keysDown = {};
        this.keysUp = {};
        this.keysPressed = {};

        this.mouseButtons = { left: false, middle: false, right: false };
        this.mouseButtonsDown = { left: false, middle: false, right: false };
        this.mouseButtonsUp = { left: false, middle: false, right: false };

        this.touches = {};
        this.touchesStarted = {};
        this.touchesEnded = {};
    }

    // Prevent context menu from showing on right click
    preventContextMenu() {
        this.preventContextMenu = true;
    }

    // Allow context menu to show on right click
    allowContextMenu() {
        this.preventContextMenu = false;
    }

    /**
 * Enable debug logging for input events
 */
    enableDebugMode() {
        this.debugMode = true;

        // Add console logs to event handlers
        const originalHandleMouseDown = this._handleMouseDown;
        const originalHandleMouseUp = this._handleMouseUp;
        const originalHandleMouseMove = this._handleMouseMove;

        this._handleMouseDown = (e) => {
            if (this.debugMode) console.log('Mouse down:', e.button, 'at', e.clientX, e.clientY);
            originalHandleMouseDown.call(this, e);
        };

        this._handleMouseUp = (e) => {
            if (this.debugMode) console.log('Mouse up:', e.button, 'at', e.clientX, e.clientY);
            originalHandleMouseUp.call(this, e);
        };

        this._handleMouseMove = (e) => {
            if (this.debugMode && this.frameCount % 60 === 0) { // Log every 60th frame to avoid spam
                console.log('Mouse move:', e.clientX, e.clientY);
            }
            originalHandleMouseMove.call(this, e);
        };

        this.frameCount = 0;
    }

    /**
     * Test if event listeners are properly attached
     */
    testEventListeners() {
        console.log('Testing event listeners...');
        console.log('Target element:', this.targetElement);
        console.log('Canvas element:', this.engine?.canvas);

        // Test with a temporary click handler
        const testHandler = (e) => {
            console.log('TEST: Click detected on', e.target.tagName, 'at', e.clientX, e.clientY);
            document.removeEventListener('click', testHandler);
        };

        document.addEventListener('click', testHandler);
        console.log('Click anywhere to test event detection...');
    }

    /**
     * Switch to canvas-based event listeners
     */
    useCanvasTarget() {
        if (!this.engine || !this.engine.canvas) {
            console.warn('Cannot switch to canvas target: engine or canvas not available');
            return;
        }

        // Remove existing listeners
        this.targetElement.removeEventListener('mousemove', this._handleMouseMove);
        this.targetElement.removeEventListener('mousedown', this._handleMouseDown);
        this.targetElement.removeEventListener('mouseup', this._handleMouseUp);
        this.targetElement.removeEventListener('wheel', this._handleWheel);

        // Switch target to canvas
        this.targetElement = this.engine.canvas;

        // Make canvas focusable
        this.targetElement.tabIndex = 0;

        // Re-attach listeners to canvas
        this.targetElement.addEventListener('mousemove', this._handleMouseMove);
        this.targetElement.addEventListener('mousedown', this._handleMouseDown);
        this.targetElement.addEventListener('mouseup', this._handleMouseUp);
        this.targetElement.addEventListener('wheel', this._handleWheel);

        console.log('Switched to canvas-based event listeners');
    }

    /**
     * Get current input state for debugging
     */
    getDebugState() {
        return {
            mousePosition: this.mousePosition,
            worldMousePosition: this.worldMousePosition,
            mouseButtons: this.mouseButtons,
            mouseButtonsDown: this.mouseButtonsDown,
            mouseButtonsUp: this.mouseButtonsUp,
            enabled: this.enabled,
            targetElement: this.targetElement.tagName || 'document',
            touchCount: this.getTouchCount()
        };
    }

    // Add constants for key codes and mouse buttons like 'key.a', 'key.alt', 'key.space', 'mouse.left', etc.
    /**
     * Constants for key codes and mouse buttons for easier use
     */
    static get key() {
        return {
            // Letters
            a: 'a', b: 'b', c: 'c', d: 'd', e: 'e', f: 'f', g: 'g', h: 'h',
            i: 'i', j: 'j', k: 'k', l: 'l', m: 'm', n: 'n', o: 'o', p: 'p',
            q: 'q', r: 'r', s: 's', t: 't', u: 'u', v: 'v', w: 'w', x: 'x',
            y: 'y', z: 'z',

            // Numbers
            0: '0', 1: '1', 2: '2', 3: '3', 4: '4',
            5: '5', 6: '6', 7: '7', 8: '8', 9: '9',

            // Special keys
            backspace: 'backspace',
            tab: 'tab',
            enter: 'enter',
            shift: 'shift',
            control: 'control',
            ctrl: 'control',
            alt: 'alt',
            pause: 'pause',
            capslock: 'capslock',
            escape: 'escape',
            esc: 'escape',
            space: ' ',
            pageup: 'pageup',
            pagedown: 'pagedown',
            end: 'end',
            home: 'home',

            // Arrow keys
            left: 'arrowleft',
            up: 'arrowup',
            right: 'arrowright',
            down: 'arrowdown',
            arrowleft: 'arrowleft',
            arrowup: 'arrowup',
            arrowright: 'arrowright',
            arrowdown: 'arrowdown',

            // Special characters
            insert: 'insert',
            delete: 'delete',

            // Function keys
            f1: 'f1', f2: 'f2', f3: 'f3', f4: 'f4', f5: 'f5',
            f6: 'f6', f7: 'f7', f8: 'f8', f9: 'f9', f10: 'f10',
            f11: 'f11', f12: 'f12',

            // Number pad
            numlock: 'numlock',
            numpad0: '0', numpad1: '1', numpad2: '2', numpad3: '3', numpad4: '4',
            numpad5: '5', numpad6: '6', numpad7: '7', numpad8: '8', numpad9: '9',

            // Operators
            multiply: '*',
            add: '+',
            subtract: '-',
            decimal: '.',
            divide: '/',

            // Others
            semicolon: ';',
            equal: '=',
            comma: ',',
            dash: '-',
            period: '.',
            slash: '/',
            graveaccent: '`',
            openbracket: '[',
            backslash: '\\',
            closebracket: ']',
            quote: "'",

            // Meta keys
            meta: 'meta',
            cmd: 'meta',
            win: 'meta'
        };
    }

    /**
     * Constants for mouse buttons for easier use
     */
    static get mouse() {
        return {
            left: 'left',
            middle: 'middle',
            right: 'right',
            button1: 0,   // Left button
            button2: 2,   // Right button
            button3: 1,   // Middle button
            button4: 3,   // Browser back button
            button5: 4    // Browser forward button
        };
    }

    /**
     * Constants for gamepad buttons
     */
    static get gamepad() {
        return {
            a: 0,
            b: 1,
            x: 2,
            y: 3,
            leftbumper: 4,
            rightbumper: 5,
            lefttrigger: 6,
            righttrigger: 7,
            select: 8,
            start: 9,
            leftstick: 10,
            rightstick: 11,
            dpadup: 12,
            dpaddown: 13,
            dpadleft: 14,
            dpadright: 15,
            home: 16
        };
    }
}

// Create a global instance
window.input = new InputManager();
window.key = InputManager.key;
window.mouse = InputManager.mouse;
window.gamepad = InputManager.gamepad;

// src/core/DecalChunk.js
class DecalChunk {
    constructor(x, y, size = 256) {
        this.x = x; // World X position of chunk
        this.y = y; // World Y position of chunk
        this.size = size; // Chunk size in world units
        this.decals = []; // Array of decal objects: {x, y, image, options, lifetime, startTime}
        this.dirty = false; // Flag to redraw the chunk
    }

    addDecal(worldX, worldY, imageOrDrawFunction, options = {}) {
        const localX = worldX - this.x;
        const localY = worldY - this.y;

        // Ensure options has valid defaults to prevent undefined values
        const defaultOptions = {
            rotation: 0,
            scale: 1,
            alpha: 1,  // Default to full opacity if not provided
            width: 64,
            height: 64,
            lifetime: 0
        };
        const finalOptions = { ...defaultOptions, ...options };
        // Clamp alpha to 0-1 to ensure validity
        finalOptions.alpha = Math.max(0, Math.min(1, finalOptions.alpha));

        if (typeof imageOrDrawFunction === 'function') {
            // Store the draw function directly for dynamic rendering
            const decal = { x: localX, y: localY, drawFunction: imageOrDrawFunction, options: finalOptions, lifetime: finalOptions.lifetime, startTime: Date.now() };
            this.decals.push(decal);
            this.dirty = true;
        } else {
            // Assume it's an Image object (unchanged)
            const decal = { x: localX, y: localY, image: imageOrDrawFunction, options: finalOptions, lifetime: finalOptions.lifetime, startTime: Date.now() };
            this.decals.push(decal);
            this.dirty = true;
        }
    }

    async generateImageFromDrawFunction(drawFunction, options) {
        const canvas = document.createElement('canvas');
        canvas.width = options.width || 64; // Default size, can be overridden in options
        canvas.height = options.height || 64;
        const ctx = canvas.getContext('2d');

        // Call the user's drawing function
        drawFunction(ctx);

        // Convert to image
        const image = new Image();
        image.src = canvas.toDataURL();
        return new Promise((resolve) => {
            image.onload = () => resolve(image);
        });
    }

    clear() {
        this.decals = [];
        this.dirty = true;
    }

    update(deltaTime) {
        // Update decals for fading (unchanged, but now works better with dynamic drawing)
        this.decals = this.decals.filter(decal => {
            if (decal.lifetime > 0) {
                const elapsed = (Date.now() - decal.startTime) / 1000; // Seconds
                if (elapsed >= decal.lifetime) {
                    return false; // Remove expired decal
                }
                // Fade out opacity, ensuring alpha stays clamped and valid
                decal.options.alpha = Math.max(0, Math.min(1, decal.options.alpha - (deltaTime / decal.lifetime)));
            }
            return true;
        });
        if (this.decals.length === 0) this.dirty = false;
    }

    draw(ctx, viewport, debug = false) {
        if (!this.dirty && this.decals.length === 0 && !debug) return;  // Allow drawing empty chunks if debug is enabled
        // Draw decals relative to chunk origin
        this.decals.forEach(decal => {
            ctx.save();
            ctx.translate(decal.x, decal.y);
            // Apply any decal-specific options (e.g., rotation, scale)
            if (decal.options.rotation) ctx.rotate(decal.options.rotation);
            if (decal.options.scale) ctx.scale(decal.options.scale, decal.options.scale);
            ctx.globalAlpha = decal.options.alpha;  // Apply current alpha for fading

            if (decal.image && decal.image.complete) {
                // For image-based decals (unchanged)
                ctx.drawImage(decal.image, 0, 0);
            } else if (decal.drawFunction) {
                // For custom draw functions: Call dynamically with current alpha
                decal.drawFunction(ctx);
            }

            ctx.restore();
        });

        // Debug: Draw a rectangle around the chunk's edge if debug is enabled
        if (debug) {
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)'; // Semi-transparent red
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, this.size, this.size); // Rectangle from (0,0) to (size,size)
            ctx.restore();
        }

        this.dirty = false;
    }

    isVisible(viewport) {
        // Check if chunk intersects with viewport bounds
        const chunkLeft = this.x;
        const chunkRight = this.x + this.size;
        const chunkTop = this.y;
        const chunkBottom = this.y + this.size;
        const viewLeft = (viewport.x) / viewport.zoom;
        const viewRight = (viewport.x + viewport.width) / viewport.zoom;
        const viewTop = (viewport.y) / viewport.zoom;
        const viewBottom = (viewport.y + viewport.height) / viewport.zoom;
        return !(chunkRight < viewLeft || chunkLeft > viewRight || chunkBottom < viewTop || chunkTop > viewBottom);
    }
}

// src/core/Scene.js
class Scene {
    constructor(name = "New Scene") {
        this.name = name;
        this.path = null; // Store file path when saved
        this.gameObjects = [];
        this.settings = {
            viewportWidth: 1280,
            viewportHeight: 720,
            viewportX: 0,  
            viewportY: 0,
            backgroundColor: "#1e1e1e",
            gridEnabled: true,
            gridSize: 32,
            snapToGrid: false
        };
        this.dirty = false; // Track unsaved changes
    }

    markDirty() {
        this.dirty = true;
    }

    toJSON() {
        return {
            name: this.name,
            settings: {
                viewportWidth: this.settings.viewportWidth,
                viewportHeight: this.settings.viewportHeight,
                viewportX: this.settings.viewportX || 0,
                viewportY: this.settings.viewportY || 0,
                backgroundColor: this.settings.backgroundColor,
                gridEnabled: this.settings.gridEnabled,
                gridSize: this.settings.gridSize,
                snapToGrid: this.settings.snapToGrid,
                gravity: { x: 0, y: 1 },       // Physics gravity direction
                physicsEnabled: true,          // Whether physics is enabled
                physicsDebugDraw: false   
            },
            gameObjects: this.gameObjects.filter(obj => !obj.parent).map(obj => obj.toJSON())
        };
    }

    static fromJSON(json) {
        const scene = new Scene(json.name);
        scene.settings = json.settings || {};
        
        // Restore other scene properties
        scene.activeCamera = json.activeCamera;
        
        // Create gameObjects if we have GameObject reference
        if (typeof GameObject !== 'undefined' || window.GameObject) {
            // Use the appropriate GameObject reference
            const GameObjectRef = typeof GameObject !== 'undefined' ? GameObject : window.GameObject;
            
            // Create gameObjects
            scene.gameObjects = json.gameObjects.map(objJson => {
                return GameObjectRef.fromJSON(objJson);
            });
        } else {
            // If GameObject isn't available, store the JSON for later
            scene.gameObjectsJSON = json.gameObjects;
            scene.gameObjects = [];
            console.warn("GameObject class not available. Game objects will be loaded when GameObject class is available.");
        }
        
        return scene;
    }

    completeLoading() {
        if (this.gameObjectsJSON && (typeof GameObject !== 'undefined' || window.GameObject)) {
            const GameObjectRef = typeof GameObject !== 'undefined' ? GameObject : window.GameObject;
            this.gameObjects = this.gameObjectsJSON.map(objJson => {
                return GameObjectRef.fromJSON(objJson);
            });
            delete this.gameObjectsJSON;
            return true;
        }
        return false;
    }

    // Add engine integration methods
    attachToEngine(engine) {
        engine.scene = this;
        engine.gameObjects = this.gameObjects;
    }

    /**
     * Find a GameObject by name in the scene
     * @param {string} name - The name of the GameObject to find
     * @returns {GameObject|null} The found GameObject or null if not found
     */
    findGameObjectByName(name) {
        return this.findGameObjectByNameRecursive(this.gameObjects, name);
    }

    /**
     * Recursively search for a GameObject by name
     * @param {Array} objects - Array of GameObjects to search
     * @param {string} name - The name to search for
     * @returns {GameObject|null} The found GameObject or null if not found
     */
    findGameObjectByNameRecursive(objects, name) {
        for (const obj of objects) {
            if (obj.name === name) {
                return obj;
            }
            
            // Search in children if they exist
            if (obj.children && obj.children.length > 0) {
                const found = this.findGameObjectByNameRecursive(obj.children, name);
                if (found) {
                    return found;
                }
            }
        }
        return null;
    }

    /**
     * Alias for findGameObjectByName for consistency with documentation
     * @param {string} name - The name of the GameObject to find
     * @returns {GameObject|null} The found GameObject or null if not found
     */
    findGameObject(name) {
        return this.findGameObjectByName(name);
    }
}

// src/core/Engine.js
class Engine {
    constructor(canvas, options = {}) {
        this.canvas = canvas;
        this.useWebGL = options.useWebGL || true; // New option to enable WebGLCanvas

        this.guiCanvas = document.createElement('canvas');
        this.guiCanvas.width = 800;
        this.guiCanvas.height = 600;
        this.guiCanvas.style.position = 'absolute';
        this.guiCanvas.style.left = '0px';
        this.guiCanvas.style.top = '0px';
        this.guiCanvas.style.pointerEvents = 'none';

        this.backgroundCanvas = document.createElement('canvas');
        this.backgroundCanvas.width = 800;
        this.backgroundCanvas.height = 600;
        this.backgroundCanvas.style.position = 'absolute';
        this.backgroundCanvas.style.left = '0px';
        this.backgroundCanvas.style.top = '0px';
        this.backgroundCanvas.style.pointerEvents = 'none';

        //this.ctx = canvas.getContext('2d');
        this.scene = null;
        this.gameObjects = [];
        this.lastTime = 0;
        this.running = false;
        this.preloaded = false;

        this.decalCanvas = document.createElement('canvas');
        this.decalCanvas.width = 800;
        this.decalCanvas.height = 600;
        this.decalCanvas.style.position = 'absolute';
        this.decalCanvas.style.left = '0px';
        this.decalCanvas.style.top = '0px';
        this.decalCanvas.style.pointerEvents = 'none';

        this.decalCtx = this.decalCanvas.getContext('2d');
        this.decalChunks = new Map(); // Map of chunks by key (e.g., "x_y")

        this.debugDecals = false;

        // Decal chunk settings
        this.chunkSize = 512; // World units per chunk (configurable)
        this.preloadChunkRadius = 1; // Number of chunks to preload in each direction around viewport

        this.usePixi = false; // Set to true to enable Pixi.js
        this.pixiRenderer = null;

        if (this.useWebGL && window.WebGLCanvas) {
            try {
                // Use WebGLCanvas for GPU-accelerated rendering
                this.ctx = new WebGLCanvas(this.canvas, {
                    enableFullscreen: false,
                    pixelWidth: this.canvas.width,
                    pixelHeight: this.canvas.height,
                    pixelScale: 1,
                    batchSize: 8000
                });

                // Check if WebGLCanvas actually initialized properly
                if (this.ctx) {
                    console.log("WebGLCanvas initialized successfully");
                    console.log("WebGLCanvas methods:", Object.getOwnPropertyNames(this.ctx));
                } else if (this.ctx && typeof this.ctx.init === 'function') {
                    // Some WebGL contexts need explicit initialization
                    //await this.ctx.init();
                    console.log("WebGLCanvas initialized after init() call");
                } else {
                    console.warn("WebGLCanvas created but may not be ready");
                    // Fallback to 2D context
                    this.useWebGL = false;
                    this.ctx = this.canvas.getContext('2d');
                    console.log("Falling back to Canvas 2D context");
                }
            } catch (error) {
                console.error("Failed to initialize WebGLCanvas:", error);
                this.useWebGL = false;
                this.ctx = this.canvas.getContext('2d');
                console.log("Falling back to Canvas 2D context due to error");
            }
        } else {
            // Fallback to standard 2D context
            this.ctx = this.canvas.getContext('2d');
            console.log("Using standard Canvas 2D context");
        }

        // Track viewport settings
        this.viewport = {
            width: 800,
            height: 600,
            x: 0,
            y: 0,
            zoom: 1,
            angle: 0,
            // Add bounds checking
            minZoom: 0.1,
            maxZoom: 10,
            // Track if viewport is dirty and needs updates
            dirty: true,
            // Add viewport shake for effects
            shake: { x: 0, y: 0, intensity: 0, duration: 0 }
        };

        this.viewportOriginalPosition = {
            width: 800,
            height: 600,
            x: 0,
            y: 0,
            zoom: 1,
            angle: 0 // Camera angle in degrees
        };

        this.renderConfig = {
            scaleMode: 'fit', // 'fit', 'stretch', 'pixel-perfect', 'nearest-neighbor'
            fullscreen: false,
            maintainAspectRatio: true,
            pixelPerfect: false,
            smoothing: true,
            // Add DPI awareness
            pixelRatio: window.devicePixelRatio || 1
        };

        // Add reference to the editor
        this.editor = null;

        // Track if canvas was resized
        this.canvasResized = true;

        // Add viewport change callbacks
        this.viewportCallbacks = [];

        // Set the input manager reference to this engine
        if (window.input) {
            window.input.setEngine(this);
            window.input.useCanvasTarget();
        }

        if (!window.viewport) {
            window.viewport = this.viewport;
        }

        //if(!window.prefabManager) {
        //    window.prefabManager = new PrefabManager();
        //}

        window.engine = this; // Global reference for easy access

        // Initialize MelodiCode if available
        if (window.MelodiCode) {
            this.melodicode = new window.MelodiCode();
        }

        // Set up resize observer to continuously monitor container size
        this.setupResizeObserver();

        // Also listen for window resize events
        window.addEventListener('resize', () => {
            this.resizeCanvas();
        });

        // Listen for panel resize events
        window.addEventListener('panel-resized', () => {
            this.resizeCanvas();
        });

        // Initialize viewport properly
        this.initializeViewport();

        // Initialize prefab manager if not already available
        if (!window.prefabManager) {
            // Create a simple prefab manager for runtime
            window.prefabManager = {
                prefabs: new Map(),

                loadPrefabs: function (prefabsData) {
                    if (!prefabsData) return;

                    for (const [name, prefabData] of Object.entries(prefabsData)) {
                        this.prefabs.set(name, prefabData);
                        console.log('Loaded prefab:', name);
                    }

                    console.log('Total prefabs loaded:', this.prefabs.size);
                },

                findPrefabByName: function (name) {
                    if (!name) return null;

                    if (this.prefabs.has(name)) {
                        return this.prefabs.get(name);
                    }

                    const lowerName = name.toLowerCase();
                    for (const [key, value] of this.prefabs) {
                        if (key.toLowerCase() === lowerName) {
                            return value;
                        }
                    }

                    return null;
                },

                hasPrefab: function (name) {
                    return this.findPrefabByName(name) !== null;
                },

                getAllPrefabNames: function () {
                    return Array.from(this.prefabs.keys());
                },

                instantiatePrefabByName: function (name, position = null, parent = null) {
                    const prefabData = this.findPrefabByName(name);
                    if (!prefabData) {
                        console.error('Prefab not found:', name);
                        return null;
                    }

                    return this.instantiatePrefab(prefabData, position, parent);
                },

                instantiatePrefab: function (prefabData, position = null, parent = null) {
                    try {
                        const gameObject = GameObject.fromJSON(prefabData);

                        if (position) {
                            gameObject.position.x = position.x;
                            gameObject.position.y = position.y;
                        }

                        if (parent) {
                            parent.addChild(gameObject);
                        } else if (window.engine && window.engine.gameObjects) {
                            window.engine.gameObjects.push(gameObject);
                        }

                        return gameObject;
                    } catch (error) {
                        console.error('Error instantiating prefab:', error);
                        return null;
                    }
                }
            };
        }

        // Store reference in engine for easy access
        this.prefabManager = window.prefabManager;

        // Track dynamically created objects for cleanup
        this.dynamicObjects = new Set();
        this.originalGameObjects = [];

        this.maxFPS = 120; // Default, will be updated from settings
        this._minFrameInterval = 1000 / this.maxFPS;
        this._lastFrameTime = 0;
        this.fps = 0;

        this.enableVSync = true;

        this.frameCount = 0; // Tracks frames since last FPS update
        this.lastFpsUpdate = 0; // Timestamp of last FPS calculation

        this.prefabs = {}; // Store loaded prefabs by name or ID

        canvas.tabIndex = 0; // Makes canvas focusable
        canvas.focus(); // Give it focus
    }

    initializePixiRenderer() {
        if (this.usePixi && window.PixiRenderer) {
            this.pixiRenderer = new PixiRenderer(this.canvas, this.viewport.width, this.viewport.height, {
                backgroundColor: this.scene.settings.backgroundColor || 0x000000,
                antialias: true
            });

            this.pixiRenderer.Init().then(success => {
                if (success) {
                    console.log("PixiRenderer initialized");
                } else {
                    console.error("Failed to initialize PixiRenderer");
                    this.pixiRenderer = null;
                    this.usePixi = false;
                }
            });
        }
    }


    initializeViewport() {
        // Ensure viewport is properly initialized
        this.viewport.dirty = true;
        this.updateViewport();
    }

    /**
 * Load all existing prefabs into memory
 */
    async loadExistingPrefabs() {
        if (!this.editor || !this.editor.fileBrowser) return;

        try {
            const files = await this.editor.fileBrowser.getAllFiles();
            const prefabFiles = files.filter(file => file.name.endsWith('.prefab'));

            for (const file of prefabFiles) {
                try {
                    const content = file.content || await this.editor.fileBrowser.readFile(file.path);
                    if (!content) continue;

                    const prefabData = JSON.parse(content);

                    // Store by metadata name or filename without extension
                    const prefabName = prefabData.metadata?.name || file.name.replace('.prefab', '');
                    this.prefabs.set(prefabName, prefabData);

                    console.log(`Loaded prefab: ${prefabName}`);
                } catch (error) {
                    console.error(`Error loading prefab ${file.name}:`, error);
                }
            }

            console.log(`Loaded ${this.prefabs.size} prefabs into memory`);

            // Also update the global prefab manager if it exists
            if (window.prefabManager && typeof window.prefabManager.loadPrefabs === 'function') {
                const prefabsData = {};
                for (const [name, data] of this.prefabs) {
                    prefabsData[name] = data;
                }
                window.prefabManager.loadPrefabs(prefabsData);
            }
        } catch (error) {
            console.error('Error loading existing prefabs:', error);
        }
    }

    updateViewport() {
        // Add safety check for shake object
        if (!this.viewport.shake) {
            this.viewport.shake = { x: 0, y: 0, intensity: 0, duration: 0 };
        }

        // Clamp zoom within bounds
        this.viewport.zoom = Math.max(this.viewport.minZoom,
            Math.min(this.viewport.maxZoom, this.viewport.zoom));

        // Normalize angle to 0-360 range
        this.viewport.angle = ((this.viewport.angle % 360) + 360) % 360;

        // Update viewport shake
        if (this.viewport.shake.duration > 0) {
            this.viewport.shake.duration -= 16; // Assuming 60fps
            if (this.viewport.shake.duration <= 0) {
                this.viewport.shake.x = 0;
                this.viewport.shake.y = 0;
                this.viewport.shake.intensity = 0;
            } else {
                const intensity = this.viewport.shake.intensity * (this.viewport.shake.duration / 1000);
                this.viewport.shake.x = (Math.random() - 0.5) * intensity;
                this.viewport.shake.y = (Math.random() - 0.5) * intensity;
            }
        }

        // Preload decal chunks around the new viewport position
        this.preloadChunks();

        // Mark as clean
        this.viewport.dirty = false;

        // Notify callbacks
        this.viewportCallbacks.forEach(callback => {
            try {
                callback(this.viewport);
            } catch (error) {
                console.error('Error in viewport callback:', error);
            }
        });
    }

    setupResizeObserver() {
        if (this.canvas && this.canvas.parentElement && window.ResizeObserver) {
            // Create a ResizeObserver to monitor container size changes
            this.resizeObserver = new ResizeObserver(entries => {
                // Resize the canvas whenever the container size changes
                this.resizeCanvas();
            });

            // Start observing the canvas container
            this.resizeObserver.observe(this.canvas.parentElement);
        } else {
            // Fallback for browsers without ResizeObserver
            setInterval(() => this.resizeCanvas(), 1000); // Check every second
        }
    }

    // Set the canvas context for different drawing modes
    getBackgroundCanvas() {
        return this.backgroundCanvas.getContext('2d');
    }

    getGuiCanvas() {
        return this.guiCanvas.getContext('2d');
    }

    getMainCanvas() {
        return this.canvas.getContext('2d');
    }

    updateRenderConfig(settings) {
        // Update settings
        Object.assign(this.renderConfig, settings);

        // Force canvas resize to apply new settings
        this.resizeCanvas();
    }

    getGameObjectByName(name) {
        // Use a simple recursive search to find the first matching game object by name
        const findInObjects = (objects) => {
            for (const obj of objects) {
                if (obj.name === name) {
                    return obj;
                }
                if (obj.children && obj.children.length > 0) {
                    const found = findInObjects(obj.children);
                    if (found) return found;
                }
            }
            return null;
        };
        return findInObjects(this.gameObjects);
    }

    getAllObjects(objects = this.gameObjects, visited = new Set()) {
        let result = [];
        objects.forEach(obj => {
            if (visited.has(obj)) return;
            visited.add(obj);
            result.push(obj);
            if (obj.children && obj.children.length) {
                result = result.concat(this.getAllObjects(obj.children, visited));
            }
        });
        return result;
    }

    /*
        Find the nearest object to x and y by name within a certain range
    */
    findNearestObjectByName(x, y, name, maxRange = Infinity) {
        let nearest = null;
        let nearestDist = maxRange;

        this.gameObjects.forEach(obj => {
            if (obj.name === name) {
                const dx = obj.position.x - x;
                const dy = obj.position.y - y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < nearestDist) {
                    nearestDist = dist;
                    nearest = obj;
                }
            }
        });

        return nearest;
    }

    async preload() {
        console.log("Preloading game objects...");
        const preloadPromises = [];

        // Traverse all game objects and collect preload promises
        this.traverseGameObjects(this.gameObjects, obj => {
            if (obj.preload) {
                preloadPromises.push(obj.preload());
            }
            if (obj.modules) {
                obj.modules.forEach(module => {
                    if (module.preload) {
                        preloadPromises.push(module.preload(obj));
                    }
                });
            }
            obj.engine = this; // Set engine reference for each object
        });

        // Wait for all resources to load
        await Promise.all(preloadPromises);
        this.preloaded = true;
        console.log("All resources preloaded.");
    }

    traverseGameObjects(objects, callback) {
        objects.forEach(obj => {
            callback(obj);
            if (obj.children && obj.children.length > 0) {
                this.traverseGameObjects(obj.children, callback);
            }
        });
    }

    setViewportPosition(x, y) {
        this.viewport.x = x;
        this.viewport.y = y;
        this.viewport.dirty = true;
    }

    moveViewport(deltaX, deltaY) {
        this.viewport.x += deltaX;
        this.viewport.y += deltaY;
        this.viewport.dirty = true;
    }

    setViewportZoom(zoom) {
        this.viewport.zoom = Math.max(this.viewport.minZoom,
            Math.min(this.viewport.maxZoom, zoom));
        this.viewport.dirty = true;
    }

    zoomViewport(factor) {
        this.setViewportZoom(this.viewport.zoom * factor);
    }

    setViewportAngle(angle) {
        this.viewport.angle = angle;
        this.viewport.dirty = true;
    }

    rotateViewport(deltaAngle) {
        this.viewport.angle += deltaAngle;
        this.viewport.dirty = true;
    }

    shakeViewport(intensity, duration) {
        this.viewport.shake.intensity = intensity;
        this.viewport.shake.duration = duration;
    }

    worldToScreen(worldX, worldY) {
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;

        // Apply viewport transformations in reverse order
        let screenX = worldX - this.viewport.x + this.viewport.shake.x;
        let screenY = worldY - this.viewport.y + this.viewport.shake.y;

        // Apply zoom
        screenX = (screenX - centerX) * this.viewport.zoom + centerX;
        screenY = (screenY - centerY) * this.viewport.zoom + centerY;

        // Apply rotation if needed
        if (this.viewport.angle !== 0) {
            const radians = this.viewport.angle * Math.PI / 180;
            const cos = Math.cos(radians);
            const sin = Math.sin(radians);

            const relX = screenX - centerX;
            const relY = screenY - centerY;

            screenX = centerX + (relX * cos - relY * sin);
            screenY = centerY + (relX * sin + relY * cos);
        }

        return { x: screenX, y: screenY };
    }

    screenToWorld(screenX, screenY) {
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;

        let worldX = screenX;
        let worldY = screenY;

        // Reverse rotation
        if (this.viewport.angle !== 0) {
            const radians = -this.viewport.angle * Math.PI / 180;
            const cos = Math.cos(radians);
            const sin = Math.sin(radians);

            const relX = worldX - centerX;
            const relY = worldY - centerY;

            worldX = centerX + (relX * cos - relY * sin);
            worldY = centerY + (relX * sin + relY * cos);
        }

        // Reverse zoom
        worldX = (worldX - centerX) / this.viewport.zoom + centerX;
        worldY = (worldY - centerY) / this.viewport.zoom + centerY;

        // Reverse position offset and shake
        worldX = worldX + this.viewport.x - this.viewport.shake.x;
        worldY = worldY + this.viewport.y - this.viewport.shake.y;

        return { x: worldX, y: worldY };
    }

    onViewportChange(callback) {
        this.viewportCallbacks.push(callback);
    }

    removeViewportCallback(callback) {
        const index = this.viewportCallbacks.indexOf(callback);
        if (index > -1) {
            this.viewportCallbacks.splice(index, 1);
        }
    }

    async start() {
        if (this.usePixi && !this.pixiRenderer) {
            this.initializePixiRenderer();
        }

        if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null; // Ensure no stale frame
        }

        if (!this.scene) {
            console.error('No scene loaded');
            return;
        }

        // Make sure InputManager has the engine reference
        if (window.input) {
            window.input.setEngine(this);
        }

        console.log("Starting game...");

        this.viewportOriginalPosition = {
            width: this.viewport.width,
            height: this.viewport.height,
            x: this.viewport.x,
            y: this.viewport.y,
            zoom: this.viewport.zoom,
            angle: this.viewport.angle
        };

        // Perform any pre-start setup
        this.refreshModules();

        if (!this.preloaded) {
            await this.preload();
        }

        // Call start on all game objects
        this.traverseGameObjects(this.gameObjects, obj => {
            if (obj.active) {
                // Call the object's start method
                if (obj.start) {
                    obj.start();
                }

                // Call each module's start method
                /*obj.modules.forEach(module => {
                    if (module.enabled && module.start) {
                        try {
                            module.start();
                        } catch (error) {
                            console.error(`Error starting module ${module.type || module.constructor.name}:`, error);
                        }
                    }
                });*/
            }
        });

        // Initialize touch controls
        this.initTouchControls();

        this.running = true;
        this.lastTime = performance.now();
        this.animationFrameId = requestAnimationFrame(this.gameLoop.bind(this));

        //await window.prefabManager.loadExistingPrefabs()
    }

    pause() {
        if (this.running) {
            this.wasRunning = true;
            this.running = false;
            cancelAnimationFrame(this.animationFrameId);
            console.log("Game paused");
        }
    }

    resume() {
        if (this.wasRunning && !this.running) {
            this.running = true;
            this.wasRunning = false;
            this.lastFrameTime = performance.now();
            this.animationFrameId = requestAnimationFrame(this.gameLoop.bind(this));
            console.log("Game resumed");
        }
    }

    stop() {
        console.log("Stopping game...");
        this.running = false;
        this.wasRunning = false;
        if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null; // Ensure no stale frame
        }

        this.clearDecals();

        // Preserve shake object structure when resetting viewport
        this.viewport = {
            width: this.viewportOriginalPosition.width,
            height: this.viewportOriginalPosition.height,
            x: this.viewportOriginalPosition.x,
            y: this.viewportOriginalPosition.y,
            zoom: this.viewportOriginalPosition.zoom,
            angle: this.viewportOriginalPosition.angle,
            // Preserve all viewport properties
            minZoom: this.viewport.minZoom,
            maxZoom: this.viewport.maxZoom,
            dirty: this.viewport.dirty,
            shake: { x: 0, y: 0, intensity: 0, duration: 0 }
        };

        // Call onDestroy on all game objects
        this.traverseGameObjects(this.gameObjects, obj => {
            if (obj.modules) {
                obj.modules.forEach(module => {
                    if (module.onDestroy) {
                        try {
                            module.onDestroy();
                        } catch (error) {
                            console.error(`Error in onDestroy for module ${module.type || module.constructor.name}:`, error);
                        }
                    }
                });
            }
        });

        // Clean up dynamically created prefab instances
        this.cleanupDynamicObjects();

        // Reset physics after calling onDestroy to properly restore positions
        if (window.physicsManager) {
            window.physicsManager.reset();
        }

        // NEW: Restore the original objects to the editor and fix selection
        if (window.editor && window.editor.activeScene) {
            // Restore original objects to the scene
            window.editor.activeScene.gameObjects = [...this.originalGameObjects];
            window.editor.scene.gameObjects = [...this.originalGameObjects];

            // If there was a selected object, try to find its original counterpart
            if (window.editor.hierarchy && window.editor.hierarchy.selectedObject) {
                const selectedClone = window.editor.hierarchy.selectedObject;

                // Find the original object by matching name and position
                const originalObject = this.findOriginalObject(selectedClone, this.originalGameObjects);

                if (originalObject) {
                    // Deselect the clone
                    selectedClone.setSelected(false);

                    // Select the original object
                    originalObject.setSelected(true);
                    window.editor.hierarchy.selectedObject = originalObject;

                    // Update the inspector to show the original object
                    if (window.editor.inspector) {
                        window.editor.inspector.inspectObject(originalObject);
                    }

                    // Update hierarchy UI to show proper selection
                    window.editor.hierarchy.refreshHierarchy();

                    // Make sure the hierarchy item is selected
                    const hierarchyItem = document.querySelector(`.hierarchy-item[data-id="${originalObject.id}"]`);
                    if (hierarchyItem) {
                        // Remove selection from all items first
                        document.querySelectorAll('.hierarchy-item').forEach(item => {
                            item.classList.remove('selected');
                        });
                        // Add selection to the correct item
                        hierarchyItem.classList.add('selected');
                    }
                } else {
                    // If we can't find the original, just clear the selection
                    selectedClone.setSelected(false);
                    window.editor.hierarchy.selectedObject = null;

                    // Update hierarchy UI
                    document.querySelectorAll('.hierarchy-item').forEach(item => {
                        item.classList.remove('selected');
                    });

                    // Show "no object selected" in inspector
                    if (window.editor.inspector) {
                        window.editor.inspector.showNoObjectMessage();
                    }
                }
            }

            // Refresh the hierarchy to show original objects
            if (window.editor.hierarchy) {
                window.editor.hierarchy.refreshHierarchy();
            }

            // Refresh the editor canvas to show restored objects
            window.editor.refreshCanvas();
        }
    }

    /**
     * Find the original object that corresponds to a cloned object
     * @param {GameObject} clonedObject - The cloned object to find the original for
     * @param {Array} originalObjects - Array of original objects to search in
     * @returns {GameObject|null} - The original object or null if not found
     */
    findOriginalObject(clonedObject, originalObjects) {
        // Helper function to search recursively through objects and their children
        const searchInObjects = (objects) => {
            for (const obj of objects) {
                // Match by name and original position (before any runtime changes)
                if (obj.name === clonedObject.name &&
                    obj._originalPosition && clonedObject._originalPosition &&
                    Math.abs(obj._originalPosition.x - clonedObject._originalPosition.x) < 0.01 &&
                    Math.abs(obj._originalPosition.y - clonedObject._originalPosition.y) < 0.01) {
                    return obj;
                }

                // If no original position stored, fall back to ID matching if available
                if (!obj._originalPosition && obj.id === clonedObject.id) {
                    return obj;
                }

                // Search in children
                if (obj.children && obj.children.length > 0) {
                    const found = searchInObjects(obj.children);
                    if (found) return found;
                }
            }
            return null;
        };

        return searchInObjects(originalObjects);
    }

    /**
     * Remove a dynamically created object
     * @param {GameObject} gameObject - The object to remove
     */
    removeDynamicObject(gameObject) {
        if (!gameObject) return false;

        // Remove from dynamic objects tracking
        this.dynamicObjects.delete(gameObject);

        // Remove from game objects array
        const index = this.gameObjects.indexOf(gameObject);
        if (index > -1) {
            this.gameObjects.splice(index, 1);
        }

        // Also remove from parent if it has one
        if (gameObject.parent) {
            gameObject.parent.removeChild(gameObject);
        }

        // Remove from editor's scene if available
        if (window.editor && window.editor.activeScene) {
            const editorIndex = window.editor.activeScene.gameObjects.indexOf(gameObject);
            if (editorIndex > -1) {
                window.editor.activeScene.gameObjects.splice(editorIndex, 1);
            }

            // Also remove from editor's scene reference
            const sceneIndex = window.editor.scene.gameObjects.indexOf(gameObject);
            if (sceneIndex > -1) {
                window.editor.scene.gameObjects.splice(sceneIndex, 1);
            }
        }

        // Check if this object is currently selected in the editor
        if (window.editor && window.editor.hierarchy && window.editor.hierarchy.selectedObject === gameObject) {
            gameObject.setSelected(false);
            window.editor.hierarchy.selectedObject = null;

            // Update hierarchy UI
            document.querySelectorAll('.hierarchy-item').forEach(item => {
                item.classList.remove('selected');
            });

            // Show "no object selected" in inspector
            if (window.editor.inspector) {
                window.editor.inspector.showNoObjectMessage();
            }
        }

        // Call onDestroy on the object and its modules
        if (gameObject.modules) {
            gameObject.modules.forEach(module => {
                if (module.onDestroy) {
                    try {
                        module.onDestroy();
                    } catch (error) {
                        console.error(`Error in onDestroy for module ${module.type || module.constructor.name}:`, error);
                    }
                }
            });
        }

        console.log(`Removed dynamic object: ${gameObject.name || 'Unnamed'}`);
        return true;
    }

    /**
     * Clean up all dynamically created objects
     */
    cleanupDynamicObjects() {
        console.log(`Cleaning up ${this.dynamicObjects.size} dynamic objects...`);

        // Convert to array to avoid modification during iteration
        const objectsToRemove = Array.from(this.dynamicObjects);

        objectsToRemove.forEach(obj => {
            this.removeDynamicObject(obj);
        });

        // Restore original game objects
        this.gameObjects = [...this.originalGameObjects];
        this.dynamicObjects.clear();

        // Update the editor if available
        if (window.editor) {
            // Update the editor's scene gameObjects reference
            if (window.editor.activeScene) {
                window.editor.activeScene.gameObjects = [...this.originalGameObjects];
                window.editor.scene.gameObjects = [...this.originalGameObjects];
            }

            // Clear any selected object if it was dynamic
            if (window.editor.hierarchy && window.editor.hierarchy.selectedObject) {
                const selectedObj = window.editor.hierarchy.selectedObject;
                if (selectedObj._isDynamic) {
                    selectedObj.setSelected(false);
                    window.editor.hierarchy.selectedObject = null;

                    // Update hierarchy UI
                    document.querySelectorAll('.hierarchy-item').forEach(item => {
                        item.classList.remove('selected');
                    });

                    // Show "no object selected" in inspector
                    if (window.editor.inspector) {
                        window.editor.inspector.showNoObjectMessage();
                    }
                }
            }

            // Refresh the hierarchy to remove dynamic objects from the UI
            if (window.editor.hierarchy) {
                window.editor.hierarchy.refreshHierarchy();
            }

            // Refresh the editor canvas
            window.editor.refreshCanvas();
        }

        console.log('Dynamic object cleanup complete');
    }

    refreshModules() {
        if (!window.moduleReloader || !window.moduleRegistry) {
            console.warn("Cannot refresh modules: ModuleReloader or ModuleRegistry not available");
            return false;
        }

        console.log("Refreshing all module instances before game start...");

        let totalUpdated = 0;

        // Get all registered module types
        const moduleTypes = Array.from(window.moduleRegistry.modules.keys());

        // Update instances of each module type
        moduleTypes.forEach(className => {
            const updated = window.moduleReloader.updateModuleInstances(
                className,
                this.gameObjects
            );

            if (updated > 0) {
                totalUpdated += updated;
                console.log(`Updated ${updated} instances of ${className}`);
            }
        });

        console.log(`Total module instances refreshed: ${totalUpdated}`);
        return totalUpdated > 0;
    }

    updateFPSLimit(newMaxFPS) {
        this.maxFPS = newMaxFPS;
        this._minFrameInterval = this.maxFPS > 0 ? 1000 / this.maxFPS : 0;
    }

    setVSync(enabled) {
        this.enableVSync = enabled;
        console.log(`VSync ${enabled ? 'enabled' : 'disabled'}`);
    }

    gameLoop(timestamp) {
        if (!this.running) return;

        // FPS limiting logic - only apply when VSync is disabled
        if (!this.enableVSync && this.maxFPS > 0) {
            if (timestamp - this._lastFrameTime < this._minFrameInterval) {
                this.animationFrameId = requestAnimationFrame(this.gameLoop.bind(this));
                return;
            }
        }
        this._lastFrameTime = timestamp;

        const deltaTime = Math.min((timestamp - this.lastTime) / 1000, 0.1);
        this.lastTime = timestamp;

        this.frameCount++;
        if (timestamp - this.lastFpsUpdate >= 1000) { // Update every 1 second
            this.fps = this.frameCount; // Set FPS to frames in the last second
            this.frameCount = 0; // Reset frame count
            this.lastFpsUpdate = timestamp; // Update timestamp
        }

        // Update input manager at the start of the frame
        if (window.input) {
            window.input.beginFrame();
        }

        // Update viewport if dirty
        if (this.viewport.dirty) {
            this.updateViewport();
        }

        // Update decal chunks for fading
        this.decalChunks.forEach(chunk => chunk.update(deltaTime));

        this.update(deltaTime);
        this.draw();

        // Update input manager at the end of the frame
        if (window.input) {
            window.input.endFrame();
        }

        this.animationFrameId = requestAnimationFrame(this.gameLoop.bind(this));
    }

    update(deltaTime) {
        // Begin loop phase
        this.traverseGameObjects(this.gameObjects, obj => {
            if (obj.active) {
                // Call object's beginLoop method
                if (obj.beginLoop) obj.beginLoop(deltaTime);

                // Call modules' beginLoop methods
                /*obj.modules.forEach(module => {
                    if (module.enabled && module.beginLoop) {
                        try {
                            // Only pass deltaTime parameter, not the object reference
                            module.beginLoop(deltaTime);
                        } catch (error) {
                            console.error(`Error in beginLoop for module ${module.type || module.constructor.name}:`, error);
                        }
                    }
                });*/
            }
        });

        // Update collision system
        /*if (window.collisionSystem) {
            // Get all active objects
            const allObjects = this.getAllObjects(this.gameObjects).filter(obj => obj.active);

            // Update collision detection
            window.collisionSystem.update(allObjects);
        }*/

        // Main loop phase
        this.traverseGameObjects(this.gameObjects, obj => {
            if (obj.active) {
                // Call object's loop method
                if (obj.loop) obj.loop(deltaTime);

                // Call modules' loop methods
                /*obj.modules.forEach(module => {
                    if (module.enabled && module.loop) {
                        try {
                            // Only pass deltaTime parameter, not the object reference
                            module.loop(deltaTime);
                        } catch (error) {
                            console.error(`Error in loop for module ${module.type || module.constructor.name}:`, error);
                        }
                    }
                });*/
            }
        });

        // End loop phase
        this.traverseGameObjects(this.gameObjects, obj => {
            if (obj.active) {
                // Call object's endLoop method
                if (obj.endLoop) obj.endLoop(deltaTime);

                // Call modules' endLoop methods
                /*obj.modules.forEach(module => {
                    if (module.enabled && module.endLoop) {
                        try {
                            // Only pass deltaTime parameter, not the object reference
                            module.endLoop(deltaTime);
                        } catch (error) {
                            console.error(`Error in endLoop for module ${module.type || module.constructor.name}:`, error);
                        }
                    }
                });*/
            }
        });
    }

    draw() {
        if (!this.canvas || !this.ctx || !this.running) return;

        if (this.usePixi && this.pixiRenderer) {
            // Sync GameObjects to Pixi
            const allObjects = this.getAllObjects(this.gameObjects);
            allObjects.forEach(obj => {
                if (!obj.pixiDisplayObject) {
                    const pixiObj = obj.createPixiDisplayObject();
                    this.pixiRenderer.addDisplayObject(pixiObj);
                }
                obj.updatePixiDisplayObject();
            });

            // Draw each active and visible object using pixiRenderer as context
            allObjects
                .filter(obj => obj.active && obj.visible !== false)
                .sort((a, b) => b.depth - a.depth)
                .forEach(obj => {
                    try {
                        obj.draw(this.pixiRenderer); // Pass pixiRenderer as context
                    } catch (error) {
                        console.error(`Error drawing object ${obj.name}:`, error);
                    }
                });

            this.pixiRenderer.render();
            return;
        }

        // Clear canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

        // Always fill with a solid color to prevent transparency issues
        // Use scene background color if available, otherwise default to black
        const fillColor = (this.scene && this.scene.settings && this.scene.settings.backgroundColor)
            ? this.scene.settings.backgroundColor
            : '#000000'; // Default fallback
        this.ctx.fillStyle = fillColor;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        if (this.backgroundCanvas) {
            const bgCtx = this.backgroundCanvas.getContext('2d');
            bgCtx.clearRect(0, 0, this.backgroundCanvas.width, this.backgroundCanvas.height);
        }
        if (this.guiCanvas) {
            const guiCtx = this.guiCanvas.getContext('2d');
            guiCtx.clearRect(0, 0, this.guiCanvas.width, this.guiCanvas.height);
        }
        if (this.decalCanvas) {
            const decalCtx = this.decalCanvas.getContext('2d');
            decalCtx.clearRect(0, 0, this.decalCanvas.width, this.decalCanvas.height);
        }

        // Fill with scene background color
        if (this.scene && this.scene.settings && this.scene.settings.backgroundColor) {
            this.ctx.fillStyle = this.scene.settings.backgroundColor;
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        }

        // Apply viewport transformation
        this.ctx.save();

        // Apply any camera transformations
        this.applyViewportTransform();

        // Draw background canvas if available
        if (this.backgroundCanvas) {
            this.ctx.save();
            this.ctx.globalAlpha = 1.0;
            // Apply proper background positioning
            this.ctx.drawImage(this.backgroundCanvas, 0, 0);
            this.ctx.restore();
        }

        // Draw decal canvas (in world space, before objects)
        if (this.decalCanvas) {
            this.ctx.save();
            this.ctx.globalAlpha = 1.0;
            // Render only visible chunks
            this.decalChunks.forEach(chunk => {
                if (chunk.isVisible(this.viewport)) {
                    this.ctx.save();
                    this.ctx.translate(chunk.x, chunk.y); // Position chunk in world space
                    chunk.draw(this.ctx, this.viewport, this.debugDecals); // Pass debug flag
                    this.ctx.restore();
                }
            });
            this.ctx.restore();
        }

        // Draw all game objects, sorted by depth
        const allObjects = this.getAllObjects(this.gameObjects);

        // Make sure we actually have objects to draw
        if (allObjects.length === 0) {
            // If no objects, draw a placeholder message
            this.ctx.fillStyle = "#ffffff";
            this.ctx.font = "20px Arial";
            this.ctx.textAlign = "center";
            this.ctx.fillText("No objects in scene... What is a game without objects?", this.canvas.width / 2, this.canvas.height / 2);
        } else {
            // Draw each active and visible object
            allObjects
                .filter(obj => obj.active && obj.visible !== false)
                .sort((a, b) => b.depth - a.depth)
                .forEach(obj => {
                    try {
                        obj.draw(this.ctx);
                    } catch (error) {
                        console.error(`Error drawing object ${obj.name}:`, error);
                    }
                });
        }

        this.ctx.restore();

        // Draw GUI canvas AFTER restoring transform (GUI should not be affected by viewport)
        if (this.guiCanvas) {
            this.ctx.save();
            this.ctx.globalAlpha = 1.0;
            this.ctx.drawImage(this.guiCanvas, 0, 0);
            this.ctx.restore();
        }

        if (this.ctx.flush) this.ctx.flush(); // Ensure all drawing commands are executed
    }

    applyViewportTransform() {
        const centerX = this.canvas.width / 2;
        const centerY = this.canvas.height / 2;

        /*if (this.useWebGL && this.ctx.setTransform && typeof this.ctx.setTransform === 'function') {
            // For WebGLCanvas, use the matrix-based transform
            const radians = this.viewport.angle * Math.PI / 180;
            const cos = Math.cos(radians);
            const sin = Math.sin(radians);

            // Create transformation matrix
            const a = this.viewport.zoom * cos;
            const b = -this.viewport.zoom * sin;
            const c = this.viewport.zoom * sin;
            const d = this.viewport.zoom * cos;
            const e = centerX - this.viewport.x + this.viewport.shake.x;
            const f = centerY - this.viewport.y + this.viewport.shake.y;

            this.ctx.setTransform(a, b, c, d, e, f);
        } else {*/
        // Standard 2D canvas transforms
        this.ctx.translate(centerX, centerY);

        if (this.viewport.angle && this.viewport.angle !== 0) {
            const radians = this.viewport.angle * Math.PI / 180;
            this.ctx.rotate(radians);
        }

        if (this.viewport.zoom && this.viewport.zoom !== 1) {
            this.ctx.scale(this.viewport.zoom, this.viewport.zoom);
        }

        this.ctx.translate(
            -centerX - this.viewport.x + this.viewport.shake.x,
            -centerY - this.viewport.y + this.viewport.shake.y
        );
        //}
    }

    loadScene(scene) {
        // Stop current scene if running
        if (this.running) {
            this.stop();
        } else if (window.physicsManager) {
            // Ensure physics is reset even if not currently running
            window.physicsManager.reset();
        }

        console.log(`Loading scene: ${scene.name}`);
        console.log(`Scene has ${scene.gameObjects.length} game objects`);

        // Clone the scene to avoid modifying the editor version
        this.scene = scene;
        this.clearDecals();

        // Copy viewport settings and validate them
        if (scene.settings) {
            this.viewport.width = Math.max(1, scene.settings.viewportWidth || 800);
            this.viewport.height = Math.max(1, scene.settings.viewportHeight || 600);
            this.viewport.x = scene.settings.viewportX || 0;
            this.viewport.y = scene.settings.viewportY || 0;
            this.viewport.zoom = Math.max(0.1, scene.settings.viewportZoom || 1);
            this.viewport.angle = scene.settings.viewportAngle || 0;
        }

        // Load chunk settings from scene if available
        if (scene.settings) {
            this.chunkSize = scene.settings.chunkSize || this.chunkSize;
            this.preloadChunkRadius = scene.settings.preloadChunkRadius || this.preloadChunkRadius;
        }

        // Mark viewport as dirty to force update
        this.viewport.dirty = true;

        // Deep clone only in editor. In exported/runtime builds, use objects as-built
        // so embedded assets (like SpriteRenderer.imageData) are preserved.
        if (window.editor) {
            // Store original positions before cloning
            this.storeOriginalPositions(scene.gameObjects);
            this.gameObjects = this.cloneGameObjects(scene.gameObjects, false);
        } else {
            this.gameObjects = scene.gameObjects;
        }

        // Store original objects for cleanup purposes
        this.originalGameObjects = [...scene.gameObjects]; // Use the original scene objects
        this.dynamicObjects.clear();

        this.preloaded = false;
        this.canvasResized = true;

        // Force canvas resize with new viewport settings
        this.resizeCanvas();
    }

    /**
 * Load scene by index (useful for exported games)
 */
    loadSceneByIndex(scenes, index) {
        if (!scenes || !Array.isArray(scenes) || index < 0 || index >= scenes.length) {
            console.error('Invalid scene index or scenes array');
            return false;
        }

        const scene = scenes[index];
        this.loadScene(scene);
        return true;
    }

    /**
     * Enhanced prefab instantiation
     */
    async instantiatePrefab(prefabName, x = 0, y = 0) {
        console.log(`Attempting to instantiate prefab: ${prefabName}`);

        let instantiated = null;

        // Method 1: Use engine's own prefab manager first
        if (this.prefabManager && typeof this.prefabManager.instantiatePrefabByName === 'function') {
            const position = new Vector2(x, y);
            instantiated = this.prefabManager.instantiatePrefabByName(prefabName, position);

            if (instantiated) {
                // Add to the current scene's gameObjects if not already added
                if (!this.gameObjects.includes(instantiated)) {
                    this.gameObjects.push(instantiated);
                }
                console.log(`Successfully instantiated prefab via engine prefab manager: ${prefabName}`);
            }
        }

        // Method 2: Check if we're in the editor - use the hierarchy's prefab manager
        if (!instantiated && window.editor && window.editor.hierarchy && window.editor.hierarchy.prefabManager) {
            const position = new Vector2(x, y);
            instantiated = window.editor.hierarchy.prefabManager.instantiatePrefabByName(prefabName, position);

            if (instantiated) {
                // Add to the current scene's gameObjects if not already added
                if (!this.gameObjects.includes(instantiated)) {
                    this.gameObjects.push(instantiated);
                }
                console.log(`Successfully instantiated prefab via editor: ${prefabName}`);
            }
        }

        // Method 3: Try the global prefab manager (for exported games)
        if (!instantiated && window.prefabManager) {
            console.log('Using global prefab manager for instantiation');

            if (typeof window.prefabManager.instantiatePrefabByName === 'function') {
                const position = new Vector2(x, y);
                instantiated = window.prefabManager.instantiatePrefabByName(prefabName, position);

                if (instantiated) {
                    // Add to the current scene's gameObjects if not already added
                    if (!this.gameObjects.includes(instantiated)) {
                        this.gameObjects.push(instantiated);
                    }
                    console.log(`Successfully instantiated prefab via global manager: ${prefabName}`);
                }
            }
        }

        // Method 4: Try loading from file browser (editor fallback)
        if (!instantiated && window.editor && window.editor.fileBrowser) {
            const variations = [
                `${prefabName}.prefab`,
                `Prefabs/${prefabName}.prefab`,
                `/Prefabs/${prefabName}.prefab`
            ];

            for (const variation of variations) {
                try {
                    const content = await window.editor.fileBrowser.readFile(variation);
                    if (content) {
                        const prefabData = JSON.parse(content);
                        instantiated = this.createGameObjectFromPrefab(prefabData, x, y);

                        if (instantiated) {
                            if (!this.gameObjects.includes(instantiated)) {
                                this.gameObjects.push(instantiated);
                            }
                            console.log(`Successfully instantiated prefab from file: ${variation}`);
                            break;
                        }
                    }
                } catch (error) {
                    console.warn(`Failed to load prefab from ${variation}:`, error);
                }
            }
        }

        // Track the instantiated object for cleanup
        if (instantiated) {
            this.dynamicObjects.add(instantiated);
            // Mark it as dynamically created for identification
            instantiated._isDynamic = true;
            console.log(`Tracked dynamic object: ${instantiated.name || 'Unnamed'}`);
        } else {
            console.error(`Prefab not found: ${prefabName}`);
            console.log('Available prefabs in global manager:', window.prefabManager ? window.prefabManager.getAllPrefabNames() : 'None');
            console.log('Available prefabs in engine:', this.getAvailablePrefabs());
        }

        return instantiated;
    }

    /**
     * Create GameObject from prefab data
     */
    createGameObjectFromPrefab(prefabData, x = 0, y = 0) {
        if (!prefabData) return null;

        try {
            // Create GameObject
            const gameObject = GameObject.fromJSON(prefabData);
            gameObject.position = new Vector2(x, y);
            return gameObject;

        } catch (error) {
            console.error(`Error creating GameObject from prefab:`, error);
            return null;
        }
    }

    /**
     * Check if a prefab exists by name
     * @param {string} prefabName - Name of the prefab to check
     * @returns {boolean} True if the prefab exists
     */
    hasPrefab(prefabName) {
        if (!prefabName) return false;

        // Check if we're in the editor - use the hierarchy's prefab manager
        if (window.editor && window.editor.hierarchy && window.editor.hierarchy.prefabManager) {
            return window.editor.hierarchy.prefabManager.hasPrefab(prefabName);
        }

        // Check if we're in an exported game with embedded prefabs
        if (window.prefabManager && typeof window.prefabManager.hasPrefab === 'function') {
            return window.prefabManager.hasPrefab(prefabName);
        }

        // Also check if prefabs are available through the file browser
        if (window.editor && window.editor.fileBrowser) {
            // Try to find a prefab file that matches
            const variations = [
                `${prefabName}.prefab`,
                `Prefabs/${prefabName}.prefab`,
                `/Prefabs/${prefabName}.prefab`
            ];

            for (const variation of variations) {
                if (window.editor.fileBrowser.exists && window.editor.fileBrowser.exists(variation)) {
                    return true;
                }
            }
        }

        return false;
    }

    findGameObjectByName(name) {
        // Use a simple recursive search to find the first matching game object by name
        const findInObjects = (objects) => {
            for (const obj of objects) {
                if (obj.name === name) {
                    return obj;
                }
                if (obj.children && obj.children.length > 0) {
                    const found = findInObjects(obj.children);
                    if (found) return found;
                }
            }
            return null;
        };
        return findInObjects(this.gameObjects);
    }

    /**
     * Add a decal at world coordinates (x, y)
     * @param {number} x - World X position
     * @param {number} y - World Y position
     * @param {Image|Function} imageOrDrawFunction - The decal image or a function(ctx) to draw custom graphics
     * @param {Object} options - Optional: {rotation, scale, alpha, width, height} (width/height for drawing functions)
     */
    addDecal(x, y, imageOrDrawFunction, options = {}) {
        const chunkX = Math.floor(x / this.chunkSize) * this.chunkSize;
        const chunkY = Math.floor(y / this.chunkSize) * this.chunkSize;
        const key = `${chunkX}_${chunkY}`;

        // Validate chunk bounds (ensure decal is within chunk)
        const localX = x - chunkX;
        const localY = y - chunkY;
        if (localX < 0 || localX >= this.chunkSize || localY < 0 || localY >= this.chunkSize) {
            console.warn(`Decal at (${x}, ${y}) is outside chunk bounds (${chunkX}, ${chunkY}) - adjusting.`);
            // Optional: Adjust position to fit within chunk (or skip addition)
        }

        if (!this.decalChunks.has(key)) {
            this.decalChunks.set(key, new DecalChunk(chunkX, chunkY, this.chunkSize));
        }

        if (this.debugDecals) {
            console.log(`Adding decal to chunk: ${key} at local (${localX}, ${localY})`);
        }

        this.decalChunks.get(key).addDecal(x, y, imageOrDrawFunction, options);
    }

    /**
     * Clear all decals or decals in a specific chunk
     * @param {number} x - Optional: World X to clear chunk
     * @param {number} y - Optional: World Y to clear chunk
     */
    clearDecals(x = null, y = null) {
        if (x !== null && y !== null) {
            const chunkX = Math.floor(x / this.chunkSize) * this.chunkSize;
            const chunkY = Math.floor(y / this.chunkSize) * this.chunkSize;
            const key = `${chunkX}_${chunkY}`;
            if (this.decalChunks.has(key)) {
                this.decalChunks.get(key).clear();
            }
        } else {
            this.decalChunks.forEach(chunk => chunk.clear());
        }
    }

    /**
     * Get or create a chunk for a world position
     * @param {number} x - World X
     * @param {number} y - World Y
     * @returns {DecalChunk}
     */
    getChunk(x, y) {
        const chunkX = Math.floor(x / this.chunkSize) * this.chunkSize;
        const chunkY = Math.floor(y / this.chunkSize) * this.chunkSize;
        const key = `${chunkX}_${chunkY}`;
        if (!this.decalChunks.has(key)) {
            this.decalChunks.set(key, new DecalChunk(chunkX, chunkY, this.chunkSize));
        }
        return this.decalChunks.get(key);
    }

    /**
     * Preload decal chunks around the viewport to ensure persistence
     */
    preloadChunks() {
        // Calculate viewport bounds in world space correctly
        // Visible world width/height is viewport dimensions divided by zoom
        const halfVisibleWidth = (this.viewport.width / 2) / this.viewport.zoom;
        const halfVisibleHeight = (this.viewport.height / 2) / this.viewport.zoom;

        const viewLeft = this.viewport.x - halfVisibleWidth;
        const viewRight = this.viewport.x + halfVisibleWidth;
        const viewTop = this.viewport.y - halfVisibleHeight;
        const viewBottom = this.viewport.y + halfVisibleHeight;

        // Add buffer chunks around the viewport for safety
        const buffer = this.preloadChunkRadius * this.chunkSize; // Use preloadChunkRadius as buffer distance
        const minChunkX = Math.floor((viewLeft - buffer) / this.chunkSize) * this.chunkSize;
        const maxChunkX = Math.floor((viewRight + buffer) / this.chunkSize) * this.chunkSize;
        const minChunkY = Math.floor((viewTop - buffer) / this.chunkSize) * this.chunkSize;
        const maxChunkY = Math.floor((viewBottom + buffer) / this.chunkSize) * this.chunkSize;

        if (this.debugDecals) {
            console.log(`Preloading chunks: view bounds (${viewLeft}, ${viewTop}) to (${viewRight}, ${viewBottom}), buffer: ${buffer}`);
        }

        // Preload all chunks that intersect or are near the viewport
        for (let x = minChunkX; x <= maxChunkX; x += this.chunkSize) {
            for (let y = minChunkY; y <= maxChunkY; y += this.chunkSize) {
                const key = `${x}_${y}`;
                if (!this.decalChunks.has(key)) {
                    this.decalChunks.set(key, new DecalChunk(x, y, this.chunkSize));
                    if (this.debugDecals) {
                        console.log(`Preloaded chunk: ${key}`);
                    }
                }
            }
        }

        // Optional: Unload distant chunks to prevent memory bloat
        const unloadBuffer = buffer * 2; // Unload beyond 2x the buffer
        const unloadMinX = minChunkX - unloadBuffer;
        const unloadMaxX = maxChunkX + unloadBuffer;
        const unloadMinY = minChunkY - unloadBuffer;
        const unloadMaxY = maxChunkY + unloadBuffer;

        for (const [key, chunk] of this.decalChunks) {
            const [cx, cy] = key.split('_').map(Number);
            if (cx < unloadMinX || cx > unloadMaxX || cy < unloadMinY || cy > unloadMaxY) {
                if (this.debugDecals) {
                    console.log(`Unloading distant chunk: ${key}`);
                }
                this.decalChunks.delete(key);
            }
        }
    }

    /**
     * Store original positions on objects before cloning for runtime
     * @param {Array} gameObjects - Array of game objects to process
     */
    storeOriginalPositions(gameObjects) {
        const storeForObject = (obj) => {
            // Store the original position
            obj._originalPosition = { x: obj.position.x, y: obj.position.y };

            // Store for children too
            if (obj.children && obj.children.length > 0) {
                obj.children.forEach(storeForObject);
            }
        };

        gameObjects.forEach(storeForObject);
    }

    cloneGameObjects(objects, addNameCopySuffix = true) {
        return objects.map(obj => {
            // Use the GameObject's built-in clone method
            const clonedObj = obj.clone(addNameCopySuffix);

            // Copy the original position to the clone for tracking
            if (obj._originalPosition) {
                clonedObj._originalPosition = { x: obj._originalPosition.x, y: obj._originalPosition.y };
            }

            // Handle the cloning of children separately to maintain proper hierarchy
            if (obj.children && obj.children.length > 0) {
                // Remove any existing children that were cloned
                clonedObj.children = [];

                // Clone all children recursively and add them properly
                const clonedChildren = this.cloneGameObjects(obj.children, addNameCopySuffix);
                clonedChildren.forEach(child => {
                    clonedObj.addChild(child);
                });
            }

            return clonedObj;
        });
    }

    /**
     * Save the current game state
     * @param {string} saveFileName - Name for the save file
     * @param {boolean} saveLocal - If true, save to localStorage; else, download as file
     */
    saveGame(saveFileName = 'savegame', saveLocal = true) {
        const state = {
            scene: this.scene ? this.scene.name : null,
            gameObjects: this.gameObjects.map(obj => obj.toJSON ? obj.toJSON() : obj),
            viewport: this.viewport,
            timestamp: Date.now()
        };
        const saveData = JSON.stringify(state);

        if (saveLocal) {
            localStorage.setItem(`dmjs_save_${saveFileName}`, saveData);
            alert(`Game saved locally as "${saveFileName}"`);
        } else {
            const blob = new Blob([saveData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${saveFileName}.dmjs-save.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    }

    /**
     * Load a game state from localStorage or file
     * @param {string|File} source - Save file name (local) or File object
     * @returns {Promise<boolean>}
     */
    async loadGame(source) {
        let saveData = null;
        if (typeof source === 'string') {
            saveData = localStorage.getItem(`dmjs_save_${source}`);
        } else if (source instanceof File) {
            saveData = await source.text();
        }
        if (!saveData) {
            alert('Save file not found.');
            return false;
        }
        try {
            const state = JSON.parse(saveData);
            // Load scene by name if available
            if (state.scene && window.editor && window.editor.scenes) {
                const scene = window.editor.scenes.find(s => s.name === state.scene);
                if (scene) this.loadScene(scene);
            }
            // Restore game objects
            if (state.gameObjects) {
                this.gameObjects = state.gameObjects.map(objData =>
                    window.GameObject && window.GameObject.fromJSON
                        ? window.GameObject.fromJSON(objData)
                        : objData
                );
            }
            // Restore viewport
            if (state.viewport) {
                Object.assign(this.viewport, state.viewport);
            }
            alert('Game loaded!');
            return true;
        } catch (e) {
            alert('Failed to load game: ' + e.message);
            return false;
        }
    }

    /**
     * Load prefabs into the engine's prefab manager
     * @param {Object} prefabsData - Object containing prefab data
     */
    loadPrefabs(prefabsData) {
        if (!prefabsData) return;

        console.log('Loading prefabs into engine:', Object.keys(prefabsData));

        // Ensure we have a prefab manager
        if (!this.prefabManager && window.prefabManager) {
            this.prefabManager = window.prefabManager;
        }

        if (this.prefabManager && typeof this.prefabManager.loadPrefabs === 'function') {
            this.prefabManager.loadPrefabs(prefabsData);
            console.log(`Engine loaded ${Object.keys(prefabsData).length} prefabs`);
        } else {
            console.warn('No prefab manager available in engine');
        }
    }

    /**
     * Get all available prefab names from the engine's prefab manager
     * @returns {Array<string>} Array of prefab names
     */
    getAvailablePrefabs() {
        if (this.prefabManager && typeof this.prefabManager.getAllPrefabNames === 'function') {
            return this.prefabManager.getAllPrefabNames();
        }

        // Fallback to global prefab manager
        if (window.prefabManager && typeof window.prefabManager.getAllPrefabNames === 'function') {
            return window.prefabManager.getAllPrefabNames();
        }

        return [];
    }

    initTouchControls() {
        if (!this.canvas) return;

        // Prevent default touch actions on the canvas
        this.canvas.addEventListener('touchstart', (e) => {
            //e.preventDefault();

            // Convert touch to mouse events for simplicity
            if (window.input) {
                const touch = e.touches[0];
                const rect = this.canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                window.input.handleMouseDown({
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    button: 0, // Simulate left click
                    offsetX: x,
                    offsetY: y
                });
            }
        }, { passive: false });

        this.canvas.addEventListener('touchmove', (e) => {
            //e.preventDefault();

            // Convert touch to mouse events
            if (window.input) {
                const touch = e.touches[0];
                const rect = this.canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                window.input.handleMouseMove({
                    clientX: touch.clientX,
                    clientY: touch.clientY,
                    offsetX: x,
                    offsetY: y
                });
            }
        }, { passive: false });

        this.canvas.addEventListener('touchend', (e) => {
            //e.preventDefault();

            // Convert touch to mouse events
            if (window.input) {
                window.input.handleMouseUp({
                    button: 0 // Simulate left click
                });
            }
        }, { passive: false });
    }

    resizeCanvas() {
        if (!this.canvas) return;

        const container = this.canvas.parentElement;
        if (!container) return;

        // Get container dimensions - force a reflow to get the latest size
        container.offsetHeight; // Trigger reflow
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;

        // Ensure we have positive dimensions to work with
        if (containerWidth <= 0 || containerHeight <= 0) {
            return;
        }

        // Get the desired viewport dimensions from scene settings
        const viewportWidth = this.viewport.width || 800;
        const viewportHeight = this.viewport.height || 600;
        const aspectRatio = viewportWidth / viewportHeight;

        const pixelRatio = this.renderConfig.pixelRatio;

        // Set physical dimensions based on scaling mode
        let physicalWidth, physicalHeight;

        if (this.renderConfig.fullscreen) {
            if (this.renderConfig.maintainAspectRatio) {
                // Calculate dimensions to maintain aspect ratio within the container
                const containerRatio = containerWidth / containerHeight;

                if (containerRatio > aspectRatio) {
                    // Container is wider than needed - height is the limiting factor
                    physicalHeight = containerHeight;
                    physicalWidth = containerHeight * aspectRatio;
                } else {
                    // Container is taller than needed - width is the limiting factor
                    physicalWidth = containerWidth;
                    physicalHeight = containerWidth / aspectRatio;
                }
            } else {
                // Stretch to fill container without maintaining aspect ratio
                physicalWidth = containerWidth;
                physicalHeight = containerHeight;
            }
        } else {
            // Fixed size mode - calculate scale to fit in container
            const scale = Math.min(
                containerWidth / viewportWidth,
                containerHeight / viewportHeight
            );

            physicalWidth = viewportWidth * scale;
            physicalHeight = viewportHeight * scale;
        }

        // Ensure we don't have zero dimensions
        physicalWidth = Math.max(1, Math.floor(physicalWidth));
        physicalHeight = Math.max(1, Math.floor(physicalHeight));

        // Calculate centering position
        const left = Math.floor((containerWidth - physicalWidth) / 2);
        const top = Math.floor((containerHeight - physicalHeight) / 2);

        // Set canvas styles for proper display
        this.canvas.style.width = `${physicalWidth}px`;
        this.canvas.style.height = `${physicalHeight}px`;
        this.canvas.style.position = 'absolute';
        this.canvas.style.left = `${left}px`;
        this.canvas.style.top = `${top}px`;

        // Remove size constraints that might prevent proper scaling
        this.canvas.style.minWidth = '0';
        this.canvas.style.minHeight = '0';
        this.canvas.style.maxWidth = 'none';
        this.canvas.style.maxHeight = 'none';

        // Set the drawing surface size (use viewport dimensions)
        this.canvas.width = viewportWidth * pixelRatio;
        this.canvas.height = viewportHeight * pixelRatio;

        // Reset transform before scaling
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        if (pixelRatio !== 1) {
            this.ctx.scale(pixelRatio, pixelRatio);
        }

        // Update GUI and background canvas sizes to match main canvas
        if (this.guiCanvas) {
            this.guiCanvas.width = this.canvas.width;
            this.guiCanvas.height = this.canvas.height;
            const guiCtx = this.guiCanvas.getContext('2d');
            if (pixelRatio !== 1) {
                guiCtx.scale(pixelRatio, pixelRatio);
            }
        }
        if (this.backgroundCanvas) {
            this.backgroundCanvas.width = this.canvas.width;
            this.backgroundCanvas.height = this.canvas.height;
            const bgCtx = this.backgroundCanvas.getContext('2d');
            if (pixelRatio !== 1) {
                bgCtx.scale(pixelRatio, pixelRatio);
            }
        }

        // Update decal canvas size to match main canvas
        if (this.decalCanvas) {
            this.decalCanvas.width = this.canvas.width;
            this.decalCanvas.height = this.canvas.height;
            const decalCtx = this.decalCanvas.getContext('2d');
            if (pixelRatio !== 1) {
                decalCtx.scale(pixelRatio, pixelRatio);
            }
        }

        // Remove transform scaling which can cause positioning issues
        this.canvas.style.transform = 'none';

        // Configure image smoothing
        this.ctx.imageSmoothingEnabled = this.renderConfig.smoothing;

        // Apply appropriate CSS image rendering mode based on scale mode
        if (this.renderConfig.scaleMode === 'nearest-neighbor') {
            this.canvas.style.imageRendering = 'pixelated';
        } else {
            this.canvas.style.imageRendering = this.renderConfig.smoothing ? 'auto' : 'crisp-edges';
        }

        // If using WebGLCanvas, call its resize method
        if (this.useWebGL && this.ctx.resize) {
            this.ctx.resize(viewportWidth * pixelRatio, viewportHeight * pixelRatio);

            if (pixelRatio !== 1) {
                this.ctx.scale(pixelRatio, pixelRatio); // Ensure scaling is applied
            }
            return;
        }

        this.canvasResized = true;
        this.viewport.dirty = true; // Mark viewport as dirty after resize
    }

    cleanup() {
        // Clean up resources when engine is destroyed
        if (this.resizeObserver) {
            this.resizeObserver.disconnect();
        }

        this._resizeHandler = this.resizeCanvas.bind(this);
        window.addEventListener('resize', this._resizeHandler);
        window.addEventListener('panel-resized', this._resizeHandler);

        // Clear viewport callbacks
        this.viewportCallbacks = [];
    }
}

window.Engine = Engine; // Make available globally

// src/core/AssetManager.js
class AssetManager {
    constructor(fileBrowser = null) {
        this.fileBrowser = fileBrowser;
        this.cache = new Map();
        this.loadingPromises = new Map();
        this.assetRegistry = new Map();
        this.modal = null;

        // Asset type handlers
        this.typeHandlers = {
            'image': this.handleImageAsset.bind(this),
            'audio': this.handleAudioAsset.bind(this),
            'json': this.handleJsonAsset.bind(this),
            'text': this.handleTextAsset.bind(this)
        };

        // Enhanced FileBrowser integration
        this.setupFileBrowserIntegration();

        // Initialize modal after DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => this.initModal());
        } else {
            this.initModal();
        }
    }

    /**
     * Setup FileBrowser integration for automatic asset registration
     */
    setupFileBrowserIntegration() {
        // Don't try to override methods if FileBrowser isn't available yet
        if (!this.fileBrowser) {
            console.log('FileBrowser not available yet for AssetManager integration');
            return;
        }

        console.log('Setting up AssetManager integration with FileBrowser');

        // Store original methods
        const originalCreateFile = this.fileBrowser.createFile.bind(this.fileBrowser);
        const originalWriteFile = this.fileBrowser.writeFile ? this.fileBrowser.writeFile.bind(this.fileBrowser) : null;
        const originalDeleteItem = this.fileBrowser.deleteItem.bind(this.fileBrowser);

        // Override createFile to auto-register assets
        this.fileBrowser.createFile = async (path, content, overwrite = false) => {
            const result = await originalCreateFile(path, content, overwrite);
            if (result) {
                // Auto-register new assets
                setTimeout(() => this.registerAssetFromPath(path), 100);
            }
            return result;
        };

        // Override writeFile if it exists
        if (originalWriteFile) {
            this.fileBrowser.writeFile = async (path, content, overwrite = false) => {
                const result = await originalWriteFile(path, content, overwrite);
                if (result) {
                    setTimeout(() => this.registerAssetFromPath(path), 100);
                }
                return result;
            };
        }

        // Override deleteItem to remove from cache
        this.fileBrowser.deleteItem = async (path) => {
            const result = await originalDeleteItem(path);
            if (result) {
                this.removeAssetByPath(path);
            }
            return result;
        };
    }

    /**
     * Scan FileBrowser for existing assets and register them
     */
    async scanAndRegisterAssets() {
        if (!this.fileBrowser) {
            console.warn('No FileBrowser available for asset scanning');
            return;
        }

        try {
            console.log('Scanning FileBrowser for assets...');
            const allFiles = await this.fileBrowser.getAllFiles();

            for (const file of allFiles) {
                if (file.type === 'file') {
                    const assetType = this.detectAssetType(file.path);
                    if (assetType === 'image' || assetType === 'audio' || assetType === 'json') {
                        await this.registerAssetFromPath(file.path);
                    }
                }
            }

            console.log(`Registered ${this.assetRegistry.size} assets from FileBrowser`);
        } catch (error) {
            console.error('Error scanning FileBrowser for assets:', error);
        }
    }

    /**
     * Register an asset automatically from a file path
     * @param {string} path - File path
     */
    async registerAssetFromPath(path) {
        const assetType = this.detectAssetType(path);
        if (assetType !== 'text' || path.endsWith('.json')) { // Register media assets and JSON
            const normalizedPath = this.normalizePath(path);
            const assetId = this.generateAssetId(normalizedPath);

            try {
                // Load content from FileBrowser
                if (this.fileBrowser) {
                    await this.loadAsset(normalizedPath);
                    console.log(`Auto-registered asset: ${assetId} from ${path}`);
                }
            } catch (error) {
                console.warn(`Failed to auto-register asset from ${path}:`, error);
            }
        }
    }

    /**
     * Remove asset by file path
     * @param {string} path - File path
     */
    removeAssetByPath(path) {
        const assetId = this.generateAssetId(path);
        this.removeAsset(assetId);

        // Also remove by path variations
        const normalizedPath = this.normalizePath(path);
        this.cache.delete(normalizedPath);
        this.cache.delete(path);
    }

    /**
     * Get asset by path (enhanced for module integration)
     * @param {string} path - Asset path
     * @returns {Promise<any>} - The asset or null if not found
     */
    async getAssetByPath(path) {
        if (!path) return null;

        const normalizedPath = this.normalizePath(path);
        const assetId = this.generateAssetId(normalizedPath);

        // Check if already in cache
        let asset = this.getAsset(assetId);
        if (asset) return asset;

        // PRIORITY: If we're in editor mode, try FileBrowser first
        if (window.editor && window.editor.fileBrowser && typeof this.fileBrowser?.readFile === 'function') {
            try {
                console.log('AssetManager: Loading from FileBrowser first:', normalizedPath);
                asset = await this.loadAsset(normalizedPath);
                return asset;
            } catch (error) {
                console.warn('AssetManager: FileBrowser loading failed:', error);
            }
        }

        // Try loading from FileBrowser if available
        if (!this.fileBrowser) {
            console.warn('No FileBrowser available for asset loading');
            return null;
        }

        try {
            asset = await this.loadAsset(normalizedPath);
            return asset;
        } catch (error) {
            console.warn(`Could not load asset from FileBrowser path: ${path}`, error);
            return null;
        }
    }

    /**
     * Enhanced loadAsset method with better FileBrowser integration
     */
    async loadAsset(path) {
        const normalizedPath = this.normalizePath(path);
        const assetId = this.generateAssetId(normalizedPath);

        // Check if already cached
        if (this.cache.has(assetId)) {
            return this.cache.get(assetId);
        }

        if (this.cache.has(normalizedPath)) {
            return this.cache.get(normalizedPath);
        }

        // Check if currently loading
        if (this.loadingPromises.has(normalizedPath)) {
            return this.loadingPromises.get(normalizedPath);
        }

        // ONLY use FileBrowser for asset loading
        if (!this.fileBrowser || typeof this.fileBrowser.readFile !== 'function') {
            console.warn(`No FileBrowser available, cannot load asset: ${normalizedPath}`);
            throw new Error(`Asset loading requires FileBrowser: ${normalizedPath}`);
        }

        const promise = this.loadFromFileBrowser(normalizedPath);
        this.loadingPromises.set(normalizedPath, promise);

        try {
            const asset = await promise;

            // Cache under multiple keys for easy lookup
            this.cache.set(assetId, asset);
            this.cache.set(normalizedPath, asset);
            this.cache.set(path, asset); // Original path too

            // Register in asset registry
            const assetType = this.detectAssetType(normalizedPath);
            this.assetRegistry.set(assetId, {
                id: assetId,
                type: assetType,
                metadata: {
                    path: normalizedPath,
                    originalPath: path,
                    addedAt: Date.now(),
                    loadedFromPath: true
                }
            });

            return asset;

        } catch (error) {
            console.error(`Failed to load asset ${normalizedPath}:`, error);
            throw error;
        } finally {
            this.loadingPromises.delete(normalizedPath);
        }
    }

    /**
     * Get all available asset paths for modules to reference
     * @param {string} type - Optional type filter ('image', 'audio', etc.)
     * @returns {Array<Object>} - Array of {id, path, type} objects
     */
    getAvailableAssetPaths(type = null) {
        const assets = [];

        for (const [id, metadata] of this.assetRegistry) {
            if (!type || metadata.type === type) {
                assets.push({
                    id: id,
                    path: metadata.metadata.path || metadata.metadata.originalPath,
                    type: metadata.type,
                    displayName: this.getDisplayName(metadata.metadata.path || id)
                });
            }
        }

        return assets.sort((a, b) => a.displayName.localeCompare(b.displayName));
    }

    /**
     * Get display name for asset dropdown
     */
    getDisplayName(path) {
        if (!path) return 'Unknown';
        return path.split('/').pop().split('\\').pop();
    }

    /**
     * Enhanced cache lookup that tries multiple path variations
     * @param {string} path - Asset path to look up
     * @returns {any} - The cached asset or null
     */
    getCachedAsset(path) {
        if (!path) return null;

        // Try direct lookup first
        if (this.cache.has(path)) {
            return this.cache.get(path);
        }

        // Try with generated asset ID
        const assetId = this.generateAssetId(path);
        if (this.cache.has(assetId)) {
            return this.cache.get(assetId);
        }

        // Try normalized path
        const normalizedPath = this.normalizePath(path);
        if (this.cache.has(normalizedPath)) {
            return this.cache.get(normalizedPath);
        }

        // Try all stored cache keys for partial matches
        for (const [key, asset] of this.cache) {
            if (key.endsWith(path) || path.endsWith(key)) {
                return asset;
            }
        }

        return null;
    }

    /**
     * Serialize cache for project saving
     * @returns {Object} - Serializable cache data
     */
    serializeCache() {
        const serializedCache = {};

        for (const [key, asset] of this.cache) {
            try {
                if (asset instanceof HTMLImageElement) {
                    // Convert image to data URL
                    const canvas = document.createElement('canvas');
                    canvas.width = asset.naturalWidth || asset.width;
                    canvas.height = asset.naturalHeight || asset.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(asset, 0, 0);

                    serializedCache[key] = {
                        type: 'image',
                        content: canvas.toDataURL('image/png'),
                        width: canvas.width,
                        height: canvas.height
                    };
                } else if (asset instanceof HTMLAudioElement) {
                    // For audio, store the source if it's a data URL
                    if (asset.src && asset.src.startsWith('data:')) {
                        serializedCache[key] = {
                            type: 'audio',
                            content: asset.src
                        };
                    }
                } else if (typeof asset === 'string' || typeof asset === 'object') {
                    // Store text and JSON data directly
                    serializedCache[key] = {
                        type: 'data',
                        content: asset
                    };
                }
            } catch (error) {
                console.warn(`Failed to serialize asset ${key}:`, error);
            }
        }

        // Also serialize asset registry metadata
        const registryData = {};
        for (const [id, metadata] of this.assetRegistry) {
            registryData[id] = {
                type: metadata.type,
                metadata: metadata.metadata
            };
        }

        return {
            cache: serializedCache,
            registry: registryData,
            version: '1.0'
        };
    }

    /**
     * Deserialize cache from project loading
     * @param {Object} data - Serialized cache data
     */
    async deserializeCache(data) {
        if (!data || !data.cache) {
            console.warn('No cache data to deserialize');
            return;
        }

        // Clear current cache
        this.cache.clear();
        this.assetRegistry.clear();

        try {
            // Restore cache entries
            for (const [key, assetData] of Object.entries(data.cache)) {
                try {
                    if (assetData.type === 'image') {
                        const img = await this.loadImage(assetData.content);
                        this.cache.set(key, img);
                    } else if (assetData.type === 'audio') {
                        const audio = await this.loadAudio(assetData.content);
                        this.cache.set(key, audio);
                    } else if (assetData.type === 'data') {
                        this.cache.set(key, assetData.content);
                    }
                } catch (error) {
                    console.warn(`Failed to deserialize asset ${key}:`, error);
                }
            }

            // Restore registry
            if (data.registry) {
                for (const [id, metadata] of Object.entries(data.registry)) {
                    this.assetRegistry.set(id, metadata);
                }
            }

            console.log(`Deserialized ${this.cache.size} assets and ${this.assetRegistry.size} registry entries`);

        } catch (error) {
            console.error('Error deserializing asset cache:', error);
        }
    }

    /**
     * Enhanced export method for ExportManager integration
     */
    async exportAssetsForGame() {
        const exportData = {};
        const processedAssets = new Set(); // Track processed assets to avoid duplicates

        console.log('Exporting assets from AssetManager...');
        console.log('Asset registry size:', this.assetRegistry.size);
        console.log('Cache size:', this.cache.size);

        // Export from asset registry first (preferred method)
        for (const [id, metadata] of this.assetRegistry) {
            const asset = this.cache.get(id);
            if (!asset) continue;

            const path = metadata.metadata.path || metadata.metadata.originalPath;
            const normalizedPath = this.normalizePath(path);

            // Skip if already processed
            if (processedAssets.has(normalizedPath)) {
                continue;
            }
            processedAssets.add(normalizedPath);

            try {
                if (metadata.type === 'image' && asset instanceof HTMLImageElement) {
                    // Convert image to data URL for export
                    const canvas = document.createElement('canvas');
                    canvas.width = asset.naturalWidth || asset.width;
                    canvas.height = asset.naturalHeight || asset.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(asset, 0, 0);

                    exportData[normalizedPath] = {
                        content: canvas.toDataURL('image/png'),
                        type: 'image/png'
                    };

                    console.log('Exported image asset:', normalizedPath);
                } else if (metadata.type === 'audio' && asset instanceof HTMLAudioElement) {
                    // For audio, we need the original data URL or file content
                    if (asset.src && asset.src.startsWith('data:')) {
                        exportData[normalizedPath] = {
                            content: asset.src,
                            type: 'audio/mpeg' // Default, should be detected properly
                        };
                        console.log('Exported audio asset:', normalizedPath);
                    }
                } else if (typeof asset === 'string') {
                    // Text content
                    exportData[normalizedPath] = {
                        content: asset,
                        type: 'text/plain'
                    };
                    console.log('Exported text asset:', normalizedPath);
                } else if (typeof asset === 'object' && asset !== null) {
                    // JSON content
                    exportData[normalizedPath] = {
                        content: JSON.stringify(asset),
                        type: 'application/json'
                    };
                    console.log('Exported JSON asset:', normalizedPath);
                }
            } catch (error) {
                console.warn(`Failed to export asset ${path}:`, error);
            }
        }

        console.log('Total assets exported:', Object.keys(exportData).length);
        return exportData;
    }

    /**
     * Add an asset to the manager with a unique ID
     * @param {string} id - Unique identifier for the asset
     * @param {string|File|Blob|HTMLImageElement|HTMLAudioElement} content - Asset content
     * @param {string} type - Asset type (image, audio, json, text)
     * @param {Object} metadata - Additional metadata
     * @returns {Promise<string>} - Asset ID
     */
    async addAsset(id, content, type, metadata = {}) {
        console.log(`Adding asset: ${id} (type: ${type})`);

        // Store metadata
        this.assetRegistry.set(id, {
            id,
            type,
            metadata: {
                ...metadata,
                addedAt: Date.now(),
                originalPath: metadata.path || id
            }
        });

        // Process the content based on type
        const handler = this.typeHandlers[type] || this.handleGenericAsset.bind(this);
        const processedAsset = await handler(content, metadata);

        // Store the processed asset
        this.cache.set(id, processedAsset);

        console.log(`Asset added successfully: ${id}`);
        return id;
    }

    /**
     * Get an asset by ID
     * @param {string} id - Asset ID
     * @returns {any} - The asset or null if not found
     */
    getAsset(id) {
        if (this.cache.has(id)) {
            return this.cache.get(id);
        }

        console.warn(`Asset not found: ${id}`);
        return null;
    }

    /**
     * Get an image asset by ID
     * @param {string} id - Image asset ID
     * @returns {HTMLImageElement|null} - The image element or null
     */
    getImage(id) {
        const asset = this.getAsset(id);
        if (asset && asset instanceof HTMLImageElement) {
            return asset;
        }

        console.warn(`Image asset not found or invalid type: ${id}`);
        return null;
    }

    /**
     * Get an audio asset by ID
     * @param {string} id - Audio asset ID
     * @returns {HTMLAudioElement|null} - The audio element or null
     */
    getAudio(id) {
        const asset = this.getAsset(id);
        if (asset && asset instanceof HTMLAudioElement) {
            return asset;
        }

        console.warn(`Audio asset not found or invalid type: ${id}`);
        return null;
    }

    /**
     * Get a JSON asset by ID
     * @param {string} id - JSON asset ID
     * @returns {Object|null} - The parsed JSON object or null
     */
    getJson(id) {
        const asset = this.getAsset(id);
        if (asset && typeof asset === 'object' && asset !== null) {
            return asset;
        }

        console.warn(`JSON asset not found or invalid type: ${id}`);
        return null;
    }

    /**
     * Get a text asset by ID
     * @param {string} id - Text asset ID
     * @returns {string|null} - The text content or null
     */
    getText(id) {
        const asset = this.getAsset(id);
        if (typeof asset === 'string') {
            return asset;
        }

        console.warn(`Text asset not found or invalid type: ${id}`);
        return null;
    }

    /**
     * Check if an asset exists
     * @param {string} id - Asset ID
     * @returns {boolean} - True if asset exists
     */
    hasAsset(id) {
        return this.cache.has(id);
    }

    /**
     * Remove an asset from the cache
     * @param {string} id - Asset ID
     * @returns {boolean} - True if asset was removed
     */
    removeAsset(id) {
        const removed = this.cache.delete(id);
        this.assetRegistry.delete(id);

        if (removed) {
            console.log(`Asset removed: ${id}`);
        }

        return removed;
    }

    /**
     * Get all asset IDs
     * @returns {string[]} - Array of asset IDs
     */
    getAssetIds() {
        return Array.from(this.cache.keys());
    }

    /**
     * Get assets by type
     * @param {string} type - Asset type to filter by
     * @returns {Object[]} - Array of assets with their IDs
     */
    getAssetsByType(type) {
        const assets = [];

        for (const [id, metadata] of this.assetRegistry) {
            if (metadata.type === type) {
                assets.push({
                    id,
                    asset: this.cache.get(id),
                    metadata
                });
            }
        }

        return assets;
    }

    /**
     * Handle image asset processing
     */
    async handleImageAsset(content, metadata = {}) {
        if (content instanceof HTMLImageElement) {
            return content;
        }

        if (content instanceof File || content instanceof Blob) {
            const dataUrl = await this.blobToDataURL(content);
            return this.loadImage(dataUrl);
        }

        if (typeof content === 'string') {
            if (content.startsWith('data:image/') || content.startsWith('blob:') || content.startsWith('http')) {
                return this.loadImage(content);
            }
        }

        throw new Error('Invalid image content type');
    }

    /**
     * Handle audio asset processing
     */
    async handleAudioAsset(content, metadata = {}) {
        if (content instanceof HTMLAudioElement) {
            return content;
        }

        if (content instanceof File || content instanceof Blob) {
            const dataUrl = await this.blobToDataURL(content);
            return this.loadAudio(dataUrl);
        }

        if (typeof content === 'string') {
            if (content.startsWith('data:audio/') || content.startsWith('blob:') || content.startsWith('http')) {
                return this.loadAudio(content);
            }
        }

        throw new Error('Invalid audio content type');
    }

    /**
     * Handle JSON asset processing
     */
    async handleJsonAsset(content, metadata = {}) {
        if (typeof content === 'object' && content !== null) {
            return content;
        }

        if (typeof content === 'string') {
            return JSON.parse(content);
        }

        if (content instanceof File || content instanceof Blob) {
            const text = await content.text();
            return JSON.parse(text);
        }

        throw new Error('Invalid JSON content type');
    }

    /**
     * Handle text asset processing
     */
    async handleTextAsset(content, metadata = {}) {
        if (typeof content === 'string') {
            return content;
        }

        if (content instanceof File || content instanceof Blob) {
            return content.text();
        }

        throw new Error('Invalid text content type');
    }

    /**
     * Handle generic asset processing
     */
    async handleGenericAsset(content, metadata = {}) {
        return content;
    }

    /**
     * Add embedded assets for exported games
     * @param {Object} assetsData - Object containing all asset data
     */
    addEmbeddedAssets(assetsData) {
        console.log('Adding embedded assets to AssetManager:', Object.keys(assetsData));

        for (const [path, assetInfo] of Object.entries(assetsData)) {
            const assetId = this.generateAssetId(path);
            const assetType = assetInfo.type ? this.getAssetTypeFromMime(assetInfo.type) : this.detectAssetType(path);

            // Add asset using the standard method
            this.addAsset(assetId, assetInfo.content, assetType, {
                path,
                originalType: assetInfo.type,
                embedded: true
            }).then(() => {
                console.log('Successfully added embedded asset:', path);
            }).catch(error => {
                console.error(`Failed to add embedded asset ${path}:`, error);
            });
        }
    }

    /**
     * Generate a unique asset ID from a path
     * @param {string} path - Asset path
     * @returns {string} - Generated asset ID
     */
    generateAssetId(path) {
        // Remove file extension and path separators, convert to camelCase
        const filename = path.split('/').pop().split('\\').pop();
        const nameWithoutExt = filename.split('.')[0];

        // Convert to camelCase and ensure it's a valid identifier
        const camelCase = nameWithoutExt
            .replace(/[^a-zA-Z0-9]/g, '_')
            .replace(/_+/g, '_')
            .replace(/^_|_$/g, '')
            .replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());

        // Ensure it doesn't start with a number
        if (/^\d/.test(camelCase)) {
            return 'asset_' + camelCase;
        }

        return camelCase || 'asset_' + Date.now();
    }

    /**
     * Detect asset type from path/filename
     * @param {string} path - Asset path
     * @returns {string} - Detected asset type
     */
    detectAssetType(path) {
        const extension = path.split('.').pop().toLowerCase();

        const typeMap = {
            // Images
            'png': 'image', 'jpg': 'image', 'jpeg': 'image', 'gif': 'image',
            'webp': 'image', 'svg': 'image', 'bmp': 'image', 'ico': 'image',

            // Audio
            'mp3': 'audio', 'wav': 'audio', 'ogg': 'audio', 'aac': 'audio',
            'flac': 'audio', 'm4a': 'audio', 'wma': 'audio',

            // Data
            'json': 'json',

            // Text
            'txt': 'text', 'md': 'text', 'csv': 'text', 'xml': 'text'
        };

        return typeMap[extension] || 'text';
    }

    /**
     * Get asset type from MIME type
     * @param {string} mimeType - MIME type
     * @returns {string} - Asset type
     */
    getAssetTypeFromMime(mimeType) {
        if (mimeType.startsWith('image/')) return 'image';
        if (mimeType.startsWith('audio/')) return 'audio';
        if (mimeType.includes('json')) return 'json';
        return 'text';
    }

    /**
     * Normalize path for consistent key lookup
     * @param {string} path - Path to normalize
     * @returns {string} - Normalized path
     */
    normalizePath(path) {
        if (!path) return '';

        // Ensure path uses forward slashes and starts with /
        let normalized = path.replace(/\\/g, '/');

        // Remove leading ./ if present
        if (normalized.startsWith('./')) {
            normalized = normalized.substring(2);
        }

        // Ensure it starts with / for FileBrowser
        if (!normalized.startsWith('/')) {
            normalized = '/' + normalized;
        }

        // Remove double slashes
        normalized = normalized.replace(/\/+/g, '/');

        try {
            normalized = decodeURIComponent(normalized);
        } catch (e) {
            // If decoding fails, use the original normalized path
        }

        return normalized;
    }

    /**
     * Load image from source
     * @param {string} src - Image source
     * @returns {Promise<HTMLImageElement>} - Loaded image
     */
    loadImage(src) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.onerror = () => reject(new Error(`Failed to load image: ${src}`));
            img.src = src;
        });
    }

    /**
     * Load audio from source
     * @param {string} src - Audio source
     * @returns {Promise<HTMLAudioElement>} - Loaded audio
     */
    loadAudio(src) {
        return new Promise((resolve, reject) => {
            const audio = new Audio();
            audio.oncanplaythrough = () => resolve(audio);
            audio.onerror = () => reject(new Error(`Failed to load audio: ${src}`));
            audio.src = src;
        });
    }

    /**
     * Convert Blob to data URL
     * @param {Blob} blob - Blob to convert
     * @returns {Promise<string>} - Data URL
     */
    async blobToDataURL(blob) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
        });
    }

    /**
     * Load asset from file browser
     * @param {string} path - Asset path
     * @returns {Promise<any>} - Loaded asset
     */
    async loadFromFileBrowser(path) {
        try {
            // Ensure path starts with / for FileBrowser
            const fileBrowserPath = path.startsWith('/') ? path : `/${path}`;

            console.log(`Loading asset from FileBrowser: ${fileBrowserPath}`);

            // Read file content from FileBrowser
            const content = await this.fileBrowser.readFile(fileBrowserPath);
            if (!content) {
                throw new Error(`Asset not found in file browser: ${fileBrowserPath}`);
            }

            const assetType = this.detectAssetType(path);
            console.log(`Processing asset as type: ${assetType}`);

            // Handle different content types based on what FileBrowser returns
            if (typeof content === 'string') {
                // FileBrowser returned string content (could be data URL or text)
                if (assetType === 'image' && content.startsWith('data:image/')) {
                    return this.loadImage(content);
                } else if (assetType === 'audio' && content.startsWith('data:audio/')) {
                    return this.loadAudio(content);
                } else if (assetType === 'json') {
                    try {
                        return JSON.parse(content);
                    } catch (e) {
                        console.warn(`Failed to parse JSON from ${path}, treating as text`);
                        return content;
                    }
                } else {
                    // Text content
                    return content;
                }
            } else if (content instanceof Blob || content instanceof File) {
                // FileBrowser returned binary content
                const handler = this.typeHandlers[assetType] || this.handleGenericAsset.bind(this);
                return handler(content);
            } else {
                // Unknown content type, return as-is
                return content;
            }

        } catch (error) {
            throw new Error(`Failed to load asset from file browser: ${path} - ${error.message}`);
        }
    }

    /**
     * Load asset from URL
     * @param {string} path - Asset path
     * @returns {Promise<any>} - Loaded asset
     */
    async loadFromUrl(path) {
        try {
            const fullPath = this.basePath ? `${this.basePath}${path}` : path;
            const response = await fetch(fullPath);

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }

            const assetType = this.detectAssetType(path);

            if (assetType === 'image') {
                const blob = await response.blob();
                const dataUrl = await this.blobToDataURL(blob);
                return this.loadImage(dataUrl);
            } else if (assetType === 'audio') {
                const blob = await response.blob();
                const dataUrl = await this.blobToDataURL(blob);
                return this.loadAudio(dataUrl);
            } else if (assetType === 'json') {
                return response.json();
            } else {
                return response.text();
            }

        } catch (error) {
            throw new Error(`Failed to load asset from URL: ${path} - ${error.message}`);
        }
    }

    /**
     * Clear all assets
     */
    clearAll() {
        this.cache.clear();
        this.assetRegistry.clear();
        this.loadingPromises.clear();
        console.log('All assets cleared');
    }

    /**
     * Get cache statistics
     * @returns {Object} - Cache statistics
     */
    getStats() {
        const stats = {
            totalAssets: this.cache.size,
            byType: {}
        };

        for (const [id, metadata] of this.assetRegistry) {
            const type = metadata.type;
            stats.byType[type] = (stats.byType[type] || 0) + 1;
        }

        return stats;
    }

    initModal() {
        // Create modal container
        this.modal = document.createElement('div');
        this.modal.className = 'asset-modal';
        this.modal.innerHTML = `
            <div class="asset-modal-content">
                <div class="asset-modal-header">
                    <h2 class="asset-modal-title">Export Assets</h2>
                    <button class="asset-modal-close"><i class="fas fa-times"></i></button>
                </div>
                <div class="asset-modal-body">
                    <div class="asset-tree"></div>
                    <div class="asset-actions">
                        <button class="asset-button select-all">Select All</button>
                        <button class="asset-button export">Export Selected</button>
                    </div>
                </div>
            </div>
        `;

        // Add CSS styles for icon selector
        const style = document.createElement('style');
        style.textContent = `
            .asset-pack-info {
                margin-bottom: 20px;
                padding: 16px;
                background: #3d3d3d;
                border-radius: 6px;
                border: 1px solid #555;
            }
            
            .asset-input-group {
                margin-bottom: 16px;
            }
            
            .asset-input-group label {
                display: block;
                margin-bottom: 6px;
                color: #ccc;
                font-size: 14px;
                font-weight: 500;
            }
            
            .asset-input-group input,
            .asset-input-group textarea {
                width: 100%;
                padding: 8px 12px;
                background: #2a2a2a;
                border: 1px solid #555;
                border-radius: 4px;
                color: #fff;
                font-size: 14px;
                font-family: inherit;
            }
            
            .asset-input-group input:focus,
            .asset-input-group textarea:focus {
                outline: none;
                border-color: #0078d4;
                box-shadow: 0 0 0 2px rgba(0, 120, 212, 0.2);
            }
            
            .icon-selector {
                display: flex;
                align-items: center;
                gap: 16px;
            }
            
            .icon-preview {
                width: 80px;
                height: 80px;
                background: #2a2a2a;
                border: 2px dashed #555;
                border-radius: 8px;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                text-align: center;
                color: #888;
                font-size: 12px;
                flex-shrink: 0;
            }
            
            .icon-preview img {
                border-radius: 4px;
            }
            
            .icon-preview span {
                margin-top: 4px;
                font-size: 10px;
            }
            
            .icon-controls {
                display: flex;
                flex-direction: column;
                gap: 8px;
            }
            
            .asset-tree-section h3 {
                color: #fff;
                margin-bottom: 12px;
                font-size: 16px;
            }
        `;
        document.head.appendChild(style);

        document.body.appendChild(this.modal);
        this.setupEventListeners();
    }

    setupEventListeners() {
        // Close button
        this.modal.querySelector('.asset-modal-close').addEventListener('click', () => {
            this.hideModal();
        });

        // Select all button
        this.modal.addEventListener('click', (e) => {
            if (e.target.classList.contains('select-all')) {
                const checkboxes = this.modal.querySelectorAll('.asset-item input[type="checkbox"]');
                checkboxes.forEach(cb => cb.checked = true);
            }

            if (e.target.classList.contains('select-none')) {
                const checkboxes = this.modal.querySelectorAll('.asset-item input[type="checkbox"]');
                checkboxes.forEach(cb => cb.checked = false);
            }

            if (e.target.classList.contains('export')) {
                this.exportSelected();
            }
        });

        // Click outside to close
        /*this.modal.addEventListener('click', (e) => {
            if (e.target === this.modal) {
                this.hideModal();
            }
        });*/
    }

    async showExportModal() {
        const files = await this.fileBrowser.getAllFiles();
        const tree = this.modal.querySelector('.asset-tree');
        tree.innerHTML = '';

        // Group files by directory
        const fileTree = this.buildFileTree(files);
        this.renderFileTree(fileTree, tree);

        // Update modal content to include name, description, and icon fields
        const modalBody = this.modal.querySelector('.asset-modal-body');
        modalBody.innerHTML = `
        <div class="asset-pack-info">
            <div class="asset-input-group">
                <label for="asset-pack-name">Asset Pack Name:</label>
                <input type="text" id="asset-pack-name" placeholder="Enter asset pack name" value="My Asset Pack">
            </div>
            <div class="asset-input-group">
                <label for="asset-pack-description">Description:</label>
                <textarea id="asset-pack-description" placeholder="Enter a description for this asset pack" rows="3"></textarea>
            </div>
            <div class="asset-input-group">
                <label for="asset-pack-version">Version:</label>
                <input type="text" id="asset-pack-version" placeholder="1.0.0" value="1.0.0">
            </div>
            <div class="asset-input-group">
                <label for="asset-pack-author">Author:</label>
                <input type="text" id="asset-pack-author" placeholder="Your name">
            </div>
            <div class="asset-input-group">
                <label for="asset-pack-icon">Icon (optional):</label>
                <div class="icon-selector">
                    <div class="icon-preview" id="icon-preview">
                        <i class="fas fa-image" style="font-size: 48px; color: #666;"></i>
                        <span>No icon selected</span>
                    </div>
                    <div class="icon-controls">
                        <button type="button" class="asset-button select-icon">Select Icon</button>
                        <button type="button" class="asset-button remove-icon" style="display: none;">Remove Icon</button>
                    </div>
                </div>
            </div>
        </div>
        <div class="asset-tree-section">
            <h3>Select Assets to Export</h3>
            <div class="asset-tree"></div>
        </div>
        <div class="asset-actions">
            <button class="asset-button select-all">Select All</button>
            <button class="asset-button select-none">Select None</button>
            <button class="asset-button export">Export Selected</button>
        </div>
    `;

        // Re-render the file tree in the new structure
        const newTree = modalBody.querySelector('.asset-tree');
        this.renderFileTree(fileTree, newTree);

        // Setup icon selection
        this.setupIconSelector();

        this.modal.style.display = 'flex';
    }

    hideModal() {
        this.modal.style.display = 'none';
    }

    buildFileTree(files) {
        const tree = {};
        files.forEach(file => {
            const parts = file.path.split('/').filter(Boolean);
            let current = tree;
            parts.forEach((part, i) => {
                if (i === parts.length - 1) {
                    if (!current.files) current.files = [];
                    current.files.push(file);
                } else {
                    current.dirs = current.dirs || {};
                    current.dirs[part] = current.dirs[part] || {};
                    current = current.dirs[part];
                }
            });
        });
        return tree;
    }

    renderFileTree(tree, container, path = '') {
        // Render directories
        if (tree.dirs) {
            Object.entries(tree.dirs).forEach(([name, subTree]) => {
                const dirElement = document.createElement('div');
                dirElement.className = 'asset-directory';
                dirElement.innerHTML = `
                    <div class="asset-dir-header">
                        <input type="checkbox" data-path="${path}/${name}">
                        <i class="fas fa-folder"></i>
                        <span>${name}</span>
                    </div>
                    <div class="asset-dir-content"></div>
                `;
                container.appendChild(dirElement);

                // Handle directory checkbox
                const checkbox = dirElement.querySelector('input[type="checkbox"]');
                const content = dirElement.querySelector('.asset-dir-content');
                checkbox.addEventListener('change', () => {
                    const items = content.querySelectorAll('input[type="checkbox"]');
                    items.forEach(item => item.checked = checkbox.checked);
                });

                this.renderFileTree(subTree, content, `${path}/${name}`);
            });
        }

        // Render files
        if (tree.files) {
            tree.files.forEach(file => {
                const fileElement = document.createElement('div');
                fileElement.className = 'asset-item';
                fileElement.innerHTML = `
                    <input type="checkbox" data-path="${file.path}">
                    <i class="fas fa-file"></i>
                    <span>${file.name}</span>
                `;
                container.appendChild(fileElement);
            });
        }
    }

    setupIconSelector() {
        const selectIconBtn = this.modal.querySelector('.select-icon');
        const removeIconBtn = this.modal.querySelector('.remove-icon');
        const iconPreview = this.modal.querySelector('#icon-preview');

        // Store selected icon data
        this.selectedIcon = null;

        selectIconBtn.addEventListener('click', async () => {
            try {
                // Create file input for icon selection
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*';

                input.onchange = async (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        await this.handleIconSelection(file, iconPreview, removeIconBtn);
                    }
                };

                input.click();
            } catch (error) {
                console.error('Error selecting icon:', error);
                this.fileBrowser?.showNotification?.('Error selecting icon: ' + error.message, 'error');
            }
        });

        removeIconBtn.addEventListener('click', () => {
            this.selectedIcon = null;
            iconPreview.innerHTML = `
                <i class="fas fa-image" style="font-size: 48px; color: #666;"></i>
                <span>No icon selected</span>
            `;
            removeIconBtn.style.display = 'none';
        });
    }

    async handleIconSelection(file, iconPreview, removeIconBtn) {
        try {
            // Validate file type
            if (!file.type.startsWith('image/')) {
                throw new Error('Please select a valid image file');
            }

            // Validate file size (max 5MB)
            if (file.size > 5 * 1024 * 1024) {
                throw new Error('Image file size must be less than 5MB');
            }

            // Create image element for resizing
            const img = new Image();
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            // Load the image
            const imageDataUrl = await this.fileToDataURL(file);

            await new Promise((resolve, reject) => {
                img.onload = resolve;
                img.onerror = () => reject(new Error('Failed to load image'));
                img.src = imageDataUrl;
            });

            // Resize to 128x128
            canvas.width = 128;
            canvas.height = 128;

            // Draw image with proper scaling to maintain aspect ratio
            const { width, height, x, y } = this.calculateImageFit(img.width, img.height, 128, 128);

            // Fill background with transparent pixels
            ctx.clearRect(0, 0, 128, 128);

            // Draw the resized image
            ctx.drawImage(img, x, y, width, height);

            // Convert to data URL
            const resizedDataUrl = canvas.toDataURL('image/png');

            // Store the icon data
            this.selectedIcon = {
                data: resizedDataUrl,
                originalName: file.name,
                size: Math.round(resizedDataUrl.length * 0.75) // Approximate size
            };

            // Update preview
            iconPreview.innerHTML = `
                <img src="${resizedDataUrl}" style="width: 64px; height: 64px; border-radius: 4px; border: 1px solid #555;">
                <span style="font-size: 12px; color: #aaa;">${file.name} (128x128)</span>
            `;

            removeIconBtn.style.display = 'inline-block';

            this.fileBrowser?.showNotification?.('Icon resized and ready for export', 'success');

        } catch (error) {
            console.error('Error processing icon:', error);
            this.fileBrowser?.showNotification?.('Error processing icon: ' + error.message, 'error');
        }
    }

    calculateImageFit(srcWidth, srcHeight, targetWidth, targetHeight) {
        const scale = Math.min(targetWidth / srcWidth, targetHeight / srcHeight);
        const width = srcWidth * scale;
        const height = srcHeight * scale;
        const x = (targetWidth - width) / 2;
        const y = (targetHeight - height) / 2;

        return { width, height, x, y };
    }

    fileToDataURL(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = e => resolve(e.target.result);
            reader.onerror = reject;
            reader.readAsDataURL(file);
        });
    }

    async exportSelected() {
        const selectedFiles = this.modal.querySelectorAll('.asset-item input[type="checkbox"]:checked');
        const selectedDirs = this.modal.querySelectorAll('.asset-dir-header input[type="checkbox"]:checked');
        const files = [];

        // Get pack metadata
        const packName = this.modal.querySelector('#asset-pack-name').value.trim() || 'Untitled Asset Pack';
        const packDescription = this.modal.querySelector('#asset-pack-description').value.trim() || '';
        const packVersion = this.modal.querySelector('#asset-pack-version').value.trim() || '1.0.0';
        const packAuthor = this.modal.querySelector('#asset-pack-author').value.trim() || '';

        // Collect explicitly selected directories
        const explicitlySelectedDirs = new Set();
        for (const checkbox of selectedDirs) {
            const dirPath = checkbox.dataset.path;
            explicitlySelectedDirs.add(dirPath);
        }

        // Collect selected files
        for (const checkbox of selectedFiles) {
            const path = checkbox.dataset.path;
            const file = await this.fileBrowser.getFile(path);
            if (file) {
                files.push({
                    path: file.path,
                    content: file.content,
                    type: file.type,
                    name: file.name,
                    parentPath: file.parentPath,
                    created: file.created,
                    modified: file.modified
                });
            }
        }

        if (files.length === 0) {
            alert('No files selected for export');
            return;
        }

        // Build directory structure - only include explicitly selected directories
        const directories = new Set();

        // Add explicitly selected directories first
        explicitlySelectedDirs.forEach(dirPath => {
            if (dirPath && dirPath !== '/') {
                directories.add(dirPath);
            }
        });

        // For each selected file, check if any parent directories are explicitly selected
        // If so, include those parent directories (but not auto-created ones)
        files.forEach(file => {
            let currentPath = file.parentPath;
            while (currentPath && currentPath !== '/') {
                // Only add this directory if it was explicitly selected
                if (explicitlySelectedDirs.has(currentPath)) {
                    directories.add(currentPath);

                    // Also add any parent directories of explicitly selected directories
                    let parentOfSelected = currentPath.substring(0, currentPath.lastIndexOf('/')) || '/';
                    while (parentOfSelected && parentOfSelected !== '/' && explicitlySelectedDirs.has(parentOfSelected)) {
                        directories.add(parentOfSelected);
                        parentOfSelected = parentOfSelected.substring(0, parentOfSelected.lastIndexOf('/')) || '/';
                    }
                }
                currentPath = currentPath.substring(0, currentPath.lastIndexOf('/')) || '/';
            }
        });

        // Convert directories to array and sort
        const directoryList = Array.from(directories).sort();

        // Create enhanced asset package
        const assetPackage = {
            // Package metadata
            name: packName,
            description: packDescription,
            version: packVersion,
            author: packAuthor,
            timestamp: Date.now(),

            // Icon data (if selected)
            icon: this.selectedIcon ? {
                data: this.selectedIcon.data,
                originalName: this.selectedIcon.originalName,
                size: this.selectedIcon.size
            } : null,

            // Structure information
            directories: directoryList,
            totalFiles: files.length,
            totalDirectories: directoryList.length,

            // File data
            files: files,

            // Additional metadata
            metadata: {
                exportedBy: 'Dark Matter JS Game Engine',
                exportVersion: '1.0',
                engineVersion: window.engineVersion || '1.0.0',
                selectionMode: 'explicit-directories-only' // Indicates this export method
            }
        };

        // Create and download file
        const blob = new Blob([JSON.stringify(assetPackage, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;

        // Sanitize filename
        const sanitizedName = packName.replace(/[^a-z0-9]/gi, '_').toLowerCase();
        a.download = `${sanitizedName}.dmjs`;

        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        this.fileBrowser.showNotification(`Asset pack "${packName}" exported successfully!`, 'success');
        this.hideModal();
    }

    async importAssets(file) {
        try {
            const content = await this.readFileContent(file);
            const assetPackage = JSON.parse(content);

            if (!assetPackage.version || !assetPackage.files) {
                throw new Error('Invalid asset package format');
            }

            // Show import confirmation with package details
            const confirmMessage = `Import Asset Pack: "${assetPackage.name}"
        
Description: ${assetPackage.description || 'No description'}
Version: ${assetPackage.version}
Author: ${assetPackage.author || 'Unknown'}
Files: ${assetPackage.totalFiles || assetPackage.files.length}
Directories: ${assetPackage.totalDirectories || 0}

Continue with import?`;

            if (!confirm(confirmMessage)) {
                return;
            }

            // Create directory based on package name
            const packageName = assetPackage.name || file.name.replace('.dmjs', '');
            const sanitizedPackageName = packageName.replace(/[^a-z0-9\s]/gi, '_');
            const importPath = `/${sanitizedPackageName}`;

            // Ensure the main directory exists
            await this.fileBrowser.createDirectory(importPath);

            // Create all directories first (if directory structure is preserved)
            if (assetPackage.directories) {
                for (const dirPath of assetPackage.directories) {
                    const newDirPath = `${importPath}${dirPath}`;
                    await this.fileBrowser.createDirectory(newDirPath);
                }
            }

            // Import files with preserved directory structure
            let successCount = 0;
            let errorCount = 0;

            for (const fileEntry of assetPackage.files) {
                try {
                    // Preserve original directory structure
                    const newPath = `${importPath}${fileEntry.path}`;

                    // Ensure parent directories exist
                    const parentPath = newPath.substring(0, newPath.lastIndexOf('/'));
                    if (parentPath !== importPath && parentPath !== '/') {
                        await this.fileBrowser.createDirectory(parentPath);
                    }

                    // Write the file
                    await this.fileBrowser.writeFile(newPath, fileEntry.content, true);
                    successCount++;
                } catch (error) {
                    console.error(`Error importing file ${fileEntry.path}:`, error);
                    errorCount++;
                }
            }

            this.fileBrowser.refreshFiles();

            const statusMessage = errorCount > 0
                ? `Asset pack imported with ${successCount} files succeeded, ${errorCount} files failed`
                : `Asset pack "${packageName}" imported successfully with ${successCount} files`;

            this.fileBrowser.showNotification(statusMessage, errorCount > 0 ? 'warning' : 'success');

            // Navigate to the newly created directory
            await this.fileBrowser.navigateTo(importPath);

        } catch (error) {
            console.error('Error importing assets:', error);
            this.fileBrowser.showNotification(`Error importing assets: ${error.message}`, 'error');
        }
    }

    readFileContent(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = e => resolve(e.target.result);
            reader.onerror = e => reject(e.target.error);
            reader.readAsText(file);
        });
    }
}

window.assetManager = new AssetManager(window.fileBrowser || null);

// src/core/AssetReference.js
/**
 * AssetReference - A class that represents a reference to an asset in the file browser
 * 
 * This class allows module properties to reference assets in the file system,
 * such as images, audio files, and scripts, with proper serialization support.
 */
class AssetReference {
    constructor(path = null, type = 'any') {
        this.path = path;
        this.type = type; // 'image', 'audio', 'script', 'any'
        this._cachedData = null;
        this._isLoading = false;
        this._loadPromise = null;
    }
    
    /**
     * Check if this reference has a valid path
     */
    isValid() {
        return !!this.path;
    }
    
    /**
     * Get the filename without path
     */
    getFilename() {
        if (!this.path) return null;
        return this.path.split('/').pop().split('\\').pop();
    }
    
    /**
     * Get the file extension
     */
    getExtension() {
        if (!this.path) return null;
        return this.path.split('.').pop().toLowerCase();
    }
    
    /**
     * Load the referenced asset
     * @returns {Promise<any>} The loaded asset data
     */
    async load() {
        // If already loaded, return cached data
        if (this._cachedData) {
            return this._cachedData;
        }
        
        // If already loading, return the existing promise
        if (this._isLoading && this._loadPromise) {
            return this._loadPromise;
        }
        
        // If no path, return null
        if (!this.path) {
            return null;
        }
        
        this._isLoading = true;

        // --- Support exported runtime asset loading ---
        this._loadPromise = new Promise(async (resolve, reject) => {
            try {
                // If running in exported game (no FileBrowser), load from assets folder or embedded data
                if (!window.fileBrowser) {
                    // Try to load from assets folder (ZIP export) or embedded data (standalone HTML)
                    const extension = this.getExtension();
                    let assetUrl = null;

                    // If path is already a data URL, use it directly
                    if (this.path.startsWith('data:image/') || this.path.startsWith('data:audio/')) {
                        assetUrl = this.path;
                    } else if (window.__ASSET_MAP && window.__ASSET_MAP[this.path]) {
                        // If a global asset map is present (for standalone HTML), use it
                        assetUrl = window.__ASSET_MAP[this.path];
                    } else {
                        // Otherwise, assume assets are in 'assets/' folder (ZIP export)
                        assetUrl = 'assets/' + this.getFilename();
                    }

                    if (['png', 'jpg', 'jpeg', 'gif', 'webp', 'svg'].includes(extension) || assetUrl.startsWith('data:image/')) {
                        // Image asset
                        const img = new Image();
                        const imgPromise = new Promise((imgResolve, imgReject) => {
                            img.onload = () => imgResolve(img);
                            img.onerror = (err) => imgReject(new Error(`Error loading image: ${err.message || 'Unknown error'}`));
                        });
                        img.src = assetUrl;
                        this._cachedData = await imgPromise;
                        resolve(this._cachedData);

                    } else if (['mp3', 'wav', 'ogg', 'aac'].includes(extension) || assetUrl.startsWith('data:audio/')) {
                        // Audio asset
                        const audio = new Audio();
                        const audioPromise = new Promise((audioResolve, audioReject) => {
                            audio.oncanplaythrough = () => audioResolve(audio);
                            audio.onerror = (err) => audioReject(new Error(`Error loading audio: ${err.message || 'Unknown error'}`));
                        });
                        audio.src = assetUrl;
                        this._cachedData = await audioPromise;
                        resolve(this._cachedData);

                    } else if (extension === 'js') {
                        // Script asset (fetch as text)
                        try {
                            const response = await fetch(assetUrl);
                            if (!response.ok) throw new Error(`Failed to fetch script: ${assetUrl}`);
                            const scriptContent = await response.text();
                            this._cachedData = scriptContent;
                            resolve(this._cachedData);
                        } catch (err) {
                            reject(err);
                        }

                    } else {
                        // Default: fetch as text or blob
                        try {
                            const response = await fetch(assetUrl);
                            if (!response.ok) throw new Error(`Failed to fetch asset: ${assetUrl}`);
                            const content = await response.text();
                            this._cachedData = content;
                            resolve(this._cachedData);
                        } catch (err) {
                            reject(err);
                        }
                    }
                    return;
                }

                // Editor mode: use FileBrowser
                const content = await window.fileBrowser.readFile(this.path);
                if (!content) {
                    throw new Error(`File not found: ${this.path}`);
                }
                const extension = this.getExtension();
                if (['png', 'jpg', 'jpeg', 'gif', 'webp', 'svg'].includes(extension) || content.startsWith('data:image/')) {
                    const img = new Image();
                    const imgPromise = new Promise((imgResolve, imgReject) => {
                        img.onload = () => imgResolve(img);
                        img.onerror = (err) => imgReject(new Error(`Error loading image: ${err.message || 'Unknown error'}`));
                    });
                    img.src = content;
                    this._cachedData = await imgPromise;
                    resolve(this._cachedData);
                } else if (['mp3', 'wav', 'ogg', 'aac'].includes(extension)) {
                    const audio = new Audio();
                    const audioPromise = new Promise((audioResolve, audioReject) => {
                        audio.oncanplaythrough = () => audioResolve(audio);
                        audio.onerror = (err) => audioReject(new Error(`Error loading audio: ${err.message || 'Unknown error'}`));
                    });
                    audio.src = content;
                    this._cachedData = await audioPromise;
                    resolve(this._cachedData);
                } else if (extension === 'js') {
                    this._cachedData = content;
                    resolve(this._cachedData);
                } else {
                    this._cachedData = content;
                    resolve(this._cachedData);
                }
            } catch (error) {
                console.error(`Error loading asset ${this.path}:`, error);
                this._cachedData = null;
                reject(error);
            } finally {
                this._isLoading = false;
            }
        });
        
        return this._loadPromise;
    }
    
    /**
     * Create a clone of this AssetReference
     */
    clone() {
        const clone = new AssetReference(this.path, this.type);
        clone._cachedData = this._cachedData;
        return clone;
    }
    
    /**
     * Convert to a simple object for serialization
     */
    toJSON() {
        return {
            path: this.path,
            type: this.type
        };
    }
    
    /**
     * Create an AssetReference from serialized data
     * @param {Object} json - Serialized data
     * @returns {AssetReference} The created AssetReference
     */
    static fromJSON(json) {
        if (!json) return new AssetReference();
        return new AssetReference(json.path, json.type || 'any');
    }
}

// Register globally
window.AssetReference = AssetReference;

// Game Modules
// src/core/Modules/Visual/SpriteRenderer.js
/**
 * SpriteRenderer - Renders sprite images
 * 
 * This module renders sprite images and supports sprite properties 
 * like size, pivot, and flip modes.
 */
class SpriteRenderer extends Module {
    static allowMultiple = false;
    static namespace = "Visual";
    static description = "Displays a sprite/image";
    static iconClass = "fas fa-image";

    constructor() {
        super("SpriteRenderer");

        // Import AssetReference if it's not already available
        if (!window.AssetReference) {
            console.warn("AssetReference not found, SpriteRenderer may not work correctly");
        }

        // Sprite image reference - use a safe way to create an AssetReference
        try {
            this.imageAsset = new (window.AssetReference || function (p) { return { path: p }; })(null, 'image');
        } catch (error) {
            console.error("Error creating AssetReference:", error);
            this.imageAsset = { path: null, load: () => Promise.resolve(null) };
        }

        // Sprite size
        this.width = 64;
        this.height = 64;

        // Sprite properties
        this.color = "#ffffff";
        this.flipX = false;
        this.flipY = false;
        this.pivot = new Vector2(0.5, 0.5); // Center pivot by default
        this.sliceMode = false; // 9-slice rendering mode
        this.sliceBorder = { left: 10, right: 10, top: 10, bottom: 10 };

        // New scaling property
        this.scaleMode = "stretch"; // Options: stretch, fit, fill, tile

        // Animation properties
        this.frameX = 0;
        this.frameY = 0;
        this.frameWidth = 64;
        this.frameHeight = 64;
        this.frames = 1;

        // Internal state
        this._image = null;
        this._isLoaded = false;
        this._imageWidth = 0;
        this._imageHeight = 0;

        // Make sure this is called after all properties are set up
        this.registerProperties();

        // Attempt to refresh Inspector if already available
        setTimeout(() => this.refreshInspector(), 100);

        // Add custom styles to the document
        this.addCustomStyles();
    }

    /**
     * Register all properties for this module
     */
    registerProperties() {
        // Clear any previously registered properties
        this.clearProperties();

        // Enhanced image asset property with AssetManager integration
        this.exposeProperty("imageAsset", "asset", this.imageAsset, {
            description: "Sprite image to display",
            assetType: 'image',  // This tells the Inspector it's an image asset
            fileTypes: ['png', 'jpg', 'jpeg', 'gif', 'webp'],
            onAssetSelected: (assetPath) => {
                this.setSprite(assetPath);  // Your custom handler
            }
        });

        this.exposeProperty("width", "number", this.width, {
            description: "Width of the sprite in pixels",
            min: 1,
            max: 2048,
            step: 1,
            onChange: (value) => {
                this.width = value;
                window.editor?.refreshCanvas();
            }
        });

        this.exposeProperty("height", "number", this.height, {
            description: "Height of the sprite in pixels",
            min: 1,
            max: 2048,
            step: 1,
            onChange: (value) => {
                this.height = value;
                window.editor?.refreshCanvas();
            }
        });

        // Make sure the scaleMode property is correctly registered with onChange handler
        this.exposeProperty("scaleMode", "enum", this.scaleMode, {
            description: "How the image should be scaled to fit the dimensions",
            enumValues: [
                { value: "stretch", label: "Stretch" },
                { value: "fit", label: "Fit (preserve aspect ratio)" },
                { value: "fill", label: "Fill (preserve aspect ratio, may crop)" },
                { value: "tile", label: "Tile (repeat image)" },
                { value: "9-slice", label: "9-Slice (stretchable borders)" }
            ],
            onChange: (value) => {
                // Store previous mode to check for changes
                const previousMode = this.scaleMode;

                // Update the scale mode
                this.scaleMode = value;

                // Handle 9-slice mode toggle
                if (value === "9-slice") {
                    this.sliceMode = true;

                    // Only refresh border controls if we're switching TO 9-slice mode
                    if (previousMode !== "9-slice") {
                        this.refreshBorderControls();
                    }
                } else {
                    this.sliceMode = false;

                    // If we're switching FROM 9-slice mode, refresh to remove border controls
                    if (previousMode === "9-slice") {
                        this.refreshBorderControls();
                    }
                }

                // Refresh the canvas
                window.editor?.refreshCanvas();
            },
            cssClass: "scale-mode-dropdown" // Add custom CSS class for styling
        });

        // Register remaining properties
        this.exposeProperty("color", "color", this.color, {
            description: "Tint color for the sprite",
            onChange: (value) => {
                this.color = value;
                window.editor?.refreshCanvas();
            }
        });

        this.exposeProperty("flipX", "boolean", this.flipX, {
            description: "Flip the sprite horizontally",
            onChange: (value) => {
                this.flipX = value;
                window.editor?.refreshCanvas();
            }
        });

        this.exposeProperty("flipY", "boolean", this.flipY, {
            description: "Flip the sprite vertically",
            onChange: (value) => {
                this.flipY = value;
                window.editor?.refreshCanvas();
            }
        });

        this.exposeProperty("pivot", "vector2", this.pivot, {
            description: "Pivot point for rotation (0,0 = top left, 1,1 = bottom right)",
            onChange: (value) => {
                this.pivot = value;
                window.editor?.refreshCanvas();
            }
        });

        // Only show slice border options when 9-slice mode is active
        if (this.scaleMode === "9-slice" || this.sliceMode) {
            this.addSliceBorderProperties();
        }
    }

    /**
     * Add 9-slice border properties to the inspector
     */
    addSliceBorderProperties() {
        this.exposeProperty("sliceBorder.left", "number", this.sliceBorder.left, {
            description: "Left border size for 9-slice",
            min: 0,
            max: 100,
            step: 1,
            label: "Border Left",
            onChange: (value) => {
                this.sliceBorder.left = value;
                window.editor?.refreshCanvas();
            }
        });

        this.exposeProperty("sliceBorder.right", "number", this.sliceBorder.right, {
            description: "Right border size for 9-slice",
            min: 0,
            max: 100,
            step: 1,
            label: "Border Right",
            onChange: (value) => {
                this.sliceBorder.right = value;
                window.editor?.refreshCanvas();
            }
        });

        this.exposeProperty("sliceBorder.top", "number", this.sliceBorder.top, {
            description: "Top border size for 9-slice",
            min: 0,
            max: 100,
            step: 1,
            label: "Border Top",
            onChange: (value) => {
                this.sliceBorder.top = value;
                window.editor?.refreshCanvas();
            }
        });

        this.exposeProperty("sliceBorder.bottom", "number", this.sliceBorder.bottom, {
            description: "Bottom border size for 9-slice",
            min: 0,
            max: 100,
            step: 1,
            label: "Border Bottom",
            onChange: (value) => {
                this.sliceBorder.bottom = value;
                window.editor?.refreshCanvas();
            }
        });
    }

    clearProperties() {
        // Clear any previously registered properties
        if (this.properties) {
            for (const prop in this.properties) {
                if (this.properties.hasOwnProperty(prop)) {
                    delete this.properties[prop];
                }
            }
        }
    }

    /**
     * Refresh border controls when switching to 9-slice mode
     */
    refreshBorderControls() {
        // Re-register all properties to include/exclude slice border properties
        this.registerProperties();

        // Force a refresh of the inspector UI
        this.refreshInspector();
    }

    /**
     * Called when the module is first activated
     */
    async start() {
        // Only load the sprite image if we don't already have embedded data loaded
        if (!this._isLoaded) {
            await this.loadImage();
        }
    }

    /**
     * Load the sprite image from the asset reference
     */
    async loadImage() {
        // If we have embedded data and no path, don't try to load from path
        if (this.imageAsset && this.imageAsset.embedded && !this.imageAsset.path) {
            console.log('Skipping path-based loading for embedded image data - already loaded');
            return this._image;
        }

        if (!this.imageAsset || (!this.imageAsset.path && !this.imageAsset.embedded)) {
            if (!this._isLoaded && (!this.imageAsset || !this.imageAsset.embedded)) {
                console.warn('No image asset path to load');
            }
            return null;
        }

        try {
            console.log('Loading image for SpriteRenderer:', this.imageAsset.path);

            // PRIORITY 1: Load from AssetManager (both editor and exported games)
            if (this.imageAsset.path) {
                const asset = await this.loadFromAssetManager(this.imageAsset.path);
                if (asset) {
                    return asset;
                }
            }

            // PRIORITY 2: If we're in editor mode with FileBrowser, load from FileBrowser
            if (window.editor && window.editor.fileBrowser && this.imageAsset.path) {
                try {
                    const image = await this.loadImageFromFileBrowser(this.imageAsset.path);
                    if (image) {
                        console.log('Image loaded via FileBrowser successfully');
                        this._image = image;
                        this._imageWidth = image.naturalWidth || image.width;
                        this._imageHeight = image.naturalHeight || image.height;
                        this._isLoaded = true;
                        return image;
                    }
                } catch (error) {
                    console.warn('FileBrowser loading failed, trying fallback:', error);
                }
            }

            // If we have embedded data, use the load function
            if (this.imageAsset.embedded && typeof this.imageAsset.load === 'function') {
                console.log('Loading embedded image data');
                const image = await this.imageAsset.load();
                if (image) {
                    this._image = image;
                    this._imageWidth = image.naturalWidth || image.width;
                    this._imageHeight = image.naturalHeight || image.height;
                    this._isLoaded = true;
                    return image;
                }
            }

            // Final fallback for exported games
            if (this.imageAsset.path) {
                return await this.fallbackLoadImage(this.imageAsset.path);
            }

            return null;

        } catch (error) {
            console.error('Error loading sprite image:', error);
            this._image = null;
            this._isLoaded = false;
            return null;
        }
    }

    /**
     * Load image from FileBrowser (editor mode)
     * @param {string} path - Path to the image
     * @returns {Promise<HTMLImageElement>} - Loaded image
     */
    async loadImageFromFileBrowser(path) {
    try {
        const fileBrowser = window.editor.fileBrowser;

        // Read the file content from FileBrowser
        const content = await fileBrowser.readFile(path);
        if (!content) {
            throw new Error(`Could not read file from FileBrowser: ${path}`);
        }

        console.log('FileBrowser content type:', typeof content, content.substring ? content.substring(0, 50) + '...' : 'Binary data');

        // Check if content is already a data URL (for images)
        if (typeof content === 'string' && content.startsWith('data:image')) {
            console.log('Loading image from data URL via FileBrowser');
            const image = await this.loadImageFromDataURL(content);
            
            // Auto-size the sprite to match the image if dimensions are default
            if (this.width === 64 && this.height === 64) {
                this.width = image.naturalWidth;
                this.height = image.naturalHeight;
                console.log(`Auto-sized sprite to ${this.width}x${this.height}`);
                
                // Refresh inspector to show new dimensions
                if (window.editor && window.editor.inspector) {
                    window.editor.inspector.refreshModuleUI(this);
                }
            }
            
            return image;
        }
        // Handle cases where FileBrowser returns the content differently
        else if (typeof content === 'string' && !content.startsWith('data:')) {
            // If it's a string but not a data URL, it might be base64 or raw content
            // Try to construct a data URL
            try {
                // Detect image type from path
                const extension = path.split('.').pop().toLowerCase();
                let mimeType = 'image/png'; // default
                
                if (extension === 'jpg' || extension === 'jpeg') {
                    mimeType = 'image/jpeg';
                } else if (extension === 'gif') {
                    mimeType = 'image/gif';
                } else if (extension === 'webp') {
                    mimeType = 'image/webp';
                } else if (extension === 'svg') {
                    mimeType = 'image/svg+xml';
                }

                let dataUrl;
                if (content.startsWith('data:')) {
                    // Already has data URL prefix, might be malformed
                    dataUrl = content.startsWith('data:') ? content : `data:${mimeType};base64,${content}`;
                } else {
                    // Assume it's base64 data
                    dataUrl = `data:${mimeType};base64,${content}`;
                }

                console.log('Attempting to load as constructed data URL');
                const image = await this.loadImageFromDataURL(dataUrl);
                
                // Auto-size the sprite to match the image if dimensions are default
                if (this.width === 64 && this.height === 64) {
                    this.width = image.naturalWidth;
                    this.height = image.naturalHeight;
                    console.log(`Auto-sized sprite to ${this.width}x${this.height}`);
                    
                    // Refresh inspector to show new dimensions
                    if (window.editor && window.editor.inspector) {
                        window.editor.inspector.refreshModuleUI(this);
                    }
                }
                
                return image;
            } catch (error) {
                console.error('Failed to construct data URL:', error);
                throw new Error(`File content is not a valid image: ${path}`);
            }
        }
        // Handle binary content (Blob/ArrayBuffer)
        else if (content instanceof Blob || content instanceof ArrayBuffer) {
            console.log('Converting binary content to data URL');
            let blob = content;
            if (content instanceof ArrayBuffer) {
                blob = new Blob([content], { type: `image/${path.split('.').pop().toLowerCase()}` });
            }

            const dataUrl = await this.blobToDataURL(blob);
            const image = await this.loadImageFromDataURL(dataUrl);
            
            // Auto-size the sprite to match the image if dimensions are default
            if (this.width === 64 && this.height === 64) {
                this.width = image.naturalWidth;
                this.height = image.naturalHeight;
                console.log(`Auto-sized sprite to ${this.width}x${this.height}`);
                
                // Refresh inspector to show new dimensions
                if (window.editor && window.editor.inspector) {
                    window.editor.inspector.refreshModuleUI(this);
                }
            }
            
            return image;
        }
        else {
            throw new Error(`Unsupported file content type for image: ${typeof content}`);
        }
    } catch (error) {
        console.error('Error loading image from FileBrowser:', error);
        throw error;
    }
}

    async blobToDataURL(blob) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(blob);
        });
    }

    /**
     * Force a refresh of the Inspector UI for this module
     */
    refreshInspector() {
        if (window.editor && window.editor.inspector) {
            // Clear any cached property data
            if (window.editor.inspector.clearModuleCache) {
                window.editor.inspector.clearModuleCache(this);
            }

            // Re-generate the module UI
            window.editor.inspector.refreshModuleUI(this);

            // Refresh the canvas to show visual changes
            window.editor.refreshCanvas();
        }
    }

    /**
     * Fallback method to load an image when AssetReference isn't working
     * @param {string} path - Path to the image
     * @returns {Promise<HTMLImageElement>} - Loaded image
     */
    fallbackLoadImage(path) {
        return new Promise((resolve, reject) => {
            // Check if path is null or undefined
            if (!path) {
                reject(new Error('No image path provided'));
                return;
            }

            const img = new Image();

            // For exported games, if asset manager has no cache, that's a critical error
            if (window.assetManager && window.assetManager.cache) {
                const normalizedPath = window.assetManager.normalizePath ?
                    window.assetManager.normalizePath(path) :
                    path.replace(/^\/+/, '').replace(/\\/g, '/');

                console.log('Looking for cached asset:', normalizedPath);
                console.log('Available cached assets:', Object.keys(window.assetManager.cache));

                // Try multiple path variations for lookup
                const pathVariations = [
                    path,
                    normalizedPath,
                    path.replace(/^[\/\\]+/, ''),
                    path.replace(/\\/g, '/'),
                    path.split('/').pop(),
                    path.split('\\').pop(),
                    decodeURIComponent(path),
                    '/' + path.replace(/^[\/\\]+/, ''),
                    '/' + normalizedPath,
                ];

                let cached = null;
                let foundPath = null;

                for (const variation of pathVariations) {
                    if (window.assetManager.cache[variation]) {
                        cached = window.assetManager.cache[variation];
                        foundPath = variation;
                        console.log('Found cached asset with path variation:', foundPath);
                        break;
                    }
                }

                if (cached) {
                    if (cached instanceof HTMLImageElement) {
                        console.log('Using cached HTMLImageElement');
                        this._image = cached;
                        this._imageWidth = cached.naturalWidth || cached.width;
                        this._imageHeight = cached.naturalHeight || cached.height;
                        this._isLoaded = true;
                        resolve(cached);
                        return;
                    } else if (typeof cached === 'string' && cached.startsWith('data:')) {
                        console.log('Loading cached data URL');
                        img.src = cached;
                    } else if (cached.content && typeof cached.content === 'string' && cached.content.startsWith('data:')) {
                        console.log('Loading cached asset content as data URL');
                        img.src = cached.content;
                    } else {
                        console.error('Cached asset is not a valid image format:', typeof cached, cached);
                        reject(new Error(`Cached asset for ${path} is not a valid image`));
                        return;
                    }
                } else {
                    // Critical error for exported games
                    const isExportedGame = window.location.protocol === 'file:' || !window.fileBrowser;
                    if (isExportedGame) {
                        const errorMsg = `Image not found in asset cache: ${path}. This is likely an export issue. Available assets: ${Object.keys(window.assetManager.cache).join(', ')}`;
                        console.error(errorMsg);
                        reject(new Error(errorMsg));
                        return;
                    } else {
                        // Development mode - try direct loading
                        console.warn('Asset not in cache, trying direct load for development mode');
                        this.tryMultipleImagePaths(img, path).then(resolve).catch(reject);
                        return;
                    }
                }
            } else {
                console.warn('No asset manager or cache available');
                // Try direct loading
                img.src = path;
            }

            img.onload = () => {
                console.log('Image loaded successfully:', img.src.substring(0, 100) + '...');
                this._image = img;
                this._imageWidth = img.naturalWidth || img.width;
                this._imageHeight = img.naturalHeight || img.height;
                this._isLoaded = true;
                resolve(img);
            };

            img.onerror = (error) => {
                console.error('Error loading image:', path, error);
                reject(new Error(`Failed to load image: ${path}`));
            };
        });
    }

    /**
     * Try loading an image from multiple possible paths
     * @param {HTMLImageElement} img - Image element to load into
     * @param {string} originalPath - Original path that failed
     * @returns {Promise<HTMLImageElement>} - Promise that resolves when image loads
     */
    async tryMultipleImagePaths(img, originalPath) {
        // First, try to use FileBrowser to resolve the path
        if (window.editor && window.editor.fileBrowser) {
            const fileBrowser = window.editor.fileBrowser;

            // Try different relative paths within the FileBrowser's workspace
            const possiblePaths = [
                originalPath,
                originalPath.replace(/^[\/\\]+/, ''), // Remove leading slashes
                `assets/${originalPath.replace(/^[\/\\]+/, '')}`,
                `images/${originalPath.replace(/^[\/\\]+/, '')}`,
                `src/assets/${originalPath.replace(/^[\/\\]+/, '')}`,
                `public/assets/${originalPath.replace(/^[\/\\]+/, '')}`,
                // Also try just the filename in common directories
                `assets/${originalPath.split(/[\/\\]/).pop()}`,
                `images/${originalPath.split(/[\/\\]/).pop()}`,
                `src/assets/${originalPath.split(/[\/\\]/).pop()}`,
                `public/assets/${originalPath.split(/[\/\\]/).pop()}`
            ];

            console.log('Trying FileBrowser paths for image:', originalPath, possiblePaths);

            // Try each path with FileBrowser
            for (const testPath of possiblePaths) {
                try {
                    if (await fileBrowser.fileExists(testPath)) {
                        console.log('Found file in FileBrowser:', testPath);
                        const image = await this.loadImageFromFileBrowser(testPath);
                        if (image) {
                            this._image = image;
                            this._imageWidth = image.naturalWidth || image.width;
                            this._imageHeight = image.naturalHeight || image.height;
                            this._isLoaded = true;
                            return image;
                        }
                    }
                } catch (error) {
                    // Continue to next path
                    continue;
                }
            }
        }

        // If FileBrowser approach failed, try AssetManager cache with normalized paths
        if (window.assetManager && window.assetManager.cache) {
            const cache = window.assetManager.cache;
            const cleanPath = originalPath.replace(/^[\/\\]+/, '').replace(/\\/g, '/');

            const pathVariations = [
                originalPath,
                cleanPath,
                `/${cleanPath}`,
                cleanPath.split('/').pop(), // Just filename
                cleanPath.split('\\').pop(), // Just filename (Windows)
                decodeURIComponent(originalPath),
                decodeURIComponent(cleanPath)
            ];

            console.log('Trying AssetManager cache paths:', pathVariations);
            console.log('Available cached assets:', Object.keys(cache));

            for (const variation of pathVariations) {
                if (cache[variation]) {
                    const cached = cache[variation];
                    if (cached instanceof HTMLImageElement) {
                        console.log('Found cached image:', variation);
                        this._image = cached;
                        this._imageWidth = cached.naturalWidth || cached.width;
                        this._imageHeight = cached.naturalHeight || cached.height;
                        this._isLoaded = true;
                        return cached;
                    } else if (typeof cached === 'string' && cached.startsWith('data:')) {
                        console.log('Loading cached data URL:', variation);
                        return this.loadImageFromDataURL(cached);
                    }
                }
            }
        }

        // Last resort: only for exported games or when all else fails
        console.warn('All relative path attempts failed, falling back to direct URL loading');
        return this.directUrlFallback(img, originalPath);
    }

    /**
 * Direct URL fallback (only for exported games or when other methods fail)
 * @param {HTMLImageElement} img - Image element to load into
 * @param {string} originalPath - Original path that failed
 * @returns {Promise<HTMLImageElement>} - Promise that resolves when image loads
 */
async directUrlFallback(img, originalPath) {
    // Only use direct URL loading as a last resort and warn about it
    console.warn('Using direct URL fallback - this may not work in all environments:', originalPath);
    
    // Remove leading slashes and normalize
    const cleanPath = originalPath.replace(/^\/+/, '').replace(/\\/g, '/');

    // Generate minimal possible paths to try
    const possiblePaths = [
        cleanPath, // Relative to current directory
        `assets/${cleanPath}`,
        `images/${cleanPath}`,
        originalPath // Original path as-is
    ];

    console.log('Trying direct URL paths:', possiblePaths);

    // Try each path until one works
    for (const testPath of possiblePaths) {
        try {
            const success = await this.testImagePath(testPath);
            if (success) {
                console.log('Successfully loaded image from direct URL:', testPath);
                return new Promise((resolve, reject) => {
                    img.onload = () => {
                        this._image = img;
                        this._imageWidth = img.naturalWidth || img.width;
                        this._imageHeight = img.naturalHeight || img.height;
                        this._isLoaded = true;
                        resolve(img);
                    };
                    img.onerror = reject;
                    img.src = testPath;
                });
            }
        } catch (error) {
            // Continue to next path
            continue;
        }
    }

    throw new Error(`Could not load image from any of the attempted paths for: ${originalPath}`);
}

    /**
     * Test if an image can be loaded from a specific path
     * @param {string} path - Path to test
     * @returns {Promise<boolean>} - True if image loads successfully
     */
    testImagePath(path) {
        return new Promise((resolve) => {
            const testImg = new Image();
            testImg.onload = () => resolve(true);
            testImg.onerror = () => resolve(false);

            // Set a timeout to avoid hanging
            setTimeout(() => resolve(false), 3000);

            testImg.src = path;
        });
    }

    /**
     * Resolve image path for direct loading
     * @param {string} path - Original path
     * @returns {string} - Resolved path
     */
    resolveImagePath(path) {
        if (!path) return '';

        // If it's already a full URL or data URL, return as-is
        if (path.startsWith('http') || path.startsWith('data:') || path.startsWith('blob:')) {
            return path;
        }

        // Remove leading slashes and normalize
        const cleanPath = path.replace(/^\/+/, '').replace(/\\/g, '/');

        // Try to construct a proper path relative to the current location
        const baseUrl = window.location.origin + window.location.pathname.replace(/\/[^\/]*$/, '/');

        // Check if the file exists in common asset directories
        const possiblePaths = [
            cleanPath,
            `assets/${cleanPath}`,
            `images/${cleanPath}`,
            `src/assets/${cleanPath}`,
            `src/images/${cleanPath}`,
            `public/${cleanPath}`,
            `public/assets/${cleanPath}`,
            `public/images/${cleanPath}`
        ];

        // For now, return the first possible path
        // In a real implementation, you might want to test each path
        return baseUrl + possiblePaths[0];
    }

    /**
     * Set the sprite image by path
     * @param {string} path - File path to the image
     */
    async setSprite(path) {
        console.log('setSprite called with path:', path);

        if (path === null || path === undefined) {
            this.imageAsset = null;
            this._image = null;
            this._isLoaded = false;
            return;
        }

        if (this.imageAsset && this.imageAsset.path === path) {
            console.log('Sprite path unchanged, skipping');
            return;
        }

        try {
            // Create new asset reference
            if (window.AssetReference) {
                this.imageAsset = new window.AssetReference(path, 'image');
            } else {
                this.imageAsset = {
                    path: path,
                    type: 'image',
                    load: () => window.assetManager ?
                        window.assetManager.getAssetByPath(path) :
                        this.fallbackLoadImage(path)
                };
            }

            // Load via AssetManager
            const image = await this.loadImage();

            if (image) {
                console.log('Image loaded successfully:', image.src || 'data URL');
            } else {
                console.warn('Failed to load image');
            }

            // Force refresh of UI and canvas
            if (window.editor) {
                window.editor.refreshCanvas();
            }

        } catch (error) {
            console.error("Error setting sprite:", error);
        }
    }

    /**
      * Draw the sprite
      * @param {CanvasRenderingContext2D} ctx - Canvas rendering context
      */
    draw(ctx) {
        // Don't draw if we have no image or width/height is zero
        if (!this._image || !this._isLoaded || this.width === 0 || this.height === 0) {
            this.drawPlaceholder(ctx);
            return;
        }

        // Calculate draw position based on pivot
        const pivotX = this.width * this.pivot.x;
        const pivotY = this.height * this.pivot.y;

        // Save current context state
        ctx.save();

        // Apply flipping
        if (this.flipX || this.flipY) {
            ctx.scale(this.flipX ? -1 : 1, this.flipY ? -1 : 1);
        }

        // Handle drawing based on frame/slice/scale mode
        //if (this.frameWidth < this._imageWidth || this.frameHeight < this._imageHeight) {
        // Draw a specific frame from a spritesheet
        //    this.drawFrame(ctx, -pivotX, -pivotY);
        //} else {
        // Draw based on scale mode - Always use drawWithScaleMode
        this.drawWithScaleMode(ctx, -pivotX, -pivotY);
        //}

        // Apply color tint if not white (after drawing the image)
        if (this.color !== "#ffffff") {
            ctx.globalCompositeOperation = 'multiply';
            ctx.fillStyle = this.color;
            ctx.fillRect(-pivotX, -pivotY, this.width, this.height);
        }

        // Restore context state
        ctx.restore();
    }

    /**
     * Draw a frame from a spritesheet
     */
    drawFrame(ctx, x, y) {
        ctx.drawImage(
            this._image,
            this.frameX * this.frameWidth,
            this.frameY * this.frameHeight,
            this.frameWidth,
            this.frameHeight,
            x, y,
            this.width,
            this.height
        );
    }

    /**
     * Register this module with the Inspector to handle custom UI
     */
    registerCustomInspectorHandlers() {
        if (!window.editor || !window.editor.inspector) return;

        // Register a custom UI creator for this module type
        window.editor.inspector.registerCustomUIHandler(
            'SpriteRenderer',
            'imageAsset',
            (element, module) => {
                // Set up drag and drop for the image preview
                if (element.classList.contains('image-preview')) {
                    module.setupDragAndDrop(element);
                }
            }
        );
    }

    /**
     * Override to handle image preview in the Inspector
     */
    onInspectorCreated() {
        // Register custom handlers for the Inspector
        this.registerCustomInspectorHandlers();
    }

    /**
     * Set up the image preview element to handle drag and drop
     * @param {HTMLElement} imagePreview - The image preview element 
     */
    setupDragAndDrop(imagePreview) {
        if (!imagePreview) return;

        // Enable drag & drop
        imagePreview.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            imagePreview.classList.add('drag-over');
        });

        imagePreview.addEventListener('dragleave', () => {
            imagePreview.classList.remove('drag-over');
        });

        imagePreview.addEventListener('drop', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            imagePreview.classList.remove('drag-over');

            const success = await this.handleImageDrop(e.dataTransfer);
            if (success) {
                // Find the parent Inspector instance to refresh UI
                if (window.editor && window.editor.inspector) {
                    window.editor.inspector.refreshModuleUI(this);
                    window.editor.refreshCanvas();
                }
            }
        });
    }

    /**
 * Handle dropped image files
 * @param {DataTransfer} dataTransfer - Drop event data
 * @returns {Promise<boolean>} - Success status
 */
    async handleImageDrop(dataTransfer) {
        try {
            // Check if we have files directly dropped
            if (dataTransfer.files && dataTransfer.files.length > 0) {
                const file = dataTransfer.files[0];

                // Validate it's an image
                if (!file.type.startsWith('image/')) {
                    console.warn('Dropped file is not an image:', file.type);
                    return false;
                }

                // Get the FileBrowser instance
                const fileBrowser = window.editor?.fileBrowser || window.fileBrowser;
                if (!fileBrowser) {
                    console.warn('FileBrowser not available for image upload');
                    return false;
                }

                // Upload to FileBrowser
                await fileBrowser.handleFileUpload(file);

                // Set the image asset to this path
                const path = `${fileBrowser.currentPath}/${file.name}`;
                await this.setSprite(path);

                console.log('Successfully set sprite to:', path);
                return true;
            }

            // Check if we have JSON data (from internal drag & drop from file browser)
            const jsonData = dataTransfer.getData('application/json');
            if (jsonData) {
                try {
                    const items = JSON.parse(jsonData);
                    if (items && items.length > 0) {
                        // Get the first item's path
                        const path = items[0].path;
                        if (path && this.isImagePath(path)) {
                            await this.setSprite(path);
                            console.log('Successfully set sprite to:', path);
                            return true;
                        }
                    }
                } catch (e) {
                    console.error('Error parsing drag JSON data:', e);
                }
            }

            // Check if we have plain text (from copy link etc)
            const textData = dataTransfer.getData('text/plain');
            if (textData && this.isImagePath(textData)) {
                await this.setSprite(textData);
                console.log('Successfully set sprite to:', textData);
                return true;
            }

            return false;
        } catch (error) {
            console.error('Error handling image drop:', error);
            return false;
        }
    }

    /**
     * Check if a path is an image file based on extension
     * @param {string} path - File path
     * @returns {boolean} - True if it's an image file
     */
    isImagePath(path) {
        if (!path) return false;
        const imageExtensions = ['.png', '.jpg', '.jpeg', '.gif', '.webp', '.svg'];
        const lowercasePath = path.toLowerCase();
        return imageExtensions.some(ext => lowercasePath.endsWith(ext));
    }

    /**
     * Load an image from local file
     */
    async loadImageFromFile() {
        // Create a file input
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';

        // Listen for file selection
        input.onchange = async (e) => {
            if (e.target.files && e.target.files[0]) {
                const file = e.target.files[0];

                // Get the FileBrowser instance
                const fileBrowser = window.editor?.fileBrowser;
                if (!fileBrowser) {
                    console.warn('FileBrowser not available for image upload');
                    return;
                }

                // Upload to FileBrowser
                await fileBrowser.handleFileUpload(file);

                // Set the sprite to this path
                const path = `${fileBrowser.currentPath}/${file.name}`;
                await this.setSprite(path);
            }
        };

        // Trigger file selection
        input.click();
    }

    /**
 * Load image from data URL
 * @param {string} dataUrl - Data URL of the image
 * @returns {Promise<HTMLImageElement>} - Loaded image
 */
    loadImageFromDataURL(dataUrl) {
        return new Promise((resolve, reject) => {
            const img = new Image();

            img.onload = () => {
                console.log('Image loaded from data URL successfully');
                resolve(img);
            };

            img.onerror = (error) => {
                console.error('Error loading image from data URL:', error);
                reject(new Error('Failed to load image from data URL'));
            };

            img.src = dataUrl;
        });
    }

    /**
     * Load an image from URL
     */
    async loadImageFromUrl() {
        // Show a prompt for URL input
        const url = await this.promptUrlInput();
        if (!url) return;

        try {
            // Create a temporary image to validate the URL
            const tempImg = new Image();

            // Create a promise to wait for image loading
            const loaded = new Promise((resolve, reject) => {
                tempImg.onload = () => resolve(true);
                tempImg.onerror = () => reject(new Error(`Failed to load image from URL: ${url}`));

                // Set a timeout in case the image never loads
                setTimeout(() => reject(new Error('Image loading timed out')), 10000);
            });

            // Start loading the image
            tempImg.crossOrigin = "anonymous";
            tempImg.src = url;

            // Wait for the image to load
            await loaded;

            // Get the FileBrowser instance
            const fileBrowser = window.editor?.fileBrowser;
            if (!fileBrowser) {
                console.warn('FileBrowser not available for image upload');
                // Use direct URL as fallback
                await this.setSprite(url);
                return;
            }

            // Convert the image to a data URL (fetch the image first to ensure CORS doesn't block it)
            const imgData = await this.fetchImageAsDataURL(url);

            // Generate a filename from the URL
            const filename = this.generateFilenameFromUrl(url);

            // Save to FileBrowser
            await fileBrowser.createFile(`${fileBrowser.currentPath}/${filename}`, imgData);

            // Set the sprite to this path
            const path = `${fileBrowser.currentPath}/${filename}`;
            await this.setSprite(path);
        } catch (error) {
            console.error('Error loading image from URL:', error);
            alert(`Failed to load image: ${error.message}`);
        }
    }

    /**
     * Fetch an image and convert to data URL
     * @param {string} url - Image URL
     * @returns {Promise<string>} - Data URL
     */
    async fetchImageAsDataURL(url) {
        try {
            // Try to fetch the image
            const response = await fetch(url, { mode: 'cors' });
            const blob = await response.blob();

            // Convert to data URL
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.readAsDataURL(blob);
            });
        } catch (error) {
            console.warn('Could not fetch image (possible CORS issue), using direct URL');
            return url;
        }
    }

    /**
     * Generate a filename from URL
     * @param {string} url - Image URL
     * @returns {string} - Filename
     */
    generateFilenameFromUrl(url) {
        try {
            // Try to get the filename from the URL
            const urlObj = new URL(url);
            const pathname = urlObj.pathname;
            const filename = pathname.split('/').pop();

            // If we have a valid filename with extension, use it
            if (filename && filename.includes('.')) {
                return filename;
            }
        } catch (e) {
            // URL parsing failed
        }

        // Generate a random filename
        const randomId = Math.random().toString(36).substring(2, 10);
        return `image_${randomId}.png`;
    }

    /**
     * Show a prompt dialog for URL input
     * @returns {Promise<string>} - URL or null if canceled
     */
    async promptUrlInput() {
        return new Promise((resolve) => {
            // Create modal dialog
            const dialog = document.createElement('div');
            dialog.className = 'url-input-dialog';
            dialog.innerHTML = `
                <div class="url-input-content">
                    <h3>Enter Image URL</h3>
                    <input type="text" placeholder="https://example.com/image.png" class="url-input-field">
                    <div class="url-input-buttons">
                        <button class="cancel-btn">Cancel</button>
                        <button class="ok-btn">OK</button>
                    </div>
                </div>
            `;

            // Add styles for the dialog
            const style = document.createElement('style');
            style.innerHTML = `
                .url-input-dialog {
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(0,0,0,0.5);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                }
                .url-input-content {
                    background-color: #2a2a2a;
                    border-radius: 4px;
                    padding: 20px;
                    width: 400px;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.2);
                }
                .url-input-content h3 {
                    margin-top: 0;
                    color: #eee;
                }
                .url-input-field {
                    width: 100%;
                    padding: 8px;
                    margin: 10px 0;
                    background: #333;
                    border: 1px solid #555;
                    color: #eee;
                    border-radius: 2px;
                }
                .url-input-buttons {
                    display: flex;
                    justify-content: flex-end;
                    margin-top: 15px;
                }
                .url-input-buttons button {
                    padding: 6px 12px;
                    margin-left: 10px;
                    background: #444;
                    border: none;
                    color: #eee;
                    border-radius: 2px;
                    cursor: pointer;
                }
                .url-input-buttons button.ok-btn {
                    background: #2196F3;
                }
                .url-input-buttons button:hover {
                    opacity: 0.9;
                }
            `;
            document.head.appendChild(style);
            document.body.appendChild(dialog);

            // Get elements
            const input = dialog.querySelector('.url-input-field');
            const cancelBtn = dialog.querySelector('.cancel-btn');
            const okBtn = dialog.querySelector('.ok-btn');

            // Functions to handle dialog interaction
            const close = () => {
                document.body.removeChild(dialog);
                document.head.removeChild(style);
            };

            const cancel = () => {
                close();
                resolve(null);
            };

            const confirm = () => {
                const url = input.value.trim();
                close();
                resolve(url ? url : null);
            };

            // Set up event listeners
            cancelBtn.addEventListener('click', cancel);
            okBtn.addEventListener('click', confirm);

            // Handle Enter key
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') confirm();
                if (e.key === 'Escape') cancel();
            });

            // Focus the input field
            setTimeout(() => input.focus(), 50);
        });
    }

    /**
     * Draw a placeholder when no image is loaded
     */
    drawPlaceholder(ctx) {
        // Calculate position based on pivot
        const pivotX = this.width * this.pivot.x;
        const pivotY = this.height * this.pivot.y;

        ctx.save();

        // Draw a placeholder rectangle with an "image" icon
        ctx.strokeStyle = "#aaaaaa";
        ctx.fillStyle = "#333333";
        ctx.lineWidth = 2;

        // Draw background
        ctx.fillRect(-pivotX, -pivotY, this.width || 64, this.height || 64);
        ctx.strokeRect(-pivotX, -pivotY, this.width || 64, this.height || 64);

        // Draw image icon
        ctx.fillStyle = "#aaaaaa";
        const iconSize = Math.min(this.width || 64, this.height || 64) * 0.5;
        const centerX = -pivotX + (this.width || 64) / 2 - iconSize / 2;
        const centerY = -pivotY + (this.height || 64) / 2 - iconSize / 2;

        // Draw simplified image icon
        ctx.fillRect(centerX, centerY, iconSize, iconSize);
        ctx.fillStyle = "#333333";
        ctx.beginPath();
        ctx.arc(centerX + iconSize * 0.7, centerY + iconSize * 0.3, iconSize * 0.15, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }

    /**
     * Draw the image using the selected scale mode
     */
    drawWithScaleMode(ctx, x, y) {
        // Add some debugging
        //console.log(`Drawing with scale mode: ${this.scaleMode}`);

        switch (this.scaleMode) {
            case "fit":
                this.drawFit(ctx, x, y);
                break;
            case "fill":
                this.drawFill(ctx, x, y);
                break;
            case "tile":
                this.drawTile(ctx, x, y);
                break;
            case "9-slice":
                this.drawNineSlice(ctx, x, y);
                break;
            case "stretch":
            default:
                // Default to stretch (simple drawImage)
                ctx.drawImage(this._image, x, y, this.width, this.height);
                break;
        }
    }

    /**
     * Draw the image preserving aspect ratio and fitting inside dimensions
     */
    drawFit(ctx, x, y) {
        // Calculate aspect ratios
        const imageRatio = this._imageWidth / this._imageHeight;
        const targetRatio = this.width / this.height;

        let drawWidth, drawHeight, offsetX, offsetY;

        if (imageRatio > targetRatio) {
            // Image is wider than the target area relative to height
            drawWidth = this.width;
            drawHeight = this.width / imageRatio;
            offsetX = 0;
            offsetY = (this.height - drawHeight) / 2;
        } else {
            // Image is taller than the target area relative to width
            drawHeight = this.height;
            drawWidth = this.height * imageRatio;
            offsetX = (this.width - drawWidth) / 2;
            offsetY = 0;
        }

        // Draw the image centered
        ctx.drawImage(this._image, 0, 0, this._imageWidth, this._imageHeight,
            x + offsetX, y + offsetY, drawWidth, drawHeight);
    }

    /**
     * Draw the image preserving aspect ratio and filling the entire area (may crop)
     */
    drawFill(ctx, x, y) {
        // Calculate aspect ratios
        const imageRatio = this._imageWidth / this._imageHeight;
        const targetRatio = this.width / this.height;

        let sourceX, sourceY, sourceWidth, sourceHeight;

        if (imageRatio > targetRatio) {
            // Image is wider than the target area relative to height
            sourceHeight = this._imageHeight;
            sourceWidth = this._imageHeight * targetRatio;
            sourceX = (this._imageWidth - sourceWidth) / 2;
            sourceY = 0;
        } else {
            // Image is taller than the target area relative to width
            sourceWidth = this._imageWidth;
            sourceHeight = this._imageWidth / targetRatio;
            sourceX = 0;
            sourceY = (this._imageHeight - sourceHeight) / 2;
        }

        // Draw the image cropped to fill the entire target area
        ctx.drawImage(
            this._image,
            sourceX, sourceY, sourceWidth, sourceHeight,
            x, y, this.width, this.height
        );
    }

    /**
     * Draw the image tiled to fill the entire area
     */
    drawTile(ctx, x, y) {
        // Create a pattern and fill the area
        const pattern = ctx.createPattern(this._image, 'repeat');
        if (!pattern) {
            // Fallback if pattern creation fails
            ctx.drawImage(this._image, x, y, this.width, this.height);
            return;
        }

        // Save context to isolate the pattern drawing
        ctx.save();

        // Clip to the target rectangle
        ctx.beginPath();
        ctx.rect(x, y, this.width, this.height);
        ctx.clip();

        // Fill with the pattern
        ctx.fillStyle = pattern;
        ctx.fillRect(x, y, this.width, this.height);

        // Restore context
        ctx.restore();
    }

    /**
     * Draw a nine-slice image
     */
    drawNineSlice(ctx, x, y) {
        // Implementation of 9-slice rendering
        const img = this._image;
        const w = this.width;
        const h = this.height;
        const border = this.sliceBorder;

        // Ensure border values are valid and don't exceed image dimensions
        const validLeft = Math.min(border.left, this._imageWidth / 3);
        const validRight = Math.min(border.right, this._imageWidth / 3);
        const validTop = Math.min(border.top, this._imageHeight / 3);
        const validBottom = Math.min(border.bottom, this._imageHeight / 3);

        // Ensure borders don't overlap
        const maxHorizontalBorder = Math.floor(this._imageWidth / 2);
        const maxVerticalBorder = Math.floor(this._imageHeight / 2);

        const safeLeft = Math.min(validLeft, maxHorizontalBorder);
        const safeRight = Math.min(validRight, maxHorizontalBorder);
        const safeTop = Math.min(validTop, maxVerticalBorder);
        const safeBottom = Math.min(validBottom, maxVerticalBorder);

        // Source coordinates (slices from the original image)
        const srcX = [0, safeLeft, this._imageWidth - safeRight, this._imageWidth];
        const srcY = [0, safeTop, this._imageHeight - safeBottom, this._imageHeight];

        // Destination coordinates (where to draw on the canvas)
        const dstX = [x, x + safeLeft, x + w - safeRight, x + w];
        const dstY = [y, y + safeTop, y + h - safeBottom, y + h];

        // Draw all 9 slices
        for (let row = 0; row < 3; row++) {
            for (let col = 0; col < 3; col++) {
                const sx = srcX[col];
                const sy = srcY[row];
                const sw = srcX[col + 1] - sx;
                const sh = srcY[row + 1] - sy;

                const dx = dstX[col];
                const dy = dstY[row];
                const dw = dstX[col + 1] - dx;
                const dh = dstY[row + 1] - dy;

                // Only draw if width and height are positive
                if (sw > 0 && sh > 0 && dw > 0 && dh > 0) {
                    ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);
                }
            }
        }
    }

    /**
     * Add custom styles for the SpriteRenderer's UI
     */
    addCustomStyles() {
        // Check if styles already exist
        if (document.getElementById('sprite-renderer-styles')) {
            return;
        }

        // Create style element
        const style = document.createElement('style');
        style.id = 'sprite-renderer-styles';
        style.innerHTML = `
            .scale-mode-dropdown {
                width: 100%;
                background-color: #333;
                color: #eee;
                border: 1px solid #555;
                padding: 8px;
                border-radius: 3px;
                font-size: 12px;
                height: auto !important;
                appearance: menulist; /* Show dropdown arrow */
            }
            
            .scale-mode-dropdown option {
                background-color: #333;
                color: #eee;
                padding: 6px;
            }
            
            .scale-mode-dropdown:focus {
                outline: none;
                border-color: #2196F3;
            }
            
            /* Ensure border controls are correctly aligned */
            .property-row input[data-prop-name^="sliceBorder"] {
                width: 60px;
                text-align: right;
            }
        `;
        document.head.appendChild(style);
    }

    /**
     * Load image from data URL (for deserialization)
     */
    async loadImageFromData(dataUrl) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = () => {
                this._image = img;
                this._imageWidth = img.naturalWidth;
                this._imageHeight = img.naturalHeight;
                this._isLoaded = true;
                console.log('Image loaded from data URL, dimensions:', this._imageWidth, 'x', this._imageHeight);

                // Trigger canvas refresh if in editor
                if (window.editor) {
                    window.editor.refreshCanvas();
                }

                resolve(img);
            };
            img.onerror = (error) => {
                console.error('Failed to load image from data URL:', error);
                reject(error);
            };
            img.src = dataUrl;
        });
    }

    /**
 * Load image from AssetManager
 * @param {string} path - Asset path
 * @returns {Promise<HTMLImageElement>} - Loaded image
 */
    async loadFromAssetManager(path) {
        if (!path) return null;

        try {
            // Always try to load from AssetManager first
            if (window.assetManager) {
                const asset = await window.assetManager.getAssetByPath(path);
                if (asset && asset instanceof HTMLImageElement) {
                    this._image = asset;
                    this._imageWidth = asset.naturalWidth || asset.width;
                    this._imageHeight = asset.naturalHeight || asset.height;
                    this._isLoaded = true;
                    console.log('Image loaded from AssetManager:', path);
                    return asset;
                }
            }

            // Fallback to direct loading if not in AssetManager
            return await this.fallbackLoadImage(path);
        } catch (error) {
            console.error('Error loading from AssetManager:', error);
            return null;
        }
    }

    /**
     * Override to handle serialization
     */
    toJSON() {
        const json = super.toJSON() || {};

        // Only store the asset reference, not the actual image data
        json.imageAsset = this.imageAsset ? {
            path: this.imageAsset.path,
            type: 'image',
            embedded: this.imageAsset.embedded || false
        } : null;

        json.width = this.width;
        json.height = this.height;
        json.color = this.color;
        json.flipX = this.flipX;
        json.flipY = this.flipY;
        json.pivot = { x: this.pivot.x, y: this.pivot.y };
        json.scaleMode = this.scaleMode;

        // Animation properties
        json.frameX = this.frameX;
        json.frameY = this.frameY;
        json.frameWidth = this.frameWidth;
        json.frameHeight = this.frameHeight;
        json.frames = this.frames;

        // 9-slice properties
        json.sliceMode = this.sliceMode;
        json.sliceBorder = { ...this.sliceBorder };

        // DON'T store image data here - let AssetManager handle it
        return json;
    }

    /**
     * Override to handle deserialization
     */
    fromJSON(json) {
        super.fromJSON(json);

        if (!json) return;

        // Restore other properties first
        if (json.width !== undefined) this.width = json.width;
        if (json.height !== undefined) this.height = json.height;
        if (json.color !== undefined) this.color = json.color;
        if (json.flipX !== undefined) this.flipX = json.flipX;
        if (json.flipY !== undefined) this.flipY = json.flipY;
        if (json.pivot !== undefined) this.pivot = json.pivot;
        if (json.scaleMode !== undefined) this.scaleMode = json.scaleMode;
        if (json.sliceMode !== undefined) this.sliceMode = json.sliceMode;
        if (json.sliceBorder !== undefined) this.sliceBorder = json.sliceBorder;

        // Restore asset reference and load from AssetManager
        if (json.imageAsset && json.imageAsset.path) {
            console.log('Loading sprite from AssetManager:', json.imageAsset.path);

            try {
                if (window.AssetReference) {
                    this.imageAsset = new window.AssetReference(json.imageAsset.path, 'image');
                } else {
                    this.imageAsset = {
                        path: json.imageAsset.path,
                        type: 'image',
                        embedded: json.imageAsset.embedded || false,
                        load: () => this.loadFromAssetManager(json.imageAsset.path)
                    };
                }

                // Load the asset from AssetManager
                this.loadFromAssetManager(json.imageAsset.path);
            } catch (error) {
                console.error("Error restoring image asset:", error);
            }
        } else {
            this.imageAsset = {
                path: null,
                type: 'image',
                load: () => Promise.resolve(null)
            };
            this._image = null;
            this._isLoaded = false;
        }
    }
}

// Register module globally
window.SpriteRenderer = SpriteRenderer;

// src/core/Modules/Matter-js/RigidBody.js
/**
 * RigidBody - Physics component that adds a physical body to a GameObject
 */
class RigidBody extends Module {
    static allowMultiple = false; // Only one RigidBody per GameObject
    static namespace = "Matter.js";
    static description = "Physics component that adds a physical body to a GameObject for Matter.js";

    constructor() {
        super("RigidBody");

        // Physics body reference
        this.body = null;

        // Body properties
        this.bodyType = "dynamic";  // "dynamic", "static", "kinematic"
        this.density = 1;           // Density (mass = density * area)
        this.friction = 0.8;        // Friction coefficient
        this.restitution = 0.1;     // Bounciness (0 to 1)
        this.linearDamping = 0.01;  // Air resistance to linear movement
        this.angularDamping = 0.01; // Air resistance to rotation
        this.isSensor = false;      // Is this a trigger/sensor?
        this.collisionFilter = {    // Collision filtering
            category: 0x0001,       // What category this body belongs to
            mask: 0xFFFFFFFF,       // What categories this body collides with
            group: 0                // Collision groups
        };

        this.useGravity = true; // New property: reacts to gravity
        this.frictionAir = 0.01; // Air resistance (linear damping)
        this.sleepingAllowed = true; // Can the body sleep?
        this.label = ""; // Custom label

        // Shape options
        this.shape = "rectangle";   // "rectangle", "circle", "polygon", "capsule"
        this.width = 50;           // Used for rectangle
        this.height = 50;          // Used for rectangle
        this.radius = 25;           // Used for circle
        this.vertices = [];         // Used for polygon

        // Constraint options
        this.fixedRotation = false; // Prevent rotation

        // Collision tracking
        this.inCollision = new Set();  // Set of bodies currently in contact
        this.bodyNeedsUpdate = false;  // Flag to update static bodies when moved

        this._skipRebuild = true; // Internal flag to skip rebuilds during bulk updates

        // Expose properties to the inspector
        this.exposeProperty("bodyType", "enum", this.bodyType, {
            options: ["dynamic", "static", "kinematic"],
            onChange: (val) => { this.bodyType = val; if (!this._skipRebuild) this.rebuildBody(); }
        });

        this.exposeProperty("shape", "enum", this.shape, {
            options: ["rectangle", "circle", "capsule", "polygon"],
            onChange: (val) => { this.shape = val; if (!this._skipRebuild) this.rebuildBody(); }
        });

        this.exposeProperty("width", "number", this.width, {
            min: 1,
            onChange: (val) => { this.width = val; if (!this._skipRebuild) this.rebuildBody(); }
        });

        this.exposeProperty("height", "number", this.height, {
            min: 1,
            onChange: (val) => { this.height = val; if (!this._skipRebuild) this.rebuildBody(); }
        });

        this.exposeProperty("radius", "number", this.radius, {
            min: 1,
            onChange: (val) => { this.radius = val; if (!this._skipRebuild) this.rebuildBody(); }
        });

        this.exposeProperty("density", "number", this.density, {
            min: 0.001,
            max: 100,
            onChange: (val) => { this.density = val; if (this.body) Matter.Body.setDensity(this.body, val); }
        });

        this.exposeProperty("friction", "number", this.friction, {
            min: 0,
            max: 1,
            onChange: (val) => { this.friction = val; if (this.body) this.body.friction = val; }
        });

        this.exposeProperty("restitution", "number", this.restitution, {
            min: 0,
            max: 1,
            onChange: (val) => { this.restitution = val; if (this.body) this.body.restitution = val; }
        });

        this.exposeProperty("useGravity", "boolean", this.useGravity, {
            onChange: (val) => {
                this.useGravity = val;
                if (this.body) this.body.ignoreGravity = !val; // Custom flag, see below
            }
        });

        this.exposeProperty("frictionAir", "number", this.frictionAir, {
            min: 0,
            max: 1,
            onChange: (val) => {
                this.frictionAir = val;
                if (this.body) this.body.frictionAir = val;
            }
        });

        this.exposeProperty("sleepingAllowed", "boolean", this.sleepingAllowed, {
            onChange: (val) => {
                this.sleepingAllowed = val;
                if (this.body) this.body.sleepThreshold = val ? 60 : -1; // Matter.js default is 60
            }
        });

        this.exposeProperty("label", "string", this.label, {
            onChange: (val) => {
                this.label = val;
                if (this.body) this.body.label = val;
            }
        });

        this.exposeProperty("fixedRotation", "boolean", false, {
            onChange: (value) => {
                this.fixedRotation = value;
                if (this.body) {
                    // Fix: Use correct method to set inertia for fixed rotation
                    if (value) {
                        this.body.inertia = Infinity;
                        this.body.inverseInertia = 0;
                    } else {
                        // Calculate proper inertia based on the body shape
                        if (this.shape === "circle") {
                            // For circle: I = m * r^2
                            const mass = this.body.mass;
                            const radius = this.radius;
                            this.body.inertia = mass * radius * radius;
                        } else {
                            // For rectangles and other shapes, use Matter.js built-in calculation
                            // We need to recalculate based on vertices
                            const mass = this.body.mass;
                            let inertia = 0;
                            const vertices = this.body.vertices;

                            // Simple approximation for non-circular shapes
                            // Based on Matter.js internal calculations
                            const centre = this.body.position;
                            for (let i = 0; i < vertices.length; i++) {
                                const vertex = vertices[i];
                                const dx = vertex.x - centre.x;
                                const dy = vertex.y - centre.y;
                                const distSq = dx * dx + dy * dy;
                                inertia += distSq;
                            }

                            this.body.inertia = mass * (inertia / vertices.length);
                        }

                        // Make sure to update inverseInertia as well
                        this.body.inverseInertia = 1 / this.body.inertia;
                    }
                }
            }
        });

        this.exposeProperty("isSensor", "boolean", this.isSensor, {
            onChange: (val) => { this.isSensor = val; if (this.body) this.body.isSensor = val; }
        });

        this.boundOnCollisionStart = this.onCollisionStart.bind(this);
        this.boundOnCollisionEnd = this.onCollisionEnd.bind(this);

        // Store initial position for reset
        if (this.gameObject) {
            const pos = this.gameObject.getWorldPosition();
            this.initialPosition = { x: pos.x, y: pos.y };
            this.initialAngle = this.gameObject.angle;
        } else {
            this.initialPosition = null;
            this.initialAngle = null;
        }
    }

    /**
     * Create the physics body when the component starts
     */
    start() {
        if (!window.physicsManager) {
            console.error("Physics manager not found. Make sure it's initialized before using RigidBody.");
            return;
        }

        // Store initial position and angle
        if (this.gameObject) {
            const pos = this.gameObject.getWorldPosition();
            this.initialPosition = { x: pos.x, y: pos.y };
            this.initialAngle = this.gameObject.angle;
        }

        this.onStart();

        // Set up collision handlers
        Matter.Events.on(window.physicsManager.engine, 'collisionStart', this.boundOnCollisionStart);
        Matter.Events.on(window.physicsManager.engine, 'collisionEnd', this.boundOnCollisionEnd);
    }

    /**
     * Create the physics body based on current settings
     */
    createBody() {
        if (!this.gameObject) return;

        this.removeBody();

        if (!window.physicsManager) {
            console.error("PhysicsManager not found or not initialized");
            return null;
        }

        let body;
        let pos = this.gameObject.getWorldPosition();
        const angle = this.gameObject.angle * (Math.PI / 180);

        // Use collider size from GameObject
        const colliderWidth = this.gameObject.size?.x * this.gameObject.scale.x || this.width;
        const colliderHeight = this.gameObject.size?.y * this.gameObject.scale.y || this.height;
        const colliderRadius = (this.gameObject.size?.x * this.gameObject.scale.x || this.radius) / 2;

        const options = {
            friction: this.friction,
            frictionAir: this.frictionAir,
            restitution: this.restitution,
            density: this.density,
            isSensor: this.isSensor,
            isStatic: this.bodyType === "static",
            angle: angle,
            label: this.label || this.gameObject.name || "Body",
            collisionFilter: this.collisionFilter,
            sleepThreshold: this.sleepingAllowed ? 60 : -1
        };

        try {
            switch (this.shape) {
                case "rectangle":
                    body = Matter.Bodies.rectangle(pos.x, pos.y, colliderWidth, colliderHeight, options);
                    break;
                case "circle":
                    body = Matter.Bodies.circle(pos.x, pos.y, colliderRadius, options);
                    break;
                case "capsule":
                    // Create capsule as a compound body with a rectangle and two circles
                    const capsuleRadius = Math.min(colliderWidth, colliderHeight) / 2;
                    const capsuleLength = Math.max(colliderWidth, colliderHeight) - (capsuleRadius * 2);

                    if (colliderHeight > colliderWidth) {
                        // Vertical capsule
                        const rectHeight = capsuleLength;
                        const rect = Matter.Bodies.rectangle(pos.x, pos.y, colliderWidth, rectHeight, options);
                        const topCircle = Matter.Bodies.circle(pos.x, pos.y - rectHeight / 2, capsuleRadius, options);
                        const bottomCircle = Matter.Bodies.circle(pos.x, pos.y + rectHeight / 2, capsuleRadius, options);
                        body = Matter.Body.create({
                            parts: [rect, topCircle, bottomCircle],
                            ...options
                        });
                    } else {
                        // Horizontal capsule
                        const rectWidth = capsuleLength;
                        const rect = Matter.Bodies.rectangle(pos.x, pos.y, rectWidth, colliderHeight, options);
                        const leftCircle = Matter.Bodies.circle(pos.x - rectWidth / 2, pos.y, capsuleRadius, options);
                        const rightCircle = Matter.Bodies.circle(pos.x + rectWidth / 2, pos.y, capsuleRadius, options);
                        body = Matter.Body.create({
                            parts: [rect, leftCircle, rightCircle],
                            ...options
                        });
                    }
                    break;
                case "polygon":
                    let vertices = this.gameObject.polygonPoints?.length ?
                        this.gameObject.polygonPoints.map(pt => ({ x: pt.x, y: pt.y })) : this.vertices;
                    if (vertices && vertices.length >= 3) {
                        body = Matter.Bodies.fromVertices(pos.x, pos.y, vertices, options);
                    } else {
                        body = Matter.Bodies.polygon(pos.x, pos.y, 3, colliderRadius, options);
                    }
                    break;
                default:
                    body = Matter.Bodies.rectangle(pos.x, pos.y, colliderWidth, colliderHeight, options);
            }
        } catch (error) {
            console.error("Error creating physics body:", error);
            return null;
        }

        // Now that we have a valid body, continue with the rest of the method

        // Ensure static bodies are really static
        if (this.bodyType === "static") {
            //body.isStatic = true;
            body.inertia = Infinity;
            body.inverseInertia = 0;
            body.inverseMass = 0;
            body.mass = Infinity;
            body.velocity.x = 0;
            body.velocity.y = 0;
            body.angularVelocity = 0;

            //Matter.Body.setStatic(body, true);
        }
        else if (this.bodyType === "kinematic") {
            //body.isStatic = false;
            body.inertia = Infinity;
            body.inverseInertia = 0;
            body.mass = Infinity;
            body.inverseMass = 0;
        }
        else {
            //body.isStatic = false;
            body.mass = (this.density * body.area) || 1;
        }

        // Apply fixed rotation constraint
        if (this.fixedRotation) {
            body.inertia = Infinity;
            body.inverseInertia = 0;
        }

        // Gravity control (custom implementation)
        if (body) {
            body.ignoreGravity = !this.useGravity; // Custom flag, must be handled in your physicsManager update
        }

        // Register with physics manager - ensure this properly adds to the world
        try {
            // Register with physics manager
            if (window.physicsManager && body) {
                window.physicsManager.registerBody(body, this.gameObject);

                const isInWorld = window.physicsManager.engine.world.bodies.includes(body);
                if (!isInWorld) {
                    console.warn(`Body for ${options.label} was not properly added to the physics world`);
                    Matter.World.add(window.physicsManager.engine.world, body);
                }
            }
        } catch (error) {
            console.error("Error registering physics body:", error);
        }

        // Store reference to this module in the body
        if (body) {
            this.body = body;
            this.body.module = this;
        }

        return body;
    }

    setAngle(angle) {
        if (this.body) {
            const radians = angle * (Math.PI / 180);
            Matter.Body.setAngle(this.body, radians);
        }
    }

    rotate(deltaAngle) {
        if (this.body) {
            const radians = deltaAngle;
            Matter.Body.setAngle(this.body, this.body.angle + radians);
        }
    }

    updateMass(weight = 1) {
        if (this.body && this.bodyType === "dynamic") {
            const area = this.body.area || 1;
            const newMass = this.density * area * weight;
            Matter.Body.setMass(this.body, newMass);
        }
    }

    /**
     * Called when body should be created during game startup
     */
    onStart() {
        if (this.pendingBodyCreation && !this.body) {
            console.log("Creating pending RigidBody for:", this.gameObject?.name);
            this.createBody();
            this.pendingBodyCreation = false;
        }
    }

    /**
     * Reset the physics body and GameObject to their initial position and angle
     */
    resetPosition() {
        if (this.initialPosition && this.gameObject) {
            this.gameObject.setWorldPosition(this.initialPosition.x, this.initialPosition.y);
            this.gameObject.angle = this.initialAngle || 0;
            if (this.body) {
                Matter.Body.setPosition(this.body, { x: this.initialPosition.x, y: this.initialPosition.y });
                Matter.Body.setAngle(this.body, (this.initialAngle || 0) * (Math.PI / 180));
            }
        }
    }

    /**
     * Remove the body from the physics world
     */
    removeBody() {
        if (this.body && window.physicsManager) {
            window.physicsManager.removeBody(this.body);
            this.body = null;
        }
    }

    /**
     * Rebuild the body when properties change
     */
    rebuildBody() {
        if (this.gameObject && window.physicsManager) {
            // Update initial position and angle before rebuilding
            const pos = this.gameObject.getWorldPosition();
            this.initialPosition = { x: pos.x, y: pos.y };
            this.initialAngle = this.gameObject.angle;
            this.createBody();
        }
    }

    /**
     * Apply a force to the center of the body
     * @param {Vector2} force - The force to apply
     */
    applyForce(force) {
        if (this.body) {
            Matter.Body.applyForce(this.body, this.body.position, { x: force.x, y: force.y });
        }
    }

    /**
     * Apply an impulse to the center of the body
     * @param {Vector2} impulse - The impulse to apply
     */
    applyImpulse(impulse) {
        if (this.body) {
            const position = this.body.position;
            Matter.Body.applyForce(this.body, position, {
                x: impulse.x / this.body.mass,
                y: impulse.y / this.body.mass
            });
        }
    }

    /**
     * Apply a torque (rotational force) to the body
     * @param {number} torque - The torque to apply
     */
    applyTorque(torque) {
        if (this.body) {
            Matter.Body.setAngularVelocity(this.body, this.body.angularVelocity + torque);
        }
    }

    setAngularVelocity(angularVelocity) {
        if (this.body) {
            // Convert from degrees/sec to radians/sec
            const radians = angularVelocity * (Math.PI / 180);
            Matter.Body.setAngularVelocity(this.body, radians);
        }
    }

    /**
     * Set the linear velocity of the body
     * @param {Vector2} velocity - The velocity to set
     */
    setVelocity(velocity) {
        if (this.body) {
            Matter.Body.setVelocity(this.body, { x: velocity.x, y: velocity.y });
        }
    }

    /**
     * Get the current linear velocity of the body
     * @returns {Vector2} The current velocity
     */
    getVelocity() {
        if (this.body) {
            return new Vector2(this.body.velocity.x, this.body.velocity.y);
        }
        return new Vector2(0, 0);
    }

    /**
     * Set the angular velocity of the body
     * @param {number} angularVelocity - The angular velocity in degrees/second
     */
    setAngularVelocity(angularVelocity) {
        if (this.body) {
            // Convert from degrees/sec to radians/sec
            const radians = angularVelocity * (Math.PI / 180);
            Matter.Body.setAngularVelocity(this.body, radians);
        }
    }

    /**
     * Get the current angular velocity of the body
     * @returns {number} The angular velocity in degrees/second
     */
    getAngularVelocity() {
        if (this.body) {
            // Convert from radians/sec to degrees/sec
            return this.body.angularVelocity * (180 / Math.PI);
        }
        return 0;
    }

    updateColliderSize() {
        if (!this.gameObject || this._skipRebuild) return;
        
        const newWidth = this.gameObject.size?.x * this.gameObject.scale.x || this.width;
        const newHeight = this.gameObject.size?.y * this.gameObject.scale.y || this.height;
        const newRadius = (this.gameObject.size?.x * this.gameObject.scale.x || this.radius) / 2;
        
        // Check if size changed
        const currentWidth = this.width;
        const currentHeight = this.height;
        const currentRadius = this.radius;
        
        if (Math.abs(newWidth - currentWidth) > 0.1 || 
            Math.abs(newHeight - currentHeight) > 0.1 || 
            Math.abs(newRadius - currentRadius) > 0.1) {
            
            this.width = newWidth;
            this.height = newHeight;
            this.radius = newRadius;
            this.rebuildBody();
        }
    }

    /**
     * Handle collision start events
     */
    onCollisionStart(event) {
        const pairs = event.pairs;

        for (let i = 0; i < pairs.length; i++) {
            const pair = pairs[i];

            if (pair.bodyA === this.body) {
                // Add the colliding body to our contacts
                this.inCollision.add(pair.bodyB);

                // Find the other game object
                const otherObject = window.physicsManager.bodies.get(pair.bodyB);
                if (otherObject) {
                    // Call the onCollisionEnter method if it exists
                    if (this.gameObject && this.gameObject.onCollisionEnter) {
                        this.gameObject.onCollisionEnter(otherObject);
                    }
                }
            }
            else if (pair.bodyB === this.body) {
                // Add the colliding body to our contacts
                this.inCollision.add(pair.bodyA);

                // Find the other game object
                const otherObject = window.physicsManager.bodies.get(pair.bodyA);
                if (otherObject) {
                    // Call the onCollisionEnter method if it exists
                    if (this.gameObject && this.gameObject.onCollisionEnter) {
                        this.gameObject.onCollisionEnter(otherObject);
                    }
                }
            }
        }
    }

    /**
     * Handle collision end events
     */
    onCollisionEnd(event) {
        const pairs = event.pairs;

        for (let i = 0; i < pairs.length; i++) {
            const pair = pairs[i];

            if (pair.bodyA === this.body) {
                // Remove the body from our contacts
                this.inCollision.delete(pair.bodyB);

                // Find the other game object
                const otherObject = window.physicsManager.bodies.get(pair.bodyB);
                if (otherObject) {
                    // Call the onCollisionExit method if it exists
                    if (this.gameObject && this.gameObject.onCollisionExit) {
                        this.gameObject.onCollisionExit(otherObject);
                    }
                }
            }
            else if (pair.bodyB === this.body) {
                // Remove the body from our contacts
                this.inCollision.delete(pair.bodyA);

                // Find the other game object
                const otherObject = window.physicsManager.bodies.get(pair.bodyA);
                if (otherObject) {
                    // Call the onCollisionExit method if it exists
                    if (this.gameObject && this.gameObject.onCollisionExit) {
                        this.gameObject.onCollisionExit(otherObject);
                    }
                }
            }
        }
    }

    /**
     * Called before rendering to update static bodies if needed
     */
    beginLoop() {
        // Update collider size if GameObject size changed
        this.updateColliderSize();

        // If the game object has moved, we need to update static bodies
        if (this.body && this.bodyType === 'static' && this.gameObject) {
            const pos = this.gameObject.getWorldPosition();
            const angle = this.gameObject.angle * (Math.PI / 180);
            Matter.Body.setPosition(this.body, { x: pos.x, y: pos.y });
            Matter.Body.setAngle(this.body, angle);
        }

        if (this.fixedRotation) {
            if (this.body) {
                Matter.Body.setAngularVelocity(this.body, 0);
                this.body.angle = 0;
            }
        }
    }

    /**
     * Override onEnable to handle pending body creation
     */
    onEnable() {
        if (this.pendingBodyCreation && !this.body && window.physicsManager) {
            this.createBody();
            this.pendingBodyCreation = false;
        }
    }

    drawGizmos(ctx) {
        const transform = this.gameObject;

        const pos = transform.position;
        const angle = transform.angle * (Math.PI / 180);
        
        // Get actual collider size
        const colliderWidth = this.gameObject.size?.x * this.gameObject.scale.x || this.width;
        const colliderHeight = this.gameObject.size?.y * this.gameObject.scale.y || this.height;
        const colliderRadius = (this.gameObject.size?.x * this.gameObject.scale.x || this.radius) / 2;

        ctx.save();
        ctx.translate(pos.x, pos.y);
        ctx.rotate(angle);
        
        // Set gizmo style
        ctx.strokeStyle = this.isSensor ? '#00ff00' : '#ffffff';
        ctx.lineWidth = this.bodyType === 'static' ? 2 : 1;
        ctx.setLineDash(this.bodyType === 'kinematic' ? [5, 5] : []);
        
        ctx.beginPath();
        
        switch (this.shape) {
            case "rectangle":
                ctx.rect(-colliderWidth/2, -colliderHeight/2, colliderWidth, colliderHeight);
                break;
                
            case "circle":
                ctx.arc(0, 0, colliderRadius, 0, Math.PI * 2);
                // Draw radius line
                ctx.moveTo(0, 0);
                ctx.lineTo(colliderRadius, 0);
                break;
                
            case "capsule":
                const capsuleRadius = Math.min(colliderWidth, colliderHeight) / 2;
                const capsuleLength = Math.max(colliderWidth, colliderHeight) - (capsuleRadius * 2);
                
                if (colliderHeight > colliderWidth) {
                    // Vertical capsule
                    const halfLength = capsuleLength / 2;
                    // Draw rectangle part
                    ctx.rect(-colliderWidth/2, -halfLength, colliderWidth, capsuleLength);
                    // Draw top semicircle
                    ctx.arc(0, -halfLength, capsuleRadius, Math.PI, 0, false);
                    // Draw bottom semicircle
                    ctx.arc(0, halfLength, capsuleRadius, 0, Math.PI, false);
                } else {
                    // Horizontal capsule
                    const halfLength = capsuleLength / 2;
                    // Draw rectangle part
                    ctx.rect(-halfLength, -colliderHeight/2, capsuleLength, colliderHeight);
                    // Draw left semicircle
                    ctx.arc(-halfLength, 0, capsuleRadius, Math.PI/2, -Math.PI/2, false);
                    // Draw right semicircle
                    ctx.arc(halfLength, 0, capsuleRadius, -Math.PI/2, Math.PI/2, false);
                }
                break;
                
            case "polygon":
                const vertices = this.gameObject.polygonPoints?.length ? 
                    this.gameObject.polygonPoints : 
                    this.vertices.length ? this.vertices :
                    // Default triangle
                    [{ x: 0, y: -colliderRadius }, { x: -colliderRadius, y: colliderRadius }, { x: colliderRadius, y: colliderRadius }];
                
                if (vertices.length > 0) {
                    ctx.moveTo(vertices[0].x, vertices[0].y);
                    for (let i = 1; i < vertices.length; i++) {
                        ctx.lineTo(vertices[i].x, vertices[i].y);
                    }
                    ctx.closePath();
                }
                break;
        }
        
        ctx.stroke();
        ctx.restore();
    }

    /**
     * Called when the module is destroyed
     */
    onDestroy() {
        // Remove event listeners
        if (window.physicsManager && window.physicsManager.engine) {
            Matter.Events.off(window.physicsManager.engine, 'collisionStart', this.boundOnCollisionStart);
            Matter.Events.off(window.physicsManager.engine, 'collisionEnd', this.boundOnCollisionEnd);
        }

        // Remove body from physics world
        this.removeBody();
    }

    toJSON() {
        return {
            ...super.toJSON(),
            bodyType: this.bodyType,
            shape: this.shape,
            width: this.width,
            height: this.height,
            radius: this.radius,
            density: this.density,
            friction: this.friction,
            frictionAir: this.frictionAir,
            restitution: this.restitution,
            fixedRotation: this.fixedRotation,
            isSensor: this.isSensor,
            useGravity: this.useGravity,
            sleepingAllowed: this.sleepingAllowed,
            label: this.label,
            collisionFilter: { ...this.collisionFilter },
            vertices: this.vertices
        };
    }

    /**
     * Override from Module to handle deserialization
     * @param {Object} data - The serialized data
     */
    fromJSON(data) {
        super.fromJSON(data);
        this.bodyType = data.bodyType ?? this.bodyType;
        this.shape = data.shape ?? this.shape;
        this.width = data.width ?? this.width;
        this.height = data.height ?? this.height;
        this.radius = data.radius ?? this.radius;
        this.density = data.density ?? this.density;
        this.friction = data.friction ?? this.friction;
        this.frictionAir = data.frictionAir ?? this.frictionAir;
        this.restitution = data.restitution ?? this.restitution;
        this.fixedRotation = data.fixedRotation ?? false;
        this.isSensor = data.isSensor ?? false;
        this.useGravity = data.useGravity ?? true;
        this.sleepingAllowed = data.sleepingAllowed ?? true;
        this.label = data.label ?? "";
        this.collisionFilter = { ...this.collisionFilter, ...data.collisionFilter };
        this.vertices = data.vertices ?? [];

        // Update initial position and angle after deserialization
        if (this.gameObject) {
            const pos = this.gameObject.getWorldPosition();
            this.initialPosition = { x: pos.x, y: pos.y };
            this.initialAngle = this.gameObject.angle;
            //this.createBody();
        }

        this.pendingBodyCreation = true; // Delay body creation until onEnable or start
    }
}

// Register the module
window.RigidBody = RigidBody;

// src/core/Modules/Drawing/DrawCircle.js
class DrawCircle extends Module {
    static namespace   = "Drawing";
    static description = "Draws a filled circle at the GameObject's position";
    static iconColor = "#a200ffff";

    constructor() {
        super("DrawCircle");

        /** @type {number} Radius of the circle */
        this.radius = 25;
        /** @type {Vector2} Offset from the GameObject's center */
        this.offset = new Vector2(0, 0);
        /** @type {string} Fill color */
        this.color = "#ffffff";
        /** @type {boolean} Whether to fill the circle */
        this.fill = true;
        /** @type {boolean} Whether to draw an outline */
        this.outline = false;
        /** @type {string} Outline color */
        this.outlineColor = "#000000";
        /** @type {number} Outline width */
        this.outlineWidth = 2;

        // Expose all properties with onChange handlers
        this.exposeProperty("radius", "number", this.radius, { 
            min: 0, 
            description: "Circle radius",
            onChange: (val) => this.radius = val
        });
        
        this.exposeProperty("offset", "vector2", this.offset, { 
            description: "Offset from center",
            onChange: (val) => this.offset = val
        });
        
        this.exposeProperty("color", "color", this.color, { 
            description: "Fill color",
            onChange: (val) => this.color = val
        });
        
        this.exposeProperty("fill", "boolean", this.fill, { 
            description: "Fill circle",
            onChange: (val) => this.fill = val
        });
        
        this.exposeProperty("outline", "boolean", this.outline, { 
            description: "Show outline",
            onChange: (val) => this.outline = val
        });
        
        this.exposeProperty("outlineColor", "color", this.outlineColor, { 
            description: "Outline color",
            onChange: (val) => this.outlineColor = val
        });
        
        this.exposeProperty("outlineWidth", "number", this.outlineWidth, { 
            description: "Outline thickness",
            min: 0,
            max: 20,
            step: 0.5,
            onChange: (val) => this.outlineWidth = val
        });
    }

    getBoundingBox() {
        // Calculate bounding box based on radius and offset
        const x = this.offset.x - this.radius;
        const y = this.offset.y - this.radius;
        return {
            x: x,
            y: y,
            width: this.radius * 2,
            height: this.radius * 2
        };
    }

    /**
     * Draw the circle centered at the GameObject,
     * then translated by offset.
     */
    draw(ctx, pixiDisplayObject) {
        if (!this.enabled) return;

        // PIXI path
        if (window.engine && window.engine.usePixi && ctx instanceof window.PixiRenderer) {
            const graphics = pixiDisplayObject || ctx.graphics;
            graphics.clear();

            // Helper to convert color string to hex
            function toHex(color) {
                if (window.PIXI && window.PIXI.utils && window.PIXI.utils.string2hex) {
                    return window.PIXI.utils.string2hex(color);
                }
                // Fallback: handle #RRGGBB or #RGB
                if (typeof color === "string" && color.startsWith("#")) {
                    return parseInt(color.slice(1), 16);
                }
                // Default to white
                return 0xffffff;
            }

            // Fill
            if (this.fill) {
                graphics.beginFill(toHex(this.color));
            }
            // Outline
            if (this.outline) {
                graphics.lineStyle(this.outlineWidth, toHex(this.outlineColor));
            }
            graphics.drawCircle(this.offset.x, this.offset.y, this.radius);
            graphics.endFill();
            ctx.render();
            return;
        }

        ctx.save();
        ctx.translate(this.offset.x, this.offset.y);

        // Draw the circle path
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        
        // Fill if enabled
        if (this.fill) {
            ctx.fillStyle = this.color;
            ctx.fill();
        }
        
        // Draw outline if enabled
        if (this.outline) {
            ctx.strokeStyle = this.outlineColor;
            ctx.lineWidth = this.outlineWidth;
            ctx.stroke();
        }

        ctx.restore();
    }

    toJSON() {
        return {
            ...super.toJSON(),
            radius: this.radius,
            offset: this.offset.toJSON(),
            color: this.color,
            fill: this.fill,
            outline: this.outline,
            outlineColor: this.outlineColor,
            outlineWidth: this.outlineWidth
        };
    }

    /**
     * Override to handle deserialization
     * @param {Object} data Serialized data
     */
    fromJSON(data) {
        super.fromJSON(data);
        this.radius = data.radius || this.radius;
        this.offset = Vector2.fromJSON(data.offset) || this.offset;
        this.color = data.color || this.color;
        this.fill = data.fill !== undefined ? data.fill : this.fill;
        this.outline = data.outline !== undefined ? data.outline : this.outline;
        this.outlineColor = data.outlineColor || this.outlineColor;
        this.outlineWidth = data.outlineWidth || this.outlineWidth;
    }
}

window.DrawCircle = DrawCircle;

// src/core/Modules/Drawing/DrawRectangle.js
class DrawRectangle extends Module {
    static namespace   = "Drawing";
    static description = "Draws a filled rectangle at the GameObject's position";
    static iconColor = "#a200ffff";

    constructor() {
        super("DrawRectangle");

        /** @type {number} Full width of the rectangle */
        this.width = 50;
        /** @type {number} Full height of the rectangle */
        this.height = 50;
        /** @type {Vector2} Offset from the GameObject's center */
        this.offset = new Vector2(0, 0);
        /** @type {string} Fill color */
        this.color = "#ffffff";
        /** @type {boolean} Whether to fill the rectangle */
        this.fill = true;
        /** @type {boolean} Whether to draw an outline */
        this.outline = false;
        /** @type {string} Outline color */
        this.outlineColor = "#000000";
        /** @type {number} Outline width */
        this.outlineWidth = 2;

        this.exposeProperty("width", "number", this.width, { 
            min: 0, 
            description: "Rectangle width",
            onChange: (val) => this.width = val
        });
        
        this.exposeProperty("height", "number", this.height, { 
            min: 0, 
            description: "Rectangle height",
            onChange: (val) => this.height = val
        });
        
        this.exposeProperty("offset", "vector2", this.offset, { 
            description: "Offset from center",
            onChange: (val) => this.offset = val
        });
        
        this.exposeProperty("color", "color", this.color, { 
            description: "Fill color",
            onChange: (val) => this.color = val
        });
        
        this.exposeProperty("fill", "boolean", this.fill, { 
            description: "Fill rectangle",
            onChange: (val) => this.fill = val
        });
        
        this.exposeProperty("outline", "boolean", this.outline, { 
            description: "Show outline",
            onChange: (val) => this.outline = val
        });
        
        this.exposeProperty("outlineColor", "color", this.outlineColor, { 
            description: "Outline color",
            onChange: (val) => this.outlineColor = val
        });
        
        this.exposeProperty("outlineWidth", "number", this.outlineWidth, { 
            description: "Outline thickness",
            min: 0,
            max: 20,
            step: 0.5,
            onChange: (val) => this.outlineWidth = val
        });
    }

    getBoundingBox() {
        if (!this.gameObject) return null;
        // Calculate bounding box based on width, height and offset
        const x = this.gameObject.position.x + this.offset.x - this.width / 2;
        const y = this.gameObject.position.y + this.offset.y - this.height / 2;
        return {
            x: x,
            y: y,
            width: this.width,
            height: this.height
        };
    }

    /**
     * Draw the rectangle centered at the GameObject,
     * then translated by offset.
     */
    draw(ctx) {
        if (!this.enabled) return;

        ctx.save();
        // apply offset relative to object center
        ctx.translate(this.offset.x, this.offset.y);

        // Draw the rectangle path
        ctx.beginPath();
        ctx.rect(-this.width/2, -this.height/2, this.width, this.height);
        
        // Fill if enabled
        if (this.fill) {
            ctx.fillStyle = this.color;
            ctx.fill();
        }
        
        // Draw outline if enabled
        if (this.outline) {
            ctx.strokeStyle = this.outlineColor;
            ctx.lineWidth = this.outlineWidth;
            ctx.stroke();
        }

        ctx.restore();
    }

    toJSON() {
        return {
            width: this.width,
            height: this.height,
            offset:  { x: this.offset.x, y: this.offset.y },
            color: this.color,
            fill: this.fill,
            outline: this.outline,
            outlineColor: this.outlineColor,
            outlineWidth: this.outlineWidth
        };
    }

    /**
     * Override to handle serialization
     * @returns {Object} Serialized data
     */
    fromJSON(data) {
        if (data.width !== undefined) this.width = data.width;
        if (data.height !== undefined) this.height = data.height;
        if (data.offset) this.offset = data.offset;
        if (data.color !== undefined) this.color = data.color;
        if (data.fill !== undefined) this.fill = data.fill;
        if (data.outline !== undefined) this.outline = data.outline;
        if (data.outlineColor !== undefined) this.outlineColor = data.outlineColor;
        if (data.outlineWidth !== undefined) this.outlineWidth = data.outlineWidth;
    }
}

// make it available to the engine
window.DrawRectangle = DrawRectangle;

// src/core/Modules/ObjectTiling.js
// Could not load src/core/Modules/ObjectTiling.js: Failed to load src/core/Modules/ObjectTiling.js: 404

// src/core/Modules/Controllers/CameraController.js
/**
 * CameraController - Controls the game's camera view
 * 
 * This module provides smooth camera movement and zoom capabilities.
 * When attached to a GameObject, the camera automatically follows that object.
 */
class CameraController extends Module {
    static allowMultiple = false;
    static namespace = "Camera";
    static description = "Control the viewport camera for the game scene. ";
    static iconClass = "fas fa-video";

    constructor() {
        super("CameraController");

        // Camera position (in world coordinates)
        this.position = new Vector2(0, 0);

        // Camera settings
        this.followSpeed = 5.0;
        this.zoomSpeed = 2.0;
        this.zoom = 1.0;
        this.targetZoom = 1.0;
        this.bounds = null; // Optional camera bounds {x, y, width, height}

        // Offset from attached object (useful for looking ahead)
        this.offset = new Vector2(0, 0);

        // Damping (smoothness) values
        this.positionDamping = 0.85;
        this.zoomDamping = 0.85;

        // Dynamic zoom properties
        this.dynamicZoomEnabled = false;
        this.maxZoomOut = 0.2;
        this.zoomSmoothness = 0.85;
        this.zoomIntensityMultiplier = 0.001;

        // Shake effect properties
        this.shakeIntensity = 0;
        this.shakeDuration = 0;
        this.shakeTimer = 0;
        this.shakeDecay = 1;

        // Auto-follow settings
        this.followOwner = true;
        this.followOwnerAngle = false; // Angle to follow the owner at
        this.followAngleOffset = 0; // Angle offset when following owner
        this.currentAngle = 0; // Current camera angle for smooth lerping
        this.targetAngle = 0; // Target angle for smooth lerping

        // Expose properties
        this.exposeProperty("followOwner", "boolean", true, {
            description: "Whether camera follows this GameObject",
            onChange: (val) => { this.followOwner = val; }
        });

        /*this.exposeProperty("followOwnerAngle", "boolean", false, {
            description: "Whether camera follows the owner's angle",
            onChange: (val) => { this.followOwnerAngle = val; }
        });*/

        /*this.exposeProperty("followAngleOffset", "number", 0, {
            description: "Angle offset when following owner",
            min: -Math.PI,
            max: Math.PI,
            step: 0.01,
            onChange: (val) => { this.followAngleOffset = val; }
        });*/

        this.exposeProperty("followSpeed", "number", 5.0, {
            description: "How quickly the camera follows its target",
            min: 0.1,
            max: 20,
            step: 0.1,
            onChange: (val) => { this.followSpeed = val; }
        });

        this.exposeProperty("zoom", "number", 1.0, {
            description: "Camera zoom level (1.0 = 100%)",
            min: 0.1,
            max: 10,
            step: 0.1,
            onChange: (val) => { this.zoom = val; }
        });

        this.exposeProperty("targetZoom", "number", 1.0, {
            description: "Target zoom level (base zoom level)",
            min: 0.1,
            max: 10,
            step: 0.1,
            onChange: (val) => { this.targetZoom = val; }
        });

        this.exposeProperty("positionDamping", "number", 0.85, {
            description: "Smoothness of camera movement (0-1)",
            min: 0,
            max: 0.99,
            step: 0.01,
            onChange: (val) => { this.positionDamping = val; }
        });

        this.exposeProperty("zoomDamping", "number", 0.85, {
            description: "Smoothness of camera zoom (0-1)",
            min: 0,
            max: 0.99,
            step: 0.01,
            onChange: (val) => { this.zoomDamping = val; }
        });

        this.exposeProperty("dynamicZoomEnabled", "boolean", false, {
            description: "Enable dynamic zoom based on GameObject speed",
            onChange: (val) => { this.dynamicZoomEnabled = val; }
        });

        this.exposeProperty("maxZoomOut", "number", 0.5, {
            description: "Maximum zoom out level",
            min: 0.1,
            max: 10,
            step: 0.1,
            onChange: (val) => { this.maxZoomOut = val; }
        });

        this.exposeProperty("zoomSmoothness", "number", 0.85, {
            description: "Smoothness of dynamic zoom (0-1)",
            min: 0,
            max: 0.99,
            step: 0.01,
            onChange: (val) => { this.zoomSmoothness = val; }
        });

        this.exposeProperty("zoomIntensityMultiplier", "number", 0.01, {
            description: "Multiplier for zoom intensity based on speed",
            min: 0.001,
            max: 1,
            step: 0.001,
            onChange: (val) => { this.zoomIntensityMultiplier = val; }
        });

        this.exposeProperty("shakeIntensity", "number", 0, {
            description: "Intensity of camera shake effect",
            min: 0,
            max: 100,
            step: 1,
            onChange: (val) => { this.shakeIntensity = val; }
        });

        this.exposeProperty("shakeTimer", "number", 0, {
            description: "Internal timer for shake effect",
            readOnly: true,
            onChange: (val) => { this.shakeTimer = val; }
        });

        this.exposeProperty("offset", "vector2", this.offset, {
            description: "Camera offset from this GameObject",
            onChange: (val) => {
                this.offset = new Vector2(val.x, val.y);
                //this.updateSceneViewport(); // Update immediately
            }
        });
    }

    /**
 * Optional method for enhanced inspector UI using the Style helper
 * This will be called by the Inspector if it exists
 * @param {Style} style - Styling helper
 */
    style(style) {
        style.startGroup("Camera Follow", false, {
            backgroundColor: 'rgba(100,150,255,0.08)',
            borderRadius: '6px',
            padding: '8px'
        });
        style.exposeProperty("followOwner", "boolean", this.followOwner, { label: "Follow GameObject" });
        style.exposeProperty("followSpeed", "number", this.followSpeed, { label: "Follow Speed" });
        style.exposeProperty("offset", "vector2", this.offset, { label: "Camera Offset" });
        style.endGroup();

        style.addDivider();

        style.startGroup("Zoom & Dynamics", false, {
            backgroundColor: 'rgba(150,255,150,0.08)',
            borderRadius: '6px',
            padding: '8px'
        });
        style.exposeProperty("zoom", "number", this.zoom, { label: "Zoom" });
        style.exposeProperty("targetZoom", "number", this.targetZoom, { label: "Target Zoom" });
        style.exposeProperty("zoomDamping", "number", this.zoomDamping, { label: "Zoom Damping" });
        style.exposeProperty("dynamicZoomEnabled", "boolean", this.dynamicZoomEnabled, { label: "Dynamic Zoom" });
        style.exposeProperty("maxZoomOut", "number", this.maxZoomOut, { label: "Max Zoom Out" });
        style.exposeProperty("zoomSmoothness", "number", this.zoomSmoothness, { label: "Zoom Smoothness" });
        style.exposeProperty("zoomIntensityMultiplier", "number", this.zoomIntensityMultiplier, { label: "Zoom Intensity Multiplier" });
        style.endGroup();

        style.addDivider();

        style.startGroup("Shake & Misc", false, {
            backgroundColor: 'rgba(255,150,150,0.08)',
            borderRadius: '6px',
            padding: '8px'
        });
        style.exposeProperty("shakeIntensity", "number", this.shakeIntensity, { label: "Shake Intensity" });
        style.exposeProperty("shakeTimer", "number", this.shakeTimer, { label: "Shake Timer" });
        style.exposeProperty("positionDamping", "number", this.positionDamping, { label: "Position Damping" });
        style.endGroup();
    }

    /**
     * Called when the module is first attached
     */
    onAttach(gameObject) {
        // Initialize camera position to the GameObject's position
        const pos = gameObject.getWorldPosition();
        this.position = new Vector2(pos.x, pos.y);

        // Initialize the scene viewport immediately to prevent black screen
        this.updateSceneViewport();
    }

    /**
     * Get the target position (including offset)
     */
    getTargetPosition() {
        if (!this.gameObject || !this.followOwner) return this.position.clone();

        const targetPos = this.gameObject.getWorldPosition();
        return new Vector2(
            targetPos.x + this.offset.x,
            targetPos.y + this.offset.y
        );
    }

    /**
     * Immediately move the camera to the target without smoothing
     */
    jumpToTarget() {
        this.position = this.getTargetPosition();
        //this.applyBounds();
        this.updateSceneViewport();
    }

    /**
     * Move camera to specific world position with optional smoothing
     * @param {Vector2} position - World position to move to
     * @param {boolean} immediate - If true, jump immediately without smoothing
     */
    moveTo(position, immediate = false) {
        // Temporarily disable following while moving to a specific point
        const wasFollowing = this.followOwner;
        this.followOwner = false;

        if (immediate) {
            this.position = position.clone();
            //this.applyBounds();
            this.updateSceneViewport();
        } else {
            this._targetPosition = position.clone();
        }

        // After 1 second, restore original following state
        if (wasFollowing) {
            setTimeout(() => {
                this.followOwner = wasFollowing;
            }, 1000);
        }
    }

    /**
     * Set camera zoom level
     * @param {number} zoomLevel - New zoom level
     * @param {boolean} immediate - If true, apply immediately without smoothing
     */
    setZoom(zoomLevel, immediate = false) {
        this.targetZoom = Math.max(0.1, zoomLevel);

        if (immediate) {
            this.zoom = this.targetZoom;
            this.updateSceneViewport();
        }
    }

    /**
     * Apply a camera shake effect
     * @param {number} intensity - Shake intensity
     * @param {number} duration - Shake duration in seconds
     */
    shake(intensity = 10, duration = 0.5) {
        this.shakeIntensity = intensity;
        this.shakeDuration = duration;
        this.shakeTimer = duration;
    }

    /**
     * Constrain camera to bounds if set
     */
    applyBounds() {
        if (!this.bounds) return;

        // Get half-viewport dimensions
        const engine = window.engine;
        if (!engine || !engine.scene) return;

        const settings = engine.scene.settings || {};
        const viewportWidth = settings.viewportWidth || 800;
        const viewportHeight = settings.viewportHeight || 600;
        const halfWidth = (viewportWidth / 2) / this.zoom;
        const halfHeight = (viewportHeight / 2) / this.zoom;

        // Constrain to bounds with viewport consideration
        if (this.bounds) {
            this.position.x = Math.max(
                this.bounds.x + halfWidth,
                Math.min(this.bounds.x + this.bounds.width - halfWidth, this.position.x)
            );
            this.position.y = Math.max(
                this.bounds.y + halfHeight,
                Math.min(this.bounds.y + this.bounds.height - halfHeight, this.position.y)
            );
        }
    }

    /**
     * Update the scene's viewport settings based on camera position/zoom
     */
    updateSceneViewport() {
        const engine = window.engine;
        if (!engine) {
            console.warn("CameraController: Engine not available, cannot update viewport.");
            return;
        }

        const viewportWidth = engine.viewport.width ? engine.viewport.width : 800;
        const viewportHeight = engine.viewport.height ? engine.viewport.height : 600;

        let centerX = this.position.x;
        let centerY = this.position.y;

        // Apply shake effect if active
        let shakeOffsetX = 0;
        let shakeOffsetY = 0;

        let halfWidth = viewportWidth / 2 / this.zoom;
        let halfHeight = viewportHeight / 2 / this.zoom;

        // Use the smoothly lerped angle
        engine.viewport.angle = this.currentAngle;

        if (this.shakeTimer > 0) {
            shakeOffsetX = (Math.random() * 2 - 1) * this.shakeIntensity;
            shakeOffsetY = (Math.random() * 2 - 1) * this.shakeIntensity;
        }

        // Camera position is always the center, so subtract half the viewport size divided by zoom
        engine.viewport.x = centerX - (viewportWidth / 2) + shakeOffsetX;
        engine.viewport.y = centerY - (viewportHeight / 2) + shakeOffsetY;

        engine.viewport.width = viewportWidth;
        engine.viewport.height = viewportHeight;
        engine.viewport.zoom = this.zoom;

        if (engine.resizeCanvas) {
            engine.resizeCanvas();
        }
    }

    /**
     * Main update loop
     * @param {number} deltaTime - Time since last frame in seconds
     */
    loop(deltaTime) {
        // Always follow owner if dynamic zoom is enabled
        if (this.dynamicZoomEnabled) {
            this.followOwner = true;
            this._targetPosition = undefined;
        }

        // Handle following with smooth lerp
        const targetPos = this.followOwner ? this.getTargetPosition() : (this._targetPosition || this.position);

        // Update target angle if following owner angle
        if (this.followOwnerAngle && this.gameObject) {
            // Get the owner's angle directly - it should already be in the correct format
            this.targetAngle = this.gameObject.angle + this.followAngleOffset;
        } else {
            this.targetAngle = 0;
        }

        // Smoothly move towards target position
        if (!this.position.equals(targetPos)) {
            // Calculate how far to move this frame using follow speed
            const lerpFactor = 1.0 - Math.pow(this.positionDamping, deltaTime * this.followSpeed);

            this.position.x = this.position.x + (targetPos.x - this.position.x) * lerpFactor;
            this.position.y = this.position.y + (targetPos.y - this.position.y) * lerpFactor;
        }

        // Smooth angle changes when following owner angle
        if (this.followOwnerAngle && this.gameObject) {
            // Use the same lerp factor as position for consistent feel
            const angleLerpFactor = 1.0 - Math.pow(this.positionDamping, deltaTime * this.followSpeed);

            // Handle angle wrapping for shortest rotation path
            let angleDiff = this.targetAngle - this.currentAngle;

            // Normalize angle difference to [-π, π] for shortest rotation
            while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
            while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

            this.currentAngle += angleDiff * angleLerpFactor;
        } else if (!this.followOwnerAngle) {
            // Reset to 0 when not following angle
            if (Math.abs(this.currentAngle) > 0.001) {
                const angleLerpFactor = 1.0 - Math.pow(this.positionDamping, deltaTime * this.followSpeed);

                let angleDiff = -this.currentAngle;
                while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
                while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;

                this.currentAngle += angleDiff * angleLerpFactor;

                if (Math.abs(this.currentAngle) < 0.001) {
                    this.currentAngle = 0;
                }
            }
        }

        // Smooth zoom changes
        if (this.zoom !== this.targetZoom) {
            const zoomLerpFactor = 1.0 - Math.pow(this.zoomDamping, deltaTime * this.zoomSpeed);
            this.zoom += (this.targetZoom - this.zoom) * zoomLerpFactor;

            // Snap to target when close enough
            if (Math.abs(this.zoom - this.targetZoom) < 0.001) {
                this.zoom = this.targetZoom;
            }
        }

        // Dynamic zoom based on GameObject speed
        if (this.dynamicZoomEnabled && this.gameObject && this.gameObject.previousPosition) {
            const prev = this.gameObject.previousPosition;
            const curr = this.gameObject.position;
            const speed = Math.sqrt(
                Math.pow(curr.x - prev.x, 2) + Math.pow(curr.y - prev.y, 2)
            ) / (deltaTime || 1);

            // Calculate target zoom based on speed
            // At speed=0, zoom=1.0; at high speed, zoom approaches maxZoomOut
            let desiredZoom = 1.0 - speed * this.zoomIntensityMultiplier;
            desiredZoom = Math.max(this.maxZoomOut, Math.min(1.0, desiredZoom));
            this.targetZoom = desiredZoom;

            // Smooth zoom changes
            const zoomLerpFactor = 1.0 - Math.pow(this.zoomSmoothness, deltaTime * this.zoomSpeed);
            this.zoom += (this.targetZoom - this.zoom) * zoomLerpFactor;
            if (Math.abs(this.zoom - this.targetZoom) < 0.001) {
                this.zoom = this.targetZoom;
            }
        }

        // Update shake effect
        if (this.shakeTimer > 0) {
            this.shakeTimer -= deltaTime;
            if (this.shakeTimer <= 0) {
                this.shakeTimer = 0;
                this.shakeIntensity = 0;
            } else {
                // Gradually reduce intensity over time
                this.shakeIntensity *= this.shakeDecay;
            }
        }

        if (this.zoom <= 0.1) {
            this.zoom = 0.1; // Prevent zooming out too far
            this.targetZoom = 0.1; // Ensure target zoom is also clamped
        }

        // Ensure camera stays within bounds
        //this.applyBounds();

        // Update the actual viewport in the scene
        this.updateSceneViewport();
    }

    /**
     * Set camera bounds
     * @param {number} x - Left boundary
     * @param {number} y - Top boundary
     * @param {number} width - Boundary width
     * @param {number} height - Boundary height
     */
    setBounds(x, y, width, height) {
        this.bounds = { x, y, width, height };
        //this.applyBounds(); // Apply immediately
    }

    /**
     * Clear camera bounds
     */
    clearBounds() {
        this.bounds = null;
    }

    /**
     * Pan the camera by a given amount (in world units)
     * @param {number} dx - Amount to move in X
     * @param {number} dy - Amount to move in Y
     * @param {boolean} immediate - If true, move instantly
     */
    pan(dx, dy, immediate = false) {
        this.followOwner = false; // Disable auto-follow when panning manually
        const newPos = new Vector2(this.position.x + dx, this.position.y + dy);
        this.moveTo(newPos, immediate);
    }

    /**
     * Center camera on a specific world position
     * @param {number} x
     * @param {number} y
     * @param {boolean} immediate
     */
    centerOn(x, y, immediate = false) {
        this.followOwner = false;
        this.moveTo(new Vector2(x, y), immediate);
    }

    /**
     * Called when the module is enabled 
     */
    onEnable() {
        // Make sure viewport is updated when module is enabled
        if (this.gameObject) {
            const pos = this.gameObject.getWorldPosition();
            this.position = new Vector2(pos.x, pos.y);
            this.updateSceneViewport();
        }
    }

    /**
     * Called when the module is first attached
     */
    onAttach(gameObject) {
        // Initialize camera position to the GameObject's position
        const pos = gameObject.getWorldPosition();
        this.position = new Vector2(pos.x, pos.y);

        // Initialize the scene viewport immediately to prevent black screen
        setTimeout(() => {
            // Using setTimeout ensures the engine is fully initialized
            this.jumpToTarget();
        }, 0);
    }

    /**
     * Override to handle serialization
     */
    toJSON() {
        const json = super.toJSON() || {};

        // Store camera properties
        json.position = { x: this.position.x, y: this.position.y };
        json.zoom = this.zoom;
        json.targetZoom = this.targetZoom;
        json.followOwner = this.followOwner;
        json.followSpeed = this.followSpeed;
        json.zoomSpeed = this.zoomSpeed;
        json.positionDamping = this.positionDamping;
        json.zoomDamping = this.zoomDamping;
        json.offset = { x: this.offset.x, y: this.offset.y };
        json.followOwnerAngle = this.followOwnerAngle;
        json.followAngleOffset = this.followAngleOffset;
        json.currentAngle = this.currentAngle;
        json.targetAngle = this.targetAngle;

        // Store bounds if set
        if (this.bounds) {
            json.bounds = { ...this.bounds };
        }

        return json;
    }

    /**
     * Override to handle deserialization
     */
    fromJSON(json) {
        super.fromJSON(json);

        if (!json) return;

        // Restore camera properties
        if (json.position) {
            this.position = new Vector2(json.position.x, json.position.y);
        }

        if (json.zoom !== undefined) this.zoom = json.zoom;
        if (json.targetZoom !== undefined) this.targetZoom = json.targetZoom;
        if (json.followOwner !== undefined) this.followOwner = json.followOwner;
        if (json.followSpeed !== undefined) this.followSpeed = json.followSpeed;
        if (json.zoomSpeed !== undefined) this.zoomSpeed = json.zoomSpeed;
        if (json.positionDamping !== undefined) this.positionDamping = json.positionDamping;
        if (json.zoomDamping !== undefined) this.zoomDamping = json.zoomDamping;
        if (json.followOwnerAngle !== undefined) this.followOwnerAngle = json.followOwnerAngle;
        if (json.followAngleOffset !== undefined) this.followAngleOffset = json.followAngleOffset;
        if (json.currentAngle !== undefined) this.currentAngle = json.currentAngle;
        if (json.targetAngle !== undefined) this.targetAngle = json.targetAngle;

        if (json.offset) {
            this.offset = new Vector2(json.offset.x, json.offset.y);
        }

        // Restore bounds if set
        if (json.bounds) {
            this.bounds = { ...json.bounds };
        }

        // Initialize viewport right away to prevent black screen
        this.updateSceneViewport();
    }
}

// Register module globally
window.CameraController = CameraController;

// src/core/Modules/Matter-js/VehiclePhysics.js
/**
 * VehiclePhysics - Realistic top-down vehicle physics module with drift system
 * Requires RigidBody module on the same GameObject
 */
class VehiclePhysics extends Module {
    static allowMultiple = false;
    static namespace = "Matter.js";
    static description = "Realistic top-down vehicle physics with steering, acceleration, and drift mechanics for Matter.js";
    static iconClass = "fas fa-car";

    constructor() {
        super("VehiclePhysics");

        // Control settings
        this.playerControlled = true;           // Can be controlled with arrow keys
        this.upKey = "arrowup";                 // Accelerate key
        this.downKey = "arrowdown";             // Brake/reverse key
        this.leftKey = "arrowleft";             // Turn left key
        this.rightKey = "arrowright";           // Turn right key
        this.handbrakeKey = " ";            // Handbrake/drift key

        // Vehicle physics properties
        this.weight = 1000;                  // Vehicle weight in kg
        this.maxSpeed = 1000;                   // Maximum speed in pixels/second
        this.acceleration = 300;               // Acceleration force
        this.brakeForce = 250;                 // Braking force
        this.decelerationRate = 0.05;          // Natural deceleration when not accelerating
        this.reverseMaxSpeed = 250;            // Max reverse speed

        // Steering system
        this.maxTurnAngle = 45;                // Maximum wheel turn angle in degrees
        this.wheelTurnSpeed = 90;             // Degrees per second wheel turn rate
        this.wheelReturnSpeed = 90;           // Speed wheels return to center when not turning        
        this.turnMultiplier = 20.0;             // Multiplies steering effect based on speed

        this.dragCoefficient = 0.95;           // Natural drag (0-1, closer to 1 = less drag)
        this.lateralGrip = 0.85;               // Base side friction for normal driving (0-1)
        this.minTurnSpeed = 50;                // Minimum speed to turn effectively

        // Advanced physics
        this.wheelBase = 60;                   // Distance between front and rear axles
        this.frontWheelDrive = false;           // Front or rear wheel drive
        this.differentialStrength = 0.6;       // How much wheels stick together (0-1)
        this.antiRoll = 0.3;                   // Prevents excessive body roll

        // Tire mark properties
        this.tireMarkEnabled = true; // Enable/disable tire marks
        this.tireMarkScale = 1.0; // Scale of tire marks
        this.tireMarkOpacity = 0.7; // Initial opacity
        this.tireMarkDistanceApart = 40; // Distance between left and right tire marks
        this.tireMarkLifetime = 10; // Seconds before fading out (0 = no fade)
        this.tireMarkOffsetX = -40; // Offset from center X (positive = right, negative = left)
        this.tireMarkOffsetY = 0; // Offset from center Y (positive = back, negative = front)

        this.lastLeftMarkPos = null; // {x, y} - Last world position of left tire mark
        this.lastRightMarkPos = null; // {x, y} - Last world position of right tire mark
        this.minMarkSpacing = 32; // Minimum distance (pixels) between marks to prevent overlap

        this.gtaStyleVehicle = true; // Use GTA-style enter/exit vehicle

        // NEW: GTA-style vehicle system
        this.enterKey = "enter";                    // Key to enter/exit vehicle
        this.enterDistance = 80;                // Distance player needs to be to enter vehicle
        this.playerInside = false;              // Whether player is currently inside
        this.playerGameObject = null;           // Reference to player GameObject
        this.playerOriginalPosition = null;     // Store player's position when entering
        this.hidePlayerWhenInside = true;       // Hide player sprite when inside vehicle
        this.ejectOnDestroy = true;             // Eject player when vehicle is destroyed
        this.showEnterPrompt = true;

        // NEW: Drift and traction system
        this.handbrakeForce = 6;             // How much handbrake reduces rear grip (0-1)
        this.driftThreshold = 0.8;             // Speed threshold for drift to begin (0-1 of max speed)
        this.tractionLoss = 0.4;               // How much traction is lost under hard acceleration (0-1)
        this.powerOversteerStrength = 1.2;     // Multiplier for rear-wheel drive oversteer
        this.frontGripAdvantage = 0.15;        // Extra grip for front-wheel drive in turns
        this.driftRecoveryRate = 1.2;          // How quickly traction recovers when not drifting
        this.velocityDriftFactor = 0.7;        // How much velocity direction affects drift angle

        // Traction control simulation
        this.tractionControlEnabled = true;    // Simulates modern traction control
        this.tractionControlStrength = 0.6;    // How much TC reduces power loss (0-1)
        this.absEnabled = true;                // Anti-lock braking simulation
        this.absStrength = 0.8;               // ABS effectiveness (0-1)

        // Internal state
        this.currentSpeed = 0;                 // Current speed magnitude
        this.currentWheelAngle = 0;            // Current wheel angle in degrees (-maxTurnAngle to +maxTurnAngle)
        this.throttleInput = 0;                // Current throttle/brake input (-1 to 1)
        this.targetThrottleInput = 0;          // Target throttle input from controls
        this.steeringInput = 0;                // Current steering input (-1 to 1)
        this.targetSteeringInput = 0;          // Target steering from controls

        this.isAccelerating = false;
        this.isBraking = false;
        this.isTurning = false;
        this.isHandbraking = false;            // NEW: Handbrake state
        this.isDrifting = false;               // NEW: Whether vehicle is currently drifting
        this.driftAngle = 0;                   // NEW: Current drift angle in degrees
        this.currentTraction = 1.0;            // NEW: Current traction level (0-1)
        this.wheelSpinAmount = 0;              // NEW: Amount of wheel spin/loss of traction

        this.rigidBody = null;                 // Reference to RigidBody component

        // Debug options
        this.showDebugInfo = false;            // Show speed/steering debug
        this.showWheelDirection = true;        // Show wheel direction indicators
        this.showDriftInfo = true;             // NEW: Show drift-related debug info

        this.require("RigidBody");

        // Expose properties to inspector
        this.exposeProperty("weight", "number", this.weight, {
            description: "Vehicle weight in kg",
            min: 1,
            max: 5000,
            step: 10,
            onChange: (val) => { this.weight = val; }
        });

        this.exposeProperty("playerControlled", "boolean", this.playerControlled, {
            description: "Can be controlled with arrow keys",
            onChange: (val) => { this.playerControlled = val; }
        });

        this.exposeProperty("gtaStyleVehicle", "boolean", this.gtaStyleVehicle, {
            description: "Allow player to enter/exit this vehicle",
            style: { label: "GTA Style Vehicle" },
            onChange: (val) => { this.gtaStyleVehicle = val; }
        });

        this.exposeProperty("maxSpeed", "number", this.maxSpeed, {
            description: "Maximum forward speed",
            min: 1,
            max: 500,
            onChange: (val) => { this.maxSpeed = val; }
        });

        this.exposeProperty("acceleration", "number", this.acceleration, {
            description: "Acceleration force",
            min: 0.1,
            max: 100,
            onChange: (val) => { this.acceleration = val; }
        });

        this.exposeProperty("brakeForce", "number", this.brakeForce, {
            description: "Braking force",
            min: 0.1,
            max: 1000,
            onChange: (val) => { this.brakeForce = val; }
        });

        this.exposeProperty("frontWheelDrive", "boolean", this.frontWheelDrive, {
            description: "Front wheel drive vs rear wheel drive",
            onChange: (val) => { this.frontWheelDrive = val; }
        });

        this.exposeProperty("handbrakeForce", "number", this.handbrakeForce, {
            description: "Handbrake drift strength",
            min: 0.1,
            max: 1.0,
            step: 0.1,
            onChange: (val) => { this.handbrakeForce = val; }
        });

        this.exposeProperty("tractionLoss", "number", this.tractionLoss, {
            description: "Traction loss under hard acceleration",
            min: 0.0,
            max: 1.0,
            step: 0.1,
            onChange: (val) => { this.tractionLoss = val; }
        });

        this.exposeProperty("showDebugInfo", "boolean", this.showDebugInfo, {
            description: "Show speed and steering debug info",
            onChange: (val) => { this.showDebugInfo = val; }
        });

        this.exposeProperty("showDriftInfo", "boolean", this.showDriftInfo, {
            description: "Show drift debug information",
            onChange: (val) => { this.showDriftInfo = val; }
        });
    }

    style(style) {
        style.startGroup("Vehicle Controls", false, {
            backgroundColor: 'rgba(100, 200, 100, 0.1)',
            borderRadius: '6px',
            padding: '8px'
        });

        style.exposeProperty("playerControlled", "boolean", this.playerControlled, {
            description: "Enable arrow key controls",
            style: { label: "Player Controlled" }
        });

        style.exposeProperty("gtaStyleVehicle", "boolean", this.gtaStyleVehicle, {
            description: "Allow player to enter/exit this vehicle",
            style: { label: "GTA Style Vehicle" }
        });

        style.exposeProperty("handbrakeKey", "string", this.handbrakeKey, {
            description: "Key for handbrake/drift",
            style: { label: "Handbrake Key" }
        });

        style.endGroup();

        style.startGroup("Performance", false, {
            backgroundColor: 'rgba(255, 150, 100, 0.1)',
            borderRadius: '6px',
            padding: '8px'
        });

        style.exposeProperty("weight", "number", this.weight, {
            description: "Vehicle weight in kg",
            min: 1,
            max: 5000,
            step: 10
        });

        style.exposeProperty("maxSpeed", "number", this.maxSpeed, {
            description: "Top speed in pixels per second",
            min: 50,
            max: 1000,
            step: 25,
            style: { label: "Max Speed", slider: true }
        });

        style.exposeProperty("acceleration", "number", this.acceleration, {
            description: "How quickly the vehicle accelerates",
            min: 100,
            max: 2000,
            step: 50,
            style: { label: "Acceleration", slider: true }
        });

        style.exposeProperty("brakeForce", "number", this.brakeForce, {
            description: "Braking strength",
            min: 200,
            max: 2000,
            step: 50,
            style: { label: "Brake Force", slider: true }
        });

        style.exposeProperty("decelerationRate", "number", this.decelerationRate, {
            description: "Natural slowdown when coasting",
            min: 0.05,
            max: 0.5,
            step: 0.05,
            style: { label: "Deceleration", slider: true }
        });

        style.endGroup();

        style.startGroup("Drive Type & Traction", false, {
            backgroundColor: 'rgba(255, 200, 100, 0.1)',
            borderRadius: '6px',
            padding: '8px'
        });

        style.exposeProperty("frontWheelDrive", "boolean", this.frontWheelDrive, {
            description: "FWD vs RWD affects handling and drift characteristics",
            style: { label: "Front Wheel Drive" }
        });

        style.exposeProperty("tractionLoss", "number", this.tractionLoss, {
            description: "Traction loss under hard acceleration",
            min: 0.0,
            max: 1.0,
            step: 0.1,
            style: { label: "Power Traction Loss", slider: true }
        });

        style.exposeProperty("powerOversteerStrength", "number", this.powerOversteerStrength, {
            description: "RWD oversteer multiplier",
            min: 0.5,
            max: 3.0,
            step: 0.1,
            style: { label: "RWD Oversteer", slider: true }
        });

        style.exposeProperty("frontGripAdvantage", "number", this.frontGripAdvantage, {
            description: "FWD cornering grip advantage",
            min: 0.0,
            max: 0.5,
            step: 0.05,
            style: { label: "FWD Grip Bonus", slider: true }
        });

        style.endGroup();

        style.startGroup("Tire Marks", false, {
            backgroundColor: 'rgba(100, 100, 100, 0.1)',
            borderRadius: '6px',
            padding: '8px'
        });

        style.exposeProperty("tireMarkEnabled", "boolean", this.tireMarkEnabled, {
            description: "Enable tire mark decals",
            style: { label: "Enabled" }
        });

        style.exposeProperty("tireMarkScale", "number", this.tireMarkScale, {
            description: "Scale of tire marks",
            min: 0.1,
            max: 5.0,
            step: 0.1,
            style: { label: "Scale", slider: true }
        });

        style.exposeProperty("tireMarkOpacity", "number", this.tireMarkOpacity, {
            description: "Initial opacity of tire marks",
            min: 0.1,
            max: 1.0,
            step: 0.1,
            style: { label: "Opacity", slider: true }
        });

        style.exposeProperty("tireMarkDistanceApart", "number", this.tireMarkDistanceApart, {
            description: "Distance between left and right tire marks",
            min: 10,
            max: 100,
            step: 5,
            style: { label: "Distance Apart", slider: true }
        });

        style.exposeProperty("tireMarkLifetime", "number", this.tireMarkLifetime, {
            description: "Lifetime in seconds before fading (0 = no fade)",
            min: 0,
            max: 60,
            step: 1,
            style: { label: "Lifetime (s)", slider: true }
        });

        style.exposeProperty("tireMarkOffsetX", "number", this.tireMarkOffsetX, {
            description: "Offset from center X (positive = right)",
            min: -50,
            max: 50,
            step: 5,
            style: { label: "Offset X", slider: true }
        });

        style.exposeProperty("tireMarkOffsetY", "number", this.tireMarkOffsetY, {
            description: "Offset from center Y (positive = back)",
            min: -50,
            max: 50,
            step: 5,
            style: { label: "Offset Y", slider: true }
        });

        style.endGroup();

        style.startGroup("Drift System", false, {
            backgroundColor: 'rgba(200, 100, 255, 0.1)',
            borderRadius: '6px',
            padding: '8px'
        });

        style.exposeProperty("handbrakeForce", "number", this.handbrakeForce, {
            description: "Handbrake drift strength (higher = more sliding)",
            min: 0.1,
            max: 1.0,
            step: 0.1,
            style: { label: "Handbrake Strength", slider: true }
        });

        style.exposeProperty("driftThreshold", "number", this.driftThreshold, {
            description: "Speed threshold for drift initiation",
            min: 0.3,
            max: 1.0,
            step: 0.1,
            style: { label: "Drift Speed Threshold", slider: true }
        });

        style.exposeProperty("driftRecoveryRate", "number", this.driftRecoveryRate, {
            description: "How quickly traction recovers",
            min: 1.0,
            max: 10.0,
            step: 0.5,
            style: { label: "Traction Recovery", slider: true }
        });

        style.exposeProperty("velocityDriftFactor", "number", this.velocityDriftFactor, {
            description: "How much velocity affects drift angle",
            min: 0.1,
            max: 2.0,
            step: 0.1,
            style: { label: "Velocity Drift Factor", slider: true }
        });

        style.endGroup();

        style.startGroup("Steering", false, {
            backgroundColor: 'rgba(150, 150, 255, 0.1)',
            borderRadius: '6px',
            padding: '8px'
        });

        style.exposeProperty("turnMultiplier", "number", this.turnMultiplier, {
            description: "Steering strength multiplier",
            min: 0.1,
            max: 5,
            step: 0.1,
            style: { label: "Turn Multiplier", slider: true }
        });

        style.exposeProperty("maxTurnAngle", "number", this.maxTurnAngle, {
            description: "Maximum wheel turn angle",
            min: 15,
            max: 90,
            step: 5,
            style: { label: "Max Turn Angle", slider: true }
        });

        style.exposeProperty("lateralGrip", "number", this.lateralGrip, {
            description: "Base tire grip for cornering",
            min: 0.1,
            max: 1,
            step: 0.05,
            style: { label: "Base Tire Grip", slider: true }
        });

        style.endGroup();

        style.startGroup("Driver Assists", true, {
            backgroundColor: 'rgba(100, 255, 200, 0.1)',
            borderRadius: '6px',
            padding: '8px'
        });

        style.exposeProperty("tractionControlEnabled", "boolean", this.tractionControlEnabled, {
            description: "Simulates traction control system",
            style: { label: "Traction Control" }
        });

        style.exposeProperty("tractionControlStrength", "number", this.tractionControlStrength, {
            description: "TC effectiveness",
            min: 0.0,
            max: 1.0,
            step: 0.1,
            style: { label: "TC Strength", slider: true }
        });

        style.exposeProperty("absEnabled", "boolean", this.absEnabled, {
            description: "Anti-lock braking system",
            style: { label: "ABS" }
        });

        style.endGroup();

        style.startGroup("Debug", true, {
            backgroundColor: 'rgba(200, 200, 200, 0.1)',
            borderRadius: '6px',
            padding: '8px'
        });

        style.exposeProperty("showDebugInfo", "boolean", this.showDebugInfo, {
            description: "Display basic vehicle debug information",
            style: { label: "Debug Info" }
        });

        style.exposeProperty("showDriftInfo", "boolean", this.showDriftInfo, {
            description: "Display drift-specific debug information",
            style: { label: "Drift Debug" }
        });

        style.exposeProperty("showWheelDirection", "boolean", this.showWheelDirection, {
            description: "Show wheel and velocity vectors",
            style: { label: "Wheel Vectors" }
        });

        style.endGroup();

        style.startGroup("GTA Vehicle System", false, {
            backgroundColor: 'rgba(255, 100, 255, 0.1)',
            borderRadius: '6px',
            padding: '8px'
        });

        style.exposeProperty("gtaStyleVehicle", "boolean", this.gtaStyleVehicle, {
            description: "Enable GTA-style enter/exit system",
            style: { label: "GTA Style Vehicle" }
        });

        style.exposeProperty("enterKey", "string", this.enterKey, {
            description: "Key to enter/exit vehicle",
            style: { label: "Enter/Exit Key" }
        });

        style.exposeProperty("enterDistance", "number", this.enterDistance, {
            description: "Distance player needs to be to enter",
            min: 30,
            max: 200,
            step: 10,
            style: { label: "Enter Distance", slider: true }
        });

        style.exposeProperty("hidePlayerWhenInside", "boolean", this.hidePlayerWhenInside, {
            description: "Hide player sprite when inside vehicle",
            style: { label: "Hide Player Inside" }
        });

        style.exposeProperty("showEnterPrompt", "boolean", this.showEnterPrompt, {
            description: "Show enter/exit prompts",
            style: { label: "Show Enter Prompt" }
        });

        style.endGroup();

        style.addDivider();
        style.addHelpText("Enhanced physics with realistic drift mechanics. Use handbrake + steering to initiate drifts. RWD vehicles have more oversteer, FWD have better traction.");
    }

    start() {
        // Get the RigidBody component
        this.rigidBody = this.gameObject.getModule("RigidBody");

        if (!this.rigidBody) {
            console.error("VehiclePhysics requires a RigidBody component on the same GameObject!");
            return;
        }

        // Configure RigidBody for vehicle physics
        this.rigidBody.useGravity = false;      // Disable gravity for top-down
        this.rigidBody.bodyType = "dynamic";    // Must be dynamic
        this.rigidBody.friction = 0.1;          // Low friction, we'll handle it
        this.rigidBody.frictionAir = 0.02;      // Minimal air resistance
        this.rigidBody.density = 1.5;           // Moderate density for realistic mass

        // Set up collision filter if needed
        if (this.rigidBody.body) {
            this.rigidBody.body.ignoreGravity = true;
        }

        this.rigidBody.updateMass(this.weight);

        console.log(this.playerControlled ? "Player-controlled vehicle initialized." : "AI-controlled vehicle initialized.");
    }

    loop(deltaTime) {
        if (!this.rigidBody || !this.rigidBody.body) return;

        // Handle GTA-style vehicle entry/exit system
        if (this.gtaStyleVehicle) {
            this.handleVehicleEntry();
        }

        // Reset input flags
        this.isAccelerating = false;
        this.isBraking = false;
        this.isTurning = false;
        this.isHandbraking = false;

        // Get target input values
        this.targetThrottleInput = 0;
        this.targetSteeringInput = 0;

        // Only allow control when player is inside the vehicle OR when it's not a GTA-style vehicle
        const canControl = this.playerControlled && (!this.gtaStyleVehicle || this.playerInside);

        if (canControl) {
            // Vehicle controls (same as before)
            if (window.input.keyDown(this.upKey)) {
                this.targetThrottleInput = 1;
                this.isAccelerating = true;
            }
            if (window.input.keyDown(this.downKey)) {
                this.targetThrottleInput = -1;
                this.isBraking = true;
            }
            if (window.input.keyDown(this.leftKey)) {
                this.targetSteeringInput = -1;
                this.isTurning = true;
            }
            if (window.input.keyDown(this.rightKey)) {
                this.targetSteeringInput = 1;
                this.isTurning = true;
            }
            if (window.input.keyDown(this.handbrakeKey)) {
                this.isHandbraking = true;
            }
        }

        // Create tire marks when losing traction
        if (this.tireMarkEnabled && this.isLosingTraction()) {
            this.createTireMarks();
        } else {
            // Reset last tire mark positions when traction is regained to prevent connecting old marks
            this.lastLeftMarkPos = null;
            this.lastRightMarkPos = null;
        }

        // Update physics systems
        this.updateInputs(deltaTime);
        this.updateWheelSteering(deltaTime);
        this.updateTractionSystem(deltaTime);
        this.updateVehiclePhysics(deltaTime);
        this.updateDriftPhysics(deltaTime);
    }

    handleVehicleEntry() {
        if (!window.engine || !window.engine.gameObjectManager) return;

        // Find player GameObject (assuming it has a "Player" tag or specific name)
        if (!this.playerGameObject) {
            this.playerGameObject = this.findPlayerGameObject();
        }

        if (!this.playerGameObject) return;

        const playerPos = this.playerGameObject.getWorldPosition();
        const vehiclePos = this.gameObject.getWorldPosition();
        const distance = this.calculateDistance(playerPos, vehiclePos);

        // Check if player is close enough to enter/exit
        if (distance <= this.enterDistance) {
            // Show enter prompt if player is outside
            if (!this.playerInside && this.showEnterPrompt) {
                this.showEnterPromptUI();
            }

            // Handle enter/exit input
            if (window.input.keyPressed(this.enterKey)) {
                if (this.playerInside) {
                    this.exitVehicle();
                } else {
                    this.enterVehicle();
                }
            }
        } else {
            // Hide enter prompt when too far
            this.hideEnterPromptUI();
        }

        // Keep player inside vehicle if they're in it
        if (this.playerInside && this.playerGameObject) {
            this.updatePlayerPositionInVehicle();
        }
    }

    enterVehicle() {
        if (!this.playerGameObject || this.playerInside) return;

        console.log("Player entering vehicle");

        // Store player's original position for ejection
        this.playerOriginalPosition = this.playerGameObject.getWorldPosition();

        // Set player as inside
        this.playerInside = true;

        // Position player at vehicle center
        const vehiclePos = this.gameObject.getWorldPosition();
        this.playerGameObject.setWorldPosition(vehiclePos.x, vehiclePos.y);

        // Hide player sprite if enabled
        if (this.hidePlayerWhenInside) {
            this.setPlayerVisibility(false);
        }

        // Disable player movement (if player has movement script)
        this.setPlayerMovementEnabled(false);

        this.hideEnterPromptUI();
    }

    exitVehicle() {
        if (!this.playerGameObject || !this.playerInside) return;

        console.log("Player exiting vehicle");

        // Calculate exit position (slightly to the side of vehicle)
        const vehiclePos = this.gameObject.getWorldPosition();
        const vehicleAngle = this.gameObject.angle * (Math.PI / 180);
        const exitDistance = 60; // Distance from vehicle center

        // Exit to the left side of the vehicle
        const exitX = vehiclePos.x - Math.sin(vehicleAngle) * exitDistance;
        const exitY = vehiclePos.y + Math.cos(vehicleAngle) * exitDistance;

        // Position player at exit location
        this.playerGameObject.setWorldPosition(exitX, exitY);

        // Set player as outside
        this.playerInside = false;

        // Show player sprite
        if (this.hidePlayerWhenInside) {
            this.setPlayerVisibility(true);
        }

        // Re-enable player movement
        this.setPlayerMovementEnabled(true);

        this.playerOriginalPosition = null;
    }

    updatePlayerPositionInVehicle() {
        if (!this.playerGameObject || !this.playerInside) return;

        const vehiclePos = this.gameObject.getWorldPosition();
        this.playerGameObject.setWorldPosition(vehiclePos.x, vehiclePos.y);

        // Optionally match vehicle rotation
        // this.playerGameObject.angle = this.gameObject.angle;
    }

    findPlayerGameObject() {
        // Look for GameObject with "Player" tag first
        let player = window.engine.gameObjectManager.findGameObjectByTag("Player");

        if (!player) {
            // Fallback: look for GameObject named "Player"
            const allObjects = window.engine.gameObjectManager.getAllGameObjects();
            player = allObjects.find(obj => obj.name && obj.name.toLowerCase().includes("player"));
        }

        if (!player) {
            // Last resort: look for GameObject with player movement component
            const allObjects = window.engine.gameObjectManager.getAllGameObjects();
            player = allObjects.find(obj => {
                // Check for common player movement modules
                return obj.getModule("PlayerMovement") ||
                    obj.getModule("Movement") ||
                    obj.getModule("TopDownMovement");
            });
        }

        return player;
    }

    calculateDistance(pos1, pos2) {
        const dx = pos1.x - pos2.x;
        const dy = pos1.y - pos2.y;
        return Math.sqrt(dx * dx + dy * dy);
    }

    setPlayerVisibility(visible) {
        if (!this.playerGameObject) return;

        // Try to find and toggle sprite renderer
        const spriteRenderer = this.playerGameObject.getModule("SpriteRenderer");
        if (spriteRenderer) {
            spriteRenderer.visible = visible;
        }

        // Also try other common renderer modules
        const renderer = this.playerGameObject.getModule("Renderer");
        if (renderer) {
            renderer.visible = visible;
        }
    }

    setPlayerMovementEnabled(enabled) {
        if (!this.playerGameObject) return;

        // Try to find and toggle movement modules
        const playerMovement = this.playerGameObject.getModule("PlayerMovement");
        if (playerMovement && typeof playerMovement.setEnabled === 'function') {
            playerMovement.setEnabled(enabled);
        }

        const movement = this.playerGameObject.getModule("Movement");
        if (movement && typeof movement.setEnabled === 'function') {
            movement.setEnabled(enabled);
        }

        const topDownMovement = this.playerGameObject.getModule("TopDownMovement");
        if (topDownMovement && typeof topDownMovement.setEnabled === 'function') {
            topDownMovement.setEnabled(enabled);
        }
    }

    showEnterPromptUI() {
        // Simple implementation - you can enhance this with proper UI
        if (!this._promptShown) {
            this._promptShown = true;
            // You could implement a proper UI system here
            console.log(`Press ${this.enterKey.toUpperCase()} to enter vehicle`);
        }
    }

    hideEnterPromptUI() {
        this._promptShown = false;
    }

    updateInputs(deltaTime) {
        // Smooth throttle input transitions
        if (this.targetThrottleInput !== 0) {
            // Accelerating or braking - use acceleration/brake rates
            let lerpRate = this.targetThrottleInput > 0 ? this.acceleration * 0.01 : this.brakeForce * 0.01;
            this.throttleInput = this.lerp(this.throttleInput, this.targetThrottleInput, lerpRate * deltaTime);
        } else {
            // Coasting - use deceleration rate
            this.throttleInput = this.lerp(this.throttleInput, 0, this.decelerationRate * deltaTime * 60);
        }

        // Smooth steering input transitions
        if (this.targetSteeringInput !== 0) {
            this.steeringInput = this.lerp(this.steeringInput, this.targetSteeringInput, 8 * deltaTime);
        } else {
            this.steeringInput = this.lerp(this.steeringInput, 0, 6 * deltaTime);
        }
    }

    updateWheelSteering(deltaTime) {
        // Calculate target wheel angle based on steering input
        let targetWheelAngle = this.steeringInput * this.maxTurnAngle;

        // Determine wheel turn speed
        let turnSpeed = this.wheelTurnSpeed;
        if (this.targetSteeringInput === 0 && this.isMoving()) {
            // Use return speed when wheels should return to center while moving
            turnSpeed = this.wheelReturnSpeed;
        }

        // Smooth wheel angle transitions
        let angleDiff = targetWheelAngle - this.currentWheelAngle;
        let maxAngleChange = turnSpeed * deltaTime;

        if (Math.abs(angleDiff) <= maxAngleChange) {
            this.currentWheelAngle = targetWheelAngle;
        } else {
            this.currentWheelAngle += Math.sign(angleDiff) * maxAngleChange;
        }
    }

    updateTractionSystem(deltaTime) {
        const speedRatio = this.currentSpeed / this.maxSpeed;
        const throttleAmount = Math.abs(this.throttleInput);

        // Calculate wheel spin based on acceleration and drive type
        this.wheelSpinAmount = 0;

        if (this.isAccelerating && throttleAmount > 0.7) {
            // Hard acceleration causes wheel spin
            let baseSpin = throttleAmount * this.tractionLoss;

            // RWD loses more traction under power, especially when turning
            if (!this.frontWheelDrive) {
                baseSpin *= (1 + Math.abs(this.steeringInput) * this.powerOversteerStrength);
            }

            // Higher speeds make it easier to break traction
            baseSpin *= (0.5 + speedRatio * 0.5);

            this.wheelSpinAmount = baseSpin;
        }

        // Calculate current effective traction
        let targetTraction = 1.0;

        // Reduce traction based on wheel spin
        if (this.wheelSpinAmount > 0) {
            targetTraction = Math.max(0.2, 1.0 - this.wheelSpinAmount);

            // Traction control helps recover traction
            if (this.tractionControlEnabled) {
                targetTraction = this.lerp(targetTraction, 1.0, this.tractionControlStrength);
            }
        }

        // Handbrake reduces rear traction significantly
        if (this.isHandbraking) {
            // Handbrake mainly affects rear wheels
            let handbrakeEffect = this.handbrakeForce;
            if (this.frontWheelDrive) {
                // FWD can still steer somewhat with handbrake
                targetTraction = Math.max(0.3, targetTraction - handbrakeEffect * 0.7);
            } else {
                // RWD loses more control with handbrake
                targetTraction = Math.max(0.1, targetTraction - handbrakeEffect);
            }
        }

        // FWD gets grip advantage in normal conditions
        if (this.frontWheelDrive && !this.isHandbraking && this.wheelSpinAmount < 0.3) {
            targetTraction = Math.min(1.0, targetTraction + this.frontGripAdvantage);
        }

        // Smooth traction transitions
        this.currentTraction = this.lerp(this.currentTraction, targetTraction, this.driftRecoveryRate * deltaTime);
    }

    updateVehiclePhysics(deltaTime) {
        const body = this.rigidBody.body;
        const velocity = this.rigidBody.getVelocity();

        // Calculate current speed and direction
        this.currentSpeed = Math.sqrt(velocity.x * velocity.x + velocity.y * velocity.y);
        const currentAngle = this.gameObject.angle * (Math.PI / 180);

        // Forward direction vector (vehicle body direction)
        const forwardX = Math.cos(currentAngle);
        const forwardY = Math.sin(currentAngle);

        // Right direction vector (for lateral forces)
        const rightX = -Math.sin(currentAngle);
        const rightY = Math.cos(currentAngle);

        // Calculate forward and lateral velocity components
        const forwardVel = velocity.x * forwardX + velocity.y * forwardY;
        const rightVel = velocity.x * rightX + velocity.y * rightY;

        // Apply throttle forces with traction consideration
        if (Math.abs(this.throttleInput) > 0.01) {
            let targetSpeed = this.throttleInput > 0 ? this.maxSpeed : -this.reverseMaxSpeed;
            let force = Math.abs(this.throttleInput > 0 ? this.acceleration : this.brakeForce);

            // ABS simulation for braking
            if (this.throttleInput < 0 && this.absEnabled) {
                force *= (0.3 + this.currentTraction * 0.7 * this.absStrength);
            }

            // Reduce force as we approach max speed
            let speedRatio = Math.abs(forwardVel) / Math.abs(targetSpeed);
            if (speedRatio > 0.8) {
                force *= Math.max(0.1, 1 - speedRatio);
            }

            // Apply traction to driving force
            let effectiveForce = force * this.throttleInput * this.currentTraction * deltaTime * 60;

            // Wheel spin causes reduced forward motion but can help initiate drifts
            if (this.wheelSpinAmount > 0.5 && Math.abs(this.steeringInput) > 0.3) {
                effectiveForce *= 0.7; // Reduce forward motion when spinning wheels while turning
            }

            this.rigidBody.applyForce({
                x: forwardX * effectiveForce,
                y: forwardY * effectiveForce
            });
        }

        // --- Add roll force in wheel direction when not accelerating ---
        if (!this.isAccelerating && this.isMoving()) {
            // Calculate wheel direction vector
            const wheelAngleRad = (this.currentWheelAngle * Math.PI / 180);
            const wheelDirection = currentAngle + wheelAngleRad;
            const wheelDirX = Math.cos(wheelDirection);
            const wheelDirY = Math.sin(wheelDirection);

            // Project velocity onto wheel direction
            const velDotWheel = velocity.x * wheelDirX + velocity.y * wheelDirY;

            // Calculate desired velocity in wheel direction
            const desiredVelX = wheelDirX * velDotWheel;
            const desiredVelY = wheelDirY * velDotWheel;

            // Blend factor increases as speed drops (stronger at low speed)
            const speedRatio = Math.min(1, this.currentSpeed / this.maxSpeed);
            // At low speed, blend is high (0.25), at high speed, blend is low (0.05)
            const rollBlend = 0.05 + (1 - speedRatio) * 0.2;

            // Further increase blend if traction is low
            const tractionBlend = rollBlend * (1 - this.currentTraction);

            // Final blend factor
            const blend = Math.max(rollBlend, tractionBlend);

            // Apply roll force
            const rollForceX = (desiredVelX - velocity.x) * blend;
            const rollForceY = (desiredVelY - velocity.y) * blend;

            this.rigidBody.applyForce({
                x: rollForceX,
                y: rollForceY
            });
        }

        // Apply wheel-based steering with traction consideration
        if (Math.abs(this.currentWheelAngle) > 1 && this.isMoving()) {
            const wheelAngleRad = (this.currentWheelAngle * Math.PI / 180);
            const wheelDirection = currentAngle + wheelAngleRad;

            const wheelForwardX = Math.cos(wheelDirection);
            const wheelForwardY = Math.sin(wheelDirection);

            // Calculate steering force with traction
            let steerForce = this.currentSpeed * Math.sin(wheelAngleRad) * this.currentTraction;

            // Apply drive type effects to steering
            if (!this.frontWheelDrive && this.wheelSpinAmount > 0.3) {
                steerForce *= (1.5 + Math.abs(this.throttleInput) * 0.5);
            }

            this.rigidBody.applyForce({
                x: wheelForwardX * steerForce * 0.5,
                y: wheelForwardY * steerForce * 0.5
            });

            // Calculate turn radius and apply angular velocity
            let wheelbase = this.wheelBase;
            let turnRadius = wheelbase / Math.tan(Math.abs(wheelAngleRad));
            let angularVel = (forwardVel / turnRadius) * (this.currentWheelAngle / Math.abs(this.currentWheelAngle)) * this.turnMultiplier;

            // Modify angular velocity based on traction
            angularVel *= this.currentTraction;

            // RWD oversteer effect
            if (!this.frontWheelDrive && this.isAccelerating && this.wheelSpinAmount > 0.3) {
                angularVel *= 1.3;
            }

            // Limit angular velocity for stability  
            angularVel = Math.max(-5, Math.min(5, angularVel));
            this.rigidBody.setAngularVelocity(angularVel);
        }

        // Apply drag forces
        if (this.currentSpeed > 0) {
            // Forward/backward drag
            const dragForce = forwardVel * forwardVel * (1 - this.dragCoefficient) * 0.01;
            this.rigidBody.applyForce({
                x: -forwardX * dragForce * Math.sign(forwardVel),
                y: -forwardY * dragForce * Math.sign(forwardVel)
            });

            // Lateral drag (tire friction) modified by current traction
            let effectiveLateralGrip = this.lateralGrip * this.currentTraction;
            const lateralDragForce = Math.abs(rightVel) * rightVel * effectiveLateralGrip * 0.5;

            this.rigidBody.applyForce({
                x: -rightX * lateralDragForce,
                y: -rightY * lateralDragForce
            });
        }

        // Apply angular damping
        if (body.angularVelocity !== 0) {
            const angularDrag = body.angularVelocity * 0.8 * this.currentTraction;
            body.angularVelocity -= angularDrag * deltaTime;
        }
    }

    updateDriftPhysics(deltaTime) {
        if (!this.rigidBody || !this.rigidBody.body) return;

        const velocity = this.rigidBody.getVelocity();
        const currentAngle = this.gameObject.angle * (Math.PI / 180);

        // Calculate velocity angle
        const velocityAngle = Math.atan2(velocity.y, velocity.x);

        // Calculate drift angle (difference between car direction and velocity direction)
        let rawDriftAngle = (velocityAngle - currentAngle) * (180 / Math.PI);

        // Normalize angle to -180 to 180
        while (rawDriftAngle > 180) rawDriftAngle -= 360;
        while (rawDriftAngle < -180) rawDriftAngle += 360;

        // Apply velocity factor to drift angle calculation
        this.driftAngle = rawDriftAngle * this.velocityDriftFactor;

        // Determine if we're drifting (symmetrical for left/right)
        const speedRatio = this.currentSpeed / this.maxSpeed;
        const driftThreshold = this.driftThreshold;

        this.isDrifting = (
            speedRatio > driftThreshold &&
            (Math.abs(this.driftAngle) > 15 || this.isHandbraking || this.currentTraction < 0.8)
        );

        // Enhanced drift effects when handbraking
        if (this.isHandbraking && speedRatio > 0.2 && Math.abs(this.steeringInput) > 0.01) {
            // Calculate sideways (perpendicular) direction to car's forward
            const rightX = -Math.sin(currentAngle);
            const rightY = Math.cos(currentAngle);

            // Drift force is perpendicular to car direction, scaled by steering direction
            // But should move opposite to current velocity for initial slide
            // So, apply force opposite to velocity, plus a sideways force for turning
            // 1. Opposite to velocity (to break traction)
            const slideForce = -1 * this.handbrakeForce * this.currentSpeed;
            this.rigidBody.applyForce({
                x: velocity.x * slideForce * deltaTime,
                y: velocity.y * slideForce * deltaTime
            });

            // 2. Sideways force (perpendicular to forward, scaled by steering)
            const driftSideForce = this.currentSpeed * this.handbrakeForce * Math.sign(this.steeringInput);
            this.rigidBody.applyForce({
                x: rightX * driftSideForce * deltaTime,
                y: rightY * driftSideForce * deltaTime
            });

            // 3. Stronger damping to prevent speed accumulation
            const dampingForce = 0.8; // Increased damping
            this.rigidBody.applyForce({
                x: -velocity.x * dampingForce * deltaTime,
                y: -velocity.y * dampingForce * deltaTime
            });
        }
    }

    // Utility function for smooth interpolation
    lerp(start, end, factor) {
        factor = Math.max(0, Math.min(1, factor));
        return start + (end - start) * factor;
    }

    draw(ctx) {
        if (!this.showDebugInfo && !this.showWheelDirection && !this.showDriftInfo) return;

        const pos = this.gameObject.getWorldPosition();
        const angle = 0;//this.gameObject.angle * (Math.PI / 180);

        ctx.save();

        if (this.showDebugInfo) {
            // Draw basic debug info
            ctx.fillStyle = "white";
            ctx.font = "12px Arial";
            ctx.textAlign = "center";

            const speed = Math.round(this.currentSpeed);
            const angle_deg = Math.round(this.gameObject.angle % 360);
            const wheelAngle = Math.round(this.currentWheelAngle);
            const throttle = Math.round(this.throttleInput * 100);

            ctx.fillText(`Speed: ${speed}px/s`, 0, -70);
            ctx.fillText(`Angle: ${angle_deg}°`, 0, -58);
            ctx.fillText(`Wheels: ${wheelAngle}°`, 0, -46);
            ctx.fillText(`Throttle: ${throttle}%`, 0, -34);

            if (this.isAccelerating) ctx.fillText("ACCEL", 0, -22);
            if (this.isBraking) ctx.fillText("BRAKE", 0, -22);
            if (this.isTurning) ctx.fillText("TURN", 0, -10);
            if (this.isHandbraking) ctx.fillText("HANDBRAKE", 0, 2);
        }

        // Draw enter prompt and vehicle status
        if (this.gtaStyleVehicle) {
            this.drawVehicleUI(ctx);
        }

        if (this.showDriftInfo) {
            // Draw drift-specific debug info
            ctx.fillStyle = this.isDrifting ? "orange" : "lightblue";
            ctx.font = "11px Arial";
            ctx.textAlign = "center";

            const traction = Math.round(this.currentTraction * 100);
            const driftAngle = Math.round(this.driftAngle);
            const wheelSpin = Math.round(this.wheelSpinAmount * 100);

            let yOffset = this.showDebugInfo ? 14 : -58;

            ctx.fillText(`Traction: ${traction}%`, 0, yOffset);
            ctx.fillText(`Drift: ${driftAngle}°`, 0, yOffset + 12);
            ctx.fillText(`Wheel Spin: ${wheelSpin}%`, 0, yOffset + 24);

            if (this.isDrifting) {
                ctx.fillStyle = "orange";
                ctx.fillText("DRIFTING!", 0, yOffset + 36);
            }

            // Drive type indicator
            ctx.fillStyle = "yellow";
            ctx.fillText(this.frontWheelDrive ? "FWD" : "RWD", 0, yOffset + 48);

            // Traction control indicators
            if (this.tractionControlEnabled || this.absEnabled) {
                ctx.fillStyle = "lime";
                let assists = [];
                if (this.tractionControlEnabled) assists.push("TC");
                if (this.absEnabled) assists.push("ABS");
                ctx.fillText(assists.join(" "), 0, yOffset + 60);
            }
        }

        if (this.showWheelDirection) {
            // Draw velocity vector
            try {
                const velocity = this.rigidBody.getVelocity();
                if (!velocity) return;

                if (this.currentSpeed > 10) {
                    // Color code velocity vector based on drift state
                    ctx.strokeStyle = this.isDrifting ? "orange" : "lime";
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(velocity.x * 0.5, velocity.y * 0.5);
                    ctx.stroke();
                }
            } catch (e) {
                //console.warn("VehiclePhysics: Unable to draw velocity vector", e);
            }

            // Draw forward direction (red)
            ctx.strokeStyle = "red";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(Math.cos(angle) * 30, Math.sin(angle) * 30);
            ctx.stroke();

            // Draw wheel direction (yellow)
            if (Math.abs(this.currentWheelAngle) > 1) {
                const wheelAngleRad = (this.currentWheelAngle * Math.PI / 180);
                const wheelDirection = angle + wheelAngleRad;
                ctx.strokeStyle = "lime";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(wheelDirection) * 25, Math.sin(wheelDirection) * 25);
                ctx.stroke();
            }

            // Draw traction indicator
            const tractionRadius = 15 + (this.currentTraction * 10);
            ctx.strokeStyle = `hsl(${this.currentTraction * 120}, 100%, 50%)`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, tractionRadius, 0, Math.PI * 2);
            ctx.stroke();

            // Draw wheel spin indicator
            if (this.wheelSpinAmount > 0.1) {
                ctx.strokeStyle = "red";
                ctx.lineWidth = 1;
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * Math.PI * 2;
                    const radius = 35 + Math.sin(Date.now() * 0.01 + i) * this.wheelSpinAmount * 5;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(Math.cos(angle) * radius, Math.sin(angle) * radius);
                    ctx.stroke();
                }
            }
        }

        ctx.restore();
    }

    drawVehicleUI(ctx) {
        if (!this.playerGameObject) return;

        const playerPos = this.playerGameObject.getWorldPosition();
        const vehiclePos = this.gameObject.getWorldPosition();
        const distance = this.calculateDistance(playerPos, vehiclePos);

        ctx.save();

        // Draw enter prompt when player is close
        if (!this.playerInside && distance <= this.enterDistance && this.showEnterPrompt) {
            ctx.fillStyle = "white";
            ctx.strokeStyle = "black";
            ctx.lineWidth = 2;
            ctx.font = "14px Arial";
            ctx.textAlign = "center";

            const promptText = `Press ${this.enterKey.toUpperCase()} to enter`;

            // Draw text background
            const textWidth = ctx.measureText(promptText).width;
            ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
            ctx.fillRect(-textWidth / 2 - 5, -100 - 20, textWidth + 10, 25);

            // Draw text
            ctx.fillStyle = "white";
            ctx.fillText(promptText, 0, -100);
        }

        // Draw status indicator when player is inside
        if (this.playerInside) {
            ctx.fillStyle = "lime";
            ctx.font = "12px Arial";
            ctx.textAlign = "center";
            ctx.fillText("DRIVING", 0, -85);

            // Draw exit hint
            ctx.fillStyle = "yellow";
            ctx.font = "10px Arial";
            ctx.fillText(`Press ${this.enterKey.toUpperCase()} to exit`, 0, -73);
        }

        // Draw interaction range (debug)
        if (this.showDebugInfo && !this.playerInside) {
            ctx.strokeStyle = "cyan";
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.arc(0, 0, this.enterDistance, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
        }

        ctx.restore();
    }

    onDestroy() {
        if (this.playerInside && this.ejectOnDestroy) {
            this.exitVehicle();
        }
    }

    isLosingTraction() {
        // Detect traction loss: low traction, drifting, wheel spin, or handbraking
        return this.currentTraction < 0.8 || this.isDrifting || this.wheelSpinAmount > 0.3 || this.isHandbraking;
    }

    createTireMarks() {
        if (!window.engine) return;

        const pos = this.gameObject.getWorldPosition();
        const angle = this.gameObject.angle * (Math.PI / 180);

        // Calculate current offset position (vehicle's tire position)
        const offsetX = this.tireMarkOffsetX;
        const offsetY = this.tireMarkOffsetY;
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const currentLeftX = pos.x + offsetX * cos - offsetY * sin - (this.tireMarkDistanceApart / 2) * sin;
        const currentLeftY = pos.y + offsetX * sin + offsetY * cos + (this.tireMarkDistanceApart / 2) * cos;
        const currentRightX = pos.x + offsetX * cos - offsetY * sin + (this.tireMarkDistanceApart / 2) * sin;
        const currentRightY = pos.y + offsetX * sin + offsetY * cos - (this.tireMarkDistanceApart / 2) * cos;

        // Dynamic spacing based on speed to reduce lag
        const dynamicSpacing = Math.max(1, this.minMarkSpacing - this.currentSpeed * 0.05);

        // Check if we need to create new marks (based on distance from last marks)
        const shouldCreateLeft = !this.lastLeftMarkPos || this.distance(this.lastLeftMarkPos, { x: currentLeftX, y: currentLeftY }) >= dynamicSpacing;
        const shouldCreateRight = !this.lastRightMarkPos || this.distance(this.lastRightMarkPos, { x: currentRightX, y: currentRightY }) >= dynamicSpacing;

        if (!shouldCreateLeft && !shouldCreateRight) return; // Skip if too close

        // Calculate aligned positions and angles
        let leftMarkX, leftMarkY, leftRotation;
        let rightMarkX, rightMarkY, rightRotation;

        if (this.lastLeftMarkPos) {
            // Align left mark: Use direction from last to current
            const dirX = currentLeftX - this.lastLeftMarkPos.x;
            const dirY = currentLeftY - this.lastLeftMarkPos.y;
            const dist = Math.sqrt(dirX * dirX + dirY * dirY);
            if (dist > 0) {
                leftMarkX = this.lastLeftMarkPos.x + (dirX / dist) * dynamicSpacing;
                leftMarkY = this.lastLeftMarkPos.y + (dirY / dist) * dynamicSpacing;
                leftRotation = Math.atan2(dirY, dirX);
            } else {
                leftMarkX = currentLeftX;
                leftMarkY = currentLeftY;
                leftRotation = angle;
            }
        } else {
            // First mark: Use current position
            leftMarkX = currentLeftX;
            leftMarkY = currentLeftY;
            leftRotation = angle;
        }

        if (this.lastRightMarkPos) {
            // Align right mark: Use direction from last to current
            const dirX = currentRightX - this.lastRightMarkPos.x;
            const dirY = currentRightY - this.lastRightMarkPos.y;
            const dist = Math.sqrt(dirX * dirX + dirY * dirY);
            if (dist > 0) {
                rightMarkX = this.lastRightMarkPos.x + (dirX / dist) * dynamicSpacing;
                rightMarkY = this.lastRightMarkPos.y + (dirY / dist) * dynamicSpacing;
                rightRotation = Math.atan2(dirY, dirX);
            } else {
                rightMarkX = currentRightX;
                rightMarkY = currentRightY;
                rightRotation = angle;
            }
        } else {
            // First mark: Use current position
            rightMarkX = currentRightX;
            rightMarkY = currentRightY;
            rightRotation = angle;
        }

        // Create left tire mark
        if (shouldCreateLeft) {
            window.engine.addDecal(leftMarkX, leftMarkY, this.drawTireMark.bind(this), {
                scale: this.tireMarkScale,
                alpha: this.tireMarkOpacity,
                rotation: leftRotation,
                lifetime: this.tireMarkLifetime,
                width: 32,
                height: 8
            });
            this.lastLeftMarkPos = { x: leftMarkX, y: leftMarkY };
        }

        // Create right tire mark
        if (shouldCreateRight) {
            window.engine.addDecal(rightMarkX, rightMarkY, this.drawTireMark.bind(this), {
                scale: this.tireMarkScale,
                alpha: this.tireMarkOpacity,
                rotation: rightRotation,
                lifetime: this.tireMarkLifetime,
                width: 32,
                height: 8
            });
            this.lastRightMarkPos = { x: rightMarkX, y: rightMarkY };
        }
    }

    // Utility function to calculate distance between two points
    distance(pos1, pos2) {
        const dx = pos1.x - pos2.x;
        const dy = pos1.y - pos2.y;
        return Math.sqrt(dx * dx + dy * dy);
    }

    drawTireMark(ctx) {
        // Draw a simple tire mark (black rectangle)
        ctx.fillStyle = 'black';
        ctx.fillRect(0, 0, 32, 8);
    }

    drawGizmos(ctx) {
        // Draw wheel positions and angles
        if (!this.showWheelDirection) return;

        const pos = this.gameObject.getWorldPosition();
        const angle = this.gameObject.angle * (Math.PI / 180);

        ctx.save();

        // Draw simplified wheel positions with current steering angle
        const wheelOffset = this.wheelBase * 0.3;
        const wheelAngleRad = (this.currentWheelAngle * Math.PI / 180);

        // Front wheels (steered) - color based on traction
        ctx.save();
        ctx.translate(0, -wheelOffset);
        ctx.rotate(wheelAngleRad);

        // Color wheels based on traction and drive type
        if (this.frontWheelDrive) {
            ctx.fillStyle = `hsla(${this.currentTraction * 120}, 100%, 50%, 0.8)`;
        } else {
            ctx.fillStyle = "rgba(255, 255, 0, 0.7)";
        }

        ctx.fillRect(-8, -4, 16, 8);

        // Show wheel spin on drive wheels
        if (this.frontWheelDrive && this.wheelSpinAmount > 0.2) {
            ctx.strokeStyle = "red";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(0, 0, 6, 0, Math.PI * 2);
            ctx.stroke();
        }

        ctx.restore();

        // Rear wheels (fixed)
        ctx.save();
        ctx.translate(0, wheelOffset);

        if (!this.frontWheelDrive) {
            // RWD - color based on traction
            ctx.fillStyle = `hsla(${this.currentTraction * 120}, 100%, 50%, 0.8)`;
        } else {
            ctx.fillStyle = "rgba(255, 255, 0, 0.5)";
        }

        ctx.fillRect(-8, -4, 16, 8);

        // Show wheel spin on drive wheels
        if (!this.frontWheelDrive && this.wheelSpinAmount > 0.2) {
            ctx.strokeStyle = "red";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(0, 0, 6, 0, Math.PI * 2);
            ctx.stroke();
        }

        // Show handbrake effect on rear wheels
        if (this.isHandbraking) {
            ctx.strokeStyle = "orange";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, Math.PI * 2);
            ctx.stroke();
        }

        ctx.restore();

        ctx.restore();
    }

    // Public methods for external control
    accelerate(force = 1) {
        this.targetThrottleInput = Math.max(0, Math.min(1, force));
        this.isAccelerating = true;
    }

    brake(force = 1) {
        this.targetThrottleInput = -Math.max(0, Math.min(1, force));
        this.isBraking = true;
    }

    steer(direction = 1) {
        this.targetSteeringInput = Math.max(-1, Math.min(1, direction));
        this.isTurning = true;
    }

    handbrake(enabled = true) {
        this.isHandbraking = enabled;
    }

    getCurrentSpeed() {
        return this.currentSpeed;
    }

    isMoving() {
        return this.currentSpeed !== 0;
    }

    getCurrentWheelAngle() {
        return this.currentWheelAngle;
    }

    getThrottleInput() {
        return this.throttleInput;
    }

    getDriftAngle() {
        return this.driftAngle;
    }

    getTraction() {
        return this.currentTraction;
    }

    getWheelSpinAmount() {
        return this.wheelSpinAmount;
    }

    toJSON() {
        return {
            ...super.toJSON(),
            playerControlled: this.playerControlled,
            maxSpeed: this.maxSpeed,
            acceleration: this.acceleration,
            brakeForce: this.brakeForce,
            decelerationRate: this.decelerationRate,
            reverseMaxSpeed: this.reverseMaxSpeed,
            maxTurnAngle: this.maxTurnAngle,
            turnMultiplier: this.turnMultiplier,
            wheelTurnSpeed: this.wheelTurnSpeed,
            wheelReturnSpeed: this.wheelReturnSpeed,
            dragCoefficient: this.dragCoefficient,
            lateralGrip: this.lateralGrip,
            minTurnSpeed: this.minTurnSpeed,
            wheelBase: this.wheelBase,
            frontWheelDrive: this.frontWheelDrive,
            differentialStrength: this.differentialStrength,
            antiRoll: this.antiRoll,
            handbrakeForce: this.handbrakeForce,
            driftThreshold: this.driftThreshold,
            tractionLoss: this.tractionLoss,
            powerOversteerStrength: this.powerOversteerStrength,
            frontGripAdvantage: this.frontGripAdvantage,
            driftRecoveryRate: this.driftRecoveryRate,
            velocityDriftFactor: this.velocityDriftFactor,
            tractionControlEnabled: this.tractionControlEnabled,
            tractionControlStrength: this.tractionControlStrength,
            absEnabled: this.absEnabled,
            absStrength: this.absStrength,
            showDebugInfo: this.showDebugInfo,
            showWheelDirection: this.showWheelDirection,
            showDriftInfo: this.showDriftInfo,
            upKey: this.upKey,
            downKey: this.downKey,
            leftKey: this.leftKey,
            rightKey: this.rightKey,
            handbrakeKey: this.handbrakeKey,
            tireMarkOpacity: this.tireMarkOpacity,
            tireMarkScale: this.tireMarkScale,
            tireMarkLifetime: this.tireMarkLifetime,
            tireMarkDistanceApart: this.tireMarkDistanceApart,
            tireMarkEnabled: this.tireMarkEnabled,
            tireMarkOffsetX: this.tireMarkOffsetX,
            tireMarkOffsetY: this.tireMarkOffsetY,
            gtaStyleVehicle: this.gtaStyleVehicle,
            gtaStyleVehicle: this.gtaStyleVehicle,
            enterKey: this.enterKey,
            enterDistance: this.enterDistance,
            hidePlayerWhenInside: this.hidePlayerWhenInside,
            showEnterPrompt: this.showEnterPrompt,
            ejectOnDestroy: this.ejectOnDestroy
        };
    }

    fromJSON(data) {
        super.fromJSON(data);

        if (!data) return;

        this.playerControlled = data.playerControlled !== undefined ? data.playerControlled : true;
        this.maxSpeed = data.maxSpeed || 300;
        this.acceleration = data.acceleration || 600;
        this.brakeForce = data.brakeForce || 800;
        this.decelerationRate = data.decelerationRate || 0.15;
        this.reverseMaxSpeed = data.reverseMaxSpeed || 150;
        this.maxTurnAngle = data.maxTurnAngle || 45;
        this.turnMultiplier = data.turnMultiplier || 1.0;
        this.wheelTurnSpeed = data.wheelTurnSpeed || 180;
        this.wheelReturnSpeed = data.wheelReturnSpeed || 120;
        this.dragCoefficient = data.dragCoefficient || 0.95;
        this.lateralGrip = data.lateralGrip || 0.85;
        this.minTurnSpeed = data.minTurnSpeed || 50;
        this.wheelBase = data.wheelBase || 60;
        this.frontWheelDrive = data.frontWheelDrive !== undefined ? data.frontWheelDrive : true;
        this.differentialStrength = data.differentialStrength || 0.8;
        this.antiRoll = data.antiRoll || 0.3;
        this.handbrakeForce = data.handbrakeForce || 0.3;
        this.driftThreshold = data.driftThreshold || 0.8;
        this.tractionLoss = data.tractionLoss || 0.4;
        this.powerOversteerStrength = data.powerOversteerStrength || 1.2;
        this.frontGripAdvantage = data.frontGripAdvantage || 0.15;
        this.driftRecoveryRate = data.driftRecoveryRate || 3.0;
        this.velocityDriftFactor = data.velocityDriftFactor || 0.7;
        this.tractionControlEnabled = data.tractionControlEnabled !== undefined ? data.tractionControlEnabled : true;
        this.tractionControlStrength = data.tractionControlStrength || 0.6;
        this.absEnabled = data.absEnabled !== undefined ? data.absEnabled : true;
        this.absStrength = data.absStrength || 0.8;
        this.showDebugInfo = data.showDebugInfo || false;
        this.showWheelDirection = data.showWheelDirection !== undefined ? data.showWheelDirection : true;
        this.showDriftInfo = data.showDriftInfo !== undefined ? data.showDriftInfo : true;
        this.upKey = data.upKey || "arrowup";
        this.downKey = data.downKey || "arrowdown";
        this.leftKey = data.leftKey || "arrowleft";
        this.rightKey = data.rightKey || "arrowright";
        this.handbrakeKey = data.handbrakeKey || " ";
        this.tireMarkOpacity = data.tireMarkOpacity !== undefined ? data.tireMarkOpacity : 0.5;
        this.tireMarkScale = data.tireMarkScale || 1.0;
        this.tireMarkLifetime = data.tireMarkLifetime || 8000;
        this.tireMarkDistanceApart = data.tireMarkDistanceApart || 12;
        this.tireMarkEnabled = data.tireMarkEnabled !== undefined ? data.tireMarkEnabled : true;
        this.tireMarkOffsetX = data.tireMarkOffsetX || 0;
        this.tireMarkOffsetY = data.tireMarkOffsetY || 0;
        this.gtaStyleVehicle = data.gtaStyleVehicle !== undefined ? data.gtaStyleVehicle : true;
        this.enterKey = data.enterKey || "enter";
        this.enterDistance = data.enterDistance || 80;
        this.hidePlayerWhenInside = data.hidePlayerWhenInside !== undefined ? data.hidePlayerWhenInside : true;
        this.showEnterPrompt = data.showEnterPrompt !== undefined ? data.showEnterPrompt : true;
        this.ejectOnDestroy = data.ejectOnDestroy !== undefined ? data.ejectOnDestroy : true;

    }
}

// Register the module
window.VehiclePhysics = VehiclePhysics;

// src/core/Modules/car5.js
// Could not load src/core/Modules/car5.js: Failed to load src/core/Modules/car5.js: 404

// src/core/Modules/Car2.js
// Could not load src/core/Modules/Car2.js: Failed to load src/core/Modules/Car2.js: 404

// src/core/Modules/Car4.js
// Could not load src/core/Modules/Car4.js: Failed to load src/core/Modules/Car4.js: 404

// src/core/Modules/Car3.js
// Could not load src/core/Modules/Car3.js: Failed to load src/core/Modules/Car3.js: 404

// src/core/Modules/RoadCone.js
// Could not load src/core/Modules/RoadCone.js: Failed to load src/core/Modules/RoadCone.js: 404

// Car1.js
class Car1 extends Module {
    static namespace = "Drawing";
    static description = "Custom generated drawing module";
    static allowMultiple = false;
    static iconClass = "fas fa-paint-brush";
    static iconColor = "#64B5F6";

    constructor() {
        super("Car1");

        // Visual properties
        this.scale = 1;
        this.offsetX = 0;
        this.offsetY = 0;
        this.flipped = false;

        this.animationRanges = [
        {
                "name": "idle",
                "start": 0,
                "end": 4
        }
];
        this.currentAnimation = "idle";
        
        // Animation properties
        this.isAnimated = false;
        this.currentFrame = 0;
        this.animationSpeed = 1;
        this.isPlaying = true;
        this.frameTimer = 0;
        this.pingPong = false;
        this.playDirection = 1;
        this.totalFrames = 1;
        this.enableTweening = false;
        this.tweenType = "linear";

        this.preGenerateImage = false;
        this.generatedImage = null;
        this.imageGenerated = false;
        
        // Frame data
        this.frames = [
        [
                {
                        "type": "rectangle",
                        "startX": 224,
                        "startY": 208,
                        "endX": 576,
                        "endY": 384,
                        "fillColor": "#3b82f6",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 176,
                                "y": 208
                        },
                        "worldPosition": {
                                "x": 176,
                                "y": 208
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                },
                {
                        "type": "rectangle",
                        "startX": 304,
                        "startY": 240,
                        "endX": 496,
                        "endY": 352,
                        "fillColor": "#81abee",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": false,
                                "start": "#c8d9f3",
                                "end": "#ffffff",
                                "type": "linear",
                                "angle": 0
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 304,
                                "y": 240
                        },
                        "worldPosition": {
                                "x": 304,
                                "y": 240
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                },
                {
                        "type": "rectangle",
                        "startX": 496,
                        "startY": 240,
                        "endX": 528,
                        "endY": 352,
                        "fillColor": "#81abee",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#c8d9f3",
                                "end": "#ffffff",
                                "type": "linear",
                                "angle": 0
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 496,
                                "y": 240
                        },
                        "worldPosition": {
                                "x": 496,
                                "y": 240
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                },
                {
                        "type": "rectangle",
                        "startX": 256,
                        "startY": 240,
                        "endX": 304,
                        "endY": 352,
                        "fillColor": "#81abee",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#c8d9f3",
                                "end": "#ffffff",
                                "type": "linear",
                                "angle": 0
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 256,
                                "y": 240
                        },
                        "worldPosition": {
                                "x": 256,
                                "y": 240
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                },
                {
                        "type": "rectangle",
                        "startX": 560,
                        "startY": 224,
                        "endX": 576,
                        "endY": 256,
                        "fillColor": "#ebe9cb",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 560,
                                "y": 224
                        },
                        "worldPosition": {
                                "x": 560,
                                "y": 224
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                },
                {
                        "type": "rectangle",
                        "startX": 560,
                        "startY": 368,
                        "endX": 576,
                        "endY": 336,
                        "fillColor": "#ebe9cb",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 560,
                                "y": 368
                        },
                        "worldPosition": {
                                "x": 560,
                                "y": 368
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                },
                {
                        "type": "rectangle",
                        "startX": 224,
                        "startY": 224,
                        "endX": 240,
                        "endY": 256,
                        "fillColor": "#c08c8c",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 224,
                                "y": 224
                        },
                        "worldPosition": {
                                "x": 224,
                                "y": 224
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                },
                {
                        "type": "rectangle",
                        "startX": 224,
                        "startY": 336,
                        "endX": 240,
                        "endY": 368,
                        "fillColor": "#c08c8c",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 224,
                                "y": 336
                        },
                        "worldPosition": {
                                "x": 224,
                                "y": 336
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                }
        ]
];
        
        // Initialize current animation range
        this.currentAnimationRange = this.getCurrentAnimationRange();
        
        this.exposeProperties();
    }

    getCurrentAnimationRange() {
        return this.animationRanges.find(r => r.name === this.currentAnimation) || 
               { name: "default", start: 0, end: this.totalFrames - 1 };
    }

    exposeProperties() {
        this.exposeProperty("scale", "number", this.scale, {
            description: "Scale factor",
            onChange: (val) => { this.scale = val; }
        });
        
        this.exposeProperty("offsetX", "number", this.offsetX, {
            description: "X offset",
            onChange: (val) => { this.offsetX = val; }
        });
        
        this.exposeProperty("offsetY", "number", this.offsetY, {
            description: "Y offset", 
            onChange: (val) => { this.offsetY = val; }
        });
        
        this.exposeProperty("flipped", "boolean", this.flipped, {
            description: "Flip horizontally",
            onChange: (val) => { this.flipped = val; }
        });

        this.exposeProperty("preGenerateImage", "boolean", this.preGenerateImage, {
            description: "Pre-generate image for better performance",
            onChange: (val) => { 
                this.preGenerateImage = val; 
                if (val) {
                    this.generateImage();
                } else {
                    this.generatedImage = null;
                    this.imageGenerated = false;
                }
            }
        });

        if (this.isAnimated) {
            this.exposeProperty("currentAnimation", "enum", this.currentAnimation, {
                options: this.animationRanges.map(r => r.name),
                description: "Current animation",
                onChange: (val) => {
                    this.setAnimation(val);
                }
            });

            this.exposeProperty("animationSpeed", "number", this.animationSpeed, {
                description: "Animation speed",
                onChange: (val) => { this.animationSpeed = val; }
            });
            
            this.exposeProperty("enableTweening", "boolean", this.enableTweening, {
                description: "Enable tweening for smooth transitions",
                onChange: (val) => { this.enableTweening = val; }
            });

            this.exposeProperty("tweenType", "enum", this.tweenType, {
                options: ["linear", "ease-in", "ease-out", "ease-in-out"],
                description: "Tweening type",
                onChange: (val) => { this.tweenType = val; }
            });
            
            this.exposeProperty("isPlaying", "boolean", this.isPlaying, {
                description: "Is playing animation",
                onChange: (val) => { this.isPlaying = val }
            });
        }
    }

    style(style) {
        style.startGroup("Car1 Appearance", false, { 
            backgroundColor: 'rgba(59,130,246,0.1)',
            borderRadius: '6px',
            padding: '8px'
        });
        
        style.exposeProperty("scale", "number", this.scale, {
            min: 0.1,
            max: 5,
            step: 0.1,
            style: { label: "Scale", slider: true }
        });
        
        style.exposeProperty("offsetX", "number", this.offsetX, {
            min: -200,
            max: 200,
            style: { label: "Offset X", slider: true }
        });
        
        style.exposeProperty("offsetY", "number", this.offsetY, {
            min: -200,
            max: 200,
            style: { label: "Offset Y", slider: true }
        });
        
        style.exposeProperty("flipped", "boolean", this.flipped, {
            style: { label: "Flip Horizontally" }
        });

        style.exposeProperty("preGenerateImage", "boolean", this.preGenerateImage, {
            style: { label: "Pre-generate Image" }
        });
        
        if (this.isAnimated) {
            style.startGroup("Animation Controls", true);

            style.exposeProperty("currentAnimation", "enum", this.currentAnimation, {
                options: this.animationRanges.map(r => r.name),
                style: { label: "Animation" }
            });
            
            style.exposeProperty("animationSpeed", "number", this.animationSpeed, {
                min: 0.1,
                max: 5,
                step: 0.1,
                style: { label: "Speed", slider: true }
            });

            style.exposeProperty("enableTweening", "boolean", this.enableTweening, {
                style: { label: "Enable Tweening" }
            });

            style.exposeProperty("tweenType", "enum", this.tweenType, {
                options: ["linear", "ease-in", "ease-out", "ease-in-out"],
                style: { label: "Tween Type" }
            });
            
            style.exposeProperty("isPlaying", "boolean", this.isPlaying, {
                style: { label: "Playing" }
            });
            
            style.endGroup();
        }
        
        style.endGroup();
        style.addHelpText("Generated drawing module with animation support");
        style.addHelpText(`Animation List: 
${this.animationRanges.map(r => `${r.name} (frames ${r.start}-${r.end})`).join(", ")}`);
    }

    // Public API Methods
    playAnimation(name) {
        const range = this.animationRanges.find(r => r.name === name);
        if (range) {
            this.currentAnimation = name;
            this.currentAnimationRange = range;
            this.currentFrame = range.start;
            this.isPlaying = true;
            this.frameTimer = 0;
            this.playDirection = 1;
        }
    }

    setAnimation(name) {
        const range = this.animationRanges.find(r => r.name === name);
        if (range) {
            this.currentAnimation = name;
            this.currentAnimationRange = range;
            this.currentFrame = range.start;
            this.isPlaying = false;
            this.frameTimer = 0;
            this.playDirection = 1;
        }
    }

    play() {
        this.isPlaying = true;
    }

    pause() {
        this.isPlaying = false;
    }

    stop() {
        this.isPlaying = false;
        const range = this.getCurrentAnimationRange();
        this.currentFrame = range.start;
        this.frameTimer = 0;
        this.playDirection = 1;
    }

    setFrame(frameIndex) {
        const range = this.getCurrentAnimationRange();
        if (frameIndex >= range.start && frameIndex <= range.end) {
            this.currentFrame = frameIndex;
        }
    }

    setSpeed(speed) {
        this.animationSpeed = Math.max(0.1, speed);
        return this;
    }

    getCurrentFrame() {
        return this.currentFrame;
    }

    getTotalFrames() {
        return this.totalFrames;
    }

    getAnimationFrameCount() {
        const range = this.getCurrentAnimationRange();
        return range.end - range.start + 1;
    }

    start() {
        if (this.preGenerateImage) {
            this.generateImage();
        }
        // Initialize to first frame of current animation
        const range = this.getCurrentAnimationRange();
        this.currentFrame = range.start;
    }

    loop(deltaTime) {
        if (!this.isAnimated || !this.isPlaying) return;

        const range = this.getCurrentAnimationRange();
        const frameCount = range.end - range.start + 1;

        // If only one frame in range, nothing to animate
        if (frameCount <= 1) {
            this.currentFrame = range.start;
            return;
        }

        this.frameTimer += deltaTime * this.animationSpeed;

        // Use frame duration of 0.1 seconds (10 FPS)
        const frameDuration = 0.1;
        
        if (this.frameTimer >= frameDuration) {
            this.frameTimer = 0;

            if (this.pingPong) {
                // Ping pong animation within the range
                this.currentFrame += this.playDirection;
                
                if (this.currentFrame >= range.end) {
                    this.playDirection = -1;
                    this.currentFrame = range.end;
                } else if (this.currentFrame <= range.start) {
                    this.playDirection = 1;
                    this.currentFrame = range.start;
                }
            } else {
                // Linear loop animation within the range
                this.currentFrame++;
                if (this.currentFrame > range.end) {
                    this.currentFrame = range.start;
                }
            }
        }
    }

    draw(ctx) {
        if (this.preGenerateImage && this.generatedImage && this.imageGenerated) {
            ctx.save();
            ctx.scale(this.scale, this.scale);
            if (this.flipped) {
                ctx.scale(-1, 1);
            }
            ctx.translate(this.offsetX, this.offsetY);
            
            ctx.drawImage(this.generatedImage, -this.generatedImage.width/2, -this.generatedImage.height/2);
            ctx.restore();
            return;
        }

        ctx.save();
        
        // Apply transformations
        ctx.scale(this.scale, this.scale);
        if (this.flipped) {
            ctx.scale(-1, 1);
        }
        ctx.translate(this.offsetX, this.offsetY);

        // Calculate the center point of all shapes to use as origin
        const shapeCenter = this.calculateShapesCenterPoint();
        
        // Translate so shapes center around 0,0
        ctx.translate(-shapeCenter.centerX, -shapeCenter.centerY);

        // Get current frame shapes
        let shapes;
        if (this.enableTweening && this.totalFrames > 1 && this.isPlaying) {
            shapes = this.getTweenedShapes();
        } else {
            const frameIndex = Math.floor(this.currentFrame);
            shapes = this.frames[frameIndex] || [];
        }
        shapes = shapes.filter(shape => shape && shape.visible !== false);

        shapes.forEach((shape, index) => {
            this.drawShape(ctx, shape);
        });

        ctx.restore();
    }

    getTweenedShapes() {
        const range = this.getCurrentAnimationRange();
        
        // Ensure current frame is within animation range for tweening
        let currentFrame = Math.floor(this.currentFrame);
        let nextFrame = currentFrame + 1;
        
        // Handle range boundaries
        if (nextFrame > range.end) {
            if (this.pingPong && this.playDirection === -1) {
                nextFrame = currentFrame - 1;
            } else {
                nextFrame = range.start; // Loop back to start
            }
        }
        
        // Ensure frames are valid
        currentFrame = Math.max(range.start, Math.min(range.end, currentFrame));
        nextFrame = Math.max(range.start, Math.min(range.end, nextFrame));
        
        const t = this.currentFrame - Math.floor(this.currentFrame);

        const currentShapes = this.frames[currentFrame] || [];
        const nextShapes = this.frames[nextFrame] || [];

        return this.interpolateShapes(currentShapes, nextShapes, t);
    }

    interpolateShapes(shapes1, shapes2, t) {
        const result = [];
        const maxLength = Math.max(shapes1.length, shapes2.length);

        for (let i = 0; i < maxLength; i++) {
            const shape1 = shapes1[i];
            const shape2 = shapes2[i];

            if (shape1 && shape2 && shape1.type === shape2.type) {
                result.push(this.interpolateShape(shape1, shape2, t));
            } else if (shape1) {
                result.push({ ...shape1 });
            } else if (shape2) {
                result.push({ ...shape2 });
            }
        }

        return result;
    }

    interpolateShape(shape1, shape2, t) {
        const eased = this.applyEasing(t, this.tweenType);
        const interpolated = { ...shape1 };

        // Interpolate basic properties
        if (shape1.type === 'spline') {
            interpolated.points = [];
            const maxPoints = Math.max(shape1.points.length, shape2.points.length);
            
            for (let i = 0; i < maxPoints; i++) {
                const p1 = shape1.points[i] || shape1.points[shape1.points.length - 1];
                const p2 = shape2.points[i] || shape2.points[shape2.points.length - 1];
                
                interpolated.points.push({
                    x: p1.x + (p2.x - p1.x) * eased,
                    y: p1.y + (p2.y - p1.y) * eased
                });
            }
        } else {
            interpolated.startX = shape1.startX + (shape2.startX - shape1.startX) * eased;
            interpolated.startY = shape1.startY + (shape2.startY - shape1.startY) * eased;
            interpolated.endX = shape1.endX + (shape2.endX - shape1.endX) * eased;
            interpolated.endY = shape1.endY + (shape2.endY - shape1.endY) * eased;
        }

        // Interpolate transform properties
        interpolated.rotation = (shape1.rotation || 0) + ((shape2.rotation || 0) - (shape1.rotation || 0)) * eased;
        interpolated.scaleX = (shape1.scaleX || 1) + ((shape2.scaleX || 1) - (shape1.scaleX || 1)) * eased;
        interpolated.scaleY = (shape1.scaleY || 1) + ((shape2.scaleY || 1) - (shape1.scaleY || 1)) * eased;

        return interpolated;
    }

    applyEasing(t, type) {
        switch (type) {
            case 'ease-in': return t * t;
            case 'ease-out': return 1 - (1 - t) * (1 - t);
            case 'ease-in-out': return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
            case 'bounce': return this.bounceEase(t);
            default: return t; // linear
        }
    }

    bounceEase(t) {
        const n1 = 7.5625;
        const d1 = 2.75;

        if (t < 1 / d1) {
            return n1 * t * t;
        } else if (t < 2 / d1) {
            return n1 * (t -= 1.5 / d1) * t + 0.75;
        } else if (t < 2.5 / d1) {
            return n1 * (t -= 2.25 / d1) * t + 0.9375;
        } else {
            return n1 * (t -= 2.625 / d1) * t + 0.984375;
        }
    }

    generateImage() {
        const canvas = document.createElement('canvas');
        canvas.width = 800;
        canvas.height = 600;
        const ctx = canvas.getContext('2d');
        
        // Calculate center point and translate
        const shapeCenter = this.calculateShapesCenterPoint();
        ctx.translate(canvas.width/2 - shapeCenter.centerX, canvas.height/2 - shapeCenter.centerY);
        
        // Draw all frames composited (or just frame 0 for static)
        const shapes = this.frames[0] || [];
        shapes.forEach((shape) => {
            this.drawShape(ctx, shape);
        });
        
        this.generatedImage = new Image();
        this.generatedImage.src = canvas.toDataURL();
        this.imageGenerated = true;
    }

    calculateShapesCenterPoint() {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        let hasShapes = false;

        this.frames.forEach(frame => {
            if (!frame) return;
            frame.forEach(shape => {
                hasShapes = true;
                if (shape.type === 'spline') {
                    shape.points.forEach(point => {
                        minX = Math.min(minX, point.x);
                        minY = Math.min(minY, point.y);
                        maxX = Math.max(maxX, point.x);
                        maxY = Math.max(maxY, point.y);
                    });
                } else if (shape.type === 'circle') {
                    const radius = Math.sqrt((shape.endX - shape.startX) ** 2 + (shape.endY - shape.startY) ** 2);
                    minX = Math.min(minX, shape.startX - radius);
                    minY = Math.min(minY, shape.startY - radius);
                    maxX = Math.max(maxX, shape.startX + radius);
                    maxY = Math.max(maxY, shape.startY + radius);
                } else {
                    minX = Math.min(minX, shape.startX, shape.endX);
                    minY = Math.min(minY, shape.startY, shape.endY);
                    maxX = Math.max(maxX, shape.startX, shape.endX);
                    maxY = Math.max(maxY, shape.startY, shape.endY);
                }
            });
        });

        if (!hasShapes) return { centerX: 0, centerY: 0 };
        
        return {
            centerX: (minX + maxX) / 2,
            centerY: (minY + maxY) / 2
        };
    }

    createGradient(shape, ctx) {
        if (!shape.gradient || !shape.gradient.enabled) return shape.fillColor;
        
        let gradient;
        const bounds = this.getShapeBounds(shape);
        
        if (shape.gradient.type === 'radial') {
            const centerX = bounds.x + bounds.width / 2;
            const centerY = bounds.y + bounds.height / 2;
            const radius = Math.max(bounds.width, bounds.height) / 2;
            gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
        } else {
            // Linear gradient
            const angle = (shape.gradient.angle || 0) * Math.PI / 180;
            const x1 = bounds.x + bounds.width / 2 - Math.cos(angle) * bounds.width / 2;
            const y1 = bounds.y + bounds.height / 2 - Math.sin(angle) * bounds.height / 2;
            const x2 = bounds.x + bounds.width / 2 + Math.cos(angle) * bounds.width / 2;
            const y2 = bounds.y + bounds.height / 2 + Math.sin(angle) * bounds.height / 2;
            gradient = ctx.createLinearGradient(x1, y1, x2, y2);
        }
        
        gradient.addColorStop(0, shape.gradient.start);
        gradient.addColorStop(1, shape.gradient.end);
        
        return gradient;
    }

    getShapeBounds(shape) {
        if (shape.type === 'spline') {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            shape.points.forEach(pt => {
                minX = Math.min(minX, pt.x);
                minY = Math.min(minY, pt.y);
                maxX = Math.max(maxX, pt.x);
                maxY = Math.max(maxY, pt.y);
            });
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        } else if (shape.type === 'circle') {
            const radius = Math.sqrt((shape.endX - shape.startX) ** 2 + (shape.endY - shape.startY) ** 2);
            return {
                x: shape.startX - radius,
                y: shape.startY - radius,
                width: radius * 2,
                height: radius * 2
            };
        } else {
            const minX = Math.min(shape.startX, shape.endX);
            const minY = Math.min(shape.startY, shape.endY);
            const maxX = Math.max(shape.startX, shape.endX);
            const maxY = Math.max(shape.startY, shape.endY);
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }
    }

    drawShape(ctx, shape) {
        if (!shape.visible) return;
        
        ctx.save();
        
        // Apply transformations
        if (shape.rotation || shape.scaleX !== 1 || shape.scaleY !== 1) {
            const bounds = this.getShapeBounds(shape);
            const centerX = bounds.x + bounds.width / 2;
            const centerY = bounds.y + bounds.height / 2;
            
            ctx.translate(centerX, centerY);
            ctx.rotate((shape.rotation || 0) * Math.PI / 180);
            ctx.scale(shape.scaleX || 1, shape.scaleY || 1);
            ctx.translate(-centerX, -centerY);
        }
        
        // Set up colors/gradients
        ctx.fillStyle = shape.gradient ? this.createGradient(shape, ctx) : shape.fillColor;
        ctx.strokeStyle = shape.strokeColor;
        ctx.lineWidth = shape.strokeWidth;
        ctx.setLineDash([]);

        switch (shape.type) {
            case 'rectangle':
                this.drawRectangle(ctx, shape);
                break;
            case 'circle':
                this.drawCircle(ctx, shape);
                break;
            case 'triangle':
                this.drawTriangle(ctx, shape);
                break;
            case 'line':
                this.drawLine(ctx, shape);
                break;
            case 'spline':
                this.drawSpline(ctx, shape);
                break;
        }

        ctx.restore();
    }

    drawRectangle(ctx, shape) {
        const width = shape.endX - shape.startX;
        const height = shape.endY - shape.startY;
        if (shape.fill) ctx.fillRect(shape.startX, shape.startY, width, height);
        if (shape.stroke) ctx.strokeRect(shape.startX, shape.startY, width, height);
    }

    drawCircle(ctx, shape) {
        const radius = Math.sqrt((shape.endX - shape.startX) ** 2 + (shape.endY - shape.startY) ** 2);
        ctx.beginPath();
        ctx.arc(shape.startX, shape.startY, radius, 0, Math.PI * 2);
        if (shape.fill) ctx.fill();
        if (shape.stroke) ctx.stroke();
    }

    drawTriangle(ctx, shape) {
        const midX = (shape.startX + shape.endX) / 2;
        ctx.beginPath();
        ctx.moveTo(midX, shape.startY);
        ctx.lineTo(shape.startX, shape.endY);
        ctx.lineTo(shape.endX, shape.endY);
        ctx.closePath();
        if (shape.fill) ctx.fill();
        if (shape.stroke) ctx.stroke();
    }

    drawLine(ctx, shape) {
        ctx.beginPath();
        ctx.moveTo(shape.startX, shape.startY);
        ctx.lineTo(shape.endX, shape.endY);
        ctx.stroke();
    }

    drawSpline(ctx, shape) {
        if (shape.points.length < 2) return;
        ctx.beginPath();
        if (shape.points.length === 2) {
            ctx.moveTo(shape.points[0].x, shape.points[0].y);
            ctx.lineTo(shape.points[1].x, shape.points[1].y);
        } else {
            // Use the original points without offset
            this.drawSmoothSpline(shape.points, shape.curveIntensity, shape.closed, ctx);
        }
        if (shape.closed) ctx.closePath();
        if (shape.fill && shape.closed) ctx.fill();
        if (shape.stroke) ctx.stroke();
    }

    // Update drawSmoothSpline to accept ctx
    drawSmoothSpline(points, intensity, closed, ctx = this.ctx) {
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            const prev = points[i - 1];
            const curr = points[i];
            const next = points[(i + 1) % points.length];
            const cp1x = prev.x + (curr.x - prev.x) * intensity;
            const cp1y = prev.y + (curr.y - prev.y) * intensity;
            const cp2x = curr.x - (next.x - prev.x) * intensity * 0.2;
            const cp2y = curr.y - (next.y - prev.y) * intensity * 0.2;
            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, curr.x, curr.y);
        }
    }

    toJSON() {
        return {
            ...super.toJSON(),
            scale: this.scale,
            offsetX: this.offsetX,
            offsetY: this.offsetY,
            flipped: this.flipped,
            animationSpeed: this.animationSpeed,
            isPlaying: this.isPlaying,
            currentFrame: this.currentFrame,
            currentAnimation: this.currentAnimation
        };
    }

    fromJSON(data) {
        super.fromJSON(data);
        if (!data) return;

        this.scale = data.scale || 1;
        this.offsetX = data.offsetX || 0;
        this.offsetY = data.offsetY || 0;
        this.flipped = data.flipped || false;
        this.animationSpeed = data.animationSpeed || 1;
        this.isPlaying = data.isPlaying || false;
        this.currentFrame = data.currentFrame || 0;
        this.currentAnimation = data.currentAnimation || "idle";
        
        // Update animation range after loading
        this.currentAnimationRange = this.getCurrentAnimationRange();
    }
}

window.Car1 = Car1;

// Car2.js
class Car2 extends Module {
    static namespace = "Drawing";
    static description = "Custom generated drawing module";
    static allowMultiple = false;
    static iconClass = "fas fa-paint-brush";
    static iconColor = "#64B5F6";

    constructor() {
        super("Car2");

        // Visual properties
        this.scale = 1;
        this.offsetX = 0;
        this.offsetY = 0;
        this.flipped = false;

        this.animationRanges = [
        {
                "name": "idle",
                "start": 0,
                "end": 4
        }
];
        this.currentAnimation = "idle";
        
        // Animation properties
        this.isAnimated = false;
        this.currentFrame = 0;
        this.animationSpeed = 1;
        this.isPlaying = true;
        this.frameTimer = 0;
        this.pingPong = false;
        this.playDirection = 1;
        this.totalFrames = 1;
        this.enableTweening = false;
        this.tweenType = "linear";

        this.preGenerateImage = false;
        this.generatedImage = null;
        this.imageGenerated = false;
        
        // Frame data
        this.frames = [
        [
                {
                        "type": "rectangle",
                        "startX": 224,
                        "startY": 208,
                        "endX": 576,
                        "endY": 384,
                        "fillColor": "#f73bb2",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 176,
                                "y": 208
                        },
                        "worldPosition": {
                                "x": 176,
                                "y": 208
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 304,
                        "startY": 240,
                        "endX": 496,
                        "endY": 352,
                        "fillColor": "#904c83",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": false,
                                "start": "#c8d9f3",
                                "end": "#ffffff",
                                "type": "linear",
                                "angle": 0
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 304,
                                "y": 240
                        },
                        "worldPosition": {
                                "x": 304,
                                "y": 240
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 496,
                        "startY": 240,
                        "endX": 528,
                        "endY": 352,
                        "fillColor": "#81abee",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#c8d9f3",
                                "end": "#ffffff",
                                "type": "linear",
                                "angle": 0
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 496,
                                "y": 240
                        },
                        "worldPosition": {
                                "x": 496,
                                "y": 240
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 256,
                        "startY": 240,
                        "endX": 304,
                        "endY": 352,
                        "fillColor": "#81abee",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#c8d9f3",
                                "end": "#ffffff",
                                "type": "linear",
                                "angle": 0
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 256,
                                "y": 240
                        },
                        "worldPosition": {
                                "x": 256,
                                "y": 240
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 560,
                        "startY": 224,
                        "endX": 576,
                        "endY": 256,
                        "fillColor": "#ebe9cb",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 560,
                                "y": 224
                        },
                        "worldPosition": {
                                "x": 560,
                                "y": 224
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 560,
                        "startY": 368,
                        "endX": 576,
                        "endY": 336,
                        "fillColor": "#ebe9cb",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 560,
                                "y": 368
                        },
                        "worldPosition": {
                                "x": 560,
                                "y": 368
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 224,
                        "startY": 224,
                        "endX": 240,
                        "endY": 256,
                        "fillColor": "#c08c8c",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 224,
                                "y": 224
                        },
                        "worldPosition": {
                                "x": 224,
                                "y": 224
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 224,
                        "startY": 336,
                        "endX": 240,
                        "endY": 368,
                        "fillColor": "#c08c8c",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 224,
                                "y": 336
                        },
                        "worldPosition": {
                                "x": 224,
                                "y": 336
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                }
        ]
];
        
        // Initialize current animation range
        this.currentAnimationRange = this.getCurrentAnimationRange();
        
        this.exposeProperties();
    }

    getCurrentAnimationRange() {
        return this.animationRanges.find(r => r.name === this.currentAnimation) || 
               { name: "default", start: 0, end: this.totalFrames - 1 };
    }

    exposeProperties() {
        this.exposeProperty("scale", "number", this.scale, {
            description: "Scale factor",
            onChange: (val) => { this.scale = val; }
        });
        
        this.exposeProperty("offsetX", "number", this.offsetX, {
            description: "X offset",
            onChange: (val) => { this.offsetX = val; }
        });
        
        this.exposeProperty("offsetY", "number", this.offsetY, {
            description: "Y offset", 
            onChange: (val) => { this.offsetY = val; }
        });
        
        this.exposeProperty("flipped", "boolean", this.flipped, {
            description: "Flip horizontally",
            onChange: (val) => { this.flipped = val; }
        });

        this.exposeProperty("preGenerateImage", "boolean", this.preGenerateImage, {
            description: "Pre-generate image for better performance",
            onChange: (val) => { 
                this.preGenerateImage = val; 
                if (val) {
                    this.generateImage();
                } else {
                    this.generatedImage = null;
                    this.imageGenerated = false;
                }
            }
        });

        if (this.isAnimated) {
            this.exposeProperty("currentAnimation", "enum", this.currentAnimation, {
                options: this.animationRanges.map(r => r.name),
                description: "Current animation",
                onChange: (val) => {
                    this.setAnimation(val);
                }
            });

            this.exposeProperty("animationSpeed", "number", this.animationSpeed, {
                description: "Animation speed",
                onChange: (val) => { this.animationSpeed = val; }
            });
            
            this.exposeProperty("enableTweening", "boolean", this.enableTweening, {
                description: "Enable tweening for smooth transitions",
                onChange: (val) => { this.enableTweening = val; }
            });

            this.exposeProperty("tweenType", "enum", this.tweenType, {
                options: ["linear", "ease-in", "ease-out", "ease-in-out"],
                description: "Tweening type",
                onChange: (val) => { this.tweenType = val; }
            });
            
            this.exposeProperty("isPlaying", "boolean", this.isPlaying, {
                description: "Is playing animation",
                onChange: (val) => { this.isPlaying = val }
            });
        }
    }

    style(style) {
        style.startGroup("Car2 Appearance", false, { 
            backgroundColor: 'rgba(59,130,246,0.1)',
            borderRadius: '6px',
            padding: '8px'
        });
        
        style.exposeProperty("scale", "number", this.scale, {
            min: 0.1,
            max: 5,
            step: 0.1,
            style: { label: "Scale", slider: true }
        });
        
        style.exposeProperty("offsetX", "number", this.offsetX, {
            min: -200,
            max: 200,
            style: { label: "Offset X", slider: true }
        });
        
        style.exposeProperty("offsetY", "number", this.offsetY, {
            min: -200,
            max: 200,
            style: { label: "Offset Y", slider: true }
        });
        
        style.exposeProperty("flipped", "boolean", this.flipped, {
            style: { label: "Flip Horizontally" }
        });

        style.exposeProperty("preGenerateImage", "boolean", this.preGenerateImage, {
            style: { label: "Pre-generate Image" }
        });
        
        if (this.isAnimated) {
            style.startGroup("Animation Controls", true);

            style.exposeProperty("currentAnimation", "enum", this.currentAnimation, {
                options: this.animationRanges.map(r => r.name),
                style: { label: "Animation" }
            });
            
            style.exposeProperty("animationSpeed", "number", this.animationSpeed, {
                min: 0.1,
                max: 5,
                step: 0.1,
                style: { label: "Speed", slider: true }
            });

            style.exposeProperty("enableTweening", "boolean", this.enableTweening, {
                style: { label: "Enable Tweening" }
            });

            style.exposeProperty("tweenType", "enum", this.tweenType, {
                options: ["linear", "ease-in", "ease-out", "ease-in-out"],
                style: { label: "Tween Type" }
            });
            
            style.exposeProperty("isPlaying", "boolean", this.isPlaying, {
                style: { label: "Playing" }
            });
            
            style.endGroup();
        }
        
        style.endGroup();
        style.addHelpText("Generated drawing module with animation support");
        style.addHelpText(`Animation List: 
${this.animationRanges.map(r => `${r.name} (frames ${r.start}-${r.end})`).join(", ")}`);
    }

    // Public API Methods
    playAnimation(name) {
        const range = this.animationRanges.find(r => r.name === name);
        if (range) {
            this.currentAnimation = name;
            this.currentAnimationRange = range;
            this.currentFrame = range.start;
            this.isPlaying = true;
            this.frameTimer = 0;
            this.playDirection = 1;
        }
    }

    setAnimation(name) {
        const range = this.animationRanges.find(r => r.name === name);
        if (range) {
            this.currentAnimation = name;
            this.currentAnimationRange = range;
            this.currentFrame = range.start;
            this.isPlaying = false;
            this.frameTimer = 0;
            this.playDirection = 1;
        }
    }

    play() {
        this.isPlaying = true;
    }

    pause() {
        this.isPlaying = false;
    }

    stop() {
        this.isPlaying = false;
        const range = this.getCurrentAnimationRange();
        this.currentFrame = range.start;
        this.frameTimer = 0;
        this.playDirection = 1;
    }

    setFrame(frameIndex) {
        const range = this.getCurrentAnimationRange();
        if (frameIndex >= range.start && frameIndex <= range.end) {
            this.currentFrame = frameIndex;
        }
    }

    setSpeed(speed) {
        this.animationSpeed = Math.max(0.1, speed);
        return this;
    }

    getCurrentFrame() {
        return this.currentFrame;
    }

    getTotalFrames() {
        return this.totalFrames;
    }

    getAnimationFrameCount() {
        const range = this.getCurrentAnimationRange();
        return range.end - range.start + 1;
    }

    start() {
        if (this.preGenerateImage) {
            this.generateImage();
        }
        // Initialize to first frame of current animation
        const range = this.getCurrentAnimationRange();
        this.currentFrame = range.start;
    }

    loop(deltaTime) {
        if (!this.isAnimated || !this.isPlaying) return;

        const range = this.getCurrentAnimationRange();
        const frameCount = range.end - range.start + 1;

        // If only one frame in range, nothing to animate
        if (frameCount <= 1) {
            this.currentFrame = range.start;
            return;
        }

        this.frameTimer += deltaTime * this.animationSpeed;

        // Use frame duration of 0.1 seconds (10 FPS)
        const frameDuration = 0.1;
        
        if (this.frameTimer >= frameDuration) {
            this.frameTimer = 0;

            if (this.pingPong) {
                // Ping pong animation within the range
                this.currentFrame += this.playDirection;
                
                if (this.currentFrame >= range.end) {
                    this.playDirection = -1;
                    this.currentFrame = range.end;
                } else if (this.currentFrame <= range.start) {
                    this.playDirection = 1;
                    this.currentFrame = range.start;
                }
            } else {
                // Linear loop animation within the range
                this.currentFrame++;
                if (this.currentFrame > range.end) {
                    this.currentFrame = range.start;
                }
            }
        }
    }

    draw(ctx) {
        if (this.preGenerateImage && this.generatedImage && this.imageGenerated) {
            ctx.save();
            ctx.scale(this.scale, this.scale);
            if (this.flipped) {
                ctx.scale(-1, 1);
            }
            ctx.translate(this.offsetX, this.offsetY);
            
            ctx.drawImage(this.generatedImage, -this.generatedImage.width/2, -this.generatedImage.height/2);
            ctx.restore();
            return;
        }

        ctx.save();
        
        // Apply transformations
        ctx.scale(this.scale, this.scale);
        if (this.flipped) {
            ctx.scale(-1, 1);
        }
        ctx.translate(this.offsetX, this.offsetY);

        // Calculate the center point of all shapes to use as origin
        const shapeCenter = this.calculateShapesCenterPoint();
        
        // Translate so shapes center around 0,0
        ctx.translate(-shapeCenter.centerX, -shapeCenter.centerY);

        // Get current frame shapes
        let shapes;
        if (this.enableTweening && this.totalFrames > 1 && this.isPlaying) {
            shapes = this.getTweenedShapes();
        } else {
            const frameIndex = Math.floor(this.currentFrame);
            shapes = this.frames[frameIndex] || [];
        }
        shapes = shapes.filter(shape => shape && shape.visible !== false);

        shapes.forEach((shape, index) => {
            this.drawShape(ctx, shape);
        });

        ctx.restore();
    }

    getTweenedShapes() {
        const range = this.getCurrentAnimationRange();
        
        // Ensure current frame is within animation range for tweening
        let currentFrame = Math.floor(this.currentFrame);
        let nextFrame = currentFrame + 1;
        
        // Handle range boundaries
        if (nextFrame > range.end) {
            if (this.pingPong && this.playDirection === -1) {
                nextFrame = currentFrame - 1;
            } else {
                nextFrame = range.start; // Loop back to start
            }
        }
        
        // Ensure frames are valid
        currentFrame = Math.max(range.start, Math.min(range.end, currentFrame));
        nextFrame = Math.max(range.start, Math.min(range.end, nextFrame));
        
        const t = this.currentFrame - Math.floor(this.currentFrame);

        const currentShapes = this.frames[currentFrame] || [];
        const nextShapes = this.frames[nextFrame] || [];

        return this.interpolateShapes(currentShapes, nextShapes, t);
    }

    interpolateShapes(shapes1, shapes2, t) {
        const result = [];
        const maxLength = Math.max(shapes1.length, shapes2.length);

        for (let i = 0; i < maxLength; i++) {
            const shape1 = shapes1[i];
            const shape2 = shapes2[i];

            if (shape1 && shape2 && shape1.type === shape2.type) {
                result.push(this.interpolateShape(shape1, shape2, t));
            } else if (shape1) {
                result.push({ ...shape1 });
            } else if (shape2) {
                result.push({ ...shape2 });
            }
        }

        return result;
    }

    interpolateShape(shape1, shape2, t) {
        const eased = this.applyEasing(t, this.tweenType);
        const interpolated = { ...shape1 };

        // Interpolate basic properties
        if (shape1.type === 'spline') {
            interpolated.points = [];
            const maxPoints = Math.max(shape1.points.length, shape2.points.length);
            
            for (let i = 0; i < maxPoints; i++) {
                const p1 = shape1.points[i] || shape1.points[shape1.points.length - 1];
                const p2 = shape2.points[i] || shape2.points[shape2.points.length - 1];
                
                interpolated.points.push({
                    x: p1.x + (p2.x - p1.x) * eased,
                    y: p1.y + (p2.y - p1.y) * eased
                });
            }
        } else {
            interpolated.startX = shape1.startX + (shape2.startX - shape1.startX) * eased;
            interpolated.startY = shape1.startY + (shape2.startY - shape1.startY) * eased;
            interpolated.endX = shape1.endX + (shape2.endX - shape1.endX) * eased;
            interpolated.endY = shape1.endY + (shape2.endY - shape1.endY) * eased;
        }

        // Interpolate transform properties
        interpolated.rotation = (shape1.rotation || 0) + ((shape2.rotation || 0) - (shape1.rotation || 0)) * eased;
        interpolated.scaleX = (shape1.scaleX || 1) + ((shape2.scaleX || 1) - (shape1.scaleX || 1)) * eased;
        interpolated.scaleY = (shape1.scaleY || 1) + ((shape2.scaleY || 1) - (shape1.scaleY || 1)) * eased;

        return interpolated;
    }

    applyEasing(t, type) {
        switch (type) {
            case 'ease-in': return t * t;
            case 'ease-out': return 1 - (1 - t) * (1 - t);
            case 'ease-in-out': return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
            case 'bounce': return this.bounceEase(t);
            default: return t; // linear
        }
    }

    bounceEase(t) {
        const n1 = 7.5625;
        const d1 = 2.75;

        if (t < 1 / d1) {
            return n1 * t * t;
        } else if (t < 2 / d1) {
            return n1 * (t -= 1.5 / d1) * t + 0.75;
        } else if (t < 2.5 / d1) {
            return n1 * (t -= 2.25 / d1) * t + 0.9375;
        } else {
            return n1 * (t -= 2.625 / d1) * t + 0.984375;
        }
    }

    generateImage() {
        const canvas = document.createElement('canvas');
        canvas.width = 800;
        canvas.height = 600;
        const ctx = canvas.getContext('2d');
        
        // Calculate center point and translate
        const shapeCenter = this.calculateShapesCenterPoint();
        ctx.translate(canvas.width/2 - shapeCenter.centerX, canvas.height/2 - shapeCenter.centerY);
        
        // Draw all frames composited (or just frame 0 for static)
        const shapes = this.frames[0] || [];
        shapes.forEach((shape) => {
            this.drawShape(ctx, shape);
        });
        
        this.generatedImage = new Image();
        this.generatedImage.src = canvas.toDataURL();
        this.imageGenerated = true;
    }

    calculateShapesCenterPoint() {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        let hasShapes = false;

        this.frames.forEach(frame => {
            if (!frame) return;
            frame.forEach(shape => {
                hasShapes = true;
                if (shape.type === 'spline') {
                    shape.points.forEach(point => {
                        minX = Math.min(minX, point.x);
                        minY = Math.min(minY, point.y);
                        maxX = Math.max(maxX, point.x);
                        maxY = Math.max(maxY, point.y);
                    });
                } else if (shape.type === 'circle') {
                    const radius = Math.sqrt((shape.endX - shape.startX) ** 2 + (shape.endY - shape.startY) ** 2);
                    minX = Math.min(minX, shape.startX - radius);
                    minY = Math.min(minY, shape.startY - radius);
                    maxX = Math.max(maxX, shape.startX + radius);
                    maxY = Math.max(maxY, shape.startY + radius);
                } else {
                    minX = Math.min(minX, shape.startX, shape.endX);
                    minY = Math.min(minY, shape.startY, shape.endY);
                    maxX = Math.max(maxX, shape.startX, shape.endX);
                    maxY = Math.max(maxY, shape.startY, shape.endY);
                }
            });
        });

        if (!hasShapes) return { centerX: 0, centerY: 0 };
        
        return {
            centerX: (minX + maxX) / 2,
            centerY: (minY + maxY) / 2
        };
    }

    createGradient(shape, ctx) {
        if (!shape.gradient || !shape.gradient.enabled) return shape.fillColor;
        
        let gradient;
        const bounds = this.getShapeBounds(shape);
        
        if (shape.gradient.type === 'radial') {
            const centerX = bounds.x + bounds.width / 2;
            const centerY = bounds.y + bounds.height / 2;
            const radius = Math.max(bounds.width, bounds.height) / 2;
            gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
        } else {
            // Linear gradient
            const angle = (shape.gradient.angle || 0) * Math.PI / 180;
            const x1 = bounds.x + bounds.width / 2 - Math.cos(angle) * bounds.width / 2;
            const y1 = bounds.y + bounds.height / 2 - Math.sin(angle) * bounds.height / 2;
            const x2 = bounds.x + bounds.width / 2 + Math.cos(angle) * bounds.width / 2;
            const y2 = bounds.y + bounds.height / 2 + Math.sin(angle) * bounds.height / 2;
            gradient = ctx.createLinearGradient(x1, y1, x2, y2);
        }
        
        gradient.addColorStop(0, shape.gradient.start);
        gradient.addColorStop(1, shape.gradient.end);
        
        return gradient;
    }

    getShapeBounds(shape) {
        if (shape.type === 'spline') {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            shape.points.forEach(pt => {
                minX = Math.min(minX, pt.x);
                minY = Math.min(minY, pt.y);
                maxX = Math.max(maxX, pt.x);
                maxY = Math.max(maxY, pt.y);
            });
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        } else if (shape.type === 'circle') {
            const radius = Math.sqrt((shape.endX - shape.startX) ** 2 + (shape.endY - shape.startY) ** 2);
            return {
                x: shape.startX - radius,
                y: shape.startY - radius,
                width: radius * 2,
                height: radius * 2
            };
        } else {
            const minX = Math.min(shape.startX, shape.endX);
            const minY = Math.min(shape.startY, shape.endY);
            const maxX = Math.max(shape.startX, shape.endX);
            const maxY = Math.max(shape.startY, shape.endY);
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }
    }

    drawShape(ctx, shape) {
        if (!shape.visible) return;
        
        ctx.save();
        
        // Apply transformations
        if (shape.rotation || shape.scaleX !== 1 || shape.scaleY !== 1) {
            const bounds = this.getShapeBounds(shape);
            const centerX = bounds.x + bounds.width / 2;
            const centerY = bounds.y + bounds.height / 2;
            
            ctx.translate(centerX, centerY);
            ctx.rotate((shape.rotation || 0) * Math.PI / 180);
            ctx.scale(shape.scaleX || 1, shape.scaleY || 1);
            ctx.translate(-centerX, -centerY);
        }
        
        // Set up colors/gradients
        ctx.fillStyle = shape.gradient ? this.createGradient(shape, ctx) : shape.fillColor;
        ctx.strokeStyle = shape.strokeColor;
        ctx.lineWidth = shape.strokeWidth;
        ctx.setLineDash([]);

        switch (shape.type) {
            case 'rectangle':
                this.drawRectangle(ctx, shape);
                break;
            case 'circle':
                this.drawCircle(ctx, shape);
                break;
            case 'triangle':
                this.drawTriangle(ctx, shape);
                break;
            case 'line':
                this.drawLine(ctx, shape);
                break;
            case 'spline':
                this.drawSpline(ctx, shape);
                break;
        }

        ctx.restore();
    }

    drawRectangle(ctx, shape) {
        const width = shape.endX - shape.startX;
        const height = shape.endY - shape.startY;
        if (shape.fill) ctx.fillRect(shape.startX, shape.startY, width, height);
        if (shape.stroke) ctx.strokeRect(shape.startX, shape.startY, width, height);
    }

    drawCircle(ctx, shape) {
        const radius = Math.sqrt((shape.endX - shape.startX) ** 2 + (shape.endY - shape.startY) ** 2);
        ctx.beginPath();
        ctx.arc(shape.startX, shape.startY, radius, 0, Math.PI * 2);
        if (shape.fill) ctx.fill();
        if (shape.stroke) ctx.stroke();
    }

    drawTriangle(ctx, shape) {
        const midX = (shape.startX + shape.endX) / 2;
        ctx.beginPath();
        ctx.moveTo(midX, shape.startY);
        ctx.lineTo(shape.startX, shape.endY);
        ctx.lineTo(shape.endX, shape.endY);
        ctx.closePath();
        if (shape.fill) ctx.fill();
        if (shape.stroke) ctx.stroke();
    }

    drawLine(ctx, shape) {
        ctx.beginPath();
        ctx.moveTo(shape.startX, shape.startY);
        ctx.lineTo(shape.endX, shape.endY);
        ctx.stroke();
    }

    drawSpline(ctx, shape) {
        if (shape.points.length < 2) return;
        ctx.beginPath();
        if (shape.points.length === 2) {
            ctx.moveTo(shape.points[0].x, shape.points[0].y);
            ctx.lineTo(shape.points[1].x, shape.points[1].y);
        } else {
            // Use the original points without offset
            this.drawSmoothSpline(shape.points, shape.curveIntensity, shape.closed, ctx);
        }
        if (shape.closed) ctx.closePath();
        if (shape.fill && shape.closed) ctx.fill();
        if (shape.stroke) ctx.stroke();
    }

    // Update drawSmoothSpline to accept ctx
    drawSmoothSpline(points, intensity, closed, ctx = this.ctx) {
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            const prev = points[i - 1];
            const curr = points[i];
            const next = points[(i + 1) % points.length];
            const cp1x = prev.x + (curr.x - prev.x) * intensity;
            const cp1y = prev.y + (curr.y - prev.y) * intensity;
            const cp2x = curr.x - (next.x - prev.x) * intensity * 0.2;
            const cp2y = curr.y - (next.y - prev.y) * intensity * 0.2;
            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, curr.x, curr.y);
        }
    }

    toJSON() {
        return {
            ...super.toJSON(),
            scale: this.scale,
            offsetX: this.offsetX,
            offsetY: this.offsetY,
            flipped: this.flipped,
            animationSpeed: this.animationSpeed,
            isPlaying: this.isPlaying,
            currentFrame: this.currentFrame,
            currentAnimation: this.currentAnimation
        };
    }

    fromJSON(data) {
        super.fromJSON(data);
        if (!data) return;

        this.scale = data.scale || 1;
        this.offsetX = data.offsetX || 0;
        this.offsetY = data.offsetY || 0;
        this.flipped = data.flipped || false;
        this.animationSpeed = data.animationSpeed || 1;
        this.isPlaying = data.isPlaying || false;
        this.currentFrame = data.currentFrame || 0;
        this.currentAnimation = data.currentAnimation || "idle";
        
        // Update animation range after loading
        this.currentAnimationRange = this.getCurrentAnimationRange();
    }
}

window.Car2 = Car2;

// Car3.js
class Car3 extends Module {
    static namespace = "Drawing";
    static description = "Custom generated drawing module";
    static allowMultiple = false;
    static iconClass = "fas fa-paint-brush";
    static iconColor = "#64B5F6";

    constructor() {
        super("Car3");

        // Visual properties
        this.scale = 1;
        this.offsetX = 0;
        this.offsetY = 0;
        this.flipped = false;

        this.animationRanges = [
        {
                "name": "idle",
                "start": 0,
                "end": 4
        }
];
        this.currentAnimation = "idle";
        
        // Animation properties
        this.isAnimated = false;
        this.currentFrame = 0;
        this.animationSpeed = 1;
        this.isPlaying = true;
        this.frameTimer = 0;
        this.pingPong = false;
        this.playDirection = 1;
        this.totalFrames = 1;
        this.enableTweening = false;
        this.tweenType = "linear";

        this.preGenerateImage = false;
        this.generatedImage = null;
        this.imageGenerated = false;
        
        // Frame data
        this.frames = [
        [
                {
                        "type": "rectangle",
                        "startX": 224,
                        "startY": 208,
                        "endX": 576,
                        "endY": 384,
                        "fillColor": "#3bf751",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 176,
                                "y": 208
                        },
                        "worldPosition": {
                                "x": 176,
                                "y": 208
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 304,
                        "startY": 240,
                        "endX": 496,
                        "endY": 352,
                        "fillColor": "#93ee81",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": false,
                                "start": "#c8d9f3",
                                "end": "#ffffff",
                                "type": "linear",
                                "angle": 0
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 304,
                                "y": 240
                        },
                        "worldPosition": {
                                "x": 304,
                                "y": 240
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 496,
                        "startY": 240,
                        "endX": 528,
                        "endY": 352,
                        "fillColor": "#81abee",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#c8d9f3",
                                "end": "#ffffff",
                                "type": "linear",
                                "angle": 0
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 496,
                                "y": 240
                        },
                        "worldPosition": {
                                "x": 496,
                                "y": 240
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 256,
                        "startY": 240,
                        "endX": 304,
                        "endY": 352,
                        "fillColor": "#81abee",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#c8d9f3",
                                "end": "#ffffff",
                                "type": "linear",
                                "angle": 0
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 256,
                                "y": 240
                        },
                        "worldPosition": {
                                "x": 256,
                                "y": 240
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 560,
                        "startY": 224,
                        "endX": 576,
                        "endY": 256,
                        "fillColor": "#ebe9cb",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 560,
                                "y": 224
                        },
                        "worldPosition": {
                                "x": 560,
                                "y": 224
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 560,
                        "startY": 368,
                        "endX": 576,
                        "endY": 336,
                        "fillColor": "#ebe9cb",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 560,
                                "y": 368
                        },
                        "worldPosition": {
                                "x": 560,
                                "y": 368
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 224,
                        "startY": 224,
                        "endX": 240,
                        "endY": 256,
                        "fillColor": "#c08c8c",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 224,
                                "y": 224
                        },
                        "worldPosition": {
                                "x": 224,
                                "y": 224
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 224,
                        "startY": 336,
                        "endX": 240,
                        "endY": 368,
                        "fillColor": "#c08c8c",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 224,
                                "y": 336
                        },
                        "worldPosition": {
                                "x": 224,
                                "y": 336
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                }
        ]
];
        
        // Initialize current animation range
        this.currentAnimationRange = this.getCurrentAnimationRange();
        
        this.exposeProperties();
    }

    getCurrentAnimationRange() {
        return this.animationRanges.find(r => r.name === this.currentAnimation) || 
               { name: "default", start: 0, end: this.totalFrames - 1 };
    }

    exposeProperties() {
        this.exposeProperty("scale", "number", this.scale, {
            description: "Scale factor",
            onChange: (val) => { this.scale = val; }
        });
        
        this.exposeProperty("offsetX", "number", this.offsetX, {
            description: "X offset",
            onChange: (val) => { this.offsetX = val; }
        });
        
        this.exposeProperty("offsetY", "number", this.offsetY, {
            description: "Y offset", 
            onChange: (val) => { this.offsetY = val; }
        });
        
        this.exposeProperty("flipped", "boolean", this.flipped, {
            description: "Flip horizontally",
            onChange: (val) => { this.flipped = val; }
        });

        this.exposeProperty("preGenerateImage", "boolean", this.preGenerateImage, {
            description: "Pre-generate image for better performance",
            onChange: (val) => { 
                this.preGenerateImage = val; 
                if (val) {
                    this.generateImage();
                } else {
                    this.generatedImage = null;
                    this.imageGenerated = false;
                }
            }
        });

        if (this.isAnimated) {
            this.exposeProperty("currentAnimation", "enum", this.currentAnimation, {
                options: this.animationRanges.map(r => r.name),
                description: "Current animation",
                onChange: (val) => {
                    this.setAnimation(val);
                }
            });

            this.exposeProperty("animationSpeed", "number", this.animationSpeed, {
                description: "Animation speed",
                onChange: (val) => { this.animationSpeed = val; }
            });
            
            this.exposeProperty("enableTweening", "boolean", this.enableTweening, {
                description: "Enable tweening for smooth transitions",
                onChange: (val) => { this.enableTweening = val; }
            });

            this.exposeProperty("tweenType", "enum", this.tweenType, {
                options: ["linear", "ease-in", "ease-out", "ease-in-out"],
                description: "Tweening type",
                onChange: (val) => { this.tweenType = val; }
            });
            
            this.exposeProperty("isPlaying", "boolean", this.isPlaying, {
                description: "Is playing animation",
                onChange: (val) => { this.isPlaying = val }
            });
        }
    }

    style(style) {
        style.startGroup("Car3 Appearance", false, { 
            backgroundColor: 'rgba(59,130,246,0.1)',
            borderRadius: '6px',
            padding: '8px'
        });
        
        style.exposeProperty("scale", "number", this.scale, {
            min: 0.1,
            max: 5,
            step: 0.1,
            style: { label: "Scale", slider: true }
        });
        
        style.exposeProperty("offsetX", "number", this.offsetX, {
            min: -200,
            max: 200,
            style: { label: "Offset X", slider: true }
        });
        
        style.exposeProperty("offsetY", "number", this.offsetY, {
            min: -200,
            max: 200,
            style: { label: "Offset Y", slider: true }
        });
        
        style.exposeProperty("flipped", "boolean", this.flipped, {
            style: { label: "Flip Horizontally" }
        });

        style.exposeProperty("preGenerateImage", "boolean", this.preGenerateImage, {
            style: { label: "Pre-generate Image" }
        });
        
        if (this.isAnimated) {
            style.startGroup("Animation Controls", true);

            style.exposeProperty("currentAnimation", "enum", this.currentAnimation, {
                options: this.animationRanges.map(r => r.name),
                style: { label: "Animation" }
            });
            
            style.exposeProperty("animationSpeed", "number", this.animationSpeed, {
                min: 0.1,
                max: 5,
                step: 0.1,
                style: { label: "Speed", slider: true }
            });

            style.exposeProperty("enableTweening", "boolean", this.enableTweening, {
                style: { label: "Enable Tweening" }
            });

            style.exposeProperty("tweenType", "enum", this.tweenType, {
                options: ["linear", "ease-in", "ease-out", "ease-in-out"],
                style: { label: "Tween Type" }
            });
            
            style.exposeProperty("isPlaying", "boolean", this.isPlaying, {
                style: { label: "Playing" }
            });
            
            style.endGroup();
        }
        
        style.endGroup();
        style.addHelpText("Generated drawing module with animation support");
        style.addHelpText(`Animation List: 
${this.animationRanges.map(r => `${r.name} (frames ${r.start}-${r.end})`).join(", ")}`);
    }

    // Public API Methods
    playAnimation(name) {
        const range = this.animationRanges.find(r => r.name === name);
        if (range) {
            this.currentAnimation = name;
            this.currentAnimationRange = range;
            this.currentFrame = range.start;
            this.isPlaying = true;
            this.frameTimer = 0;
            this.playDirection = 1;
        }
    }

    setAnimation(name) {
        const range = this.animationRanges.find(r => r.name === name);
        if (range) {
            this.currentAnimation = name;
            this.currentAnimationRange = range;
            this.currentFrame = range.start;
            this.isPlaying = false;
            this.frameTimer = 0;
            this.playDirection = 1;
        }
    }

    play() {
        this.isPlaying = true;
    }

    pause() {
        this.isPlaying = false;
    }

    stop() {
        this.isPlaying = false;
        const range = this.getCurrentAnimationRange();
        this.currentFrame = range.start;
        this.frameTimer = 0;
        this.playDirection = 1;
    }

    setFrame(frameIndex) {
        const range = this.getCurrentAnimationRange();
        if (frameIndex >= range.start && frameIndex <= range.end) {
            this.currentFrame = frameIndex;
        }
    }

    setSpeed(speed) {
        this.animationSpeed = Math.max(0.1, speed);
        return this;
    }

    getCurrentFrame() {
        return this.currentFrame;
    }

    getTotalFrames() {
        return this.totalFrames;
    }

    getAnimationFrameCount() {
        const range = this.getCurrentAnimationRange();
        return range.end - range.start + 1;
    }

    start() {
        if (this.preGenerateImage) {
            this.generateImage();
        }
        // Initialize to first frame of current animation
        const range = this.getCurrentAnimationRange();
        this.currentFrame = range.start;
    }

    loop(deltaTime) {
        if (!this.isAnimated || !this.isPlaying) return;

        const range = this.getCurrentAnimationRange();
        const frameCount = range.end - range.start + 1;

        // If only one frame in range, nothing to animate
        if (frameCount <= 1) {
            this.currentFrame = range.start;
            return;
        }

        this.frameTimer += deltaTime * this.animationSpeed;

        // Use frame duration of 0.1 seconds (10 FPS)
        const frameDuration = 0.1;
        
        if (this.frameTimer >= frameDuration) {
            this.frameTimer = 0;

            if (this.pingPong) {
                // Ping pong animation within the range
                this.currentFrame += this.playDirection;
                
                if (this.currentFrame >= range.end) {
                    this.playDirection = -1;
                    this.currentFrame = range.end;
                } else if (this.currentFrame <= range.start) {
                    this.playDirection = 1;
                    this.currentFrame = range.start;
                }
            } else {
                // Linear loop animation within the range
                this.currentFrame++;
                if (this.currentFrame > range.end) {
                    this.currentFrame = range.start;
                }
            }
        }
    }

    draw(ctx) {
        if (this.preGenerateImage && this.generatedImage && this.imageGenerated) {
            ctx.save();
            ctx.scale(this.scale, this.scale);
            if (this.flipped) {
                ctx.scale(-1, 1);
            }
            ctx.translate(this.offsetX, this.offsetY);
            
            ctx.drawImage(this.generatedImage, -this.generatedImage.width/2, -this.generatedImage.height/2);
            ctx.restore();
            return;
        }

        ctx.save();
        
        // Apply transformations
        ctx.scale(this.scale, this.scale);
        if (this.flipped) {
            ctx.scale(-1, 1);
        }
        ctx.translate(this.offsetX, this.offsetY);

        // Calculate the center point of all shapes to use as origin
        const shapeCenter = this.calculateShapesCenterPoint();
        
        // Translate so shapes center around 0,0
        ctx.translate(-shapeCenter.centerX, -shapeCenter.centerY);

        // Get current frame shapes
        let shapes;
        if (this.enableTweening && this.totalFrames > 1 && this.isPlaying) {
            shapes = this.getTweenedShapes();
        } else {
            const frameIndex = Math.floor(this.currentFrame);
            shapes = this.frames[frameIndex] || [];
        }
        shapes = shapes.filter(shape => shape && shape.visible !== false);

        shapes.forEach((shape, index) => {
            this.drawShape(ctx, shape);
        });

        ctx.restore();
    }

    getTweenedShapes() {
        const range = this.getCurrentAnimationRange();
        
        // Ensure current frame is within animation range for tweening
        let currentFrame = Math.floor(this.currentFrame);
        let nextFrame = currentFrame + 1;
        
        // Handle range boundaries
        if (nextFrame > range.end) {
            if (this.pingPong && this.playDirection === -1) {
                nextFrame = currentFrame - 1;
            } else {
                nextFrame = range.start; // Loop back to start
            }
        }
        
        // Ensure frames are valid
        currentFrame = Math.max(range.start, Math.min(range.end, currentFrame));
        nextFrame = Math.max(range.start, Math.min(range.end, nextFrame));
        
        const t = this.currentFrame - Math.floor(this.currentFrame);

        const currentShapes = this.frames[currentFrame] || [];
        const nextShapes = this.frames[nextFrame] || [];

        return this.interpolateShapes(currentShapes, nextShapes, t);
    }

    interpolateShapes(shapes1, shapes2, t) {
        const result = [];
        const maxLength = Math.max(shapes1.length, shapes2.length);

        for (let i = 0; i < maxLength; i++) {
            const shape1 = shapes1[i];
            const shape2 = shapes2[i];

            if (shape1 && shape2 && shape1.type === shape2.type) {
                result.push(this.interpolateShape(shape1, shape2, t));
            } else if (shape1) {
                result.push({ ...shape1 });
            } else if (shape2) {
                result.push({ ...shape2 });
            }
        }

        return result;
    }

    interpolateShape(shape1, shape2, t) {
        const eased = this.applyEasing(t, this.tweenType);
        const interpolated = { ...shape1 };

        // Interpolate basic properties
        if (shape1.type === 'spline') {
            interpolated.points = [];
            const maxPoints = Math.max(shape1.points.length, shape2.points.length);
            
            for (let i = 0; i < maxPoints; i++) {
                const p1 = shape1.points[i] || shape1.points[shape1.points.length - 1];
                const p2 = shape2.points[i] || shape2.points[shape2.points.length - 1];
                
                interpolated.points.push({
                    x: p1.x + (p2.x - p1.x) * eased,
                    y: p1.y + (p2.y - p1.y) * eased
                });
            }
        } else {
            interpolated.startX = shape1.startX + (shape2.startX - shape1.startX) * eased;
            interpolated.startY = shape1.startY + (shape2.startY - shape1.startY) * eased;
            interpolated.endX = shape1.endX + (shape2.endX - shape1.endX) * eased;
            interpolated.endY = shape1.endY + (shape2.endY - shape1.endY) * eased;
        }

        // Interpolate transform properties
        interpolated.rotation = (shape1.rotation || 0) + ((shape2.rotation || 0) - (shape1.rotation || 0)) * eased;
        interpolated.scaleX = (shape1.scaleX || 1) + ((shape2.scaleX || 1) - (shape1.scaleX || 1)) * eased;
        interpolated.scaleY = (shape1.scaleY || 1) + ((shape2.scaleY || 1) - (shape1.scaleY || 1)) * eased;

        return interpolated;
    }

    applyEasing(t, type) {
        switch (type) {
            case 'ease-in': return t * t;
            case 'ease-out': return 1 - (1 - t) * (1 - t);
            case 'ease-in-out': return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
            case 'bounce': return this.bounceEase(t);
            default: return t; // linear
        }
    }

    bounceEase(t) {
        const n1 = 7.5625;
        const d1 = 2.75;

        if (t < 1 / d1) {
            return n1 * t * t;
        } else if (t < 2 / d1) {
            return n1 * (t -= 1.5 / d1) * t + 0.75;
        } else if (t < 2.5 / d1) {
            return n1 * (t -= 2.25 / d1) * t + 0.9375;
        } else {
            return n1 * (t -= 2.625 / d1) * t + 0.984375;
        }
    }

    generateImage() {
        const canvas = document.createElement('canvas');
        canvas.width = 800;
        canvas.height = 600;
        const ctx = canvas.getContext('2d');
        
        // Calculate center point and translate
        const shapeCenter = this.calculateShapesCenterPoint();
        ctx.translate(canvas.width/2 - shapeCenter.centerX, canvas.height/2 - shapeCenter.centerY);
        
        // Draw all frames composited (or just frame 0 for static)
        const shapes = this.frames[0] || [];
        shapes.forEach((shape) => {
            this.drawShape(ctx, shape);
        });
        
        this.generatedImage = new Image();
        this.generatedImage.src = canvas.toDataURL();
        this.imageGenerated = true;
    }

    calculateShapesCenterPoint() {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        let hasShapes = false;

        this.frames.forEach(frame => {
            if (!frame) return;
            frame.forEach(shape => {
                hasShapes = true;
                if (shape.type === 'spline') {
                    shape.points.forEach(point => {
                        minX = Math.min(minX, point.x);
                        minY = Math.min(minY, point.y);
                        maxX = Math.max(maxX, point.x);
                        maxY = Math.max(maxY, point.y);
                    });
                } else if (shape.type === 'circle') {
                    const radius = Math.sqrt((shape.endX - shape.startX) ** 2 + (shape.endY - shape.startY) ** 2);
                    minX = Math.min(minX, shape.startX - radius);
                    minY = Math.min(minY, shape.startY - radius);
                    maxX = Math.max(maxX, shape.startX + radius);
                    maxY = Math.max(maxY, shape.startY + radius);
                } else {
                    minX = Math.min(minX, shape.startX, shape.endX);
                    minY = Math.min(minY, shape.startY, shape.endY);
                    maxX = Math.max(maxX, shape.startX, shape.endX);
                    maxY = Math.max(maxY, shape.startY, shape.endY);
                }
            });
        });

        if (!hasShapes) return { centerX: 0, centerY: 0 };
        
        return {
            centerX: (minX + maxX) / 2,
            centerY: (minY + maxY) / 2
        };
    }

    createGradient(shape, ctx) {
        if (!shape.gradient || !shape.gradient.enabled) return shape.fillColor;
        
        let gradient;
        const bounds = this.getShapeBounds(shape);
        
        if (shape.gradient.type === 'radial') {
            const centerX = bounds.x + bounds.width / 2;
            const centerY = bounds.y + bounds.height / 2;
            const radius = Math.max(bounds.width, bounds.height) / 2;
            gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
        } else {
            // Linear gradient
            const angle = (shape.gradient.angle || 0) * Math.PI / 180;
            const x1 = bounds.x + bounds.width / 2 - Math.cos(angle) * bounds.width / 2;
            const y1 = bounds.y + bounds.height / 2 - Math.sin(angle) * bounds.height / 2;
            const x2 = bounds.x + bounds.width / 2 + Math.cos(angle) * bounds.width / 2;
            const y2 = bounds.y + bounds.height / 2 + Math.sin(angle) * bounds.height / 2;
            gradient = ctx.createLinearGradient(x1, y1, x2, y2);
        }
        
        gradient.addColorStop(0, shape.gradient.start);
        gradient.addColorStop(1, shape.gradient.end);
        
        return gradient;
    }

    getShapeBounds(shape) {
        if (shape.type === 'spline') {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            shape.points.forEach(pt => {
                minX = Math.min(minX, pt.x);
                minY = Math.min(minY, pt.y);
                maxX = Math.max(maxX, pt.x);
                maxY = Math.max(maxY, pt.y);
            });
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        } else if (shape.type === 'circle') {
            const radius = Math.sqrt((shape.endX - shape.startX) ** 2 + (shape.endY - shape.startY) ** 2);
            return {
                x: shape.startX - radius,
                y: shape.startY - radius,
                width: radius * 2,
                height: radius * 2
            };
        } else {
            const minX = Math.min(shape.startX, shape.endX);
            const minY = Math.min(shape.startY, shape.endY);
            const maxX = Math.max(shape.startX, shape.endX);
            const maxY = Math.max(shape.startY, shape.endY);
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }
    }

    drawShape(ctx, shape) {
        if (!shape.visible) return;
        
        ctx.save();
        
        // Apply transformations
        if (shape.rotation || shape.scaleX !== 1 || shape.scaleY !== 1) {
            const bounds = this.getShapeBounds(shape);
            const centerX = bounds.x + bounds.width / 2;
            const centerY = bounds.y + bounds.height / 2;
            
            ctx.translate(centerX, centerY);
            ctx.rotate((shape.rotation || 0) * Math.PI / 180);
            ctx.scale(shape.scaleX || 1, shape.scaleY || 1);
            ctx.translate(-centerX, -centerY);
        }
        
        // Set up colors/gradients
        ctx.fillStyle = shape.gradient ? this.createGradient(shape, ctx) : shape.fillColor;
        ctx.strokeStyle = shape.strokeColor;
        ctx.lineWidth = shape.strokeWidth;
        ctx.setLineDash([]);

        switch (shape.type) {
            case 'rectangle':
                this.drawRectangle(ctx, shape);
                break;
            case 'circle':
                this.drawCircle(ctx, shape);
                break;
            case 'triangle':
                this.drawTriangle(ctx, shape);
                break;
            case 'line':
                this.drawLine(ctx, shape);
                break;
            case 'spline':
                this.drawSpline(ctx, shape);
                break;
        }

        ctx.restore();
    }

    drawRectangle(ctx, shape) {
        const width = shape.endX - shape.startX;
        const height = shape.endY - shape.startY;
        if (shape.fill) ctx.fillRect(shape.startX, shape.startY, width, height);
        if (shape.stroke) ctx.strokeRect(shape.startX, shape.startY, width, height);
    }

    drawCircle(ctx, shape) {
        const radius = Math.sqrt((shape.endX - shape.startX) ** 2 + (shape.endY - shape.startY) ** 2);
        ctx.beginPath();
        ctx.arc(shape.startX, shape.startY, radius, 0, Math.PI * 2);
        if (shape.fill) ctx.fill();
        if (shape.stroke) ctx.stroke();
    }

    drawTriangle(ctx, shape) {
        const midX = (shape.startX + shape.endX) / 2;
        ctx.beginPath();
        ctx.moveTo(midX, shape.startY);
        ctx.lineTo(shape.startX, shape.endY);
        ctx.lineTo(shape.endX, shape.endY);
        ctx.closePath();
        if (shape.fill) ctx.fill();
        if (shape.stroke) ctx.stroke();
    }

    drawLine(ctx, shape) {
        ctx.beginPath();
        ctx.moveTo(shape.startX, shape.startY);
        ctx.lineTo(shape.endX, shape.endY);
        ctx.stroke();
    }

    drawSpline(ctx, shape) {
        if (shape.points.length < 2) return;
        ctx.beginPath();
        if (shape.points.length === 2) {
            ctx.moveTo(shape.points[0].x, shape.points[0].y);
            ctx.lineTo(shape.points[1].x, shape.points[1].y);
        } else {
            // Use the original points without offset
            this.drawSmoothSpline(shape.points, shape.curveIntensity, shape.closed, ctx);
        }
        if (shape.closed) ctx.closePath();
        if (shape.fill && shape.closed) ctx.fill();
        if (shape.stroke) ctx.stroke();
    }

    // Update drawSmoothSpline to accept ctx
    drawSmoothSpline(points, intensity, closed, ctx = this.ctx) {
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            const prev = points[i - 1];
            const curr = points[i];
            const next = points[(i + 1) % points.length];
            const cp1x = prev.x + (curr.x - prev.x) * intensity;
            const cp1y = prev.y + (curr.y - prev.y) * intensity;
            const cp2x = curr.x - (next.x - prev.x) * intensity * 0.2;
            const cp2y = curr.y - (next.y - prev.y) * intensity * 0.2;
            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, curr.x, curr.y);
        }
    }

    toJSON() {
        return {
            ...super.toJSON(),
            scale: this.scale,
            offsetX: this.offsetX,
            offsetY: this.offsetY,
            flipped: this.flipped,
            animationSpeed: this.animationSpeed,
            isPlaying: this.isPlaying,
            currentFrame: this.currentFrame,
            currentAnimation: this.currentAnimation
        };
    }

    fromJSON(data) {
        super.fromJSON(data);
        if (!data) return;

        this.scale = data.scale || 1;
        this.offsetX = data.offsetX || 0;
        this.offsetY = data.offsetY || 0;
        this.flipped = data.flipped || false;
        this.animationSpeed = data.animationSpeed || 1;
        this.isPlaying = data.isPlaying || false;
        this.currentFrame = data.currentFrame || 0;
        this.currentAnimation = data.currentAnimation || "idle";
        
        // Update animation range after loading
        this.currentAnimationRange = this.getCurrentAnimationRange();
    }
}

window.Car3 = Car3;

// Car4.js
class Car4 extends Module {
    static namespace = "Drawing";
    static description = "Custom generated drawing module";
    static allowMultiple = false;
    static iconClass = "fas fa-paint-brush";
    static iconColor = "#64B5F6";

    constructor() {
        super("Car4");

        // Visual properties
        this.scale = 1;
        this.offsetX = 0;
        this.offsetY = 0;
        this.flipped = false;

        this.animationRanges = [
        {
                "name": "idle",
                "start": 0,
                "end": 4
        }
];
        this.currentAnimation = "idle";
        
        // Animation properties
        this.isAnimated = false;
        this.currentFrame = 0;
        this.animationSpeed = 1;
        this.isPlaying = true;
        this.frameTimer = 0;
        this.pingPong = false;
        this.playDirection = 1;
        this.totalFrames = 1;
        this.enableTweening = false;
        this.tweenType = "linear";

        this.preGenerateImage = false;
        this.generatedImage = null;
        this.imageGenerated = false;
        
        // Frame data
        this.frames = [
        [
                {
                        "type": "rectangle",
                        "startX": 224,
                        "startY": 208,
                        "endX": 576,
                        "endY": 384,
                        "fillColor": "#f73b3b",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 176,
                                "y": 208
                        },
                        "worldPosition": {
                                "x": 176,
                                "y": 208
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 304,
                        "startY": 240,
                        "endX": 496,
                        "endY": 352,
                        "fillColor": "#974444",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": false,
                                "start": "#c8d9f3",
                                "end": "#ffffff",
                                "type": "linear",
                                "angle": 0
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 304,
                                "y": 240
                        },
                        "worldPosition": {
                                "x": 304,
                                "y": 240
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 496,
                        "startY": 240,
                        "endX": 528,
                        "endY": 352,
                        "fillColor": "#81abee",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#c8d9f3",
                                "end": "#ffffff",
                                "type": "linear",
                                "angle": 0
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 496,
                                "y": 240
                        },
                        "worldPosition": {
                                "x": 496,
                                "y": 240
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 256,
                        "startY": 240,
                        "endX": 304,
                        "endY": 352,
                        "fillColor": "#81abee",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#c8d9f3",
                                "end": "#ffffff",
                                "type": "linear",
                                "angle": 0
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 256,
                                "y": 240
                        },
                        "worldPosition": {
                                "x": 256,
                                "y": 240
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 560,
                        "startY": 224,
                        "endX": 576,
                        "endY": 256,
                        "fillColor": "#ebe9cb",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 560,
                                "y": 224
                        },
                        "worldPosition": {
                                "x": 560,
                                "y": 224
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 560,
                        "startY": 368,
                        "endX": 576,
                        "endY": 336,
                        "fillColor": "#ebe9cb",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 560,
                                "y": 368
                        },
                        "worldPosition": {
                                "x": 560,
                                "y": 368
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 224,
                        "startY": 224,
                        "endX": 240,
                        "endY": 256,
                        "fillColor": "#c08c8c",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 224,
                                "y": 224
                        },
                        "worldPosition": {
                                "x": 224,
                                "y": 224
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 224,
                        "startY": 336,
                        "endX": 240,
                        "endY": 368,
                        "fillColor": "#c08c8c",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 224,
                                "y": 336
                        },
                        "worldPosition": {
                                "x": 224,
                                "y": 336
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                }
        ]
];
        
        // Initialize current animation range
        this.currentAnimationRange = this.getCurrentAnimationRange();
        
        this.exposeProperties();
    }

    getCurrentAnimationRange() {
        return this.animationRanges.find(r => r.name === this.currentAnimation) || 
               { name: "default", start: 0, end: this.totalFrames - 1 };
    }

    exposeProperties() {
        this.exposeProperty("scale", "number", this.scale, {
            description: "Scale factor",
            onChange: (val) => { this.scale = val; }
        });
        
        this.exposeProperty("offsetX", "number", this.offsetX, {
            description: "X offset",
            onChange: (val) => { this.offsetX = val; }
        });
        
        this.exposeProperty("offsetY", "number", this.offsetY, {
            description: "Y offset", 
            onChange: (val) => { this.offsetY = val; }
        });
        
        this.exposeProperty("flipped", "boolean", this.flipped, {
            description: "Flip horizontally",
            onChange: (val) => { this.flipped = val; }
        });

        this.exposeProperty("preGenerateImage", "boolean", this.preGenerateImage, {
            description: "Pre-generate image for better performance",
            onChange: (val) => { 
                this.preGenerateImage = val; 
                if (val) {
                    this.generateImage();
                } else {
                    this.generatedImage = null;
                    this.imageGenerated = false;
                }
            }
        });

        if (this.isAnimated) {
            this.exposeProperty("currentAnimation", "enum", this.currentAnimation, {
                options: this.animationRanges.map(r => r.name),
                description: "Current animation",
                onChange: (val) => {
                    this.setAnimation(val);
                }
            });

            this.exposeProperty("animationSpeed", "number", this.animationSpeed, {
                description: "Animation speed",
                onChange: (val) => { this.animationSpeed = val; }
            });
            
            this.exposeProperty("enableTweening", "boolean", this.enableTweening, {
                description: "Enable tweening for smooth transitions",
                onChange: (val) => { this.enableTweening = val; }
            });

            this.exposeProperty("tweenType", "enum", this.tweenType, {
                options: ["linear", "ease-in", "ease-out", "ease-in-out"],
                description: "Tweening type",
                onChange: (val) => { this.tweenType = val; }
            });
            
            this.exposeProperty("isPlaying", "boolean", this.isPlaying, {
                description: "Is playing animation",
                onChange: (val) => { this.isPlaying = val }
            });
        }
    }

    style(style) {
        style.startGroup("Car4 Appearance", false, { 
            backgroundColor: 'rgba(59,130,246,0.1)',
            borderRadius: '6px',
            padding: '8px'
        });
        
        style.exposeProperty("scale", "number", this.scale, {
            min: 0.1,
            max: 5,
            step: 0.1,
            style: { label: "Scale", slider: true }
        });
        
        style.exposeProperty("offsetX", "number", this.offsetX, {
            min: -200,
            max: 200,
            style: { label: "Offset X", slider: true }
        });
        
        style.exposeProperty("offsetY", "number", this.offsetY, {
            min: -200,
            max: 200,
            style: { label: "Offset Y", slider: true }
        });
        
        style.exposeProperty("flipped", "boolean", this.flipped, {
            style: { label: "Flip Horizontally" }
        });

        style.exposeProperty("preGenerateImage", "boolean", this.preGenerateImage, {
            style: { label: "Pre-generate Image" }
        });
        
        if (this.isAnimated) {
            style.startGroup("Animation Controls", true);

            style.exposeProperty("currentAnimation", "enum", this.currentAnimation, {
                options: this.animationRanges.map(r => r.name),
                style: { label: "Animation" }
            });
            
            style.exposeProperty("animationSpeed", "number", this.animationSpeed, {
                min: 0.1,
                max: 5,
                step: 0.1,
                style: { label: "Speed", slider: true }
            });

            style.exposeProperty("enableTweening", "boolean", this.enableTweening, {
                style: { label: "Enable Tweening" }
            });

            style.exposeProperty("tweenType", "enum", this.tweenType, {
                options: ["linear", "ease-in", "ease-out", "ease-in-out"],
                style: { label: "Tween Type" }
            });
            
            style.exposeProperty("isPlaying", "boolean", this.isPlaying, {
                style: { label: "Playing" }
            });
            
            style.endGroup();
        }
        
        style.endGroup();
        style.addHelpText("Generated drawing module with animation support");
        style.addHelpText(`Animation List: 
${this.animationRanges.map(r => `${r.name} (frames ${r.start}-${r.end})`).join(", ")}`);
    }

    // Public API Methods
    playAnimation(name) {
        const range = this.animationRanges.find(r => r.name === name);
        if (range) {
            this.currentAnimation = name;
            this.currentAnimationRange = range;
            this.currentFrame = range.start;
            this.isPlaying = true;
            this.frameTimer = 0;
            this.playDirection = 1;
        }
    }

    setAnimation(name) {
        const range = this.animationRanges.find(r => r.name === name);
        if (range) {
            this.currentAnimation = name;
            this.currentAnimationRange = range;
            this.currentFrame = range.start;
            this.isPlaying = false;
            this.frameTimer = 0;
            this.playDirection = 1;
        }
    }

    play() {
        this.isPlaying = true;
    }

    pause() {
        this.isPlaying = false;
    }

    stop() {
        this.isPlaying = false;
        const range = this.getCurrentAnimationRange();
        this.currentFrame = range.start;
        this.frameTimer = 0;
        this.playDirection = 1;
    }

    setFrame(frameIndex) {
        const range = this.getCurrentAnimationRange();
        if (frameIndex >= range.start && frameIndex <= range.end) {
            this.currentFrame = frameIndex;
        }
    }

    setSpeed(speed) {
        this.animationSpeed = Math.max(0.1, speed);
        return this;
    }

    getCurrentFrame() {
        return this.currentFrame;
    }

    getTotalFrames() {
        return this.totalFrames;
    }

    getAnimationFrameCount() {
        const range = this.getCurrentAnimationRange();
        return range.end - range.start + 1;
    }

    start() {
        if (this.preGenerateImage) {
            this.generateImage();
        }
        // Initialize to first frame of current animation
        const range = this.getCurrentAnimationRange();
        this.currentFrame = range.start;
    }

    loop(deltaTime) {
        if (!this.isAnimated || !this.isPlaying) return;

        const range = this.getCurrentAnimationRange();
        const frameCount = range.end - range.start + 1;

        // If only one frame in range, nothing to animate
        if (frameCount <= 1) {
            this.currentFrame = range.start;
            return;
        }

        this.frameTimer += deltaTime * this.animationSpeed;

        // Use frame duration of 0.1 seconds (10 FPS)
        const frameDuration = 0.1;
        
        if (this.frameTimer >= frameDuration) {
            this.frameTimer = 0;

            if (this.pingPong) {
                // Ping pong animation within the range
                this.currentFrame += this.playDirection;
                
                if (this.currentFrame >= range.end) {
                    this.playDirection = -1;
                    this.currentFrame = range.end;
                } else if (this.currentFrame <= range.start) {
                    this.playDirection = 1;
                    this.currentFrame = range.start;
                }
            } else {
                // Linear loop animation within the range
                this.currentFrame++;
                if (this.currentFrame > range.end) {
                    this.currentFrame = range.start;
                }
            }
        }
    }

    draw(ctx) {
        if (this.preGenerateImage && this.generatedImage && this.imageGenerated) {
            ctx.save();
            ctx.scale(this.scale, this.scale);
            if (this.flipped) {
                ctx.scale(-1, 1);
            }
            ctx.translate(this.offsetX, this.offsetY);
            
            ctx.drawImage(this.generatedImage, -this.generatedImage.width/2, -this.generatedImage.height/2);
            ctx.restore();
            return;
        }

        ctx.save();
        
        // Apply transformations
        ctx.scale(this.scale, this.scale);
        if (this.flipped) {
            ctx.scale(-1, 1);
        }
        ctx.translate(this.offsetX, this.offsetY);

        // Calculate the center point of all shapes to use as origin
        const shapeCenter = this.calculateShapesCenterPoint();
        
        // Translate so shapes center around 0,0
        ctx.translate(-shapeCenter.centerX, -shapeCenter.centerY);

        // Get current frame shapes
        let shapes;
        if (this.enableTweening && this.totalFrames > 1 && this.isPlaying) {
            shapes = this.getTweenedShapes();
        } else {
            const frameIndex = Math.floor(this.currentFrame);
            shapes = this.frames[frameIndex] || [];
        }
        shapes = shapes.filter(shape => shape && shape.visible !== false);

        shapes.forEach((shape, index) => {
            this.drawShape(ctx, shape);
        });

        ctx.restore();
    }

    getTweenedShapes() {
        const range = this.getCurrentAnimationRange();
        
        // Ensure current frame is within animation range for tweening
        let currentFrame = Math.floor(this.currentFrame);
        let nextFrame = currentFrame + 1;
        
        // Handle range boundaries
        if (nextFrame > range.end) {
            if (this.pingPong && this.playDirection === -1) {
                nextFrame = currentFrame - 1;
            } else {
                nextFrame = range.start; // Loop back to start
            }
        }
        
        // Ensure frames are valid
        currentFrame = Math.max(range.start, Math.min(range.end, currentFrame));
        nextFrame = Math.max(range.start, Math.min(range.end, nextFrame));
        
        const t = this.currentFrame - Math.floor(this.currentFrame);

        const currentShapes = this.frames[currentFrame] || [];
        const nextShapes = this.frames[nextFrame] || [];

        return this.interpolateShapes(currentShapes, nextShapes, t);
    }

    interpolateShapes(shapes1, shapes2, t) {
        const result = [];
        const maxLength = Math.max(shapes1.length, shapes2.length);

        for (let i = 0; i < maxLength; i++) {
            const shape1 = shapes1[i];
            const shape2 = shapes2[i];

            if (shape1 && shape2 && shape1.type === shape2.type) {
                result.push(this.interpolateShape(shape1, shape2, t));
            } else if (shape1) {
                result.push({ ...shape1 });
            } else if (shape2) {
                result.push({ ...shape2 });
            }
        }

        return result;
    }

    interpolateShape(shape1, shape2, t) {
        const eased = this.applyEasing(t, this.tweenType);
        const interpolated = { ...shape1 };

        // Interpolate basic properties
        if (shape1.type === 'spline') {
            interpolated.points = [];
            const maxPoints = Math.max(shape1.points.length, shape2.points.length);
            
            for (let i = 0; i < maxPoints; i++) {
                const p1 = shape1.points[i] || shape1.points[shape1.points.length - 1];
                const p2 = shape2.points[i] || shape2.points[shape2.points.length - 1];
                
                interpolated.points.push({
                    x: p1.x + (p2.x - p1.x) * eased,
                    y: p1.y + (p2.y - p1.y) * eased
                });
            }
        } else {
            interpolated.startX = shape1.startX + (shape2.startX - shape1.startX) * eased;
            interpolated.startY = shape1.startY + (shape2.startY - shape1.startY) * eased;
            interpolated.endX = shape1.endX + (shape2.endX - shape1.endX) * eased;
            interpolated.endY = shape1.endY + (shape2.endY - shape1.endY) * eased;
        }

        // Interpolate transform properties
        interpolated.rotation = (shape1.rotation || 0) + ((shape2.rotation || 0) - (shape1.rotation || 0)) * eased;
        interpolated.scaleX = (shape1.scaleX || 1) + ((shape2.scaleX || 1) - (shape1.scaleX || 1)) * eased;
        interpolated.scaleY = (shape1.scaleY || 1) + ((shape2.scaleY || 1) - (shape1.scaleY || 1)) * eased;

        return interpolated;
    }

    applyEasing(t, type) {
        switch (type) {
            case 'ease-in': return t * t;
            case 'ease-out': return 1 - (1 - t) * (1 - t);
            case 'ease-in-out': return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
            case 'bounce': return this.bounceEase(t);
            default: return t; // linear
        }
    }

    bounceEase(t) {
        const n1 = 7.5625;
        const d1 = 2.75;

        if (t < 1 / d1) {
            return n1 * t * t;
        } else if (t < 2 / d1) {
            return n1 * (t -= 1.5 / d1) * t + 0.75;
        } else if (t < 2.5 / d1) {
            return n1 * (t -= 2.25 / d1) * t + 0.9375;
        } else {
            return n1 * (t -= 2.625 / d1) * t + 0.984375;
        }
    }

    generateImage() {
        const canvas = document.createElement('canvas');
        canvas.width = 800;
        canvas.height = 600;
        const ctx = canvas.getContext('2d');
        
        // Calculate center point and translate
        const shapeCenter = this.calculateShapesCenterPoint();
        ctx.translate(canvas.width/2 - shapeCenter.centerX, canvas.height/2 - shapeCenter.centerY);
        
        // Draw all frames composited (or just frame 0 for static)
        const shapes = this.frames[0] || [];
        shapes.forEach((shape) => {
            this.drawShape(ctx, shape);
        });
        
        this.generatedImage = new Image();
        this.generatedImage.src = canvas.toDataURL();
        this.imageGenerated = true;
    }

    calculateShapesCenterPoint() {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        let hasShapes = false;

        this.frames.forEach(frame => {
            if (!frame) return;
            frame.forEach(shape => {
                hasShapes = true;
                if (shape.type === 'spline') {
                    shape.points.forEach(point => {
                        minX = Math.min(minX, point.x);
                        minY = Math.min(minY, point.y);
                        maxX = Math.max(maxX, point.x);
                        maxY = Math.max(maxY, point.y);
                    });
                } else if (shape.type === 'circle') {
                    const radius = Math.sqrt((shape.endX - shape.startX) ** 2 + (shape.endY - shape.startY) ** 2);
                    minX = Math.min(minX, shape.startX - radius);
                    minY = Math.min(minY, shape.startY - radius);
                    maxX = Math.max(maxX, shape.startX + radius);
                    maxY = Math.max(maxY, shape.startY + radius);
                } else {
                    minX = Math.min(minX, shape.startX, shape.endX);
                    minY = Math.min(minY, shape.startY, shape.endY);
                    maxX = Math.max(maxX, shape.startX, shape.endX);
                    maxY = Math.max(maxY, shape.startY, shape.endY);
                }
            });
        });

        if (!hasShapes) return { centerX: 0, centerY: 0 };
        
        return {
            centerX: (minX + maxX) / 2,
            centerY: (minY + maxY) / 2
        };
    }

    createGradient(shape, ctx) {
        if (!shape.gradient || !shape.gradient.enabled) return shape.fillColor;
        
        let gradient;
        const bounds = this.getShapeBounds(shape);
        
        if (shape.gradient.type === 'radial') {
            const centerX = bounds.x + bounds.width / 2;
            const centerY = bounds.y + bounds.height / 2;
            const radius = Math.max(bounds.width, bounds.height) / 2;
            gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
        } else {
            // Linear gradient
            const angle = (shape.gradient.angle || 0) * Math.PI / 180;
            const x1 = bounds.x + bounds.width / 2 - Math.cos(angle) * bounds.width / 2;
            const y1 = bounds.y + bounds.height / 2 - Math.sin(angle) * bounds.height / 2;
            const x2 = bounds.x + bounds.width / 2 + Math.cos(angle) * bounds.width / 2;
            const y2 = bounds.y + bounds.height / 2 + Math.sin(angle) * bounds.height / 2;
            gradient = ctx.createLinearGradient(x1, y1, x2, y2);
        }
        
        gradient.addColorStop(0, shape.gradient.start);
        gradient.addColorStop(1, shape.gradient.end);
        
        return gradient;
    }

    getShapeBounds(shape) {
        if (shape.type === 'spline') {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            shape.points.forEach(pt => {
                minX = Math.min(minX, pt.x);
                minY = Math.min(minY, pt.y);
                maxX = Math.max(maxX, pt.x);
                maxY = Math.max(maxY, pt.y);
            });
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        } else if (shape.type === 'circle') {
            const radius = Math.sqrt((shape.endX - shape.startX) ** 2 + (shape.endY - shape.startY) ** 2);
            return {
                x: shape.startX - radius,
                y: shape.startY - radius,
                width: radius * 2,
                height: radius * 2
            };
        } else {
            const minX = Math.min(shape.startX, shape.endX);
            const minY = Math.min(shape.startY, shape.endY);
            const maxX = Math.max(shape.startX, shape.endX);
            const maxY = Math.max(shape.startY, shape.endY);
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }
    }

    drawShape(ctx, shape) {
        if (!shape.visible) return;
        
        ctx.save();
        
        // Apply transformations
        if (shape.rotation || shape.scaleX !== 1 || shape.scaleY !== 1) {
            const bounds = this.getShapeBounds(shape);
            const centerX = bounds.x + bounds.width / 2;
            const centerY = bounds.y + bounds.height / 2;
            
            ctx.translate(centerX, centerY);
            ctx.rotate((shape.rotation || 0) * Math.PI / 180);
            ctx.scale(shape.scaleX || 1, shape.scaleY || 1);
            ctx.translate(-centerX, -centerY);
        }
        
        // Set up colors/gradients
        ctx.fillStyle = shape.gradient ? this.createGradient(shape, ctx) : shape.fillColor;
        ctx.strokeStyle = shape.strokeColor;
        ctx.lineWidth = shape.strokeWidth;
        ctx.setLineDash([]);

        switch (shape.type) {
            case 'rectangle':
                this.drawRectangle(ctx, shape);
                break;
            case 'circle':
                this.drawCircle(ctx, shape);
                break;
            case 'triangle':
                this.drawTriangle(ctx, shape);
                break;
            case 'line':
                this.drawLine(ctx, shape);
                break;
            case 'spline':
                this.drawSpline(ctx, shape);
                break;
        }

        ctx.restore();
    }

    drawRectangle(ctx, shape) {
        const width = shape.endX - shape.startX;
        const height = shape.endY - shape.startY;
        if (shape.fill) ctx.fillRect(shape.startX, shape.startY, width, height);
        if (shape.stroke) ctx.strokeRect(shape.startX, shape.startY, width, height);
    }

    drawCircle(ctx, shape) {
        const radius = Math.sqrt((shape.endX - shape.startX) ** 2 + (shape.endY - shape.startY) ** 2);
        ctx.beginPath();
        ctx.arc(shape.startX, shape.startY, radius, 0, Math.PI * 2);
        if (shape.fill) ctx.fill();
        if (shape.stroke) ctx.stroke();
    }

    drawTriangle(ctx, shape) {
        const midX = (shape.startX + shape.endX) / 2;
        ctx.beginPath();
        ctx.moveTo(midX, shape.startY);
        ctx.lineTo(shape.startX, shape.endY);
        ctx.lineTo(shape.endX, shape.endY);
        ctx.closePath();
        if (shape.fill) ctx.fill();
        if (shape.stroke) ctx.stroke();
    }

    drawLine(ctx, shape) {
        ctx.beginPath();
        ctx.moveTo(shape.startX, shape.startY);
        ctx.lineTo(shape.endX, shape.endY);
        ctx.stroke();
    }

    drawSpline(ctx, shape) {
        if (shape.points.length < 2) return;
        ctx.beginPath();
        if (shape.points.length === 2) {
            ctx.moveTo(shape.points[0].x, shape.points[0].y);
            ctx.lineTo(shape.points[1].x, shape.points[1].y);
        } else {
            // Use the original points without offset
            this.drawSmoothSpline(shape.points, shape.curveIntensity, shape.closed, ctx);
        }
        if (shape.closed) ctx.closePath();
        if (shape.fill && shape.closed) ctx.fill();
        if (shape.stroke) ctx.stroke();
    }

    // Update drawSmoothSpline to accept ctx
    drawSmoothSpline(points, intensity, closed, ctx = this.ctx) {
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            const prev = points[i - 1];
            const curr = points[i];
            const next = points[(i + 1) % points.length];
            const cp1x = prev.x + (curr.x - prev.x) * intensity;
            const cp1y = prev.y + (curr.y - prev.y) * intensity;
            const cp2x = curr.x - (next.x - prev.x) * intensity * 0.2;
            const cp2y = curr.y - (next.y - prev.y) * intensity * 0.2;
            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, curr.x, curr.y);
        }
    }

    toJSON() {
        return {
            ...super.toJSON(),
            scale: this.scale,
            offsetX: this.offsetX,
            offsetY: this.offsetY,
            flipped: this.flipped,
            animationSpeed: this.animationSpeed,
            isPlaying: this.isPlaying,
            currentFrame: this.currentFrame,
            currentAnimation: this.currentAnimation
        };
    }

    fromJSON(data) {
        super.fromJSON(data);
        if (!data) return;

        this.scale = data.scale || 1;
        this.offsetX = data.offsetX || 0;
        this.offsetY = data.offsetY || 0;
        this.flipped = data.flipped || false;
        this.animationSpeed = data.animationSpeed || 1;
        this.isPlaying = data.isPlaying || false;
        this.currentFrame = data.currentFrame || 0;
        this.currentAnimation = data.currentAnimation || "idle";
        
        // Update animation range after loading
        this.currentAnimationRange = this.getCurrentAnimationRange();
    }
}

window.Car4 = Car4;

// CustomDrawing.js
class CustomDrawing extends Module {
    static namespace = "Drawing";
    static description = "Custom generated drawing module";
    static allowMultiple = false;
    static iconClass = "fas fa-paint-brush";
    static iconColor = "#64B5F6";

    constructor() {
        super("CustomDrawing");

        // Visual properties
        this.scale = 1;
        this.offsetX = 0;
        this.offsetY = 0;
        this.flipped = false;

        this.animationRanges = [
        {
                "name": "idle",
                "start": 0,
                "end": 4
        }
];
        this.currentAnimation = "idle";
        
        // Animation properties
        this.isAnimated = false;
        this.currentFrame = 0;
        this.animationSpeed = 1;
        this.isPlaying = true;
        this.frameTimer = 0;
        this.pingPong = false;
        this.playDirection = 1;
        this.totalFrames = 1;
        this.enableTweening = false;
        this.tweenType = "linear";

        this.preGenerateImage = false;
        this.generatedImage = null;
        this.imageGenerated = false;
        
        // Frame data
        this.frames = [
        [
                {
                        "type": "rectangle",
                        "startX": 224,
                        "startY": 208,
                        "endX": 576,
                        "endY": 384,
                        "fillColor": "#3b82f6",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#3b82f6",
                                "end": "#7176bc",
                                "type": "linear",
                                "angle": 87
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 176,
                                "y": 208
                        },
                        "worldPosition": {
                                "x": 176,
                                "y": 208
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 336,
                        "startY": 240,
                        "endX": 480,
                        "endY": 352,
                        "fillColor": "#81abee",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#81abef",
                                "end": "#71bc9b",
                                "type": "linear",
                                "angle": 91
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 304,
                                "y": 240
                        },
                        "worldPosition": {
                                "x": 304,
                                "y": 240
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 480,
                        "startY": 240,
                        "endX": 528,
                        "endY": 352,
                        "fillColor": "#81abee",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#c8d9f3",
                                "end": "#ffffff",
                                "type": "linear",
                                "angle": 0
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 496,
                                "y": 240
                        },
                        "worldPosition": {
                                "x": 496,
                                "y": 240
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 256,
                        "startY": 240,
                        "endX": 336,
                        "endY": 352,
                        "fillColor": "#81abee",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#c8d9f3",
                                "end": "#ffffff",
                                "type": "linear",
                                "angle": 0
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 256,
                                "y": 240
                        },
                        "worldPosition": {
                                "x": 256,
                                "y": 240
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 560,
                        "startY": 224,
                        "endX": 576,
                        "endY": 256,
                        "fillColor": "#efdf0b",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 560,
                                "y": 224
                        },
                        "worldPosition": {
                                "x": 560,
                                "y": 224
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 560,
                        "startY": 368,
                        "endX": 576,
                        "endY": 336,
                        "fillColor": "#e3d40d",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 560,
                                "y": 368
                        },
                        "worldPosition": {
                                "x": 560,
                                "y": 368
                        },
                        "rotationHotspot": {
                                "x": 8,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 224,
                        "startY": 224,
                        "endX": 240,
                        "endY": 256,
                        "fillColor": "#ff0000",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 224,
                                "y": 224
                        },
                        "worldPosition": {
                                "x": 224,
                                "y": 224
                        },
                        "rotationHotspot": {
                                "x": 8,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 224,
                        "startY": 336,
                        "endX": 240,
                        "endY": 368,
                        "fillColor": "#ff0000",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 224,
                                "y": 336
                        },
                        "worldPosition": {
                                "x": 224,
                                "y": 336
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 176,
                        "startY": 224,
                        "endX": 208,
                        "endY": 368,
                        "fillColor": "#ff0000",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#81abef",
                                "end": "#71bc9b",
                                "type": "linear",
                                "angle": 91
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 208,
                                "y": 256
                        },
                        "worldPosition": {
                                "x": 208,
                                "y": 256
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                },
                {
                        "type": "rectangle",
                        "startX": 208,
                        "startY": 272,
                        "endX": 240,
                        "endY": 288,
                        "fillColor": "#ff0000",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#81abef",
                                "end": "#71bc9b",
                                "type": "linear",
                                "angle": 91
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 208,
                                "y": 272
                        },
                        "worldPosition": {
                                "x": 208,
                                "y": 272
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                },
                {
                        "type": "rectangle",
                        "startX": 208,
                        "startY": 320,
                        "endX": 240,
                        "endY": 304,
                        "fillColor": "#ff0000",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#81abef",
                                "end": "#71bc9b",
                                "type": "linear",
                                "angle": 91
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 208,
                                "y": 320
                        },
                        "worldPosition": {
                                "x": 208,
                                "y": 320
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                }
        ]
];
        
        // Initialize current animation range
        this.currentAnimationRange = this.getCurrentAnimationRange();
        
        this.exposeProperties();
    }

    getCurrentAnimationRange() {
        return this.animationRanges.find(r => r.name === this.currentAnimation) || 
               { name: "default", start: 0, end: this.totalFrames - 1 };
    }

    exposeProperties() {
        this.exposeProperty("scale", "number", this.scale, {
            description: "Scale factor",
            onChange: (val) => { this.scale = val; }
        });
        
        this.exposeProperty("offsetX", "number", this.offsetX, {
            description: "X offset",
            onChange: (val) => { this.offsetX = val; }
        });
        
        this.exposeProperty("offsetY", "number", this.offsetY, {
            description: "Y offset", 
            onChange: (val) => { this.offsetY = val; }
        });
        
        this.exposeProperty("flipped", "boolean", this.flipped, {
            description: "Flip horizontally",
            onChange: (val) => { this.flipped = val; }
        });

        this.exposeProperty("preGenerateImage", "boolean", this.preGenerateImage, {
            description: "Pre-generate image for better performance",
            onChange: (val) => { 
                this.preGenerateImage = val; 
                if (val) {
                    this.generateImage();
                } else {
                    this.generatedImage = null;
                    this.imageGenerated = false;
                }
            }
        });

        if (this.isAnimated) {
            this.exposeProperty("currentAnimation", "enum", this.currentAnimation, {
                options: this.animationRanges.map(r => r.name),
                description: "Current animation",
                onChange: (val) => {
                    this.setAnimation(val);
                }
            });

            this.exposeProperty("animationSpeed", "number", this.animationSpeed, {
                description: "Animation speed",
                onChange: (val) => { this.animationSpeed = val; }
            });
            
            this.exposeProperty("enableTweening", "boolean", this.enableTweening, {
                description: "Enable tweening for smooth transitions",
                onChange: (val) => { this.enableTweening = val; }
            });

            this.exposeProperty("tweenType", "enum", this.tweenType, {
                options: ["linear", "ease-in", "ease-out", "ease-in-out"],
                description: "Tweening type",
                onChange: (val) => { this.tweenType = val; }
            });
            
            this.exposeProperty("isPlaying", "boolean", this.isPlaying, {
                description: "Is playing animation",
                onChange: (val) => { this.isPlaying = val }
            });
        }
    }

    style(style) {
        style.startGroup("CustomDrawing Appearance", false, { 
            backgroundColor: 'rgba(59,130,246,0.1)',
            borderRadius: '6px',
            padding: '8px'
        });
        
        style.exposeProperty("scale", "number", this.scale, {
            min: 0.1,
            max: 5,
            step: 0.1,
            style: { label: "Scale", slider: true }
        });
        
        style.exposeProperty("offsetX", "number", this.offsetX, {
            min: -200,
            max: 200,
            style: { label: "Offset X", slider: true }
        });
        
        style.exposeProperty("offsetY", "number", this.offsetY, {
            min: -200,
            max: 200,
            style: { label: "Offset Y", slider: true }
        });
        
        style.exposeProperty("flipped", "boolean", this.flipped, {
            style: { label: "Flip Horizontally" }
        });

        style.exposeProperty("preGenerateImage", "boolean", this.preGenerateImage, {
            style: { label: "Pre-generate Image" }
        });
        
        if (this.isAnimated) {
            style.startGroup("Animation Controls", true);

            style.exposeProperty("currentAnimation", "enum", this.currentAnimation, {
                options: this.animationRanges.map(r => r.name),
                style: { label: "Animation" }
            });
            
            style.exposeProperty("animationSpeed", "number", this.animationSpeed, {
                min: 0.1,
                max: 5,
                step: 0.1,
                style: { label: "Speed", slider: true }
            });

            style.exposeProperty("enableTweening", "boolean", this.enableTweening, {
                style: { label: "Enable Tweening" }
            });

            style.exposeProperty("tweenType", "enum", this.tweenType, {
                options: ["linear", "ease-in", "ease-out", "ease-in-out"],
                style: { label: "Tween Type" }
            });
            
            style.exposeProperty("isPlaying", "boolean", this.isPlaying, {
                style: { label: "Playing" }
            });
            
            style.endGroup();
        }
        
        style.endGroup();
        style.addHelpText("Generated drawing module with animation support");
        style.addHelpText(`Animation List: 
${this.animationRanges.map(r => `${r.name} (frames ${r.start}-${r.end})`).join(", ")}`);
    }

    // Public API Methods
    playAnimation(name) {
        const range = this.animationRanges.find(r => r.name === name);
        if (range) {
            this.currentAnimation = name;
            this.currentAnimationRange = range;
            this.currentFrame = range.start;
            this.isPlaying = true;
            this.frameTimer = 0;
            this.playDirection = 1;
        }
    }

    setAnimation(name) {
        const range = this.animationRanges.find(r => r.name === name);
        if (range) {
            this.currentAnimation = name;
            this.currentAnimationRange = range;
            this.currentFrame = range.start;
            this.isPlaying = false;
            this.frameTimer = 0;
            this.playDirection = 1;
        }
    }

    play() {
        this.isPlaying = true;
    }

    pause() {
        this.isPlaying = false;
    }

    stop() {
        this.isPlaying = false;
        const range = this.getCurrentAnimationRange();
        this.currentFrame = range.start;
        this.frameTimer = 0;
        this.playDirection = 1;
    }

    setFrame(frameIndex) {
        const range = this.getCurrentAnimationRange();
        if (frameIndex >= range.start && frameIndex <= range.end) {
            this.currentFrame = frameIndex;
        }
    }

    setSpeed(speed) {
        this.animationSpeed = Math.max(0.1, speed);
        return this;
    }

    getCurrentFrame() {
        return this.currentFrame;
    }

    getTotalFrames() {
        return this.totalFrames;
    }

    getAnimationFrameCount() {
        const range = this.getCurrentAnimationRange();
        return range.end - range.start + 1;
    }

    start() {
        if (this.preGenerateImage) {
            this.generateImage();
        }
        // Initialize to first frame of current animation
        const range = this.getCurrentAnimationRange();
        this.currentFrame = range.start;
    }

    loop(deltaTime) {
        if (!this.isAnimated || !this.isPlaying) return;

        const range = this.getCurrentAnimationRange();
        const frameCount = range.end - range.start + 1;

        // If only one frame in range, nothing to animate
        if (frameCount <= 1) {
            this.currentFrame = range.start;
            return;
        }

        this.frameTimer += deltaTime * this.animationSpeed;

        // Use frame duration of 0.1 seconds (10 FPS)
        const frameDuration = 0.1;
        
        if (this.frameTimer >= frameDuration) {
            this.frameTimer = 0;

            if (this.pingPong) {
                // Ping pong animation within the range
                this.currentFrame += this.playDirection;
                
                if (this.currentFrame >= range.end) {
                    this.playDirection = -1;
                    this.currentFrame = range.end;
                } else if (this.currentFrame <= range.start) {
                    this.playDirection = 1;
                    this.currentFrame = range.start;
                }
            } else {
                // Linear loop animation within the range
                this.currentFrame++;
                if (this.currentFrame > range.end) {
                    this.currentFrame = range.start;
                }
            }
        }
    }

    draw(ctx) {
        if (this.preGenerateImage && this.generatedImage && this.imageGenerated) {
            ctx.save();
            ctx.scale(this.scale, this.scale);
            if (this.flipped) {
                ctx.scale(-1, 1);
            }
            ctx.translate(this.offsetX, this.offsetY);
            
            ctx.drawImage(this.generatedImage, -this.generatedImage.width/2, -this.generatedImage.height/2);
            ctx.restore();
            return;
        }

        ctx.save();
        
        // Apply transformations
        ctx.scale(this.scale, this.scale);
        if (this.flipped) {
            ctx.scale(-1, 1);
        }
        ctx.translate(this.offsetX, this.offsetY);

        // Calculate the center point of all shapes to use as origin
        const shapeCenter = this.calculateShapesCenterPoint();
        
        // Translate so shapes center around 0,0
        ctx.translate(-shapeCenter.centerX, -shapeCenter.centerY);

        // Get current frame shapes
        let shapes;
        if (this.enableTweening && this.totalFrames > 1 && this.isPlaying) {
            shapes = this.getTweenedShapes();
        } else {
            const frameIndex = Math.floor(this.currentFrame);
            shapes = this.frames[frameIndex] || [];
        }
        shapes = shapes.filter(shape => shape && shape.visible !== false);

        shapes.forEach((shape, index) => {
            this.drawShape(ctx, shape);
        });

        ctx.restore();
    }

    getTweenedShapes() {
        const range = this.getCurrentAnimationRange();
        
        // Ensure current frame is within animation range for tweening
        let currentFrame = Math.floor(this.currentFrame);
        let nextFrame = currentFrame + 1;
        
        // Handle range boundaries
        if (nextFrame > range.end) {
            if (this.pingPong && this.playDirection === -1) {
                nextFrame = currentFrame - 1;
            } else {
                nextFrame = range.start; // Loop back to start
            }
        }
        
        // Ensure frames are valid
        currentFrame = Math.max(range.start, Math.min(range.end, currentFrame));
        nextFrame = Math.max(range.start, Math.min(range.end, nextFrame));
        
        const t = this.currentFrame - Math.floor(this.currentFrame);

        const currentShapes = this.frames[currentFrame] || [];
        const nextShapes = this.frames[nextFrame] || [];

        return this.interpolateShapes(currentShapes, nextShapes, t);
    }

    interpolateShapes(shapes1, shapes2, t) {
        const result = [];
        const maxLength = Math.max(shapes1.length, shapes2.length);

        for (let i = 0; i < maxLength; i++) {
            const shape1 = shapes1[i];
            const shape2 = shapes2[i];

            if (shape1 && shape2 && shape1.type === shape2.type) {
                result.push(this.interpolateShape(shape1, shape2, t));
            } else if (shape1) {
                result.push({ ...shape1 });
            } else if (shape2) {
                result.push({ ...shape2 });
            }
        }

        return result;
    }

    interpolateShape(shape1, shape2, t) {
        const eased = this.applyEasing(t, this.tweenType);
        const interpolated = { ...shape1 };

        // Interpolate basic properties
        if (shape1.type === 'spline') {
            interpolated.points = [];
            const maxPoints = Math.max(shape1.points.length, shape2.points.length);
            
            for (let i = 0; i < maxPoints; i++) {
                const p1 = shape1.points[i] || shape1.points[shape1.points.length - 1];
                const p2 = shape2.points[i] || shape2.points[shape2.points.length - 1];
                
                interpolated.points.push({
                    x: p1.x + (p2.x - p1.x) * eased,
                    y: p1.y + (p2.y - p1.y) * eased
                });
            }
        } else {
            interpolated.startX = shape1.startX + (shape2.startX - shape1.startX) * eased;
            interpolated.startY = shape1.startY + (shape2.startY - shape1.startY) * eased;
            interpolated.endX = shape1.endX + (shape2.endX - shape1.endX) * eased;
            interpolated.endY = shape1.endY + (shape2.endY - shape1.endY) * eased;
        }

        // Interpolate transform properties
        interpolated.rotation = (shape1.rotation || 0) + ((shape2.rotation || 0) - (shape1.rotation || 0)) * eased;
        interpolated.scaleX = (shape1.scaleX || 1) + ((shape2.scaleX || 1) - (shape1.scaleX || 1)) * eased;
        interpolated.scaleY = (shape1.scaleY || 1) + ((shape2.scaleY || 1) - (shape1.scaleY || 1)) * eased;

        return interpolated;
    }

    applyEasing(t, type) {
        switch (type) {
            case 'ease-in': return t * t;
            case 'ease-out': return 1 - (1 - t) * (1 - t);
            case 'ease-in-out': return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
            case 'bounce': return this.bounceEase(t);
            default: return t; // linear
        }
    }

    bounceEase(t) {
        const n1 = 7.5625;
        const d1 = 2.75;

        if (t < 1 / d1) {
            return n1 * t * t;
        } else if (t < 2 / d1) {
            return n1 * (t -= 1.5 / d1) * t + 0.75;
        } else if (t < 2.5 / d1) {
            return n1 * (t -= 2.25 / d1) * t + 0.9375;
        } else {
            return n1 * (t -= 2.625 / d1) * t + 0.984375;
        }
    }

    generateImage() {
        const canvas = document.createElement('canvas');
        canvas.width = 800;
        canvas.height = 600;
        const ctx = canvas.getContext('2d');
        
        // Calculate center point and translate
        const shapeCenter = this.calculateShapesCenterPoint();
        ctx.translate(canvas.width/2 - shapeCenter.centerX, canvas.height/2 - shapeCenter.centerY);
        
        // Draw all frames composited (or just frame 0 for static)
        const shapes = this.frames[0] || [];
        shapes.forEach((shape) => {
            this.drawShape(ctx, shape);
        });
        
        this.generatedImage = new Image();
        this.generatedImage.src = canvas.toDataURL();
        this.imageGenerated = true;
    }

    calculateShapesCenterPoint() {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        let hasShapes = false;

        this.frames.forEach(frame => {
            if (!frame) return;
            frame.forEach(shape => {
                hasShapes = true;
                if (shape.type === 'spline') {
                    shape.points.forEach(point => {
                        minX = Math.min(minX, point.x);
                        minY = Math.min(minY, point.y);
                        maxX = Math.max(maxX, point.x);
                        maxY = Math.max(maxY, point.y);
                    });
                } else if (shape.type === 'circle') {
                    const radius = Math.sqrt((shape.endX - shape.startX) ** 2 + (shape.endY - shape.startY) ** 2);
                    minX = Math.min(minX, shape.startX - radius);
                    minY = Math.min(minY, shape.startY - radius);
                    maxX = Math.max(maxX, shape.startX + radius);
                    maxY = Math.max(maxY, shape.startY + radius);
                } else {
                    minX = Math.min(minX, shape.startX, shape.endX);
                    minY = Math.min(minY, shape.startY, shape.endY);
                    maxX = Math.max(maxX, shape.startX, shape.endX);
                    maxY = Math.max(maxY, shape.startY, shape.endY);
                }
            });
        });

        if (!hasShapes) return { centerX: 0, centerY: 0 };
        
        return {
            centerX: (minX + maxX) / 2,
            centerY: (minY + maxY) / 2
        };
    }

    createGradient(shape, ctx) {
        if (!shape.gradient || !shape.gradient.enabled) return shape.fillColor;
        
        let gradient;
        const bounds = this.getShapeBounds(shape);
        
        if (shape.gradient.type === 'radial') {
            const centerX = bounds.x + bounds.width / 2;
            const centerY = bounds.y + bounds.height / 2;
            const radius = Math.max(bounds.width, bounds.height) / 2;
            gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
        } else {
            // Linear gradient
            const angle = (shape.gradient.angle || 0) * Math.PI / 180;
            const x1 = bounds.x + bounds.width / 2 - Math.cos(angle) * bounds.width / 2;
            const y1 = bounds.y + bounds.height / 2 - Math.sin(angle) * bounds.height / 2;
            const x2 = bounds.x + bounds.width / 2 + Math.cos(angle) * bounds.width / 2;
            const y2 = bounds.y + bounds.height / 2 + Math.sin(angle) * bounds.height / 2;
            gradient = ctx.createLinearGradient(x1, y1, x2, y2);
        }
        
        gradient.addColorStop(0, shape.gradient.start);
        gradient.addColorStop(1, shape.gradient.end);
        
        return gradient;
    }

    getShapeBounds(shape) {
        if (shape.type === 'spline') {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            shape.points.forEach(pt => {
                minX = Math.min(minX, pt.x);
                minY = Math.min(minY, pt.y);
                maxX = Math.max(maxX, pt.x);
                maxY = Math.max(maxY, pt.y);
            });
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        } else if (shape.type === 'circle') {
            const radius = Math.sqrt((shape.endX - shape.startX) ** 2 + (shape.endY - shape.startY) ** 2);
            return {
                x: shape.startX - radius,
                y: shape.startY - radius,
                width: radius * 2,
                height: radius * 2
            };
        } else {
            const minX = Math.min(shape.startX, shape.endX);
            const minY = Math.min(shape.startY, shape.endY);
            const maxX = Math.max(shape.startX, shape.endX);
            const maxY = Math.max(shape.startY, shape.endY);
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }
    }

    drawShape(ctx, shape) {
        if (!shape.visible) return;
        
        ctx.save();
        
        // Apply transformations
        if (shape.rotation || shape.scaleX !== 1 || shape.scaleY !== 1) {
            const bounds = this.getShapeBounds(shape);
            const centerX = bounds.x + bounds.width / 2;
            const centerY = bounds.y + bounds.height / 2;
            
            ctx.translate(centerX, centerY);
            ctx.rotate((shape.rotation || 0) * Math.PI / 180);
            ctx.scale(shape.scaleX || 1, shape.scaleY || 1);
            ctx.translate(-centerX, -centerY);
        }
        
        // Set up colors/gradients
        ctx.fillStyle = shape.gradient ? this.createGradient(shape, ctx) : shape.fillColor;
        ctx.strokeStyle = shape.strokeColor;
        ctx.lineWidth = shape.strokeWidth;
        ctx.setLineDash([]);

        switch (shape.type) {
            case 'rectangle':
                this.drawRectangle(ctx, shape);
                break;
            case 'circle':
                this.drawCircle(ctx, shape);
                break;
            case 'triangle':
                this.drawTriangle(ctx, shape);
                break;
            case 'line':
                this.drawLine(ctx, shape);
                break;
            case 'spline':
                this.drawSpline(ctx, shape);
                break;
        }

        ctx.restore();
    }

    drawRectangle(ctx, shape) {
        const width = shape.endX - shape.startX;
        const height = shape.endY - shape.startY;
        if (shape.fill) ctx.fillRect(shape.startX, shape.startY, width, height);
        if (shape.stroke) ctx.strokeRect(shape.startX, shape.startY, width, height);
    }

    drawCircle(ctx, shape) {
        const radius = Math.sqrt((shape.endX - shape.startX) ** 2 + (shape.endY - shape.startY) ** 2);
        ctx.beginPath();
        ctx.arc(shape.startX, shape.startY, radius, 0, Math.PI * 2);
        if (shape.fill) ctx.fill();
        if (shape.stroke) ctx.stroke();
    }

    drawTriangle(ctx, shape) {
        const midX = (shape.startX + shape.endX) / 2;
        ctx.beginPath();
        ctx.moveTo(midX, shape.startY);
        ctx.lineTo(shape.startX, shape.endY);
        ctx.lineTo(shape.endX, shape.endY);
        ctx.closePath();
        if (shape.fill) ctx.fill();
        if (shape.stroke) ctx.stroke();
    }

    drawLine(ctx, shape) {
        ctx.beginPath();
        ctx.moveTo(shape.startX, shape.startY);
        ctx.lineTo(shape.endX, shape.endY);
        ctx.stroke();
    }

    drawSpline(ctx, shape) {
        if (shape.points.length < 2) return;
        ctx.beginPath();
        if (shape.points.length === 2) {
            ctx.moveTo(shape.points[0].x, shape.points[0].y);
            ctx.lineTo(shape.points[1].x, shape.points[1].y);
        } else {
            // Use the original points without offset
            this.drawSmoothSpline(shape.points, shape.curveIntensity, shape.closed, ctx);
        }
        if (shape.closed) ctx.closePath();
        if (shape.fill && shape.closed) ctx.fill();
        if (shape.stroke) ctx.stroke();
    }

    // Update drawSmoothSpline to accept ctx
    drawSmoothSpline(points, intensity, closed, ctx = this.ctx) {
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            const prev = points[i - 1];
            const curr = points[i];
            const next = points[(i + 1) % points.length];
            const cp1x = prev.x + (curr.x - prev.x) * intensity;
            const cp1y = prev.y + (curr.y - prev.y) * intensity;
            const cp2x = curr.x - (next.x - prev.x) * intensity * 0.2;
            const cp2y = curr.y - (next.y - prev.y) * intensity * 0.2;
            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, curr.x, curr.y);
        }
    }

    toJSON() {
        return {
            ...super.toJSON(),
            scale: this.scale,
            offsetX: this.offsetX,
            offsetY: this.offsetY,
            flipped: this.flipped,
            animationSpeed: this.animationSpeed,
            isPlaying: this.isPlaying,
            currentFrame: this.currentFrame,
            currentAnimation: this.currentAnimation
        };
    }

    fromJSON(data) {
        super.fromJSON(data);
        if (!data) return;

        this.scale = data.scale || 1;
        this.offsetX = data.offsetX || 0;
        this.offsetY = data.offsetY || 0;
        this.flipped = data.flipped || false;
        this.animationSpeed = data.animationSpeed || 1;
        this.isPlaying = data.isPlaying || false;
        this.currentFrame = data.currentFrame || 0;
        this.currentAnimation = data.currentAnimation || "idle";
        
        // Update animation range after loading
        this.currentAnimationRange = this.getCurrentAnimationRange();
    }
}

window.CustomDrawing = CustomDrawing;

// RoadCone.js
class RoadCone extends Module {
    static namespace = "Drawing";
    static description = "Custom generated drawing module";
    static allowMultiple = false;
    static iconClass = "fas fa-paint-brush";
    static iconColor = "#64B5F6";

    constructor() {
        super("RoadCone");

        // Visual properties
        this.scale = 1;
        this.offsetX = 0;
        this.offsetY = 0;
        this.flipped = false;

        this.animationRanges = [
        {
                "name": "idle",
                "start": 0,
                "end": 4
        }
];
        this.currentAnimation = "idle";
        
        // Animation properties
        this.isAnimated = false;
        this.currentFrame = 0;
        this.animationSpeed = 1;
        this.isPlaying = true;
        this.frameTimer = 0;
        this.pingPong = false;
        this.playDirection = 1;
        this.totalFrames = 1;
        this.enableTweening = false;
        this.tweenType = "linear";

        this.preGenerateImage = false;
        this.generatedImage = null;
        this.imageGenerated = false;
        
        // Frame data
        this.frames = [
        [
                {
                        "type": "rectangle",
                        "startX": 272,
                        "startY": 176,
                        "endX": 528,
                        "endY": 432,
                        "fillColor": "#3b82f6",
                        "strokeColor": "#000000",
                        "strokeWidth": 4,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#b4590e",
                                "end": "#9f4204",
                                "type": "linear",
                                "angle": 0
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 272,
                                "y": 176
                        },
                        "worldPosition": {
                                "x": 272,
                                "y": 176
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                },
                {
                        "type": "circle",
                        "startX": 400,
                        "startY": 304,
                        "endX": 448,
                        "endY": 400,
                        "fillColor": "#3b82f6",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#e37316",
                                "end": "#b55608",
                                "type": "linear",
                                "angle": 0
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 400,
                                "y": 304
                        },
                        "worldPosition": {
                                "x": 400,
                                "y": 304
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                },
                {
                        "type": "circle",
                        "startX": 400,
                        "startY": 304,
                        "endX": 448,
                        "endY": 352,
                        "fillColor": "#3b82f6",
                        "strokeColor": "#ffffff",
                        "strokeWidth": 5,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#ef7715",
                                "end": "#df5a01",
                                "type": "linear",
                                "angle": 0
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 400,
                                "y": 304
                        },
                        "worldPosition": {
                                "x": 400,
                                "y": 304
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                },
                {
                        "type": "circle",
                        "startX": 400,
                        "startY": 304,
                        "endX": 416,
                        "endY": 320,
                        "fillColor": "#3b82f6",
                        "strokeColor": "#ffffff",
                        "strokeWidth": 5,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#ea8634",
                                "end": "#f3ad35",
                                "type": "linear",
                                "angle": 0
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 400,
                                "y": 304
                        },
                        "worldPosition": {
                                "x": 400,
                                "y": 304
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                }
        ]
];
        
        // Initialize current animation range
        this.currentAnimationRange = this.getCurrentAnimationRange();
        
        this.exposeProperties();
    }

    getCurrentAnimationRange() {
        return this.animationRanges.find(r => r.name === this.currentAnimation) || 
               { name: "default", start: 0, end: this.totalFrames - 1 };
    }

    exposeProperties() {
        this.exposeProperty("scale", "number", this.scale, {
            description: "Scale factor",
            onChange: (val) => { this.scale = val; }
        });
        
        this.exposeProperty("offsetX", "number", this.offsetX, {
            description: "X offset",
            onChange: (val) => { this.offsetX = val; }
        });
        
        this.exposeProperty("offsetY", "number", this.offsetY, {
            description: "Y offset", 
            onChange: (val) => { this.offsetY = val; }
        });
        
        this.exposeProperty("flipped", "boolean", this.flipped, {
            description: "Flip horizontally",
            onChange: (val) => { this.flipped = val; }
        });

        this.exposeProperty("preGenerateImage", "boolean", this.preGenerateImage, {
            description: "Pre-generate image for better performance",
            onChange: (val) => { 
                this.preGenerateImage = val; 
                if (val) {
                    this.generateImage();
                } else {
                    this.generatedImage = null;
                    this.imageGenerated = false;
                }
            }
        });

        if (this.isAnimated) {
            this.exposeProperty("currentAnimation", "enum", this.currentAnimation, {
                options: this.animationRanges.map(r => r.name),
                description: "Current animation",
                onChange: (val) => {
                    this.setAnimation(val);
                }
            });

            this.exposeProperty("animationSpeed", "number", this.animationSpeed, {
                description: "Animation speed",
                onChange: (val) => { this.animationSpeed = val; }
            });
            
            this.exposeProperty("enableTweening", "boolean", this.enableTweening, {
                description: "Enable tweening for smooth transitions",
                onChange: (val) => { this.enableTweening = val; }
            });

            this.exposeProperty("tweenType", "enum", this.tweenType, {
                options: ["linear", "ease-in", "ease-out", "ease-in-out"],
                description: "Tweening type",
                onChange: (val) => { this.tweenType = val; }
            });
            
            this.exposeProperty("isPlaying", "boolean", this.isPlaying, {
                description: "Is playing animation",
                onChange: (val) => { this.isPlaying = val }
            });
        }
    }

    style(style) {
        style.startGroup("RoadCone Appearance", false, { 
            backgroundColor: 'rgba(59,130,246,0.1)',
            borderRadius: '6px',
            padding: '8px'
        });
        
        style.exposeProperty("scale", "number", this.scale, {
            min: 0.1,
            max: 5,
            step: 0.1,
            style: { label: "Scale", slider: true }
        });
        
        style.exposeProperty("offsetX", "number", this.offsetX, {
            min: -200,
            max: 200,
            style: { label: "Offset X", slider: true }
        });
        
        style.exposeProperty("offsetY", "number", this.offsetY, {
            min: -200,
            max: 200,
            style: { label: "Offset Y", slider: true }
        });
        
        style.exposeProperty("flipped", "boolean", this.flipped, {
            style: { label: "Flip Horizontally" }
        });

        style.exposeProperty("preGenerateImage", "boolean", this.preGenerateImage, {
            style: { label: "Pre-generate Image" }
        });
        
        if (this.isAnimated) {
            style.startGroup("Animation Controls", true);

            style.exposeProperty("currentAnimation", "enum", this.currentAnimation, {
                options: this.animationRanges.map(r => r.name),
                style: { label: "Animation" }
            });
            
            style.exposeProperty("animationSpeed", "number", this.animationSpeed, {
                min: 0.1,
                max: 5,
                step: 0.1,
                style: { label: "Speed", slider: true }
            });

            style.exposeProperty("enableTweening", "boolean", this.enableTweening, {
                style: { label: "Enable Tweening" }
            });

            style.exposeProperty("tweenType", "enum", this.tweenType, {
                options: ["linear", "ease-in", "ease-out", "ease-in-out"],
                style: { label: "Tween Type" }
            });
            
            style.exposeProperty("isPlaying", "boolean", this.isPlaying, {
                style: { label: "Playing" }
            });
            
            style.endGroup();
        }
        
        style.endGroup();
        style.addHelpText("Generated drawing module with animation support");
        style.addHelpText(`Animation List: 
${this.animationRanges.map(r => `${r.name} (frames ${r.start}-${r.end})`).join(", ")}`);
    }

    // Public API Methods
    playAnimation(name) {
        const range = this.animationRanges.find(r => r.name === name);
        if (range) {
            this.currentAnimation = name;
            this.currentAnimationRange = range;
            this.currentFrame = range.start;
            this.isPlaying = true;
            this.frameTimer = 0;
            this.playDirection = 1;
        }
    }

    setAnimation(name) {
        const range = this.animationRanges.find(r => r.name === name);
        if (range) {
            this.currentAnimation = name;
            this.currentAnimationRange = range;
            this.currentFrame = range.start;
            this.isPlaying = false;
            this.frameTimer = 0;
            this.playDirection = 1;
        }
    }

    play() {
        this.isPlaying = true;
    }

    pause() {
        this.isPlaying = false;
    }

    stop() {
        this.isPlaying = false;
        const range = this.getCurrentAnimationRange();
        this.currentFrame = range.start;
        this.frameTimer = 0;
        this.playDirection = 1;
    }

    setFrame(frameIndex) {
        const range = this.getCurrentAnimationRange();
        if (frameIndex >= range.start && frameIndex <= range.end) {
            this.currentFrame = frameIndex;
        }
    }

    setSpeed(speed) {
        this.animationSpeed = Math.max(0.1, speed);
        return this;
    }

    getCurrentFrame() {
        return this.currentFrame;
    }

    getTotalFrames() {
        return this.totalFrames;
    }

    getAnimationFrameCount() {
        const range = this.getCurrentAnimationRange();
        return range.end - range.start + 1;
    }

    start() {
        if (this.preGenerateImage) {
            this.generateImage();
        }
        // Initialize to first frame of current animation
        const range = this.getCurrentAnimationRange();
        this.currentFrame = range.start;
    }

    loop(deltaTime) {
        if (!this.isAnimated || !this.isPlaying) return;

        const range = this.getCurrentAnimationRange();
        const frameCount = range.end - range.start + 1;

        // If only one frame in range, nothing to animate
        if (frameCount <= 1) {
            this.currentFrame = range.start;
            return;
        }

        this.frameTimer += deltaTime * this.animationSpeed;

        // Use frame duration of 0.1 seconds (10 FPS)
        const frameDuration = 0.1;
        
        if (this.frameTimer >= frameDuration) {
            this.frameTimer = 0;

            if (this.pingPong) {
                // Ping pong animation within the range
                this.currentFrame += this.playDirection;
                
                if (this.currentFrame >= range.end) {
                    this.playDirection = -1;
                    this.currentFrame = range.end;
                } else if (this.currentFrame <= range.start) {
                    this.playDirection = 1;
                    this.currentFrame = range.start;
                }
            } else {
                // Linear loop animation within the range
                this.currentFrame++;
                if (this.currentFrame > range.end) {
                    this.currentFrame = range.start;
                }
            }
        }
    }

    draw(ctx) {
        if (this.preGenerateImage && this.generatedImage && this.imageGenerated) {
            ctx.save();
            ctx.scale(this.scale, this.scale);
            if (this.flipped) {
                ctx.scale(-1, 1);
            }
            ctx.translate(this.offsetX, this.offsetY);
            
            ctx.drawImage(this.generatedImage, -this.generatedImage.width/2, -this.generatedImage.height/2);
            ctx.restore();
            return;
        }

        ctx.save();
        
        // Apply transformations
        ctx.scale(this.scale, this.scale);
        if (this.flipped) {
            ctx.scale(-1, 1);
        }
        ctx.translate(this.offsetX, this.offsetY);

        // Calculate the center point of all shapes to use as origin
        const shapeCenter = this.calculateShapesCenterPoint();
        
        // Translate so shapes center around 0,0
        ctx.translate(-shapeCenter.centerX, -shapeCenter.centerY);

        // Get current frame shapes
        let shapes;
        if (this.enableTweening && this.totalFrames > 1 && this.isPlaying) {
            shapes = this.getTweenedShapes();
        } else {
            const frameIndex = Math.floor(this.currentFrame);
            shapes = this.frames[frameIndex] || [];
        }
        shapes = shapes.filter(shape => shape && shape.visible !== false);

        shapes.forEach((shape, index) => {
            this.drawShape(ctx, shape);
        });

        ctx.restore();
    }

    getTweenedShapes() {
        const range = this.getCurrentAnimationRange();
        
        // Ensure current frame is within animation range for tweening
        let currentFrame = Math.floor(this.currentFrame);
        let nextFrame = currentFrame + 1;
        
        // Handle range boundaries
        if (nextFrame > range.end) {
            if (this.pingPong && this.playDirection === -1) {
                nextFrame = currentFrame - 1;
            } else {
                nextFrame = range.start; // Loop back to start
            }
        }
        
        // Ensure frames are valid
        currentFrame = Math.max(range.start, Math.min(range.end, currentFrame));
        nextFrame = Math.max(range.start, Math.min(range.end, nextFrame));
        
        const t = this.currentFrame - Math.floor(this.currentFrame);

        const currentShapes = this.frames[currentFrame] || [];
        const nextShapes = this.frames[nextFrame] || [];

        return this.interpolateShapes(currentShapes, nextShapes, t);
    }

    interpolateShapes(shapes1, shapes2, t) {
        const result = [];
        const maxLength = Math.max(shapes1.length, shapes2.length);

        for (let i = 0; i < maxLength; i++) {
            const shape1 = shapes1[i];
            const shape2 = shapes2[i];

            if (shape1 && shape2 && shape1.type === shape2.type) {
                result.push(this.interpolateShape(shape1, shape2, t));
            } else if (shape1) {
                result.push({ ...shape1 });
            } else if (shape2) {
                result.push({ ...shape2 });
            }
        }

        return result;
    }

    interpolateShape(shape1, shape2, t) {
        const eased = this.applyEasing(t, this.tweenType);
        const interpolated = { ...shape1 };

        // Interpolate basic properties
        if (shape1.type === 'spline') {
            interpolated.points = [];
            const maxPoints = Math.max(shape1.points.length, shape2.points.length);
            
            for (let i = 0; i < maxPoints; i++) {
                const p1 = shape1.points[i] || shape1.points[shape1.points.length - 1];
                const p2 = shape2.points[i] || shape2.points[shape2.points.length - 1];
                
                interpolated.points.push({
                    x: p1.x + (p2.x - p1.x) * eased,
                    y: p1.y + (p2.y - p1.y) * eased
                });
            }
        } else {
            interpolated.startX = shape1.startX + (shape2.startX - shape1.startX) * eased;
            interpolated.startY = shape1.startY + (shape2.startY - shape1.startY) * eased;
            interpolated.endX = shape1.endX + (shape2.endX - shape1.endX) * eased;
            interpolated.endY = shape1.endY + (shape2.endY - shape1.endY) * eased;
        }

        // Interpolate transform properties
        interpolated.rotation = (shape1.rotation || 0) + ((shape2.rotation || 0) - (shape1.rotation || 0)) * eased;
        interpolated.scaleX = (shape1.scaleX || 1) + ((shape2.scaleX || 1) - (shape1.scaleX || 1)) * eased;
        interpolated.scaleY = (shape1.scaleY || 1) + ((shape2.scaleY || 1) - (shape1.scaleY || 1)) * eased;

        return interpolated;
    }

    applyEasing(t, type) {
        switch (type) {
            case 'ease-in': return t * t;
            case 'ease-out': return 1 - (1 - t) * (1 - t);
            case 'ease-in-out': return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
            case 'bounce': return this.bounceEase(t);
            default: return t; // linear
        }
    }

    bounceEase(t) {
        const n1 = 7.5625;
        const d1 = 2.75;

        if (t < 1 / d1) {
            return n1 * t * t;
        } else if (t < 2 / d1) {
            return n1 * (t -= 1.5 / d1) * t + 0.75;
        } else if (t < 2.5 / d1) {
            return n1 * (t -= 2.25 / d1) * t + 0.9375;
        } else {
            return n1 * (t -= 2.625 / d1) * t + 0.984375;
        }
    }

    generateImage() {
        const canvas = document.createElement('canvas');
        canvas.width = 800;
        canvas.height = 600;
        const ctx = canvas.getContext('2d');
        
        // Calculate center point and translate
        const shapeCenter = this.calculateShapesCenterPoint();
        ctx.translate(canvas.width/2 - shapeCenter.centerX, canvas.height/2 - shapeCenter.centerY);
        
        // Draw all frames composited (or just frame 0 for static)
        const shapes = this.frames[0] || [];
        shapes.forEach((shape) => {
            this.drawShape(ctx, shape);
        });
        
        this.generatedImage = new Image();
        this.generatedImage.src = canvas.toDataURL();
        this.imageGenerated = true;
    }

    calculateShapesCenterPoint() {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        let hasShapes = false;

        this.frames.forEach(frame => {
            if (!frame) return;
            frame.forEach(shape => {
                hasShapes = true;
                if (shape.type === 'spline') {
                    shape.points.forEach(point => {
                        minX = Math.min(minX, point.x);
                        minY = Math.min(minY, point.y);
                        maxX = Math.max(maxX, point.x);
                        maxY = Math.max(maxY, point.y);
                    });
                } else if (shape.type === 'circle') {
                    const radius = Math.sqrt((shape.endX - shape.startX) ** 2 + (shape.endY - shape.startY) ** 2);
                    minX = Math.min(minX, shape.startX - radius);
                    minY = Math.min(minY, shape.startY - radius);
                    maxX = Math.max(maxX, shape.startX + radius);
                    maxY = Math.max(maxY, shape.startY + radius);
                } else {
                    minX = Math.min(minX, shape.startX, shape.endX);
                    minY = Math.min(minY, shape.startY, shape.endY);
                    maxX = Math.max(maxX, shape.startX, shape.endX);
                    maxY = Math.max(maxY, shape.startY, shape.endY);
                }
            });
        });

        if (!hasShapes) return { centerX: 0, centerY: 0 };
        
        return {
            centerX: (minX + maxX) / 2,
            centerY: (minY + maxY) / 2
        };
    }

    createGradient(shape, ctx) {
        if (!shape.gradient || !shape.gradient.enabled) return shape.fillColor;
        
        let gradient;
        const bounds = this.getShapeBounds(shape);
        
        if (shape.gradient.type === 'radial') {
            const centerX = bounds.x + bounds.width / 2;
            const centerY = bounds.y + bounds.height / 2;
            const radius = Math.max(bounds.width, bounds.height) / 2;
            gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
        } else {
            // Linear gradient
            const angle = (shape.gradient.angle || 0) * Math.PI / 180;
            const x1 = bounds.x + bounds.width / 2 - Math.cos(angle) * bounds.width / 2;
            const y1 = bounds.y + bounds.height / 2 - Math.sin(angle) * bounds.height / 2;
            const x2 = bounds.x + bounds.width / 2 + Math.cos(angle) * bounds.width / 2;
            const y2 = bounds.y + bounds.height / 2 + Math.sin(angle) * bounds.height / 2;
            gradient = ctx.createLinearGradient(x1, y1, x2, y2);
        }
        
        gradient.addColorStop(0, shape.gradient.start);
        gradient.addColorStop(1, shape.gradient.end);
        
        return gradient;
    }

    getShapeBounds(shape) {
        if (shape.type === 'spline') {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            shape.points.forEach(pt => {
                minX = Math.min(minX, pt.x);
                minY = Math.min(minY, pt.y);
                maxX = Math.max(maxX, pt.x);
                maxY = Math.max(maxY, pt.y);
            });
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        } else if (shape.type === 'circle') {
            const radius = Math.sqrt((shape.endX - shape.startX) ** 2 + (shape.endY - shape.startY) ** 2);
            return {
                x: shape.startX - radius,
                y: shape.startY - radius,
                width: radius * 2,
                height: radius * 2
            };
        } else {
            const minX = Math.min(shape.startX, shape.endX);
            const minY = Math.min(shape.startY, shape.endY);
            const maxX = Math.max(shape.startX, shape.endX);
            const maxY = Math.max(shape.startY, shape.endY);
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }
    }

    drawShape(ctx, shape) {
        if (!shape.visible) return;
        
        ctx.save();
        
        // Apply transformations
        if (shape.rotation || shape.scaleX !== 1 || shape.scaleY !== 1) {
            const bounds = this.getShapeBounds(shape);
            const centerX = bounds.x + bounds.width / 2;
            const centerY = bounds.y + bounds.height / 2;
            
            ctx.translate(centerX, centerY);
            ctx.rotate((shape.rotation || 0) * Math.PI / 180);
            ctx.scale(shape.scaleX || 1, shape.scaleY || 1);
            ctx.translate(-centerX, -centerY);
        }
        
        // Set up colors/gradients
        ctx.fillStyle = shape.gradient ? this.createGradient(shape, ctx) : shape.fillColor;
        ctx.strokeStyle = shape.strokeColor;
        ctx.lineWidth = shape.strokeWidth;
        ctx.setLineDash([]);

        switch (shape.type) {
            case 'rectangle':
                this.drawRectangle(ctx, shape);
                break;
            case 'circle':
                this.drawCircle(ctx, shape);
                break;
            case 'triangle':
                this.drawTriangle(ctx, shape);
                break;
            case 'line':
                this.drawLine(ctx, shape);
                break;
            case 'spline':
                this.drawSpline(ctx, shape);
                break;
        }

        ctx.restore();
    }

    drawRectangle(ctx, shape) {
        const width = shape.endX - shape.startX;
        const height = shape.endY - shape.startY;
        if (shape.fill) ctx.fillRect(shape.startX, shape.startY, width, height);
        if (shape.stroke) ctx.strokeRect(shape.startX, shape.startY, width, height);
    }

    drawCircle(ctx, shape) {
        const radius = Math.sqrt((shape.endX - shape.startX) ** 2 + (shape.endY - shape.startY) ** 2);
        ctx.beginPath();
        ctx.arc(shape.startX, shape.startY, radius, 0, Math.PI * 2);
        if (shape.fill) ctx.fill();
        if (shape.stroke) ctx.stroke();
    }

    drawTriangle(ctx, shape) {
        const midX = (shape.startX + shape.endX) / 2;
        ctx.beginPath();
        ctx.moveTo(midX, shape.startY);
        ctx.lineTo(shape.startX, shape.endY);
        ctx.lineTo(shape.endX, shape.endY);
        ctx.closePath();
        if (shape.fill) ctx.fill();
        if (shape.stroke) ctx.stroke();
    }

    drawLine(ctx, shape) {
        ctx.beginPath();
        ctx.moveTo(shape.startX, shape.startY);
        ctx.lineTo(shape.endX, shape.endY);
        ctx.stroke();
    }

    drawSpline(ctx, shape) {
        if (shape.points.length < 2) return;
        ctx.beginPath();
        if (shape.points.length === 2) {
            ctx.moveTo(shape.points[0].x, shape.points[0].y);
            ctx.lineTo(shape.points[1].x, shape.points[1].y);
        } else {
            // Use the original points without offset
            this.drawSmoothSpline(shape.points, shape.curveIntensity, shape.closed, ctx);
        }
        if (shape.closed) ctx.closePath();
        if (shape.fill && shape.closed) ctx.fill();
        if (shape.stroke) ctx.stroke();
    }

    // Update drawSmoothSpline to accept ctx
    drawSmoothSpline(points, intensity, closed, ctx = this.ctx) {
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            const prev = points[i - 1];
            const curr = points[i];
            const next = points[(i + 1) % points.length];
            const cp1x = prev.x + (curr.x - prev.x) * intensity;
            const cp1y = prev.y + (curr.y - prev.y) * intensity;
            const cp2x = curr.x - (next.x - prev.x) * intensity * 0.2;
            const cp2y = curr.y - (next.y - prev.y) * intensity * 0.2;
            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, curr.x, curr.y);
        }
    }

    toJSON() {
        return {
            ...super.toJSON(),
            scale: this.scale,
            offsetX: this.offsetX,
            offsetY: this.offsetY,
            flipped: this.flipped,
            animationSpeed: this.animationSpeed,
            isPlaying: this.isPlaying,
            currentFrame: this.currentFrame,
            currentAnimation: this.currentAnimation
        };
    }

    fromJSON(data) {
        super.fromJSON(data);
        if (!data) return;

        this.scale = data.scale || 1;
        this.offsetX = data.offsetX || 0;
        this.offsetY = data.offsetY || 0;
        this.flipped = data.flipped || false;
        this.animationSpeed = data.animationSpeed || 1;
        this.isPlaying = data.isPlaying || false;
        this.currentFrame = data.currentFrame || 0;
        this.currentAnimation = data.currentAnimation || "idle";
        
        // Update animation range after loading
        this.currentAnimationRange = this.getCurrentAnimationRange();
    }
}

window.RoadCone = RoadCone;

// car5.js
class car5 extends Module {
    static namespace = "Drawing";
    static description = "Custom generated drawing module";
    static allowMultiple = false;
    static iconClass = "fas fa-paint-brush";
    static iconColor = "#64B5F6";

    constructor() {
        super("car5");

        // Visual properties
        this.scale = 1;
        this.offsetX = 0;
        this.offsetY = 0;
        this.flipped = false;

        this.animationRanges = [
        {
                "name": "idle",
                "start": 0,
                "end": 4
        }
];
        this.currentAnimation = "idle";
        
        // Animation properties
        this.isAnimated = false;
        this.currentFrame = 0;
        this.animationSpeed = 1;
        this.isPlaying = true;
        this.frameTimer = 0;
        this.pingPong = false;
        this.playDirection = 1;
        this.totalFrames = 1;
        this.enableTweening = false;
        this.tweenType = "linear";

        this.preGenerateImage = false;
        this.generatedImage = null;
        this.imageGenerated = false;
        
        // Frame data
        this.frames = [
        [
                {
                        "type": "rectangle",
                        "startX": 224,
                        "startY": 208,
                        "endX": 576,
                        "endY": 384,
                        "fillColor": "#3b82f6",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#3b82f6",
                                "end": "#7176bc",
                                "type": "linear",
                                "angle": 87
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 176,
                                "y": 208
                        },
                        "worldPosition": {
                                "x": 176,
                                "y": 208
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 336,
                        "startY": 240,
                        "endX": 480,
                        "endY": 352,
                        "fillColor": "#81abee",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#81abef",
                                "end": "#71bc9b",
                                "type": "linear",
                                "angle": 91
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 304,
                                "y": 240
                        },
                        "worldPosition": {
                                "x": 304,
                                "y": 240
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 480,
                        "startY": 240,
                        "endX": 528,
                        "endY": 352,
                        "fillColor": "#81abee",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#c8d9f3",
                                "end": "#ffffff",
                                "type": "linear",
                                "angle": 0
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 496,
                                "y": 240
                        },
                        "worldPosition": {
                                "x": 496,
                                "y": 240
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 256,
                        "startY": 240,
                        "endX": 336,
                        "endY": 352,
                        "fillColor": "#81abee",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#c8d9f3",
                                "end": "#ffffff",
                                "type": "linear",
                                "angle": 0
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 256,
                                "y": 240
                        },
                        "worldPosition": {
                                "x": 256,
                                "y": 240
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 560,
                        "startY": 224,
                        "endX": 576,
                        "endY": 256,
                        "fillColor": "#efdf0b",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 560,
                                "y": 224
                        },
                        "worldPosition": {
                                "x": 560,
                                "y": 224
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 560,
                        "startY": 368,
                        "endX": 576,
                        "endY": 336,
                        "fillColor": "#e3d40d",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 560,
                                "y": 368
                        },
                        "worldPosition": {
                                "x": 560,
                                "y": 368
                        },
                        "rotationHotspot": {
                                "x": 8,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 224,
                        "startY": 224,
                        "endX": 240,
                        "endY": 256,
                        "fillColor": "#ff0000",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 224,
                                "y": 224
                        },
                        "worldPosition": {
                                "x": 224,
                                "y": 224
                        },
                        "rotationHotspot": {
                                "x": 8,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 224,
                        "startY": 336,
                        "endX": 240,
                        "endY": 368,
                        "fillColor": "#ff0000",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 224,
                                "y": 336
                        },
                        "worldPosition": {
                                "x": 224,
                                "y": 336
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        },
                        "isParent": false,
                        "isGrouped": false,
                        "parentShape": null
                },
                {
                        "type": "rectangle",
                        "startX": 176,
                        "startY": 224,
                        "endX": 208,
                        "endY": 368,
                        "fillColor": "#ff0000",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#81abef",
                                "end": "#71bc9b",
                                "type": "linear",
                                "angle": 91
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 208,
                                "y": 256
                        },
                        "worldPosition": {
                                "x": 208,
                                "y": 256
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                },
                {
                        "type": "rectangle",
                        "startX": 208,
                        "startY": 272,
                        "endX": 240,
                        "endY": 288,
                        "fillColor": "#ff0000",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#81abef",
                                "end": "#71bc9b",
                                "type": "linear",
                                "angle": 91
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 208,
                                "y": 272
                        },
                        "worldPosition": {
                                "x": 208,
                                "y": 272
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                },
                {
                        "type": "rectangle",
                        "startX": 208,
                        "startY": 320,
                        "endX": 240,
                        "endY": 304,
                        "fillColor": "#ff0000",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": true,
                                "start": "#81abef",
                                "end": "#71bc9b",
                                "type": "linear",
                                "angle": 91
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 208,
                                "y": 320
                        },
                        "worldPosition": {
                                "x": 208,
                                "y": 320
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                },
                {
                        "type": "rectangle",
                        "startX": 496,
                        "startY": 192,
                        "endX": 544,
                        "endY": 208,
                        "fillColor": "#000000",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": {
                                "enabled": false,
                                "start": "#81abef",
                                "end": "#71bc9b",
                                "type": "linear",
                                "angle": 91
                        },
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 496,
                                "y": 192
                        },
                        "worldPosition": {
                                "x": 496,
                                "y": 192
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                },
                {
                        "type": "rectangle",
                        "startX": 496,
                        "startY": 192,
                        "endX": 544,
                        "endY": 208,
                        "fillColor": "#292929",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 496,
                                "y": 192
                        },
                        "worldPosition": {
                                "x": 496,
                                "y": 192
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                },
                {
                        "type": "rectangle",
                        "startX": 496,
                        "startY": 384,
                        "endX": 544,
                        "endY": 400,
                        "fillColor": "#292929",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 480,
                                "y": 384
                        },
                        "worldPosition": {
                                "x": 480,
                                "y": 384
                        },
                        "rotationHotspot": {
                                "x": 8,
                                "y": 8
                        }
                },
                {
                        "type": "rectangle",
                        "startX": 256,
                        "startY": 192,
                        "endX": 304,
                        "endY": 208,
                        "fillColor": "#292929",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 256,
                                "y": 192
                        },
                        "worldPosition": {
                                "x": 256,
                                "y": 192
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                },
                {
                        "type": "rectangle",
                        "startX": 256,
                        "startY": 384,
                        "endX": 304,
                        "endY": 400,
                        "fillColor": "#292929",
                        "strokeColor": "#000000",
                        "strokeWidth": 2,
                        "fill": true,
                        "stroke": true,
                        "visible": true,
                        "rotation": 0,
                        "scaleX": 1,
                        "scaleY": 1,
                        "gradient": null,
                        "parentGroup": null,
                        "children": [],
                        "localRotation": 0,
                        "worldRotation": 0,
                        "localPosition": {
                                "x": 256,
                                "y": 384
                        },
                        "worldPosition": {
                                "x": 256,
                                "y": 384
                        },
                        "rotationHotspot": {
                                "x": 0,
                                "y": 0
                        }
                }
        ]
];
        
        // Initialize current animation range
        this.currentAnimationRange = this.getCurrentAnimationRange();
        
        this.exposeProperties();
    }

    getCurrentAnimationRange() {
        return this.animationRanges.find(r => r.name === this.currentAnimation) || 
               { name: "default", start: 0, end: this.totalFrames - 1 };
    }

    exposeProperties() {
        this.exposeProperty("scale", "number", this.scale, {
            description: "Scale factor",
            onChange: (val) => { this.scale = val; }
        });
        
        this.exposeProperty("offsetX", "number", this.offsetX, {
            description: "X offset",
            onChange: (val) => { this.offsetX = val; }
        });
        
        this.exposeProperty("offsetY", "number", this.offsetY, {
            description: "Y offset", 
            onChange: (val) => { this.offsetY = val; }
        });
        
        this.exposeProperty("flipped", "boolean", this.flipped, {
            description: "Flip horizontally",
            onChange: (val) => { this.flipped = val; }
        });

        this.exposeProperty("preGenerateImage", "boolean", this.preGenerateImage, {
            description: "Pre-generate image for better performance",
            onChange: (val) => { 
                this.preGenerateImage = val; 
                if (val) {
                    this.generateImage();
                } else {
                    this.generatedImage = null;
                    this.imageGenerated = false;
                }
            }
        });

        if (this.isAnimated) {
            this.exposeProperty("currentAnimation", "enum", this.currentAnimation, {
                options: this.animationRanges.map(r => r.name),
                description: "Current animation",
                onChange: (val) => {
                    this.setAnimation(val);
                }
            });

            this.exposeProperty("animationSpeed", "number", this.animationSpeed, {
                description: "Animation speed",
                onChange: (val) => { this.animationSpeed = val; }
            });
            
            this.exposeProperty("enableTweening", "boolean", this.enableTweening, {
                description: "Enable tweening for smooth transitions",
                onChange: (val) => { this.enableTweening = val; }
            });

            this.exposeProperty("tweenType", "enum", this.tweenType, {
                options: ["linear", "ease-in", "ease-out", "ease-in-out"],
                description: "Tweening type",
                onChange: (val) => { this.tweenType = val; }
            });
            
            this.exposeProperty("isPlaying", "boolean", this.isPlaying, {
                description: "Is playing animation",
                onChange: (val) => { this.isPlaying = val }
            });
        }
    }

    style(style) {
        style.startGroup("car5 Appearance", false, { 
            backgroundColor: 'rgba(59,130,246,0.1)',
            borderRadius: '6px',
            padding: '8px'
        });
        
        style.exposeProperty("scale", "number", this.scale, {
            min: 0.1,
            max: 5,
            step: 0.1,
            style: { label: "Scale", slider: true }
        });
        
        style.exposeProperty("offsetX", "number", this.offsetX, {
            min: -200,
            max: 200,
            style: { label: "Offset X", slider: true }
        });
        
        style.exposeProperty("offsetY", "number", this.offsetY, {
            min: -200,
            max: 200,
            style: { label: "Offset Y", slider: true }
        });
        
        style.exposeProperty("flipped", "boolean", this.flipped, {
            style: { label: "Flip Horizontally" }
        });

        style.exposeProperty("preGenerateImage", "boolean", this.preGenerateImage, {
            style: { label: "Pre-generate Image" }
        });
        
        if (this.isAnimated) {
            style.startGroup("Animation Controls", true);

            style.exposeProperty("currentAnimation", "enum", this.currentAnimation, {
                options: this.animationRanges.map(r => r.name),
                style: { label: "Animation" }
            });
            
            style.exposeProperty("animationSpeed", "number", this.animationSpeed, {
                min: 0.1,
                max: 5,
                step: 0.1,
                style: { label: "Speed", slider: true }
            });

            style.exposeProperty("enableTweening", "boolean", this.enableTweening, {
                style: { label: "Enable Tweening" }
            });

            style.exposeProperty("tweenType", "enum", this.tweenType, {
                options: ["linear", "ease-in", "ease-out", "ease-in-out"],
                style: { label: "Tween Type" }
            });
            
            style.exposeProperty("isPlaying", "boolean", this.isPlaying, {
                style: { label: "Playing" }
            });
            
            style.endGroup();
        }
        
        style.endGroup();
        style.addHelpText("Generated drawing module with animation support");
        style.addHelpText(`Animation List: 
${this.animationRanges.map(r => `${r.name} (frames ${r.start}-${r.end})`).join(", ")}`);
    }

    // Public API Methods
    playAnimation(name) {
        const range = this.animationRanges.find(r => r.name === name);
        if (range) {
            this.currentAnimation = name;
            this.currentAnimationRange = range;
            this.currentFrame = range.start;
            this.isPlaying = true;
            this.frameTimer = 0;
            this.playDirection = 1;
        }
    }

    setAnimation(name) {
        const range = this.animationRanges.find(r => r.name === name);
        if (range) {
            this.currentAnimation = name;
            this.currentAnimationRange = range;
            this.currentFrame = range.start;
            this.isPlaying = false;
            this.frameTimer = 0;
            this.playDirection = 1;
        }
    }

    play() {
        this.isPlaying = true;
    }

    pause() {
        this.isPlaying = false;
    }

    stop() {
        this.isPlaying = false;
        const range = this.getCurrentAnimationRange();
        this.currentFrame = range.start;
        this.frameTimer = 0;
        this.playDirection = 1;
    }

    setFrame(frameIndex) {
        const range = this.getCurrentAnimationRange();
        if (frameIndex >= range.start && frameIndex <= range.end) {
            this.currentFrame = frameIndex;
        }
    }

    setSpeed(speed) {
        this.animationSpeed = Math.max(0.1, speed);
        return this;
    }

    getCurrentFrame() {
        return this.currentFrame;
    }

    getTotalFrames() {
        return this.totalFrames;
    }

    getAnimationFrameCount() {
        const range = this.getCurrentAnimationRange();
        return range.end - range.start + 1;
    }

    start() {
        if (this.preGenerateImage) {
            this.generateImage();
        }
        // Initialize to first frame of current animation
        const range = this.getCurrentAnimationRange();
        this.currentFrame = range.start;
    }

    loop(deltaTime) {
        if (!this.isAnimated || !this.isPlaying) return;

        const range = this.getCurrentAnimationRange();
        const frameCount = range.end - range.start + 1;

        // If only one frame in range, nothing to animate
        if (frameCount <= 1) {
            this.currentFrame = range.start;
            return;
        }

        this.frameTimer += deltaTime * this.animationSpeed;

        // Use frame duration of 0.1 seconds (10 FPS)
        const frameDuration = 0.1;
        
        if (this.frameTimer >= frameDuration) {
            this.frameTimer = 0;

            if (this.pingPong) {
                // Ping pong animation within the range
                this.currentFrame += this.playDirection;
                
                if (this.currentFrame >= range.end) {
                    this.playDirection = -1;
                    this.currentFrame = range.end;
                } else if (this.currentFrame <= range.start) {
                    this.playDirection = 1;
                    this.currentFrame = range.start;
                }
            } else {
                // Linear loop animation within the range
                this.currentFrame++;
                if (this.currentFrame > range.end) {
                    this.currentFrame = range.start;
                }
            }
        }
    }

    draw(ctx) {
        if (this.preGenerateImage && this.generatedImage && this.imageGenerated) {
            ctx.save();
            ctx.scale(this.scale, this.scale);
            if (this.flipped) {
                ctx.scale(-1, 1);
            }
            ctx.translate(this.offsetX, this.offsetY);
            
            ctx.drawImage(this.generatedImage, -this.generatedImage.width/2, -this.generatedImage.height/2);
            ctx.restore();
            return;
        }

        ctx.save();
        
        // Apply transformations
        ctx.scale(this.scale, this.scale);
        if (this.flipped) {
            ctx.scale(-1, 1);
        }
        ctx.translate(this.offsetX, this.offsetY);

        // Calculate the center point of all shapes to use as origin
        const shapeCenter = this.calculateShapesCenterPoint();
        
        // Translate so shapes center around 0,0
        ctx.translate(-shapeCenter.centerX, -shapeCenter.centerY);

        // Get current frame shapes
        let shapes;
        if (this.enableTweening && this.totalFrames > 1 && this.isPlaying) {
            shapes = this.getTweenedShapes();
        } else {
            const frameIndex = Math.floor(this.currentFrame);
            shapes = this.frames[frameIndex] || [];
        }
        shapes = shapes.filter(shape => shape && shape.visible !== false);

        shapes.forEach((shape, index) => {
            this.drawShape(ctx, shape);
        });

        ctx.restore();
    }

    getTweenedShapes() {
        const range = this.getCurrentAnimationRange();
        
        // Ensure current frame is within animation range for tweening
        let currentFrame = Math.floor(this.currentFrame);
        let nextFrame = currentFrame + 1;
        
        // Handle range boundaries
        if (nextFrame > range.end) {
            if (this.pingPong && this.playDirection === -1) {
                nextFrame = currentFrame - 1;
            } else {
                nextFrame = range.start; // Loop back to start
            }
        }
        
        // Ensure frames are valid
        currentFrame = Math.max(range.start, Math.min(range.end, currentFrame));
        nextFrame = Math.max(range.start, Math.min(range.end, nextFrame));
        
        const t = this.currentFrame - Math.floor(this.currentFrame);

        const currentShapes = this.frames[currentFrame] || [];
        const nextShapes = this.frames[nextFrame] || [];

        return this.interpolateShapes(currentShapes, nextShapes, t);
    }

    interpolateShapes(shapes1, shapes2, t) {
        const result = [];
        const maxLength = Math.max(shapes1.length, shapes2.length);

        for (let i = 0; i < maxLength; i++) {
            const shape1 = shapes1[i];
            const shape2 = shapes2[i];

            if (shape1 && shape2 && shape1.type === shape2.type) {
                result.push(this.interpolateShape(shape1, shape2, t));
            } else if (shape1) {
                result.push({ ...shape1 });
            } else if (shape2) {
                result.push({ ...shape2 });
            }
        }

        return result;
    }

    interpolateShape(shape1, shape2, t) {
        const eased = this.applyEasing(t, this.tweenType);
        const interpolated = { ...shape1 };

        // Interpolate basic properties
        if (shape1.type === 'spline') {
            interpolated.points = [];
            const maxPoints = Math.max(shape1.points.length, shape2.points.length);
            
            for (let i = 0; i < maxPoints; i++) {
                const p1 = shape1.points[i] || shape1.points[shape1.points.length - 1];
                const p2 = shape2.points[i] || shape2.points[shape2.points.length - 1];
                
                interpolated.points.push({
                    x: p1.x + (p2.x - p1.x) * eased,
                    y: p1.y + (p2.y - p1.y) * eased
                });
            }
        } else {
            interpolated.startX = shape1.startX + (shape2.startX - shape1.startX) * eased;
            interpolated.startY = shape1.startY + (shape2.startY - shape1.startY) * eased;
            interpolated.endX = shape1.endX + (shape2.endX - shape1.endX) * eased;
            interpolated.endY = shape1.endY + (shape2.endY - shape1.endY) * eased;
        }

        // Interpolate transform properties
        interpolated.rotation = (shape1.rotation || 0) + ((shape2.rotation || 0) - (shape1.rotation || 0)) * eased;
        interpolated.scaleX = (shape1.scaleX || 1) + ((shape2.scaleX || 1) - (shape1.scaleX || 1)) * eased;
        interpolated.scaleY = (shape1.scaleY || 1) + ((shape2.scaleY || 1) - (shape1.scaleY || 1)) * eased;

        return interpolated;
    }

    applyEasing(t, type) {
        switch (type) {
            case 'ease-in': return t * t;
            case 'ease-out': return 1 - (1 - t) * (1 - t);
            case 'ease-in-out': return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
            case 'bounce': return this.bounceEase(t);
            default: return t; // linear
        }
    }

    bounceEase(t) {
        const n1 = 7.5625;
        const d1 = 2.75;

        if (t < 1 / d1) {
            return n1 * t * t;
        } else if (t < 2 / d1) {
            return n1 * (t -= 1.5 / d1) * t + 0.75;
        } else if (t < 2.5 / d1) {
            return n1 * (t -= 2.25 / d1) * t + 0.9375;
        } else {
            return n1 * (t -= 2.625 / d1) * t + 0.984375;
        }
    }

    generateImage() {
        const canvas = document.createElement('canvas');
        canvas.width = 800;
        canvas.height = 600;
        const ctx = canvas.getContext('2d');
        
        // Calculate center point and translate
        const shapeCenter = this.calculateShapesCenterPoint();
        ctx.translate(canvas.width/2 - shapeCenter.centerX, canvas.height/2 - shapeCenter.centerY);
        
        // Draw all frames composited (or just frame 0 for static)
        const shapes = this.frames[0] || [];
        shapes.forEach((shape) => {
            this.drawShape(ctx, shape);
        });
        
        this.generatedImage = new Image();
        this.generatedImage.src = canvas.toDataURL();
        this.imageGenerated = true;
    }

    calculateShapesCenterPoint() {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        let hasShapes = false;

        this.frames.forEach(frame => {
            if (!frame) return;
            frame.forEach(shape => {
                hasShapes = true;
                if (shape.type === 'spline') {
                    shape.points.forEach(point => {
                        minX = Math.min(minX, point.x);
                        minY = Math.min(minY, point.y);
                        maxX = Math.max(maxX, point.x);
                        maxY = Math.max(maxY, point.y);
                    });
                } else if (shape.type === 'circle') {
                    const radius = Math.sqrt((shape.endX - shape.startX) ** 2 + (shape.endY - shape.startY) ** 2);
                    minX = Math.min(minX, shape.startX - radius);
                    minY = Math.min(minY, shape.startY - radius);
                    maxX = Math.max(maxX, shape.startX + radius);
                    maxY = Math.max(maxY, shape.startY + radius);
                } else {
                    minX = Math.min(minX, shape.startX, shape.endX);
                    minY = Math.min(minY, shape.startY, shape.endY);
                    maxX = Math.max(maxX, shape.startX, shape.endX);
                    maxY = Math.max(maxY, shape.startY, shape.endY);
                }
            });
        });

        if (!hasShapes) return { centerX: 0, centerY: 0 };
        
        return {
            centerX: (minX + maxX) / 2,
            centerY: (minY + maxY) / 2
        };
    }

    createGradient(shape, ctx) {
        if (!shape.gradient || !shape.gradient.enabled) return shape.fillColor;
        
        let gradient;
        const bounds = this.getShapeBounds(shape);
        
        if (shape.gradient.type === 'radial') {
            const centerX = bounds.x + bounds.width / 2;
            const centerY = bounds.y + bounds.height / 2;
            const radius = Math.max(bounds.width, bounds.height) / 2;
            gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);
        } else {
            // Linear gradient
            const angle = (shape.gradient.angle || 0) * Math.PI / 180;
            const x1 = bounds.x + bounds.width / 2 - Math.cos(angle) * bounds.width / 2;
            const y1 = bounds.y + bounds.height / 2 - Math.sin(angle) * bounds.height / 2;
            const x2 = bounds.x + bounds.width / 2 + Math.cos(angle) * bounds.width / 2;
            const y2 = bounds.y + bounds.height / 2 + Math.sin(angle) * bounds.height / 2;
            gradient = ctx.createLinearGradient(x1, y1, x2, y2);
        }
        
        gradient.addColorStop(0, shape.gradient.start);
        gradient.addColorStop(1, shape.gradient.end);
        
        return gradient;
    }

    getShapeBounds(shape) {
        if (shape.type === 'spline') {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            shape.points.forEach(pt => {
                minX = Math.min(minX, pt.x);
                minY = Math.min(minY, pt.y);
                maxX = Math.max(maxX, pt.x);
                maxY = Math.max(maxY, pt.y);
            });
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        } else if (shape.type === 'circle') {
            const radius = Math.sqrt((shape.endX - shape.startX) ** 2 + (shape.endY - shape.startY) ** 2);
            return {
                x: shape.startX - radius,
                y: shape.startY - radius,
                width: radius * 2,
                height: radius * 2
            };
        } else {
            const minX = Math.min(shape.startX, shape.endX);
            const minY = Math.min(shape.startY, shape.endY);
            const maxX = Math.max(shape.startX, shape.endX);
            const maxY = Math.max(shape.startY, shape.endY);
            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }
    }

    drawShape(ctx, shape) {
        if (!shape.visible) return;
        
        ctx.save();
        
        // Apply transformations
        if (shape.rotation || shape.scaleX !== 1 || shape.scaleY !== 1) {
            const bounds = this.getShapeBounds(shape);
            const centerX = bounds.x + bounds.width / 2;
            const centerY = bounds.y + bounds.height / 2;
            
            ctx.translate(centerX, centerY);
            ctx.rotate((shape.rotation || 0) * Math.PI / 180);
            ctx.scale(shape.scaleX || 1, shape.scaleY || 1);
            ctx.translate(-centerX, -centerY);
        }
        
        // Set up colors/gradients
        ctx.fillStyle = shape.gradient ? this.createGradient(shape, ctx) : shape.fillColor;
        ctx.strokeStyle = shape.strokeColor;
        ctx.lineWidth = shape.strokeWidth;
        ctx.setLineDash([]);

        switch (shape.type) {
            case 'rectangle':
                this.drawRectangle(ctx, shape);
                break;
            case 'circle':
                this.drawCircle(ctx, shape);
                break;
            case 'triangle':
                this.drawTriangle(ctx, shape);
                break;
            case 'line':
                this.drawLine(ctx, shape);
                break;
            case 'spline':
                this.drawSpline(ctx, shape);
                break;
        }

        ctx.restore();
    }

    drawRectangle(ctx, shape) {
        const width = shape.endX - shape.startX;
        const height = shape.endY - shape.startY;
        if (shape.fill) ctx.fillRect(shape.startX, shape.startY, width, height);
        if (shape.stroke) ctx.strokeRect(shape.startX, shape.startY, width, height);
    }

    drawCircle(ctx, shape) {
        const radius = Math.sqrt((shape.endX - shape.startX) ** 2 + (shape.endY - shape.startY) ** 2);
        ctx.beginPath();
        ctx.arc(shape.startX, shape.startY, radius, 0, Math.PI * 2);
        if (shape.fill) ctx.fill();
        if (shape.stroke) ctx.stroke();
    }

    drawTriangle(ctx, shape) {
        const midX = (shape.startX + shape.endX) / 2;
        ctx.beginPath();
        ctx.moveTo(midX, shape.startY);
        ctx.lineTo(shape.startX, shape.endY);
        ctx.lineTo(shape.endX, shape.endY);
        ctx.closePath();
        if (shape.fill) ctx.fill();
        if (shape.stroke) ctx.stroke();
    }

    drawLine(ctx, shape) {
        ctx.beginPath();
        ctx.moveTo(shape.startX, shape.startY);
        ctx.lineTo(shape.endX, shape.endY);
        ctx.stroke();
    }

    drawSpline(ctx, shape) {
        if (shape.points.length < 2) return;
        ctx.beginPath();
        if (shape.points.length === 2) {
            ctx.moveTo(shape.points[0].x, shape.points[0].y);
            ctx.lineTo(shape.points[1].x, shape.points[1].y);
        } else {
            // Use the original points without offset
            this.drawSmoothSpline(shape.points, shape.curveIntensity, shape.closed, ctx);
        }
        if (shape.closed) ctx.closePath();
        if (shape.fill && shape.closed) ctx.fill();
        if (shape.stroke) ctx.stroke();
    }

    // Update drawSmoothSpline to accept ctx
    drawSmoothSpline(points, intensity, closed, ctx = this.ctx) {
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
            const prev = points[i - 1];
            const curr = points[i];
            const next = points[(i + 1) % points.length];
            const cp1x = prev.x + (curr.x - prev.x) * intensity;
            const cp1y = prev.y + (curr.y - prev.y) * intensity;
            const cp2x = curr.x - (next.x - prev.x) * intensity * 0.2;
            const cp2y = curr.y - (next.y - prev.y) * intensity * 0.2;
            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, curr.x, curr.y);
        }
    }

    toJSON() {
        return {
            ...super.toJSON(),
            scale: this.scale,
            offsetX: this.offsetX,
            offsetY: this.offsetY,
            flipped: this.flipped,
            animationSpeed: this.animationSpeed,
            isPlaying: this.isPlaying,
            currentFrame: this.currentFrame,
            currentAnimation: this.currentAnimation
        };
    }

    fromJSON(data) {
        super.fromJSON(data);
        if (!data) return;

        this.scale = data.scale || 1;
        this.offsetX = data.offsetX || 0;
        this.offsetY = data.offsetY || 0;
        this.flipped = data.flipped || false;
        this.animationSpeed = data.animationSpeed || 1;
        this.isPlaying = data.isPlaying || false;
        this.currentFrame = data.currentFrame || 0;
        this.currentAnimation = data.currentAnimation || "idle";
        
        // Update animation range after loading
        this.currentAnimationRange = this.getCurrentAnimationRange();
    }
}

window.car5 = car5;

// CreatePrefabLine.js
class CreatePrefabLine extends Module {
    static namespace = "Prefab";
    static description = "Creates a line of prefabs.";
    static allowMultiple = true;

    constructor() {
        super("CreatePrefabLine");

        this.prefabName = "MyPrefab"; // Default prefab name
        this.count = 5;             // Default number of prefabs
        this.gap = 32;              // Default gap between prefabs
        this.direction = "horizontal"; // Default direction

        this.exposeProperty("prefabName", "string", this.prefabName, {
            description: "Name of the prefab to instantiate",
            onChange: (val) => { this.prefabName = val; }
        });
        this.exposeProperty("count", "number", this.count, {
            description: "Number of prefabs to create",
            min: 1,
            max: 20,
            step: 1,
            onChange: (val) => { this.count = val; }
        });
        this.exposeProperty("gap", "number", this.gap, {
            description: "Gap between prefabs",
            onChange: (val) => { this.gap = val; }
        });
        this.exposeProperty("direction", "enum", this.direction, {
            options: ["horizontal", "vertical"],
            description: "Direction of the prefab line",
            onChange: (val) => { this.direction = val; }
        });
    }

    start() {
        this.createPrefabLine();
    }

    createPrefabLine() {
        if (!window.engine.prefabs[this.prefabName]) {
            console.warn('Prefab "${this.prefabName}" not found.');
            //return;
        }

        for (let i = 0; i < this.count; i++) {
            const newObject = window.engine.instantiatePrefab(this.prefabName);
            if (!newObject) {
                console.warn('Failed to create prefab instance for: ${this.prefabName}');
                continue;
            }

            newObject.name = "${this.prefabName}_${i}"; // Give the object a unique name

            if (this.direction === "horizontal") {
                newObject.position.x = this.gameObject.position.x + i * this.gap;
                newObject.position.y = this.gameObject.position.y;
            } else {
                newObject.position.x = this.gameObject.position.x;
                newObject.position.y = this.gameObject.position.y + i * this.gap;
            }

            // Parent the new object to the current object. This is very important, as deleting the parent will delete the children.
            //newObject.parent = this.gameObject;
        }

        // Destroy the parent object after instantiating all children, as it only serves as a container.
        // Only destroy if this module is not running in the editor
        if(!window.engine.editor) {
            this.gameObject.destroy();
        }
    }

    toJSON() {
        return {
            ...super.toJSON(),
            prefabName: this.prefabName,
            count: this.count,
            gap: this.gap,
            direction: this.direction
        };
    }

    fromJSON(data) {
        super.fromJSON(data);
        this.prefabName = data.prefabName || "MyPrefab";
        this.count = data.count || 5;
        this.gap = data.gap || 32;
        this.direction = data.direction || "horizontal";
    }
}

window.CreatePrefabLine = CreatePrefabLine;



// Game Initialization - Fixed for Physics
let gameInitialized = false;

function setLoadingProgress(percent) {
    var bar = document.querySelector('.loading-progress');
    if (bar) bar.style.width = Math.max(0, Math.min(100, percent)) + '%';
}

async function initializeGame() {
    if (gameInitialized) return;
    gameInitialized = true;
    
    console.log('Initializing exported game...');

    // Initialize AssetManager first
    if (!window.assetManager) {
        window.assetManager = new AssetManager(null);
    }

    // Initialize Global Prefab Manager
    if (!window.prefabManager) {
        window.prefabManager = {
            prefabs: new Map(),
            
            loadPrefabs: function(prefabsData) {
                if (!prefabsData) return;
                
                console.log('Loading prefabs into global manager:', Object.keys(prefabsData));
                for (const [name, prefabData] of Object.entries(prefabsData)) {
                    this.prefabs.set(name, prefabData);
                }
                
                console.log('Total prefabs loaded:', this.prefabs.size);
            },
            
            findPrefabByName: function(name) {
                if (!name) return null;
                
                if (this.prefabs.has(name)) {
                    return this.prefabs.get(name);
                }
                
                const lowerName = name.toLowerCase();
                for (const [key, value] of this.prefabs) {
                    if (key.toLowerCase() === lowerName) {
                        return value;
                    }
                }
                
                return null;
            },
            
            hasPrefab: function(name) {
                return this.findPrefabByName(name) !== null;
            },
            
            getAllPrefabNames: function() {
                return Array.from(this.prefabs.keys());
            },
            
            instantiatePrefabByName: function(name, position = null, parent = null) {
                const prefabData = this.findPrefabByName(name);
                if (!prefabData) {
                    console.error('Prefab not found:', name);
                    return null;
                }
                
                return this.instantiatePrefab(prefabData, position, parent);
            },
            
            instantiatePrefab: function(prefabData, position = null, parent = null) {
                try {
                    // Use GameObject.fromJSON for proper deserialization (matches editor behavior)
                    const gameObject = GameObject.fromJSON(prefabData);
                    
                    // Override position if specified
                    if (position) {
                        gameObject.position.x = position.x;
                        gameObject.position.y = position.y;
                    }
                    
                    // Handle parenting
                    if (parent) {
                        parent.addChild(gameObject);
                    } else if (window.engine && window.engine.gameObjects) {
                        window.engine.gameObjects.push(gameObject);
                    }
                    
                    return gameObject;
                } catch (error) {
                    console.error('Error instantiating prefab:', error);
                    return null;
                }
            }
        };
    }

    
    // Standalone mode - embed assets directly
    const assetsData = {"/generated_texture.png":{"content":"data:image/png;base64,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","type":"image/png"},"generated_texture.png":{"content":"data:image/png;base64,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","type":"image/png","source":"fileBrowser"}};
    if (assetsData) {
        console.log('Loading embedded assets into AssetManager...');
        window.assetManager.addEmbeddedAssets(assetsData);
        
        // Wait a moment for async asset loading to complete
        await new Promise(resolve => setTimeout(resolve, 100));
        console.log('AssetManager cache populated with:', Object.keys(window.assetManager.cache));
    }
    
    // Prevent scrolling with keyboard
    document.addEventListener('keydown', (e) => {
        if ([32, 33, 34, 35, 36, 37, 38, 39, 40].includes(e.keyCode)) {
            e.preventDefault();
        }
    }, { passive: false });
    
    // Prevent context menu and drag/drop
    document.addEventListener('contextmenu', (e) => e.preventDefault());
    document.addEventListener('dragover', (e) => e.preventDefault());
    document.addEventListener('drop', (e) => e.preventDefault());
    
    const loadingScreen = document.getElementById('loading-screen');
    
    // Wait for Matter.js to be available
    if (typeof Matter === 'undefined') {
        console.log('Waiting for Matter.js to load...');
        return; // Will be called again when matter-loaded event fires
    }
    
    console.log('Matter.js is available, proceeding with initialization...');
    
    // Initialize physics manager FIRST
    window.physicsManager = new PhysicsManager();
    
    // Initialize module registry
    if (!window.moduleRegistry) {
        window.moduleRegistry = new ModuleRegistry();
    }
    
    // Register all available modules
    console.log('Registering modules...');
    
    if (typeof SpriteRenderer !== 'undefined') {
        window.moduleRegistry.register(SpriteRenderer);
        console.log('Registered module: SpriteRenderer');
    } else {
        console.error('Module class not found: SpriteRenderer');
    }
    if (typeof RigidBody !== 'undefined') {
        window.moduleRegistry.register(RigidBody);
        console.log('Registered module: RigidBody');
    } else {
        console.error('Module class not found: RigidBody');
    }
    if (typeof DrawCircle !== 'undefined') {
        window.moduleRegistry.register(DrawCircle);
        console.log('Registered module: DrawCircle');
    } else {
        console.error('Module class not found: DrawCircle');
    }
    if (typeof DrawRectangle !== 'undefined') {
        window.moduleRegistry.register(DrawRectangle);
        console.log('Registered module: DrawRectangle');
    } else {
        console.error('Module class not found: DrawRectangle');
    }
    if (typeof ObjectTiling !== 'undefined') {
        window.moduleRegistry.register(ObjectTiling);
        console.log('Registered module: ObjectTiling');
    } else {
        console.error('Module class not found: ObjectTiling');
    }
    if (typeof CameraController !== 'undefined') {
        window.moduleRegistry.register(CameraController);
        console.log('Registered module: CameraController');
    } else {
        console.error('Module class not found: CameraController');
    }
    if (typeof VehiclePhysics !== 'undefined') {
        window.moduleRegistry.register(VehiclePhysics);
        console.log('Registered module: VehiclePhysics');
    } else {
        console.error('Module class not found: VehiclePhysics');
    }
    if (typeof car5 !== 'undefined') {
        window.moduleRegistry.register(car5);
        console.log('Registered module: car5');
    } else {
        console.error('Module class not found: car5');
    }
    if (typeof Car2 !== 'undefined') {
        window.moduleRegistry.register(Car2);
        console.log('Registered module: Car2');
    } else {
        console.error('Module class not found: Car2');
    }
    if (typeof Car4 !== 'undefined') {
        window.moduleRegistry.register(Car4);
        console.log('Registered module: Car4');
    } else {
        console.error('Module class not found: Car4');
    }
    if (typeof Car3 !== 'undefined') {
        window.moduleRegistry.register(Car3);
        console.log('Registered module: Car3');
    } else {
        console.error('Module class not found: Car3');
    }
    if (typeof RoadCone !== 'undefined') {
        window.moduleRegistry.register(RoadCone);
        console.log('Registered module: RoadCone');
    } else {
        console.error('Module class not found: RoadCone');
    }
    
    console.log('Total registered modules:', window.moduleRegistry.modules.size);
    
    // Initialize input manager
    if (!window.input) {
        window.input = new InputManager();
    }

    // Enhanced path normalization function
    window.assetManager.normalizePath = function(path) {
        if (!path) return '';
        let normalized = path.replace(/^[/\\]+/, '').replace(/\\/g, '/');
        try {
            normalized = decodeURIComponent(normalized);
        } catch (e) {
            // If decoding fails, use the original normalized path
        }
        return normalized;
    };

    // Override AssetManager methods for ZIP mode
    
    
    // Initialize Global Prefab Manager
    window.prefabManager = {
        prefabs: new Map(),
        
        loadPrefabs: function(prefabsData) {
            if (!prefabsData) return;
            
            for (const [name, prefabData] of Object.entries(prefabsData)) {
                this.prefabs.set(name, prefabData);
                console.log('Loaded prefab:', name);
            }
            
            console.log('Total prefabs loaded:', this.prefabs.size);
        },
        
        findPrefabByName: function(name) {
            if (!name) return null;
            
            if (this.prefabs.has(name)) {
                return this.prefabs.get(name);
            }
            
            const lowerName = name.toLowerCase();
            for (const [key, value] of this.prefabs) {
                if (key.toLowerCase() === lowerName) {
                    return value;
                }
            }
            
            return null;
        },
        
        hasPrefab: function(name) {
            return this.findPrefabByName(name) !== null;
        },
        
        getAllPrefabNames: function() {
            return Array.from(this.prefabs.keys());
        },
        
        instantiatePrefabByName: function(name, position = null, parent = null) {
            const prefabData = this.findPrefabByName(name);
            if (!prefabData) {
                console.error('Prefab not found:', name);
                return null;
            }
            
            return this.instantiatePrefab(prefabData, position, parent);
        },
        
        instantiatePrefab: function(prefabData, position = null, parent = null) {
            try {
                const gameObject = new GameObject(prefabData.name);
                
                if (position) {
                    gameObject.position.x = position.x;
                    gameObject.position.y = position.y;
                } else {
                    gameObject.position.x = prefabData.position.x;
                    gameObject.position.y = prefabData.position.y;
                }

                gameObject.angle = prefabData.angle || 0;
                gameObject.scale.x = prefabData.scale?.x || 1;
                gameObject.scale.y = prefabData.scale?.y || 1;
                gameObject.active = prefabData.active !== false;

                if (prefabData.modules && prefabData.modules.length > 0) {
                    prefabData.modules.forEach(moduleData => {
                        try {
                            const ModuleClass = window.moduleRegistry.getModuleClass(moduleData.className);
                            if (!ModuleClass) {
                                console.warn('Module class not found:', moduleData.className);
                                return;
                            }

                            const moduleInstance = new ModuleClass();
                            
                            if (moduleData.properties) {
                                Object.keys(moduleData.properties).forEach(propName => {
                                    if (moduleInstance.hasOwnProperty(propName)) {
                                        moduleInstance[propName] = moduleData.properties[propName];
                                    }
                                });
                            }

                            gameObject.addModule(moduleInstance);
                            
                        } catch (error) {
                            console.error('Error adding module ' + moduleData.className + ':', error);
                        }
                    });
                }

                if (prefabData.children && prefabData.children.length > 0) {
                    prefabData.children.forEach(childData => {
                        const childGameObject = this.instantiatePrefab(childData, null, gameObject);
                        gameObject.addChild(childGameObject);
                    });
                }

                if (parent) {
                    parent.addChild(gameObject);
                } else if (window.engine && window.engine.gameObjects) {
                    window.engine.gameObjects.push(gameObject);
                }

                return gameObject;

            } catch (error) {
                console.error('Error instantiating prefab:', error);
                throw error;
            }
        }
    };
    
    // Load game data safely
    let gameData;
    try {
        gameData = {
            scenes: [{"name":"Main Scene","settings":{"viewportWidth":1280,"viewportHeight":720,"viewportX":0,"viewportY":0,"backgroundColor":"#568f57","gridEnabled":true,"gridSize":32,"snapToGrid":false,"gravity":{"x":0,"y":1},"physicsEnabled":true,"physicsDebugDraw":false},"gameObjects":[{"id":"5b254eb1-f9b4-474e-ae39-24374d015891","name":"Grid","position":{"x":0,"y":0},"angle":0,"scale":{"x":1,"y":1},"size":{"width":50,"height":50},"active":true,"visible":true,"depth":0,"modules":[{"type":"ObjectTiling","id":"47a45bd9-7b7c-4327-99ac-34cff0edb511","enabled":true,"data":{"name":"ObjectTiling","type":"ObjectTiling","enabled":true,"requirements":[],"properties":{},"exposedValues":{"objectName":"Grass","tileWidth":512,"tileHeight":512,"xCount":5,"yCount":5,"infinite":true,"spacingX":0,"spacingY":0,"chunkSize":512,"paddingChunks":1},"objectName":"Grass","tileWidth":512,"tileHeight":512,"xCount":5,"yCount":5,"infinite":true,"spacingX":0,"spacingY":0,"chunkSize":512,"paddingChunks":1}}]},{"id":"89d3ec18-b5a5-47db-8e38-d55c5cc4b319","name":"Car","position":{"x":426.3616038983509,"y":436.63838524193335},"angle":-12.832989044567789,"scale":{"x":1,"y":1},"size":{"width":100,"height":50},"active":true,"visible":true,"depth":0,"modules":[{"type":"CameraController","id":"8f3dfb4e-47ba-45d0-8c15-02d2b0726080","enabled":true,"data":{"name":"CameraController","type":"CameraController","enabled":true,"requirements":[],"properties":{},"exposedValues":{"followOwner":true,"followSpeed":50,"zoom":1,"targetZoom":1,"positionDamping":0.85,"zoomDamping":0.85,"dynamicZoomEnabled":true,"maxZoomOut":0.2,"zoomSmoothness":0.85,"zoomIntensityMultiplier":0.001,"shakeIntensity":0,"shakeTimer":0,"offset":{"x":0,"y":0}},"position":{"x":426.36,"y":436.64},"zoom":1,"targetZoom":1,"followOwner":true,"followSpeed":50,"zoomSpeed":2,"positionDamping":0.85,"zoomDamping":0.85,"offset":{"x":0,"y":0},"followOwnerAngle":false,"followAngleOffset":0,"currentAngle":0,"targetAngle":0}},{"type":"RigidBody","id":"6938230a-f6b6-4a88-bdfc-81de9035b642","enabled":true,"data":{"name":"RigidBody","type":"RigidBody","enabled":true,"requirements":[],"properties":{},"exposedValues":{"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"restitution":0.4,"useGravity":true,"frictionAir":0.03,"sleepingAllowed":true,"label":"","fixedRotation":false,"isSensor":false},"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"frictionAir":0.03,"restitution":0.4,"fixedRotation":false,"isSensor":false,"useGravity":true,"sleepingAllowed":true,"label":"","collisionFilter":{"category":1,"mask":4294967295,"group":0},"vertices":[]}},{"type":"VehiclePhysics","id":"49e97dd7-c99a-40c2-b79f-f77283f15c81","enabled":true,"data":{"name":"VehiclePhysics","type":"VehiclePhysics","enabled":true,"requirements":["RigidBody"],"properties":{},"exposedValues":{"weight":100,"playerControlled":true,"gtaStyleVehicle":true,"maxSpeed":5000,"acceleration":2000,"brakeForce":1000,"frontWheelDrive":false,"handbrakeForce":6,"tractionLoss":0.4,"showDebugInfo":false,"showDriftInfo":false},"playerControlled":true,"maxSpeed":5000,"acceleration":2000,"brakeForce":1000,"decelerationRate":0.05,"reverseMaxSpeed":250,"maxTurnAngle":45,"turnMultiplier":20,"wheelTurnSpeed":90,"wheelReturnSpeed":90,"dragCoefficient":0.95,"lateralGrip":0.85,"minTurnSpeed":50,"wheelBase":60,"frontWheelDrive":false,"differentialStrength":0.6,"antiRoll":0.3,"handbrakeForce":6,"driftThreshold":0.8,"tractionLoss":0.4,"powerOversteerStrength":1.2,"frontGripAdvantage":0.15,"driftRecoveryRate":1.2,"velocityDriftFactor":0.7,"tractionControlEnabled":true,"tractionControlStrength":0.6,"absEnabled":true,"absStrength":0.8,"showDebugInfo":false,"showWheelDirection":false,"showDriftInfo":false,"upKey":"arrowup","downKey":"arrowdown","leftKey":"arrowleft","rightKey":"arrowright","handbrakeKey":" ","tireMarkOpacity":0.3,"tireMarkScale":1,"tireMarkLifetime":8000,"tireMarkDistanceApart":48,"tireMarkEnabled":true,"tireMarkOffsetX":-30,"tireMarkOffsetY":0,"gtaStyleVehicle":true,"enterKey":"enter","enterDistance":80,"hidePlayerWhenInside":true,"showEnterPrompt":true,"ejectOnDestroy":true}},{"type":"car5","id":"11e82743-3c22-4d9c-936f-0512b4612a20","enabled":true,"data":{"name":"car5","type":"car5","enabled":true,"requirements":[],"properties":{},"exposedValues":{"scale":0.29,"offsetX":-24,"offsetY":0,"flipped":false,"preGenerateImage":false},"scale":0.29,"offsetX":-24,"offsetY":0,"flipped":false,"animationSpeed":1,"isPlaying":true,"currentFrame":0,"currentAnimation":"idle"}}]},{"id":"7feb6105-2ac8-4482-b2ed-a52c5a08e27b","name":"Car (Copy)","position":{"x":700.6663212577778,"y":249.9064379894646},"angle":-56.21808824634486,"scale":{"x":1,"y":1},"size":{"width":100,"height":50},"active":true,"visible":true,"depth":0,"modules":[{"type":"RigidBody","id":"d0a00c1f-fd95-4a6c-bbc3-4bf2ba859bd3","enabled":true,"data":{"name":"RigidBody","type":"RigidBody","enabled":true,"requirements":[],"properties":{},"exposedValues":{"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"restitution":0.4,"useGravity":true,"frictionAir":0.02,"sleepingAllowed":true,"label":"","fixedRotation":false,"isSensor":false},"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"frictionAir":0.02,"restitution":0.4,"fixedRotation":false,"isSensor":false,"useGravity":true,"sleepingAllowed":true,"label":"","collisionFilter":{"category":1,"mask":4294967295,"group":0},"vertices":[]}},{"type":"VehiclePhysics","id":"69e7e5c5-0827-40b1-b905-09a4fcdb3986","enabled":true,"data":{"name":"VehiclePhysics","type":"VehiclePhysics","enabled":true,"requirements":["RigidBody"],"properties":{},"exposedValues":{"weight":100,"playerControlled":false,"gtaStyleVehicle":true,"maxSpeed":3000,"acceleration":1000,"brakeForce":250,"frontWheelDrive":false,"handbrakeForce":6,"tractionLoss":0.4,"showDebugInfo":false,"showDriftInfo":false},"playerControlled":false,"maxSpeed":3000,"acceleration":1000,"brakeForce":250,"decelerationRate":0.05,"reverseMaxSpeed":250,"maxTurnAngle":45,"turnMultiplier":20,"wheelTurnSpeed":90,"wheelReturnSpeed":90,"dragCoefficient":0.95,"lateralGrip":0.85,"minTurnSpeed":50,"wheelBase":60,"frontWheelDrive":false,"differentialStrength":0.6,"antiRoll":0.3,"handbrakeForce":6,"driftThreshold":0.8,"tractionLoss":0.4,"powerOversteerStrength":1.2,"frontGripAdvantage":0.15,"driftRecoveryRate":1.2,"velocityDriftFactor":0.7,"tractionControlEnabled":false,"tractionControlStrength":0.6,"absEnabled":false,"absStrength":0.8,"showDebugInfo":false,"showWheelDirection":false,"showDriftInfo":false,"upKey":"arrowup","downKey":"arrowdown","leftKey":"arrowleft","rightKey":"arrowright","handbrakeKey":" ","tireMarkOpacity":0.5,"tireMarkScale":1,"tireMarkLifetime":8000,"tireMarkDistanceApart":12,"tireMarkEnabled":true,"tireMarkOffsetX":0,"tireMarkOffsetY":0,"gtaStyleVehicle":true,"enterKey":"enter","enterDistance":80,"hidePlayerWhenInside":true,"showEnterPrompt":true,"ejectOnDestroy":true}},{"type":"Car2","id":"bf108285-ae7d-4ab6-9398-f61bdc215c12","enabled":true,"data":{"name":"Car2","type":"Car2","enabled":true,"requirements":[],"properties":{},"exposedValues":{"scale":0.29,"offsetX":0,"offsetY":0,"flipped":false,"preGenerateImage":false},"scale":0.29,"offsetX":0,"offsetY":0,"flipped":false,"animationSpeed":1,"isPlaying":true,"currentFrame":0,"currentAnimation":"idle"}}]},{"id":"2d5e5ddd-2650-4bf4-be44-45a5250b77c9","name":"Car (Copy)","position":{"x":926.5141373934989,"y":277.72013351370765},"angle":-112.00241851806867,"scale":{"x":1,"y":1},"size":{"width":100,"height":50},"active":true,"visible":true,"depth":0,"modules":[{"type":"RigidBody","id":"17d87909-428c-4af7-9543-138e0a48c2d6","enabled":true,"data":{"name":"RigidBody","type":"RigidBody","enabled":true,"requirements":[],"properties":{},"exposedValues":{"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"restitution":0.4,"useGravity":true,"frictionAir":0.05,"sleepingAllowed":true,"label":"","fixedRotation":false,"isSensor":false},"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"frictionAir":0.05,"restitution":0.4,"fixedRotation":false,"isSensor":false,"useGravity":true,"sleepingAllowed":true,"label":"","collisionFilter":{"category":1,"mask":4294967295,"group":0},"vertices":[]}},{"type":"VehiclePhysics","id":"fe4c1309-578b-4964-bb59-62cc738c42a3","enabled":true,"data":{"name":"VehiclePhysics","type":"VehiclePhysics","enabled":true,"requirements":["RigidBody"],"properties":{},"exposedValues":{"weight":100,"playerControlled":false,"gtaStyleVehicle":true,"maxSpeed":3000,"acceleration":1000,"brakeForce":250,"frontWheelDrive":false,"handbrakeForce":6,"tractionLoss":0.4,"showDebugInfo":false,"showDriftInfo":false},"playerControlled":false,"maxSpeed":3000,"acceleration":1000,"brakeForce":250,"decelerationRate":0.05,"reverseMaxSpeed":250,"maxTurnAngle":45,"turnMultiplier":20,"wheelTurnSpeed":90,"wheelReturnSpeed":90,"dragCoefficient":0.95,"lateralGrip":0.85,"minTurnSpeed":50,"wheelBase":60,"frontWheelDrive":false,"differentialStrength":0.6,"antiRoll":0.3,"handbrakeForce":6,"driftThreshold":0.8,"tractionLoss":0.4,"powerOversteerStrength":1.2,"frontGripAdvantage":0.15,"driftRecoveryRate":1.2,"velocityDriftFactor":0.7,"tractionControlEnabled":false,"tractionControlStrength":0.6,"absEnabled":false,"absStrength":0.8,"showDebugInfo":false,"showWheelDirection":false,"showDriftInfo":false,"upKey":"arrowup","downKey":"arrowdown","leftKey":"arrowleft","rightKey":"arrowright","handbrakeKey":" ","tireMarkOpacity":0.5,"tireMarkScale":1,"tireMarkLifetime":8000,"tireMarkDistanceApart":12,"tireMarkEnabled":true,"tireMarkOffsetX":0,"tireMarkOffsetY":0,"gtaStyleVehicle":true,"enterKey":"enter","enterDistance":80,"hidePlayerWhenInside":true,"showEnterPrompt":true,"ejectOnDestroy":true}},{"type":"Car4","id":"a0bc3817-f819-4df2-a6f6-c356aa7c23b0","enabled":true,"data":{"name":"Car4","type":"Car4","enabled":true,"requirements":[],"properties":{},"exposedValues":{"scale":0.29,"offsetX":0,"offsetY":0,"flipped":false,"preGenerateImage":false},"scale":0.29,"offsetX":0,"offsetY":0,"flipped":false,"animationSpeed":1,"isPlaying":true,"currentFrame":0,"currentAnimation":"idle"}}]},{"id":"3a1831ba-a29f-43f0-8b45-c030577498c2","name":"Car (Copy)","position":{"x":811.3073508451849,"y":287.0612243149223},"angle":-85.10448085386933,"scale":{"x":1,"y":1},"size":{"width":100,"height":50},"active":true,"visible":true,"depth":0,"modules":[{"type":"RigidBody","id":"ed8cfad6-56a0-4945-9894-eff133e4d6b8","enabled":true,"data":{"name":"RigidBody","type":"RigidBody","enabled":true,"requirements":[],"properties":{},"exposedValues":{"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"restitution":0.4,"useGravity":true,"frictionAir":0.02,"sleepingAllowed":true,"label":"","fixedRotation":false,"isSensor":false},"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"frictionAir":0.02,"restitution":0.4,"fixedRotation":false,"isSensor":false,"useGravity":true,"sleepingAllowed":true,"label":"","collisionFilter":{"category":1,"mask":4294967295,"group":0},"vertices":[]}},{"type":"VehiclePhysics","id":"a4830238-73e5-444e-a363-7df62bcd067d","enabled":true,"data":{"name":"VehiclePhysics","type":"VehiclePhysics","enabled":true,"requirements":["RigidBody"],"properties":{},"exposedValues":{"weight":100,"playerControlled":false,"gtaStyleVehicle":true,"maxSpeed":3000,"acceleration":1000,"brakeForce":250,"frontWheelDrive":false,"handbrakeForce":6,"tractionLoss":0.4,"showDebugInfo":false,"showDriftInfo":false},"playerControlled":false,"maxSpeed":3000,"acceleration":1000,"brakeForce":250,"decelerationRate":0.05,"reverseMaxSpeed":250,"maxTurnAngle":45,"turnMultiplier":20,"wheelTurnSpeed":90,"wheelReturnSpeed":90,"dragCoefficient":0.95,"lateralGrip":0.85,"minTurnSpeed":50,"wheelBase":60,"frontWheelDrive":false,"differentialStrength":0.6,"antiRoll":0.3,"handbrakeForce":6,"driftThreshold":0.8,"tractionLoss":0.4,"powerOversteerStrength":1.2,"frontGripAdvantage":0.15,"driftRecoveryRate":1.2,"velocityDriftFactor":0.7,"tractionControlEnabled":false,"tractionControlStrength":0.6,"absEnabled":false,"absStrength":0.8,"showDebugInfo":false,"showWheelDirection":false,"showDriftInfo":false,"upKey":"arrowup","downKey":"arrowdown","leftKey":"arrowleft","rightKey":"arrowright","handbrakeKey":" ","tireMarkOpacity":0.5,"tireMarkScale":1,"tireMarkLifetime":8000,"tireMarkDistanceApart":12,"tireMarkEnabled":true,"tireMarkOffsetX":0,"tireMarkOffsetY":0,"gtaStyleVehicle":true,"enterKey":"enter","enterDistance":80,"hidePlayerWhenInside":true,"showEnterPrompt":true,"ejectOnDestroy":true}},{"type":"Car3","id":"48d38d04-246c-4b4d-b315-71ca1eb18b15","enabled":true,"data":{"name":"Car3","type":"Car3","enabled":true,"requirements":[],"properties":{},"exposedValues":{"scale":0.29,"offsetX":0,"offsetY":0,"flipped":false,"preGenerateImage":false},"scale":0.29,"offsetX":0,"offsetY":0,"flipped":false,"animationSpeed":1,"isPlaying":true,"currentFrame":0,"currentAnimation":"idle"}}]},{"id":"8188760f-1c0e-4b5f-97db-2060844df92f","name":"RoadCone","position":{"x":517.6499865462918,"y":121.90597739114615},"angle":0,"scale":{"x":1,"y":1},"size":{"width":25,"height":25},"active":true,"visible":true,"depth":0,"modules":[{"type":"RoadCone","id":"60fd029d-4c21-46c7-93e3-05a5092ee970","enabled":true,"data":{"name":"RoadCone","type":"RoadCone","enabled":true,"requirements":[],"properties":{},"exposedValues":{"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"preGenerateImage":false},"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"animationSpeed":1,"isPlaying":true,"currentFrame":0,"currentAnimation":"idle"}},{"type":"RigidBody","id":"e3801719-ca3e-414f-b33c-8d83d4db9613","enabled":true,"data":{"name":"RigidBody","type":"RigidBody","enabled":true,"requirements":[],"properties":{},"exposedValues":{"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"restitution":0.1,"useGravity":false,"frictionAir":0.04,"sleepingAllowed":true,"label":"","fixedRotation":false,"isSensor":false},"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"frictionAir":0.04,"restitution":0.1,"fixedRotation":false,"isSensor":false,"useGravity":false,"sleepingAllowed":true,"label":"","collisionFilter":{"category":1,"mask":4294967295,"group":0},"vertices":[]}}]},{"id":"8188760f-1c0e-4b5f-97db-2060844df92f","name":"RoadCone","position":{"x":894.6703566596412,"y":118.13084925016675},"angle":0,"scale":{"x":1,"y":1},"size":{"width":25,"height":25},"active":true,"visible":true,"depth":0,"modules":[{"type":"RoadCone","id":"60fd029d-4c21-46c7-93e3-05a5092ee970","enabled":true,"data":{"name":"RoadCone","type":"RoadCone","enabled":true,"requirements":[],"properties":{},"exposedValues":{"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"preGenerateImage":false},"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"animationSpeed":1,"isPlaying":true,"currentFrame":0,"currentAnimation":"idle"}},{"type":"RigidBody","id":"e3801719-ca3e-414f-b33c-8d83d4db9613","enabled":true,"data":{"name":"RigidBody","type":"RigidBody","enabled":true,"requirements":[],"properties":{},"exposedValues":{"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"restitution":0.1,"useGravity":false,"frictionAir":0.04,"sleepingAllowed":true,"label":"","fixedRotation":false,"isSensor":false},"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"frictionAir":0.04,"restitution":0.1,"fixedRotation":false,"isSensor":false,"useGravity":false,"sleepingAllowed":true,"label":"","collisionFilter":{"category":1,"mask":4294967295,"group":0},"vertices":[]}}]},{"id":"8138eadc-a52a-43ae-a533-e52c56c1f3e5","name":"RoadCone (Copy)","position":{"x":594.0939310357251,"y":122.48702933167277},"angle":0,"scale":{"x":1,"y":1},"size":{"width":25,"height":25},"active":true,"visible":true,"depth":0,"modules":[{"type":"RoadCone","id":"60fd029d-4c21-46c7-93e3-05a5092ee970","enabled":true,"data":{"name":"RoadCone","type":"RoadCone","enabled":true,"requirements":[],"properties":{},"exposedValues":{"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"preGenerateImage":false},"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"animationSpeed":1,"isPlaying":true,"currentFrame":0,"currentAnimation":"idle"}},{"type":"RigidBody","id":"e3801719-ca3e-414f-b33c-8d83d4db9613","enabled":true,"data":{"name":"RigidBody","type":"RigidBody","enabled":true,"requirements":[],"properties":{},"exposedValues":{"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"restitution":0.1,"useGravity":false,"frictionAir":0.04,"sleepingAllowed":true,"label":"","fixedRotation":false,"isSensor":false},"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"frictionAir":0.04,"restitution":0.1,"fixedRotation":false,"isSensor":false,"useGravity":false,"sleepingAllowed":true,"label":"","collisionFilter":{"category":1,"mask":4294967295,"group":0},"vertices":[]}}]},{"id":"f4bdbaaa-5378-4662-a61f-56e331d07061","name":"RoadCone (Copy)","position":{"x":630.395431714942,"y":122.48702933167277},"angle":0,"scale":{"x":1,"y":1},"size":{"width":25,"height":25},"active":true,"visible":true,"depth":0,"modules":[{"type":"RoadCone","id":"60fd029d-4c21-46c7-93e3-05a5092ee970","enabled":true,"data":{"name":"RoadCone","type":"RoadCone","enabled":true,"requirements":[],"properties":{},"exposedValues":{"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"preGenerateImage":false},"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"animationSpeed":1,"isPlaying":true,"currentFrame":0,"currentAnimation":"idle"}},{"type":"RigidBody","id":"e3801719-ca3e-414f-b33c-8d83d4db9613","enabled":true,"data":{"name":"RigidBody","type":"RigidBody","enabled":true,"requirements":[],"properties":{},"exposedValues":{"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"restitution":0.1,"useGravity":false,"frictionAir":0.04,"sleepingAllowed":true,"label":"","fixedRotation":false,"isSensor":false},"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"frictionAir":0.04,"restitution":0.1,"fixedRotation":false,"isSensor":false,"useGravity":false,"sleepingAllowed":true,"label":"","collisionFilter":{"category":1,"mask":4294967295,"group":0},"vertices":[]}}]},{"id":"69b8b2ca-70a0-4786-b964-a358a6a4aa82","name":"RoadCone (Copy)","position":{"x":666.6969323941589,"y":119.58290927733542},"angle":0,"scale":{"x":1,"y":1},"size":{"width":25,"height":25},"active":true,"visible":true,"depth":0,"modules":[{"type":"RoadCone","id":"60fd029d-4c21-46c7-93e3-05a5092ee970","enabled":true,"data":{"name":"RoadCone","type":"RoadCone","enabled":true,"requirements":[],"properties":{},"exposedValues":{"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"preGenerateImage":false},"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"animationSpeed":1,"isPlaying":true,"currentFrame":0,"currentAnimation":"idle"}},{"type":"RigidBody","id":"e3801719-ca3e-414f-b33c-8d83d4db9613","enabled":true,"data":{"name":"RigidBody","type":"RigidBody","enabled":true,"requirements":[],"properties":{},"exposedValues":{"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"restitution":0.1,"useGravity":false,"frictionAir":0.04,"sleepingAllowed":true,"label":"","fixedRotation":false,"isSensor":false},"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"frictionAir":0.04,"restitution":0.1,"fixedRotation":false,"isSensor":false,"useGravity":false,"sleepingAllowed":true,"label":"","collisionFilter":{"category":1,"mask":4294967295,"group":0},"vertices":[]}}]},{"id":"35594bf5-c9d4-450b-b249-f6bdd217c426","name":"RoadCone (Copy)","position":{"x":705.9025531277132,"y":119.58290927733542},"angle":0,"scale":{"x":1,"y":1},"size":{"width":25,"height":25},"active":true,"visible":true,"depth":0,"modules":[{"type":"RoadCone","id":"60fd029d-4c21-46c7-93e3-05a5092ee970","enabled":true,"data":{"name":"RoadCone","type":"RoadCone","enabled":true,"requirements":[],"properties":{},"exposedValues":{"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"preGenerateImage":false},"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"animationSpeed":1,"isPlaying":true,"currentFrame":0,"currentAnimation":"idle"}},{"type":"RigidBody","id":"e3801719-ca3e-414f-b33c-8d83d4db9613","enabled":true,"data":{"name":"RigidBody","type":"RigidBody","enabled":true,"requirements":[],"properties":{},"exposedValues":{"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"restitution":0.1,"useGravity":false,"frictionAir":0.04,"sleepingAllowed":true,"label":"","fixedRotation":false,"isSensor":false},"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"frictionAir":0.04,"restitution":0.1,"fixedRotation":false,"isSensor":false,"useGravity":false,"sleepingAllowed":true,"label":"","collisionFilter":{"category":1,"mask":4294967295,"group":0},"vertices":[]}}]},{"id":"e5a7524f-1938-4dd1-9fee-efeb0613f4f5","name":"RoadCone (Copy)","position":{"x":740.7519937797614,"y":119.58290927733542},"angle":0,"scale":{"x":1,"y":1},"size":{"width":25,"height":25},"active":true,"visible":true,"depth":0,"modules":[{"type":"RoadCone","id":"60fd029d-4c21-46c7-93e3-05a5092ee970","enabled":true,"data":{"name":"RoadCone","type":"RoadCone","enabled":true,"requirements":[],"properties":{},"exposedValues":{"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"preGenerateImage":false},"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"animationSpeed":1,"isPlaying":true,"currentFrame":0,"currentAnimation":"idle"}},{"type":"RigidBody","id":"e3801719-ca3e-414f-b33c-8d83d4db9613","enabled":true,"data":{"name":"RigidBody","type":"RigidBody","enabled":true,"requirements":[],"properties":{},"exposedValues":{"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"restitution":0.1,"useGravity":false,"frictionAir":0.04,"sleepingAllowed":true,"label":"","fixedRotation":false,"isSensor":false},"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"frictionAir":0.04,"restitution":0.1,"fixedRotation":false,"isSensor":false,"useGravity":false,"sleepingAllowed":true,"label":"","collisionFilter":{"category":1,"mask":4294967295,"group":0},"vertices":[]}}]},{"id":"63deff8c-7929-428c-bf8c-2539708a01de","name":"RoadCone (Copy)","position":{"x":775.6014344318097,"y":118.13084925016676},"angle":0,"scale":{"x":1,"y":1},"size":{"width":25,"height":25},"active":true,"visible":true,"depth":0,"modules":[{"type":"RoadCone","id":"60fd029d-4c21-46c7-93e3-05a5092ee970","enabled":true,"data":{"name":"RoadCone","type":"RoadCone","enabled":true,"requirements":[],"properties":{},"exposedValues":{"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"preGenerateImage":false},"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"animationSpeed":1,"isPlaying":true,"currentFrame":0,"currentAnimation":"idle"}},{"type":"RigidBody","id":"e3801719-ca3e-414f-b33c-8d83d4db9613","enabled":true,"data":{"name":"RigidBody","type":"RigidBody","enabled":true,"requirements":[],"properties":{},"exposedValues":{"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"restitution":0.1,"useGravity":false,"frictionAir":0.04,"sleepingAllowed":true,"label":"","fixedRotation":false,"isSensor":false},"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"frictionAir":0.04,"restitution":0.1,"fixedRotation":false,"isSensor":false,"useGravity":false,"sleepingAllowed":true,"label":"","collisionFilter":{"category":1,"mask":4294967295,"group":0},"vertices":[]}}]},{"id":"c98a8c6b-e231-43d8-a5c7-719f73ddd09e","name":"RoadCone (Copy)","position":{"x":808.9988150566893,"y":118.13084925016675},"angle":0,"scale":{"x":1,"y":1},"size":{"width":25,"height":25},"active":true,"visible":true,"depth":0,"modules":[{"type":"RoadCone","id":"60fd029d-4c21-46c7-93e3-05a5092ee970","enabled":true,"data":{"name":"RoadCone","type":"RoadCone","enabled":true,"requirements":[],"properties":{},"exposedValues":{"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"preGenerateImage":false},"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"animationSpeed":1,"isPlaying":true,"currentFrame":0,"currentAnimation":"idle"}},{"type":"RigidBody","id":"e3801719-ca3e-414f-b33c-8d83d4db9613","enabled":true,"data":{"name":"RigidBody","type":"RigidBody","enabled":true,"requirements":[],"properties":{},"exposedValues":{"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"restitution":0.1,"useGravity":false,"frictionAir":0.04,"sleepingAllowed":true,"label":"","fixedRotation":false,"isSensor":false},"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"frictionAir":0.04,"restitution":0.1,"fixedRotation":false,"isSensor":false,"useGravity":false,"sleepingAllowed":true,"label":"","collisionFilter":{"category":1,"mask":4294967295,"group":0},"vertices":[]}}]},{"id":"ed80698d-a72f-4e3f-8e93-4dd23aeb159f","name":"RoadCone (Copy)","position":{"x":845.3003157359061,"y":119.58290927733543},"angle":0,"scale":{"x":1,"y":1},"size":{"width":25,"height":25},"active":true,"visible":true,"depth":0,"modules":[{"type":"RoadCone","id":"60fd029d-4c21-46c7-93e3-05a5092ee970","enabled":true,"data":{"name":"RoadCone","type":"RoadCone","enabled":true,"requirements":[],"properties":{},"exposedValues":{"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"preGenerateImage":false},"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"animationSpeed":1,"isPlaying":true,"currentFrame":0,"currentAnimation":"idle"}},{"type":"RigidBody","id":"e3801719-ca3e-414f-b33c-8d83d4db9613","enabled":true,"data":{"name":"RigidBody","type":"RigidBody","enabled":true,"requirements":[],"properties":{},"exposedValues":{"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"restitution":0.1,"useGravity":false,"frictionAir":0.04,"sleepingAllowed":true,"label":"","fixedRotation":false,"isSensor":false},"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"frictionAir":0.04,"restitution":0.1,"fixedRotation":false,"isSensor":false,"useGravity":false,"sleepingAllowed":true,"label":"","collisionFilter":{"category":1,"mask":4294967295,"group":0},"vertices":[]}}]},{"id":"9dac05f7-fcbd-45ee-9ae0-fe48efe2e7ce","name":"RoadCone (Copy)","position":{"x":554.8883103021708,"y":121.03496930450409},"angle":0,"scale":{"x":1,"y":1},"size":{"width":25,"height":25},"active":true,"visible":true,"depth":0,"modules":[{"type":"RoadCone","id":"60fd029d-4c21-46c7-93e3-05a5092ee970","enabled":true,"data":{"name":"RoadCone","type":"RoadCone","enabled":true,"requirements":[],"properties":{},"exposedValues":{"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"preGenerateImage":false},"scale":0.1,"offsetX":0,"offsetY":0,"flipped":false,"animationSpeed":1,"isPlaying":true,"currentFrame":0,"currentAnimation":"idle"}},{"type":"RigidBody","id":"e3801719-ca3e-414f-b33c-8d83d4db9613","enabled":true,"data":{"name":"RigidBody","type":"RigidBody","enabled":true,"requirements":[],"properties":{},"exposedValues":{"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"restitution":0.1,"useGravity":false,"frictionAir":0.04,"sleepingAllowed":true,"label":"","fixedRotation":false,"isSensor":false},"bodyType":"dynamic","shape":"rectangle","width":50,"height":50,"radius":25,"density":1,"friction":0.8,"frictionAir":0.04,"restitution":0.1,"fixedRotation":false,"isSensor":false,"useGravity":false,"sleepingAllowed":true,"label":"","collisionFilter":{"category":1,"mask":4294967295,"group":0},"vertices":[]}}]}]}],
            assets: {"/generated_texture.png":{"content":"data:image/png;base64,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","type":"image/png"},"generated_texture.png":{"content":"data:image/png;base64,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","type":"image/png","source":"fileBrowser"}},
            prefabs: {}
        };
    } catch (error) {
        console.error('Error parsing game data:', error);
        loadingScreen.innerHTML = '<div>Error loading game data: ' + error.message + '</div>';
        return;
    }
    
    // Pre-load assets for standalone mode
    
    if (gameData.assets) {
        console.log('Pre-caching embedded assets...');
        console.log('Assets to cache:', Object.keys(gameData.assets));
        
        window.assetManager.addEmbeddedAssets(gameData.assets);
        
        console.log('Asset caching completed.');
        console.log('Final asset cache keys:', Object.keys(window.assetManager.cache));
    }
    
    // Initialize engine with WebGL option
    const canvas = document.getElementById('gameCanvas');

    // Get actual viewport dimensions
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;

    // Set canvas to match viewport
    canvas.width = viewportWidth;
    canvas.height = viewportHeight;

    const engineOptions = { 
        useWebGL: true,
        enableFullscreen: true,
        pixelWidth: viewportWidth,
        pixelHeight: viewportHeight,
        pixelScale: 1
    };

    const engine = new Engine(canvas, engineOptions);

    if (gameData.prefabs && Object.keys(gameData.prefabs).length > 0) {
        console.log('Loading', Object.keys(gameData.prefabs).length, 'prefabs...');
        
        // Load into global prefab manager first
        window.prefabManager.loadPrefabs(gameData.prefabs);
        
        // Then load into engine
        if (typeof engine.loadPrefabs === 'function') {
            engine.loadPrefabs(gameData.prefabs);
        }
        
        console.log('Prefabs loaded. Available in global manager:', window.prefabManager.getAllPrefabNames());
        console.log('Available in engine:', engine.getAvailablePrefabs());
    } else {
        console.warn('No prefabs found in game data');
    }
    
    engine.updateFPSLimit(60);
    
    this.ctx = canvas.ctx;
    
    // Make engine globally available for prefab instantiation
    window.engine = engine;
    
    // CRITICAL: Load prefabs into the engine BEFORE scene loading
    if (gameData.prefabs) {
        console.log('Loading prefabs into engine...');
        engine.loadPrefabs(gameData.prefabs);
        
        // Also ensure global prefab manager has the data
        if (window.prefabManager && typeof window.prefabManager.loadPrefabs === 'function') {
            window.prefabManager.loadPrefabs(gameData.prefabs);
        }
        
        console.log('Prefabs loaded. Available prefabs:', engine.getAvailablePrefabs());
    }

    // Add resize handler to engine
    engine.handleResize = function(width, height) {
        this.canvas.width = width;
        this.canvas.height = height;
        this.width = width;
        this.height = height;
        
        // Update WebGL viewport if using WebGL
        if (this.ctx && this.ctx.gl) {
            this.ctx.gl.viewport(0, 0, width, height);
        }
        
        // Update camera bounds if camera exists
        if (this.camera) {
            // Keep camera centered but update bounds
            this.camera.updateBounds(width, height);
        }
        
        console.log('Engine resized to:', width, 'x', height);
    };
    
    // CRITICAL: Connect physics to engine properly
    if (window.physicsManager) {
        console.log('Connecting physics to engine...');
        
        // Store original methods
        const originalEngineUpdate = engine.update.bind(engine);
        const originalEngineDraw = engine.draw.bind(engine);
        
        // Override engine update to include physics
        engine.update = function(deltaTime) {
            // Update physics first
            if (window.physicsManager && window.physicsManager.update) {
                window.physicsManager.update(deltaTime);
            }
            
            // Then update game objects
            originalEngineUpdate(deltaTime);
        };
        
        // Override engine draw to include physics debug
        engine.draw = function() {
            // Draw game objects
            originalEngineDraw();
            
            // Draw physics debug if enabled
            if (window.physicsManager && window.physicsManager.drawDebug && this.ctx) {
                window.physicsManager.drawDebug(this.ctx);
            }
        };
        
        console.log('Matter Physics connected to engine successfully');
    } else {
        console.error('Physics manager not found during engine setup');
    }
    
    // Setup canvas scaling
    function resizeCanvas() {
        const container = document.getElementById('game-container');
        const canvas = document.getElementById('gameCanvas');
        
        if (!canvas || !container) return;
        
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;
        const originalWidth = 800;
        const originalHeight = 600;
        
        const scaleX = containerWidth / originalWidth;
        const scaleY = containerHeight / originalHeight;
        const scale = Math.min(scaleX, scaleY);
        
        const scaledWidth = originalWidth * scale;
        const scaledHeight = originalHeight * scale;
        
        canvas.style.width = scaledWidth + 'px';
        canvas.style.height = scaledHeight + 'px';
        canvas.style.position = 'absolute';
        canvas.style.left = '50%';
        canvas.style.top = '50%';
        canvas.style.transform = 'translate(-50%, -50%)';
    }
    
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // Load scenes
    const scenes = gameData.scenes || [];
    const loadedScenes = [];
    
    scenes.forEach(sceneData => {
        const scene = new Scene(sceneData.name);
        scene.settings = sceneData.settings;
        
        sceneData.gameObjects.forEach(objData => {
            const gameObject = createGameObjectFromData(objData);
            scene.gameObjects.push(gameObject);
        });
        
        loadedScenes.push(scene);
    });
    
    // Function to create game object from serialized data
    function createGameObjectFromData(data) {
        console.log('Creating game object:', data.name, 'with', data.modules?.length || 0, 'modules');
        
        const obj = new GameObject(data.name);
        if (data.id) obj.id = data.id;

        obj.position = new Vector2(data.position.x, data.position.y);
        obj.angle = (typeof data.angle === 'number') ? data.angle : 0;
        obj.depth = data.depth;
        obj.useCollisions = data.useCollisions || false;
        obj.size = data.size ? new Vector2(data.size.width, data.size.height) : new Vector2(50, 50);

        // Restore scale if available
        if (data.scale) obj.scale = new Vector2(data.scale.x, data.scale.y);
        obj.editorColor = data.editorColor || obj.generateRandomColor();

        if (data.polygonPointCount !== undefined) {
            obj.polygonPointCount = data.polygonPointCount;
        }
        if (data.polygonPoints && Array.isArray(data.polygonPoints)) {
            obj.polygonPoints = data.polygonPoints.map(pt => new Vector2(pt.x, pt.y));
            // Pass parent, position, ...points
            obj.polygon = new Polygon(obj, obj.position.clone(), ...obj.polygonPoints.map(pt => pt.clone()));
        }

        if (data.usePolygonCollision !== undefined) {
            obj.usePolygonCollision = data.usePolygonCollision;
        }

        obj.active = data.active;
        if (data.visible !== undefined) obj.visible = data.visible;
        obj.tags = Array.isArray(data.tags) ? [...data.tags] : [];

        if (data.collisionEnabled !== undefined) obj.collisionEnabled = data.collisionEnabled;
        if (data.collisionLayer !== undefined) obj.collisionLayer = data.collisionLayer;
        if (data.collisionMask !== undefined) obj.collisionMask = data.collisionMask;

        // Add modules
        if (data.modules && data.modules.length > 0) {
            data.modules.forEach(moduleData => {
                console.log('Adding module:', moduleData.type, 'to', data.name);
                
                const ModuleClass = window.moduleRegistry.getModuleClass(moduleData.type);
                if (ModuleClass) {
                    const module = new ModuleClass();
                    module.enabled = moduleData.enabled;
                    module.id = moduleData.id;
                    
                    // CRITICAL: Skip body creation during deserialization for RigidBody
                    //if (module.constructor.name === 'RigidBody') {
                    //    module._skipRebuild = false;
                    //}
                    
                    // Restore module data
                    if (moduleData.data) {
                        if (typeof module.fromJSON === 'function') {
                            try {
                                module.fromJSON(moduleData.data);
                                console.log('Module data restored via fromJSON for:', moduleData.type);
                            } catch (error) {
                                console.error('Error restoring module data via fromJSON:', error);
                                if (moduleData.data.properties) {
                                    Object.keys(moduleData.data.properties).forEach(key => {
                                        if (key in module) {
                                            module[key] = moduleData.data.properties[key];
                                        }
                                    });
                                }
                            }
                        } else {
                            const sourceData = moduleData.data.properties || moduleData.data;
                            Object.keys(sourceData).forEach(key => {
                                if (key in module) {
                                    module[key] = sourceData[key];
                                }
                            });
                        }
                    }
                    
                    // Re-enable body creation after data restoration
                    //if (module.constructor.name === 'RigidBody') {
                    //    module._skipRebuild = false;
                        // Ensure pending creation is set for later initialization
                    //    module.pendingBodyCreation = true;
                    //}
                    
                    obj.addModule(module);
                    console.log('Successfully added module:', moduleData.type);
                }
            });
        }
        
        // Add children
        if (data.children) {
            data.children.forEach(childData => {
                const child = createGameObjectFromData(childData);
                obj.addChild(child);
            });
        }
        
        return obj;
    }
    
    // Start the game with the selected starting scene
    if (loadedScenes.length > 0) {
        try {
            const startingSceneIndex = 0;
            const sceneToLoad = loadedScenes[startingSceneIndex] || loadedScenes[0];
            console.log('Loading starting scene:', sceneToLoad.name, 'at index:', startingSceneIndex);
            
            engine.loadScene(sceneToLoad);
            await engine.start();
            loadingScreen.style.display = 'none';
            console.log('Game started successfully with scene:', sceneToLoad.name);
        } catch (error) {
            console.error('Failed to start game:', error);
            loadingScreen.innerHTML = '<div>Error loading game: ' + error.message + '</div>';
        }
    } else {
        loadingScreen.innerHTML = '<div>No scenes found</div>';
    }
}

// Wait for both DOM and Matter.js to be ready
document.addEventListener('DOMContentLoaded', function() {
    const startBtn = document.getElementById('start-game-btn');
    if (startBtn) {
        startBtn.addEventListener('click', function() {
            // Hide button and loading screen
            startBtn.style.display = 'none';
            const loadingScreen = document.getElementById('loading-screen');
            if (loadingScreen) loadingScreen.style.display = 'none';

            // Resume AudioContext if needed
            if (window.melodicode && window.melodicode.audioEngine && window.melodicode.audioEngine.context) {
                window.melodicode.audioEngine.context.resume();
            }

            // Trigger game initialization if not already started
            if (typeof initializeGame === 'function') {
                initializeGame();
            }
        });
    }
});


// Only start game after Start Game button is pressed
document.addEventListener('DOMContentLoaded', function() {
    const startBtn = document.getElementById('start-game-btn');
    if (startBtn) {
        startBtn.addEventListener('click', function() {
            // Hide button and loading screen
            startBtn.style.display = 'none';
            const loadingScreen = document.getElementById('loading-screen');
            if (loadingScreen) loadingScreen.style.display = 'none';

            // Resume AudioContext if needed
            if (window.melodicode && window.melodicode.audioEngine && window.melodicode.audioEngine.context) {
                window.melodicode.audioEngine.context.resume();
            }

            // Trigger game initialization if not already started
            if (typeof initializeGame === 'function') {
                initializeGame();
            }
        });
    }
});
</script>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="loading-screen" style="background:#000000;">
            <div class="loading-content">
                <img class="loading-logo" src="data:image/png;base64,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" alt="Logo">
                <button id="start-game-btn" style="
                    margin-top:32px;
                    padding: 16px 48px;
                    font-size: 1.4em;
                    font-weight: bold;
                    color: #fff;
                    background: #922e99;
                    border: none;
                    border-radius: 32px;
                    box-shadow: 0 2px 16px 0 #922e9944;
                    cursor: pointer;
                    transition: background 0.2s, box-shadow 0.2s;
                    outline: none;
                    letter-spacing: 1px;
                ">Start Game</button>
                <button id="load-game-btn" style="
                    margin-top:12px;
                    padding: 12px 32px;
                    font-size: 1.1em;
                    font-weight: bold;
                    color: #fff;
                    background: #922e99; // <-- changed from #444
                    border: none;
                    border-radius: 24px;
                    box-shadow: 0 2px 8px 0 #922e9944;
                    cursor: pointer;
                    transition: background 0.2s, box-shadow 0.2s;
                    outline: none;
                    letter-spacing: 1px;
                ">Load Game</button>
            </div>
        </div>
    </div>
</body>
</html>