{
  "name": "3D",
  "description": "3D Rendering using context 2D. Basic lighting, skybox, specular highlighting",
  "version": "1.5.0",
  "author": "SynKrown",
  "timestamp": 1759625090693,
  "icon": {
    "data": "data:image/png;base64,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",
    "originalName": "Generated Image October 03, 2025 - 3_09PM.png",
    "size": 367898
  },
  "directories": [],
  "totalFiles": 7,
  "totalDirectories": 0,
  "files": [
    {
      "path": "/Assets/2D Context 3D Renderer/Camera3DRasterizer.js",
      "content": "/**\n * Camera3DRasterizer - Module for 3D perspective cameras\n * \n * This module provides 3D camera functionality with multiple rendering methods.\n * Supports: Rasterization Algorithm.\n * \n * Axis orientation:\n *  - X axis: Forward/Backward\n *  - Y axis: Left/Right\n *  - Z axis: Up/Down\n */\nclass Camera3DRasterizer extends Module {\n    static namespace = \"3D\";\n\n    constructor() {\n        super(\"Camera3DRasterizer\");\n\n        this._position = new Vector3(0, 0, 0);\n        this._rotation = new Vector3(0, 0, 0);\n        this._fieldOfView = 60;\n        this._nearPlane = 0.1;\n        this._farPlane = 5000;\n        this._isActive = false;\n        this._backgroundColor = \"#000000\";\n        this._renderTextureWidth = 320;\n        this._renderTextureHeight = 240;\n        this._renderTextureSmoothing = false;\n        this._renderTexture = null;\n        this._renderTextureCtx = null;\n        this.viewportWidth = 800;\n        this.viewportHeight = 600;\n        this.drawGizmoInRuntime = false;\n        this._renderingMethod = \"raster\";\n        this._enableBackfaceCulling = true;\n        this._zBuffer = null;\n        this._imageData = null;\n\n        // Lighting properties\n        this._lightDirection = new Vector3(1, -1, -1); // Default light direction\n        this._lightColor = \"#ffffff\";\n        this._lightIntensity = 1.0;\n        this._ambientIntensity = 0.3;\n\n        // Dynamic lighting properties\n        this._dynamicLights = []; // Array of Light3D modules\n        this._maxLights = 4; // Maximum number of lights to process\n        this._lightFindDistance = 500; // Distance to search for lights\n        this._useDynamicLighting = true; // Enable/disable dynamic lights\n\n        // Background properties\n        this._skyColor = \"#87CEEB\";  // Sky blue\n        this._floorColor = \"#8B4513\"; // Brown\n        this._skyColorHorizon = \"#af686cff\"; // Sky at horizon (default same as sky)\n        this._floorColorHorizon = \"#653721ff\"; // Floor at horizon (darker brown)\n        this._backgroundType = \"skybox\"; // \"skybox\", \"transparent\", \"solid\"\n\n        // Cloud properties\n        this._cloudsEnabled = true;\n        this._cloudSpeed = 0.5; // Speed multiplier for cloud movement\n        this._cloudDensity = 0.4; // 0-1, how much cloud coverage\n        this._cloudScale = 150; // Size of cloud patterns (larger = bigger clouds)\n        this._cloudSoftness = 0.6; // 0-1, edge softness\n        this._cloudHeight = 0.3; // 0-1, where clouds appear (0=horizon, 1=zenith)\n        this._cloudThickness = 0.4; // 0-1, vertical extent of cloud layer\n        this._cloudBrightness = 1.0; // Cloud color brightness multiplier\n        this._cloudTime = 0; // Animation time tracker\n        this._cloudNoiseCache = null; // Cache for performance\n        this._cloudResolution = 0.5; // 1.0 = full res, 0.5 = half res, etc.\n\n        // Water animation properties\n        this._waterEnabled = false;\n        this._waterSpeed = 1.0; // Speed multiplier for wave animation\n        this._waterWaveHeight = 10; // Height of wave pattern in pixels\n        this._waterTime = 0; // Animation time tracker\n\n        // Sun properties (Sun is always in light direction and colored as light color)\n        this._showSun = true;\n        this._sunSize = 30; // Radius in pixels\n        this._sunGlowSize = 60; // Glow radius in pixels\n\n        // Lens flare properties\n        this._lensFlareEnabled = true;\n        this._lensFlareIntensity = 0.8; // 0-1 intensity multiplier\n        this._lensFlareCount = 5; // Number of flare elements\n        this._lensFlareSpacing = 0.15; // Distance between flares (0-1, screen space)\n        this._lensFlareSize = 20; // Base size of flare elements\n        this._lensFlareColorShift = true; // Apply chromatic aberration to flares\n\n        // Specular properties\n        this._specularEnabled = true;\n        this._specularBleedingEnabled = false;\n        this._specularPerMesh = false;\n        this._specularFullFace = true;\n\n        // Specular bloom properties\n        this._specularBloomEnabled = false;\n        this._specularBloomIntensity = 0.5;\n        this._specularBloomRadius = 2.5; // Multiplier for base radius\n        this._specularBloomThreshold = 0.3; // Minimum specular intensity to trigger bloom\n\n        // Emissive properties\n        this._emissiveIntensity = 1.0; // Emissive color brightness multiplier\n\n        // Fog properties\n        this._fogEnabled = false;\n        this._fogColor = \"#a0a0a0\"; // Gray fog\n        this._fogStart = 600; // Distance where fog starts\n        this._fogEnd = 2000; // Distance where fog is fully opaque\n        this._fogDensity = 1.0; // Fog density multiplier (0-1)\n\n        // Debug properties\n        this._showDebugInfo = false;\n        this._debugStats = {\n            totalFaces: 0,\n            renderedTriangles: 0,\n            culledFaces: 0,\n            clippedFaces: 0,\n            specularHighlights: 0,\n            renderTime: 0\n        };\n\n        this.exposeProperty(\"position\", \"vector3\", this._position, {\n            onChange: (val) => this._position = val\n        });\n        this.exposeProperty(\"rotation\", \"vector3\", this._rotation, {\n            onChange: (val) => this._rotation = val\n        });\n        this.exposeProperty(\"fieldOfView\", \"number\", 60, {\n            min: 1, max: 179, onChange: (val) => this._fieldOfView = val\n        });\n        this.exposeProperty(\"nearPlane\", \"number\", 0.1, {\n            min: 0.01, max: 10, step: 0.01, onChange: (val) => this._nearPlane = val\n        });\n        this.exposeProperty(\"farPlane\", \"number\", 1000, {\n            min: 10, max: 10000, step: 1, onChange: (val) => this._farPlane = val\n        });\n        this.exposeProperty(\"isActive\", \"boolean\", false, {\n            onChange: (val) => {\n                this._isActive = val;\n                if (val) this.setAsActiveCamera();\n            }\n        });\n        this.exposeProperty(\"backgroundColor\", \"color\", \"#000000\", {\n            onChange: (val) => this._backgroundColor = val\n        });\n        this.exposeProperty(\"drawGizmoInRuntime\", \"boolean\", false, {\n            onChange: (val) => this.drawGizmoInRuntime = val\n        });\n        this.exposeProperty(\"renderTextureWidth\", \"number\", 512, {\n            min: 64, max: 2048, step: 64,\n            onChange: (val) => {\n                this._renderTextureWidth = val;\n                this.updateRenderTexture();\n            }\n        });\n        this.exposeProperty(\"renderTextureHeight\", \"number\", 512, {\n            min: 64, max: 2048, step: 64,\n            onChange: (val) => {\n                this._renderTextureHeight = val;\n                this.updateRenderTexture();\n            }\n        });\n        this.exposeProperty(\"renderTextureSmoothing\", \"boolean\", false, {\n            onChange: (val) => this._renderTextureSmoothing = val\n        });\n        this.exposeProperty(\"renderingMethod\", \"dropdown\", \"raster\", {\n            options: [\"raster\"],\n            onChange: (val) => this._renderingMethod = val\n        });\n        this.exposeProperty(\"enableBackfaceCulling\", \"boolean\", true, {\n            onChange: (val) => this._enableBackfaceCulling = val\n        });\n\n        this.exposeProperty(\"lightDirection\", \"vector3\", this._lightDirection, {\n            onChange: (val) => this._lightDirection = val\n        });\n        this.exposeProperty(\"lightColor\", \"color\", \"#ffffff\", {\n            onChange: (val) => this._lightColor = val\n        });\n        this.exposeProperty(\"lightIntensity\", \"number\", 1.0, {\n            min: 0, max: 2, step: 0.1, onChange: (val) => this._lightIntensity = val\n        });\n        this.exposeProperty(\"ambientIntensity\", \"number\", 0.3, {\n            min: 0, max: 1, step: 0.05, onChange: (val) => this._ambientIntensity = val\n        });\n\n        this.exposeProperty(\"maxLights\", \"number\", this._maxLights, {\n            min: 0,\n            max: 16,\n            step: 1,\n            onChange: (val) => this._maxLights = val\n        });\n\n        this.exposeProperty(\"lightFindDistance\", \"number\", this._lightFindDistance, {\n            min: 50,\n            max: 2000,\n            step: 50,\n            onChange: (val) => this._lightFindDistance = val\n        });\n\n        this.exposeProperty(\"useDynamicLighting\", \"boolean\", this._useDynamicLighting, {\n            onChange: (val) => this._useDynamicLighting = val\n        });\n\n\n        this.exposeProperty(\"backgroundType\", \"dropdown\", \"skybox\", {\n            options: [\"skybox\", \"transparent\", \"solid\"],\n            onChange: (val) => this._backgroundType = val\n        });\n        this.exposeProperty(\"backgroundColor\", \"color\", \"#000000\", {\n            onChange: (val) => this._backgroundColor = val\n        });\n        this.exposeProperty(\"skyColor\", \"color\", \"#87CEEB\", {\n            onChange: (val) => this._skyColor = val\n        });\n        this.exposeProperty(\"skyColorHorizon\", \"color\", \"#87CEEB\", {\n            onChange: (val) => this._skyColorHorizon = val\n        });\n        this.exposeProperty(\"floorColor\", \"color\", \"#8B4513\", {\n            onChange: (val) => this._floorColor = val\n        });\n        this.exposeProperty(\"floorColorHorizon\", \"color\", \"#654321\", {\n            onChange: (val) => this._floorColorHorizon = val\n        });\n\n        this.exposeProperty(\"cloudsEnabled\", \"boolean\", false, {\n            onChange: (val) => this._cloudsEnabled = val\n        });\n        this.exposeProperty(\"cloudSpeed\", \"number\", 0.5, {\n            min: 0.1,\n            max: 3.0,\n            step: 0.1,\n            onChange: (val) => this._cloudSpeed = val\n        });\n        this.exposeProperty(\"cloudDensity\", \"number\", 0.4, {\n            min: 0,\n            max: 1,\n            step: 0.05,\n            onChange: (val) => this._cloudDensity = val\n        });\n        this.exposeProperty(\"cloudScale\", \"number\", 150, {\n            min: 50,\n            max: 500,\n            step: 10,\n            onChange: (val) => this._cloudScale = val\n        });\n        this.exposeProperty(\"cloudSoftness\", \"number\", 0.6, {\n            min: 0,\n            max: 1,\n            step: 0.05,\n            onChange: (val) => this._cloudSoftness = val\n        });\n        this.exposeProperty(\"cloudHeight\", \"number\", 0.3, {\n            min: 0,\n            max: 1,\n            step: 0.05,\n            onChange: (val) => this._cloudHeight = val\n        });\n        this.exposeProperty(\"cloudThickness\", \"number\", 0.4, {\n            min: 0.1,\n            max: 1,\n            step: 0.05,\n            onChange: (val) => this._cloudThickness = val\n        });\n        this.exposeProperty(\"cloudBrightness\", \"number\", 1.0, {\n            min: 0.5,\n            max: 2.0,\n            step: 0.1,\n            onChange: (val) => this._cloudBrightness = val\n        });\n        this.exposeProperty(\"cloudResolution\", \"number\", 1.0, {\n            min: 0.25,\n            max: 1.0,\n            step: 0.05,\n            onChange: (val) => this._cloudResolution = val\n        });\n\n        this.exposeProperty(\"waterEnabled\", \"boolean\", false, {\n            onChange: (val) => this._waterEnabled = val\n        });\n        this.exposeProperty(\"waterSpeed\", \"number\", 1.0, {\n            min: 0.1,\n            max: 5.0,\n            step: 0.1,\n            onChange: (val) => this._waterSpeed = val\n        });\n        this.exposeProperty(\"waterWaveHeight\", \"number\", 10, {\n            min: 1,\n            max: 50,\n            step: 1,\n            onChange: (val) => this._waterWaveHeight = val\n        });\n\n        this.exposeProperty(\"showSun\", \"boolean\", true, {\n            onChange: (val) => this._showSun = val\n        });\n        this.exposeProperty(\"sunSize\", \"number\", 30, {\n            min: 10,\n            max: 100,\n            step: 5,\n            onChange: (val) => this._sunSize = val\n        });\n        this.exposeProperty(\"sunGlowSize\", \"number\", 60, {\n            min: 20,\n            max: 200,\n            step: 10,\n            onChange: (val) => this._sunGlowSize = val\n        });\n\n        this.exposeProperty(\"lensFlareEnabled\", \"boolean\", true, {\n            onChange: (val) => this._lensFlareEnabled = val\n        });\n        this.exposeProperty(\"lensFlareIntensity\", \"number\", 0.8, {\n            min: 0,\n            max: 1,\n            step: 0.1,\n            onChange: (val) => this._lensFlareIntensity = val\n        });\n        this.exposeProperty(\"lensFlareCount\", \"number\", 5, {\n            min: 1,\n            max: 10,\n            step: 1,\n            onChange: (val) => this._lensFlareCount = val\n        });\n        this.exposeProperty(\"lensFlareSpacing\", \"number\", 0.15, {\n            min: 0.05,\n            max: 0.5,\n            step: 0.05,\n            onChange: (val) => this._lensFlareSpacing = val\n        });\n        this.exposeProperty(\"lensFlareSize\", \"number\", 20, {\n            min: 5,\n            max: 50,\n            step: 5,\n            onChange: (val) => this._lensFlareSize = val\n        });\n        this.exposeProperty(\"lensFlareColorShift\", \"boolean\", true, {\n            onChange: (val) => this._lensFlareColorShift = val\n        });\n\n        this.exposeProperty(\"specularEnabled\", \"boolean\", true, {\n            onChange: (val) => this._specularEnabled = val\n        });\n        /*this.exposeProperty(\"specularBleedingEnabled\", \"boolean\", true, {\n            onChange: (val) => this._specularBleedingEnabled = val\n        });*/\n        /*this.exposeProperty(\"specularPerMesh\", \"boolean\", false, {\n            onChange: (val) => this._specularPerMesh = val\n        });*/\n        this.exposeProperty(\"specularFullFace\", \"boolean\", false, {\n            onChange: (val) => this._specularFullFace = val\n        });\n\n        this.exposeProperty(\"specularBloomEnabled\", \"boolean\", false, {\n            onChange: (val) => this._specularBloomEnabled = val\n        });\n        this.exposeProperty(\"specularBloomIntensity\", \"number\", 0.5, {\n            min: 0,\n            max: 1,\n            step: 0.05,\n            onChange: (val) => this._specularBloomIntensity = val\n        });\n        this.exposeProperty(\"specularBloomRadius\", \"number\", 1.5, {\n            min: 1.0,\n            max: 3.0,\n            step: 0.1,\n            onChange: (val) => this._specularBloomRadius = val\n        });\n        this.exposeProperty(\"specularBloomThreshold\", \"number\", 0.3, {\n            min: 0,\n            max: 1,\n            step: 0.05,\n            onChange: (val) => this._specularBloomThreshold = val\n        });\n\n        this.exposeProperty(\"emissiveIntensity\", \"number\", 1.0, {\n            min: 0,\n            max: 3.0,\n            step: 0.1,\n            onChange: (val) => this._emissiveIntensity = val\n        });\n\n        this.exposeProperty(\"fogEnabled\", \"boolean\", false, {\n            onChange: (val) => this._fogEnabled = val\n        });\n        this.exposeProperty(\"fogColor\", \"color\", \"#a0a0a0\", {\n            onChange: (val) => this._fogColor = val\n        });\n        this.exposeProperty(\"fogStart\", \"number\", 100, {\n            min: 0,\n            max: 1000,\n            step: 10,\n            onChange: (val) => this._fogStart = val\n        });\n        this.exposeProperty(\"fogEnd\", \"number\", 500, {\n            min: 10,\n            max: 5000,\n            step: 10,\n            onChange: (val) => this._fogEnd = val\n        });\n        this.exposeProperty(\"fogDensity\", \"number\", 1.0, {\n            min: 0,\n            max: 1,\n            step: 0.05,\n            onChange: (val) => this._fogDensity = val\n        });\n\n        this.exposeProperty(\"showDebugInfo\", \"boolean\", false, {\n            onChange: (val) => this._showDebugInfo = val\n        });\n\n        this.updateRenderTexture();\n    }\n\n    setAsActiveCamera() {\n        if (!this.gameObject) return;\n        const allObjects = this.getGameObjects();\n        allObjects.forEach(obj => {\n            const camera = obj.getModule(\"Camera3D\");\n            if (camera && camera !== this) camera._isActive = false;\n        });\n        this._isActive = true;\n    }\n\n    getGameObjects() {\n        if (!this.gameObject) return [];\n        return this.getAllGameObjects();\n    }\n\n    projectPoint(point) {\n        const cameraPoint = this.worldToCameraSpace(point);\n        const depth = cameraPoint.x;\n        if (depth <= this.nearPlane || depth >= this.farPlane) return null;\n        const aspect = this.viewportWidth / this.viewportHeight;\n        const fovRadians = this.fieldOfView * (Math.PI / 180);\n        const f = 1.0 / Math.tan(fovRadians * 0.5);\n        if (depth < 1e-6) return null;\n        const ndcX = (cameraPoint.y / depth) * (f / aspect);\n        const ndcY = (cameraPoint.z / depth) * f;\n        const screenX = (ndcX * 0.5 + 0.5) * this.viewportWidth;\n        const screenY = (0.5 - ndcY * 0.5) * this.viewportHeight;\n        return new Vector2(screenX, screenY);\n    }\n\n    worldToCameraSpace(point) {\n        const goPos = (this.gameObject && this.gameObject.getWorldPosition) ?\n            this.gameObject.getWorldPosition() : { x: 0, y: 0 };\n        let goDepth = 0;\n        if (this.gameObject) {\n            if (typeof this.gameObject.getWorldDepth === 'function') {\n                goDepth = this.gameObject.getWorldDepth();\n            } else if (typeof this.gameObject.depth === 'number') {\n                goDepth = this.gameObject.depth;\n            } else if (this.gameObject.position && this.gameObject.position.z) {\n                goDepth = this.gameObject.position.z;\n            }\n        }\n        const camWorldX = (goPos.x || 0) + (this._position.x || 0);\n        const camWorldY = (goPos.y || 0) + (this._position.y || 0);\n        const camWorldZ = goDepth + (this._position.z || 0);\n        const cameraPos = new Vector3(camWorldX, camWorldY, camWorldZ);\n        const parentAngleDeg = (this.gameObject && this.gameObject.getWorldRotation) ?\n            this.gameObject.getWorldRotation() : 0;\n        const yaw = (parentAngleDeg + (this._rotation.z || 0)) * (Math.PI / 180);\n        const pitch = (this._rotation.y || 0) * (Math.PI / 180);\n        const roll = (this._rotation.x || 0) * (Math.PI / 180);\n        let relativePos = this.subtractVector3(point, cameraPos);\n        relativePos = this.rotateVectorZ(relativePos, -yaw);\n        relativePos = this.rotateVectorY(relativePos, -pitch);\n        relativePos = this.rotateVectorX(relativePos, -roll);\n        return relativePos;\n    }\n\n    subtractVector3(a, b) {\n        return new Vector3(a.x - b.x, a.y - b.y, a.z - b.z);\n    }\n\n    rotateVectorX(v, angle) {\n        const cos = Math.cos(angle), sin = Math.sin(angle);\n        return new Vector3(v.x, v.y * cos - v.z * sin, v.y * sin + v.z * cos);\n    }\n\n    rotateVectorY(v, angle) {\n        const cos = Math.cos(angle), sin = Math.sin(angle);\n        return new Vector3(v.x * cos + v.z * sin, v.y, -v.x * sin + v.z * cos);\n    }\n\n    rotateVectorZ(v, angle) {\n        const cos = Math.cos(angle), sin = Math.sin(angle);\n        return new Vector3(v.x * cos - v.y * sin, v.x * sin + v.y * cos, v.z);\n    }\n\n    clipPolygonAgainstNearPlane(vertices, nearPlane) {\n        if (!vertices || vertices.length === 0) return [];\n        const out = [];\n        const epsilon = 0.0001;\n        for (let i = 0; i < vertices.length; i++) {\n            const a = vertices[i];\n            const b = vertices[(i + 1) % vertices.length];\n            const aIn = a.x >= nearPlane - epsilon;\n            const bIn = b.x >= nearPlane - epsilon;\n            if (aIn && bIn) {\n                out.push(b);\n            } else if (aIn && !bIn) {\n                const t = Math.max(0, Math.min(1, (nearPlane - a.x) / (b.x - a.x)));\n                out.push(new Vector3(nearPlane, a.y + t * (b.y - a.y), a.z + t * (b.z - a.z)));\n            } else if (!aIn && bIn) {\n                const t = Math.max(0, Math.min(1, (nearPlane - a.x) / (b.x - a.x)));\n                out.push(new Vector3(nearPlane, a.y + t * (b.y - a.y), a.z + t * (b.z - a.z)));\n                out.push(b);\n            }\n        }\n        return out;\n    }\n\n    projectCameraPoint(cameraPoint) {\n        const depth = cameraPoint.x;\n        if (depth <= 1e-6) return null;\n        const aspect = this.viewportWidth / this.viewportHeight;\n        const fovRadians = this.fieldOfView * (Math.PI / 180);\n        const f = 1.0 / Math.tan(fovRadians * 0.5);\n        const ndcX = (cameraPoint.y / depth) * (f / aspect);\n        const ndcY = (cameraPoint.z / depth) * f;\n        const screenX = (ndcX * 0.5 + 0.5) * this.viewportWidth;\n        const screenY = (0.5 - ndcY * 0.5) * this.viewportHeight;\n        return new Vector2(screenX, screenY);\n    }\n\n    isPointVisible(point) {\n        const cameraPoint = this.worldToCameraSpace(point);\n        return cameraPoint.x >= this.nearPlane && cameraPoint.x <= this.farPlane;\n    }\n\n    updateRenderTexture() {\n        if (!this._renderTexture || this._renderTexture.width !== this._renderTextureWidth ||\n            this._renderTexture.height !== this._renderTextureHeight) {\n            this._renderTexture = document.createElement('canvas');\n            this._renderTexture.width = this._renderTextureWidth;\n            this._renderTexture.height = this._renderTextureHeight;\n            this._renderTextureCtx = this._renderTexture.getContext('2d');\n            this.viewportWidth = this._renderTextureWidth;\n            this.viewportHeight = this._renderTextureHeight;\n            this._zBuffer = new Float32Array(this._renderTextureWidth * this._renderTextureHeight);\n            this._imageData = this._renderTextureCtx.createImageData(this._renderTextureWidth, this._renderTextureHeight);\n        }\n    }\n\n    getRenderTexture() { return this._renderTexture; }\n    getRenderTextureContext() { return this._renderTextureCtx; }\n\n    clearRenderTexture() {\n        if (!this._renderTextureCtx) return;\n        this._renderTextureCtx.imageSmoothingEnabled = this._renderTextureSmoothing;\n        this._renderTextureCtx.fillStyle = this._backgroundColor;\n        this._renderTextureCtx.fillRect(0, 0, this._renderTextureWidth, this._renderTextureHeight);\n        if (this._zBuffer) this._zBuffer.fill(Infinity);\n    }\n\n    updateViewport() {\n        this.viewportWidth = this._renderTextureWidth;\n        this.viewportHeight = this._renderTextureHeight;\n    }\n\n    calculateScreenNormal(vertices) {\n        if (vertices.length < 3) return 0;\n        const v0 = vertices[0], v1 = vertices[1], v2 = vertices[2];\n        const edge1 = { x: v1.x - v0.x, y: v1.y - v0.y };\n        const edge2 = { x: v2.x - v0.x, y: v2.y - v0.y };\n        return edge1.x * edge2.y - edge1.y * edge2.x;\n    }\n\n    drawTexturedTriangle(ctx, vertices, uvs, texture) {\n        if (!texture || vertices.length !== 3 || uvs.length !== 3) return;\n        ctx.save();\n        ctx.beginPath();\n        ctx.moveTo(vertices[0].x, vertices[0].y);\n        ctx.lineTo(vertices[1].x, vertices[1].y);\n        ctx.lineTo(vertices[2].x, vertices[2].y);\n        ctx.closePath();\n        ctx.clip();\n        const x0 = vertices[0].x, y0 = vertices[0].y;\n        const x1 = vertices[1].x, y1 = vertices[1].y;\n        const x2 = vertices[2].x, y2 = vertices[2].y;\n        const u0 = uvs[0].x * texture.width, v0 = uvs[0].y * texture.height;\n        const u1 = uvs[1].x * texture.width, v1 = uvs[1].y * texture.height;\n        const u2 = uvs[2].x * texture.width, v2 = uvs[2].y * texture.height;\n        const det = u0 * (v1 - v2) - u1 * (v0 - v2) + u2 * (v0 - v1);\n        if (Math.abs(det) > 0.0001) {\n            const a = (x0 * (v1 - v2) - x1 * (v0 - v2) + x2 * (v0 - v1)) / det;\n            const b = (x0 * (u2 - u1) - x1 * (u2 - u0) + x2 * (u1 - u0)) / det;\n            const c = (x0 * (u1 * v2 - u2 * v1) - x1 * (u0 * v2 - u2 * v0) + x2 * (u0 * v1 - u1 * v0)) / det;\n            const d = (y0 * (v1 - v2) - y1 * (v0 - v2) + y2 * (v0 - v1)) / det;\n            const e = (y0 * (u2 - u1) - y1 * (u2 - u0) + y2 * (u1 - u0)) / det;\n            const f = (y0 * (u1 * v2 - u2 * v1) - y1 * (u0 * v2 - u2 * v0) + y2 * (u0 * v1 - u1 * v0)) / det;\n            ctx.transform(a, d, b, e, c, f);\n            ctx.drawImage(texture, 0, 0);\n        }\n        ctx.restore();\n    }\n\n\n\n\n    hexToRgb(hex) {\n        const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n        return result ? {\n            r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16)\n        } : { r: 0, g: 0, b: 0 };\n    }\n\n    /**\n * Register a light with this camera\n */\n    registerLight(light) {\n        if (!this._dynamicLights.includes(light)) {\n            this._dynamicLights.push(light);\n        }\n    }\n\n    /**\n     * Unregister a light from this camera\n     */\n    unregisterLight(light) {\n        const index = this._dynamicLights.indexOf(light);\n        if (index > -1) {\n            this._dynamicLights.splice(index, 1);\n        }\n    }\n\n    /**\n     * Get nearby lights sorted by distance\n     */\n    getNearbyLights() {\n        if (!this._useDynamicLighting || this._maxLights === 0) {\n            return [];\n        }\n\n        const cameraPos = this.getCameraWorldPosition();\n\n        // Filter and sort lights by distance\n        const nearbyLights = this._dynamicLights\n            .filter(light => {\n                if (!light.gameObject || !light.gameObject.active) return false;\n\n                const lightPos = light.getWorldPosition();\n                const dx = lightPos.x - cameraPos.x;\n                const dy = lightPos.y - cameraPos.y;\n                const dz = lightPos.z - cameraPos.z;\n                const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n\n                return distance <= this._lightFindDistance;\n            })\n            .sort((a, b) => {\n                const posA = a.getWorldPosition();\n                const posB = b.getWorldPosition();\n\n                const distA = Math.sqrt(\n                    (posA.x - cameraPos.x) ** 2 +\n                    (posA.y - cameraPos.y) ** 2 +\n                    (posA.z - cameraPos.z) ** 2\n                );\n\n                const distB = Math.sqrt(\n                    (posB.x - cameraPos.x) ** 2 +\n                    (posB.y - cameraPos.y) ** 2 +\n                    (posB.z - cameraPos.z) ** 2\n                );\n\n                return distA - distB;\n            })\n            .slice(0, this._maxLights);\n\n        return nearbyLights;\n    }\n\n    /**\n     * Get camera world position\n     */\n    getCameraWorldPosition() {\n        const goPos = (this.gameObject && this.gameObject.getWorldPosition) ?\n            this.gameObject.getWorldPosition() : { x: 0, y: 0 };\n        let goDepth = 0;\n        if (this.gameObject) {\n            if (typeof this.gameObject.getWorldDepth === 'function') {\n                goDepth = this.gameObject.getWorldDepth();\n            } else if (typeof this.gameObject.depth === 'number') {\n                goDepth = this.gameObject.depth;\n            } else if (this.gameObject.position && this.gameObject.position.z) {\n                goDepth = this.gameObject.position.z;\n            }\n        }\n        return new Vector3(\n            (goPos.x || 0) + (this._position.x || 0),\n            (goPos.y || 0) + (this._position.y || 0),\n            goDepth + (this._position.z || 0)\n        );\n    }\n\n    /**\n     * Calculate lighting with both directional and dynamic lights\n     */\n    calculateLightingWithDynamicLights(worldVerts, normal, baseColor, allTriangles) {\n        // Parse base color\n        const baseRgb = typeof baseColor === 'string' ? this.hexToRgb(baseColor) : baseColor;\n\n        // Calculate triangle center for lighting\n        const centerX = (worldVerts[0].x + worldVerts[1].x + worldVerts[2].x) / 3;\n        const centerY = (worldVerts[0].y + worldVerts[1].y + worldVerts[2].y) / 3;\n        const centerZ = (worldVerts[0].z + worldVerts[1].z + worldVerts[2].z) / 3;\n        const triangleCenter = { x: centerX, y: centerY, z: centerZ };\n\n        // Start with directional light\n        const directionalLight = this.calculateLighting(normal, baseColor);\n\n        // If dynamic lighting is disabled, return directional only\n        if (!this._useDynamicLighting || this._maxLights === 0) {\n            return directionalLight;\n        }\n\n        // Get nearby lights\n        const nearbyLights = this.getNearbyLights();\n        if (nearbyLights.length === 0) {\n            return directionalLight;\n        }\n\n        // Accumulate light contributions\n        let totalR = directionalLight.r;\n        let totalG = directionalLight.g;\n        let totalB = directionalLight.b;\n\n        for (const light of nearbyLights) {\n            // Check if light affects this triangle (shadow check)\n            const isLit = light.isTriangleLit(triangleCenter, normal, allTriangles);\n            if (!isLit) continue;\n\n            // Calculate light contribution\n            const contribution = light.calculateLightContribution(triangleCenter, normal);\n\n            if (contribution.intensity > 0.001) {\n                // Add light contribution to base color\n                totalR += baseRgb.r * (contribution.r / 255);\n                totalG += baseRgb.g * (contribution.g / 255);\n                totalB += baseRgb.b * (contribution.b / 255);\n            }\n        }\n\n        // Clamp final values\n        return {\n            r: Math.min(255, Math.round(totalR)),\n            g: Math.min(255, Math.round(totalG)),\n            b: Math.min(255, Math.round(totalB))\n        };\n    }\n\n    /**\n     * Calculate final color with emissive support\n     * @param {Object} tri - Triangle data with material\n     * @param {Object} litColor - Already calculated lighting color\n     * @returns {Object} - Final RGB color with emission\n     */\n    calculateEmissiveColor(tri, litColor) {\n        const material = tri.material;\n\n        // If no material or no emissive color, return lit color as-is\n        if (!material || !material._emissiveColor) {\n            return litColor;\n        }\n\n        const emissiveRgb = this.hexToRgb(material._emissiveColor);\n        const emissiveIntensity = (material._emissiveIntensity || 0) * (this._emissiveIntensity || 1.0);\n\n        // Skip if emission is negligible\n        if (emissiveIntensity < 0.01) {\n            return litColor;\n        }\n\n        // Add emissive color additively (clamped to prevent overflow)\n        return {\n            r: Math.min(255, litColor.r + Math.round(emissiveRgb.r * emissiveIntensity)),\n            g: Math.min(255, litColor.g + Math.round(emissiveRgb.g * emissiveIntensity)),\n            b: Math.min(255, litColor.b + Math.round(emissiveRgb.b * emissiveIntensity))\n        };\n    }\n\n    /**\n     * Check if a point in camera space is occluded by any triangle\n     * @param {Vector3} point - Point in camera space to test\n     * @param {Array} allTriangles - All triangles to test against\n     * @returns {boolean} - True if point is occluded\n     */\n    isPointOccluded(point, allTriangles, excludeTriangle = null) {\n        if (!allTriangles || allTriangles.length === 0) return false;\n\n        const testDepth = point.x;\n\n        const screenPos = this.projectCameraPoint(point);\n        if (!screenPos) return true;\n\n        const px = Math.floor(screenPos.x);\n        const py = Math.floor(screenPos.y);\n\n        if (px < 0 || px >= this._renderTextureWidth || py < 0 || py >= this._renderTextureHeight) {\n            return true;\n        }\n\n        const pxFloat = screenPos.x;\n        const pyFloat = screenPos.y;\n\n        for (const tri of allTriangles) {\n            if (tri === excludeTriangle) continue;\n            if (tri.isCulled) continue;\n            if (!tri.v0 || !tri.v1 || !tri.v2) continue;\n            if (!tri.v0.screen || !tri.v1.screen || !tri.v2.screen) continue;\n\n            const v0 = tri.v0.screen;\n            const v1 = tri.v1.screen;\n            const v2 = tri.v2.screen;\n\n            const denom = (v1.y - v2.y) * (v0.x - v2.x) + (v2.x - v1.x) * (v0.y - v2.y);\n            if (Math.abs(denom) < 1e-6) continue;\n\n            const w0 = ((v1.y - v2.y) * (pxFloat - v2.x) + (v2.x - v1.x) * (pyFloat - v2.y)) / denom;\n            const w1 = ((v2.y - v0.y) * (pxFloat - v2.x) + (v0.x - v2.x) * (pyFloat - v2.y)) / denom;\n            const w2 = 1 - w0 - w1;\n\n            if (w0 >= -0.001 && w1 >= -0.001 && w2 >= -0.001) {\n                const d0 = tri.v0.cameraPos?.x;\n                const d1 = tri.v1.cameraPos?.x;\n                const d2 = tri.v2.cameraPos?.x;\n                if (d0 === undefined || d1 === undefined || d2 === undefined) continue;\n                if (d0 <= 1e-6 || d1 <= 1e-6 || d2 <= 1e-6) continue;\n\n                const invDepth = w0 / d0 + w1 / d1 + w2 / d2;\n                if (invDepth <= 0) continue;\n\n                const triDepth = 1 / invDepth;\n\n                if (triDepth < testDepth - 0.05) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n * Calculate fog factor based on distance\n * Returns 0 (no fog) to 1 (full fog)\n */\n    calculateFogFactor(distance) {\n        if (!this._fogEnabled) return 0;\n\n        if (distance <= this._fogStart) return 0;\n        if (distance >= this._fogEnd) return this._fogDensity;\n\n        // Linear interpolation between fogStart and fogEnd\n        const range = this._fogEnd - this._fogStart;\n        const fogFactor = ((distance - this._fogStart) / range) * this._fogDensity;\n\n        return Math.max(0, Math.min(this._fogDensity, fogFactor));\n    }\n\n    /**\n     * Apply fog to a color based on distance\n     */\n    applyFog(color, distance) {\n        if (!this._fogEnabled) return color;\n\n        const fogFactor = this.calculateFogFactor(distance);\n        if (fogFactor === 0) return color;\n\n        const fogRgb = this.hexToRgb(this._fogColor);\n\n        // Blend color with fog color based on fog factor\n        return {\n            r: Math.round(color.r * (1 - fogFactor) + fogRgb.r * fogFactor),\n            g: Math.round(color.g * (1 - fogFactor) + fogRgb.g * fogFactor),\n            b: Math.round(color.b * (1 - fogFactor) + fogRgb.b * fogFactor)\n        };\n    }\n\n    /**\n     * Optimized pure raster rendering using scanline algorithm\n     * Fast forward rasterization without Z-buffer overhead\n     */\n    renderRasterOptimized() {\n        const startTime = performance.now();\n\n        const allObjects = this.getGameObjects();\n        const ctx = this._renderTextureCtx;\n        const imgData = this._imageData;\n        const data = imgData.data;\n        const w = this._renderTextureWidth;\n        const h = this._renderTextureHeight;\n\n        this._debugStats.totalFaces = 0;\n        this._debugStats.renderedTriangles = 0;\n        this._debugStats.culledFaces = 0;\n        this._debugStats.clippedFaces = 0;\n        this._debugStats.specularHighlights = 0;\n\n        const buffer32 = new Uint32Array(imgData.data.buffer);\n        this.clearBackgroundFast(buffer32, w, h);\n\n        const allTrianglesForShadows = [];\n        const allTriangles = [];\n        const specularHighlights = [];\n        const meshSpecularData = new Map();\n\n        allObjects.forEach(obj => {\n            if (!obj.active) return;\n            const mesh = obj.getModule(\"Mesh3D\") || obj.getModule(\"CubeMesh3D\") || obj.getModule(\"SphereMesh3D\");\n            if (!mesh) return;\n\n            const transformedVertices = mesh.transformVertices();\n            if (!transformedVertices || !mesh.faces) return;\n\n            const material = mesh.material;\n            const faceColor = material ? material.diffuseColor : (mesh.faceColor || mesh._faceColor || \"#888888\");\n\n            mesh.faces.forEach((face, faceIndex) => {\n                this._debugStats.totalFaces++;\n\n                // Get vertex indices\n                const vertIndices = Array.isArray(face) ? face : face.indices;\n                if (!vertIndices || vertIndices.length < 3) return;\n\n                const worldVerts = vertIndices.map(idx => transformedVertices[idx]).filter(v => v);\n                if (worldVerts.length < 3) return;\n\n                const cameraVerts = worldVerts.map(v => this.worldToCameraSpace(v));\n                if (cameraVerts.length < 3) return;\n\n                const clippedVerts = this.clipPolygonAgainstNearPlane(cameraVerts, this._nearPlane);\n                if (clippedVerts.length < 3) {\n                    this._debugStats.clippedFaces++;\n                    return;\n                }\n\n                const worldNormal = this.calculateFaceNormal(worldVerts[0], worldVerts[1], worldVerts[2]);\n                const isCulled = this._enableBackfaceCulling && this.shouldCullFace(clippedVerts);\n\n                const screenVerts = clippedVerts.map(cv => {\n                    const proj = this.projectCameraPoint(cv);\n                    return proj ? { screen: proj, depth: cv.x, cameraPos: cv } : null;\n                }).filter(v => v);\n\n                if (screenVerts.length < 3) return;\n\n                // Get UV coordinates for this face\n                const getUV = (vertIdx) => {\n                    if (mesh.uvCoords && mesh.uvCoords[vertIdx]) {\n                        return mesh.uvCoords[vertIdx];\n                    }\n                    return new Vector2(0, 0);\n                };\n\n                for (let i = 1; i < screenVerts.length - 1; i++) {\n                    const triWorldVerts = [\n                        worldVerts[0],\n                        worldVerts[Math.min(i, worldVerts.length - 1)],\n                        worldVerts[Math.min(i + 1, worldVerts.length - 1)]\n                    ];\n\n                    // Get UVs for this triangle\n                    const uv0 = getUV(vertIndices[0]);\n                    const uv1 = getUV(vertIndices[Math.min(i, vertIndices.length - 1)]);\n                    const uv2 = getUV(vertIndices[Math.min(i + 1, vertIndices.length - 1)]);\n\n                    const centroidX = (screenVerts[0].cameraPos.x + screenVerts[i].cameraPos.x + screenVerts[i + 1].cameraPos.x) / 3;\n                    const viewDepth = centroidX;\n\n                    const tri = {\n                        v0: screenVerts[0],\n                        v1: screenVerts[i],\n                        v2: screenVerts[i + 1],\n                        uv0: uv0,\n                        uv1: uv1,\n                        uv2: uv2,\n                        worldVerts: triWorldVerts,\n                        worldNormal: worldNormal,\n                        material: material,\n                        faceColor: faceColor,\n                        avgDepth: viewDepth,\n                        isCulled: isCulled\n                    };\n\n                    allTrianglesForShadows.push(tri);\n\n                    if (!isCulled) {\n                        this._debugStats.renderedTriangles++;\n                        allTriangles.push(tri);\n                    } else {\n                        this._debugStats.culledFaces++;\n                    }\n                }\n            });\n        });\n\n        // Cache triangles for occlusion testing\n        this._allTrianglesCache = allTriangles;\n\n        allTriangles.sort((a, b) => b.avgDepth - a.avgDepth);\n\n        allTriangles.forEach(tri => {\n            const litColor = this.calculateLightingWithDynamicLights(\n                tri.worldVerts,\n                tri.worldNormal,\n                tri.faceColor,\n                allTrianglesForShadows\n            );\n\n            // Apply emissive color\n            const emissiveColor = this.calculateEmissiveColor(tri, litColor);\n\n            // Apply fog to lit color based on triangle depth\n            const foggedColor = this.applyFog(emissiveColor, tri.avgDepth);\n\n            const packedColor = (255 << 24) | (foggedColor.b << 16) | (foggedColor.g << 8) | foggedColor.r;\n            tri.packedColor = packedColor;\n            tri.fogFactor = this.calculateFogFactor(tri.avgDepth); // Store fog factor for specular filtering\n\n            this.rasterizeTriangleFast(tri, buffer32, w, h);\n\n            // Only calculate specular if fog hasn't obscured the triangle\n            if (this._specularEnabled && tri.material && tri.material._specularColor && tri.fogFactor < 0.9) {\n                const projectedVerts = [tri.v0.screen, tri.v1.screen, tri.v2.screen];\n\n                if (this._specularPerMesh) {\n                    const mesh = tri.material.gameObject;\n                    if (!meshSpecularData.has(mesh)) {\n                        meshSpecularData.set(mesh, {\n                            mesh: mesh,\n                            triangles: [],\n                            worldNormals: [],\n                            projectedBounds: { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity }\n                        });\n                    }\n\n                    const meshData = meshSpecularData.get(mesh);\n                    meshData.triangles.push(tri);\n                    meshData.worldNormals.push(tri.worldNormal);\n\n                    const triBounds = {\n                        minX: Math.min(projectedVerts[0].x, projectedVerts[1].x, projectedVerts[2].x),\n                        maxX: Math.max(projectedVerts[0].x, projectedVerts[1].x, projectedVerts[2].x),\n                        minY: Math.min(projectedVerts[0].y, projectedVerts[1].y, projectedVerts[2].y),\n                        maxY: Math.max(projectedVerts[0].y, projectedVerts[1].y, projectedVerts[2].y)\n                    };\n                    meshData.projectedBounds.minX = Math.min(meshData.projectedBounds.minX, triBounds.minX);\n                    meshData.projectedBounds.maxX = Math.max(meshData.projectedBounds.maxX, triBounds.maxX);\n                    meshData.projectedBounds.minY = Math.min(meshData.projectedBounds.minY, triBounds.minY);\n                    meshData.projectedBounds.maxY = Math.max(meshData.projectedBounds.maxY, triBounds.maxY);\n                } else {\n                    const specular = this.calculateSpecularHighlight(tri, projectedVerts);\n                    if (specular) {\n                        // Store fog factor with specular for filtering\n                        specular.fogFactor = tri.fogFactor;\n                        specularHighlights.push(specular);\n                    }\n                }\n            }\n        });\n\n        if (this._specularEnabled && this._specularPerMesh && meshSpecularData.size > 0) {\n            this.calculateMeshSpecularHighlights(meshSpecularData, specularHighlights);\n        }\n\n        this._debugStats.specularHighlights = specularHighlights.length;\n\n        if (specularHighlights.length > 0) {\n            this.renderSpecularHighlights(specularHighlights, imgData, w, h);\n        }\n\n        ctx.putImageData(imgData, 0, 0);\n\n        // Draw visible light sources with occlusion testing\n        const nearbyLights = this.getNearbyLights();\n        nearbyLights.forEach(light => {\n            if (light._showLightSource) {\n                const lightWorldPos = light.getWorldPosition();\n                const lightCameraPos = this.worldToCameraSpace(lightWorldPos);\n\n                if (!this.isPointOccluded(lightCameraPos, allTriangles)) {\n                    light.drawLightSource(this);\n                }\n            }\n        });\n\n        if (this._showDebugInfo) {\n            this._debugStats.renderTime = performance.now() - startTime;\n            this._debugStats.activeLights = this.getNearbyLights().length;\n            this.drawDebugInfo(ctx);\n        }\n\n        // Clear cache\n        this._allTrianglesCache = null;\n    }\n\n    /**\n     * Draw debug information overlay\n     */\n    drawDebugInfo(ctx) {\n        ctx.save();\n\n        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';\n        ctx.fillRect(5, 5, 200, 145);\n\n        ctx.font = '11px monospace';\n        ctx.fillStyle = '#00ff00';\n        ctx.textAlign = 'left';\n        ctx.textBaseline = 'top';\n\n        const stats = this._debugStats;\n        const lines = [\n            `Total Faces: ${stats.totalFaces}`,\n            `Rendered Tris: ${stats.renderedTriangles}`,\n            `Culled: ${stats.culledFaces}`,\n            `Clipped: ${stats.clippedFaces}`,\n            `Specular: ${stats.specularHighlights}`,\n            `Active Lights: ${stats.activeLights || 0}/${this._maxLights}`,\n            `Render Time: ${stats.renderTime.toFixed(2)}ms`,\n            `FPS: ${(1000 / stats.renderTime).toFixed(1)}`,\n            `Resolution: ${this._renderTextureWidth}x${this._renderTextureHeight}`\n        ];\n\n        lines.forEach((line, index) => {\n            ctx.fillText(line, 10, 10 + index * 14);\n        });\n\n        ctx.restore();\n    }\n\n    /**\n     * Calculate sun position in screen space based on light direction\n     * Returns null if sun is below horizon\n     */\n    calculateSunPosition() {\n        if (!this._showSun || this._backgroundType !== \"skybox\") {\n            return null;\n        }\n\n        // Normalize light direction (pointing FROM the sun TO the scene)\n        const lightDir = this._lightDirection;\n        const len = Math.sqrt(lightDir.x ** 2 + lightDir.y ** 2 + lightDir.z ** 2);\n        const normalizedLight = {\n            x: lightDir.x / len,\n            y: lightDir.y / len,\n            z: lightDir.z / len\n        };\n\n        // Sun position is opposite to light direction (sun is the source)\n        const sunDir = {\n            x: -normalizedLight.x,\n            y: -normalizedLight.y,\n            z: -normalizedLight.z\n        };\n\n        // Check if sun is above horizon (z component positive means above)\n        if (sunDir.z <= 0) {\n            return null; // Sun is below horizon\n        }\n\n        // Get camera rotation angles\n        const parentAngleDeg = (this.gameObject && this.gameObject.getWorldRotation) ?\n            this.gameObject.getWorldRotation() : 0;\n        const yaw = (parentAngleDeg + (this._rotation.z || 0)) * (Math.PI / 180);\n        const pitch = -(this._rotation.y || 0) * (Math.PI / 180);\n\n        // Apply yaw rotation to sun direction\n        let rotatedSunDir = { ...sunDir };\n        const temp = { ...rotatedSunDir };\n        rotatedSunDir.x = temp.x * Math.cos(-yaw) - temp.y * Math.sin(-yaw);\n        rotatedSunDir.y = temp.x * Math.sin(-yaw) + temp.y * Math.cos(-yaw);\n        // Z remains unchanged by yaw\n\n        // Check if sun is behind camera (based on X in camera space)\n        if (rotatedSunDir.x <= 0) {\n            return null;\n        }\n\n        // Project to screen space\n        const aspect = this.viewportWidth / this.viewportHeight;\n        const fovRadians = this._fieldOfView * (Math.PI / 180);\n        const f = 1.0 / Math.tan(fovRadians * 0.5);\n\n        // Project sun direction as if it were at infinite distance\n        // This creates proper perspective projection\n        const ndcX = (rotatedSunDir.y / rotatedSunDir.x) * (f / aspect);\n        const ndcY = (rotatedSunDir.z / rotatedSunDir.x) * f;\n\n        // Apply pitch offset to NDC Y (affects vertical position based on camera pitch)\n        const pitchOffset = Math.tan(pitch) * f;\n        const adjustedNdcY = ndcY - pitchOffset;\n\n        // Convert NDC to screen space\n        const screenX = (ndcX * 0.5 + 0.5) * this.viewportWidth;\n        const screenY = (0.5 - adjustedNdcY * 0.5) * this.viewportHeight;\n\n        return new Vector2(screenX, screenY);\n    }\n\n    /**\n     * Draw sun on the background\n     */\n    drawSun(buffer32, w, h, sunPos) {\n        if (!sunPos) return;\n\n        const centerX = Math.round(sunPos.x);\n        const centerY = Math.round(sunPos.y);\n\n        // Parse light color for sun\n        const sunColor = this.hexToRgb(this._lightColor);\n\n        // Draw glow first (outer to inner for proper alpha blending)\n        const glowRadius = this._sunGlowSize;\n        const minGlowX = Math.max(0, centerX - glowRadius);\n        const maxGlowX = Math.min(w - 1, centerX + glowRadius);\n        const minGlowY = Math.max(0, centerY - glowRadius);\n        const maxGlowY = Math.min(h - 1, centerY + glowRadius);\n\n        for (let y = minGlowY; y <= maxGlowY; y++) {\n            for (let x = minGlowX; x <= maxGlowX; x++) {\n                const dx = x - centerX;\n                const dy = y - centerY;\n                const distSq = dx * dx + dy * dy;\n                const glowRadiusSq = glowRadius * glowRadius;\n\n                if (distSq <= glowRadiusSq) {\n                    const distance = Math.sqrt(distSq);\n                    const falloff = 1.0 - (distance / glowRadius);\n                    const alpha = falloff * falloff * 0.3; // Glow intensity\n\n                    if (alpha > 0.01) {\n                        const pixelIdx = y * w + x;\n                        const existing = buffer32[pixelIdx];\n\n                        // Extract existing RGB\n                        const existingR = existing & 0xFF;\n                        const existingG = (existing >> 8) & 0xFF;\n                        const existingB = (existing >> 16) & 0xFF;\n\n                        // Blend with sun color\n                        const newR = Math.min(255, Math.round(existingR + sunColor.r * alpha));\n                        const newG = Math.min(255, Math.round(existingG + sunColor.g * alpha));\n                        const newB = Math.min(255, Math.round(existingB + sunColor.b * alpha));\n\n                        buffer32[pixelIdx] = (255 << 24) | (newB << 16) | (newG << 8) | newR;\n                    }\n                }\n            }\n        }\n\n        // Draw sun core (bright center)\n        const coreRadius = this._sunSize;\n        const minCoreX = Math.max(0, centerX - coreRadius);\n        const maxCoreX = Math.min(w - 1, centerX + coreRadius);\n        const minCoreY = Math.max(0, centerY - coreRadius);\n        const maxCoreY = Math.min(h - 1, centerY + coreRadius);\n\n        for (let y = minCoreY; y <= maxCoreY; y++) {\n            for (let x = minCoreX; x <= maxCoreX; x++) {\n                const dx = x - centerX;\n                const dy = y - centerY;\n                const distSq = dx * dx + dy * dy;\n                const coreRadiusSq = coreRadius * coreRadius;\n\n                if (distSq <= coreRadiusSq) {\n                    const distance = Math.sqrt(distSq);\n                    const falloff = 1.0 - (distance / coreRadius);\n\n                    // Smooth falloff for softer edge\n                    const smoothFalloff = falloff * falloff * (3 - 2 * falloff);\n\n                    const pixelIdx = y * w + x;\n                    const existing = buffer32[pixelIdx];\n\n                    // Extract existing RGB\n                    const existingR = existing & 0xFF;\n                    const existingG = (existing >> 8) & 0xFF;\n                    const existingB = (existing >> 16) & 0xFF;\n\n                    // Bright core with smooth falloff\n                    const intensity = 0.7 + smoothFalloff * 0.3;\n                    const newR = Math.min(255, Math.round(existingR * (1 - intensity) + 255 * intensity));\n                    const newG = Math.min(255, Math.round(existingG * (1 - intensity) + 255 * intensity));\n                    const newB = Math.min(255, Math.round(existingB * (1 - intensity) + 255 * intensity));\n\n                    buffer32[pixelIdx] = (255 << 24) | (newB << 16) | (newG << 8) | newR;\n                }\n            }\n        }\n    }\n\n    /**\n     * Draw lens flare effect\n     * @param {Uint32Array} buffer32 - 32-bit pixel buffer\n     * @param {number} w - Width\n     * @param {number} h - Height\n     * @param {Vector2} sunPos - Sun position in screen space\n     */\n    drawLensFlare(buffer32, w, h, sunPos) {\n        if (!this._lensFlareEnabled || !sunPos) return;\n\n        // Calculate center of screen\n        const centerX = w * 0.5;\n        const centerY = h * 0.5;\n\n        // Vector from sun to center (lens flare direction)\n        const dirX = centerX - sunPos.x;\n        const dirY = centerY - sunPos.y;\n\n        // Calculate sun distance from center (for intensity falloff)\n        const sunDistFromCenter = Math.sqrt(dirX * dirX + dirY * dirY);\n        const maxDist = Math.sqrt(centerX * centerX + centerY * centerY);\n        const distanceFalloff = 1.0 - Math.min(1.0, sunDistFromCenter / maxDist);\n\n        // Early exit if sun is too far from center\n        if (distanceFalloff < 0.1) return;\n\n        // Parse sun color\n        const sunColor = this.hexToRgb(this._lightColor);\n\n        // Create flare elements along the line from sun to center\n        for (let i = 0; i < this._lensFlareCount; i++) {\n            // Position along the sun-to-center line\n            const t = (i + 1) * this._lensFlareSpacing;\n            const flareX = sunPos.x + dirX * t;\n            const flareY = sunPos.y + dirY * t;\n\n            // Skip if flare is outside screen bounds\n            if (flareX < 0 || flareX >= w || flareY < 0 || flareY >= h) continue;\n\n            // Calculate flare properties\n            const flareProgress = i / (this._lensFlareCount - 1); // 0 to 1\n            const flareSize = this._lensFlareSize * (0.5 + flareProgress * 0.5); // Smaller flares closer to sun\n            const flareIntensity = this._lensFlareIntensity * distanceFalloff * (1.0 - flareProgress * 0.3);\n\n            // Apply chromatic aberration if enabled\n            let flareColor = { ...sunColor };\n            if (this._lensFlareColorShift) {\n                // Shift colors based on flare index\n                const hueShift = (i % 3) / 3; // 0, 0.33, 0.66 for RGB shift\n                if (hueShift < 0.33) {\n                    flareColor.r = Math.min(255, sunColor.r * 1.2);\n                    flareColor.g = Math.min(255, sunColor.g * 0.8);\n                    flareColor.b = Math.min(255, sunColor.b * 0.6);\n                } else if (hueShift < 0.66) {\n                    flareColor.r = Math.min(255, sunColor.r * 0.6);\n                    flareColor.g = Math.min(255, sunColor.g * 1.2);\n                    flareColor.b = Math.min(255, sunColor.b * 0.8);\n                } else {\n                    flareColor.r = Math.min(255, sunColor.r * 0.8);\n                    flareColor.g = Math.min(255, sunColor.g * 0.6);\n                    flareColor.b = Math.min(255, sunColor.b * 1.2);\n                }\n            }\n\n            // Draw hexagonal flare element (more efficient than circle)\n            this.drawFlareElement(buffer32, w, h, flareX, flareY, flareSize, flareIntensity, flareColor);\n        }\n\n        // Add a bright streak from sun position (lens reflection)\n        if (distanceFalloff > 0.3) {\n            this.drawLensStreak(buffer32, w, h, sunPos, centerX, centerY, sunColor, distanceFalloff);\n        }\n    }\n\n    /**\n     * Draw a single lens flare element (hexagonal shape for efficiency)\n     * @param {Uint32Array} buffer32 - 32-bit pixel buffer\n     * @param {number} w - Width\n     * @param {number} h - Height\n     * @param {number} centerX - Flare center X\n     * @param {number} centerY - Flare center Y\n     * @param {number} size - Flare size\n     * @param {number} intensity - Flare intensity (0-1)\n     * @param {Object} color - RGB color object\n     */\n    drawFlareElement(buffer32, w, h, centerX, centerY, size, intensity, color) {\n        const halfSize = size * 0.5;\n        const minX = Math.max(0, Math.floor(centerX - halfSize));\n        const maxX = Math.min(w - 1, Math.ceil(centerX + halfSize));\n        const minY = Math.max(0, Math.floor(centerY - halfSize));\n        const maxY = Math.min(h - 1, Math.ceil(centerY + halfSize));\n\n        const sizeSq = halfSize * halfSize;\n\n        for (let y = minY; y <= maxY; y++) {\n            for (let x = minX; x <= maxX; x++) {\n                const dx = x - centerX;\n                const dy = y - centerY;\n                const distSq = dx * dx + dy * dy;\n\n                if (distSq <= sizeSq) {\n                    const distance = Math.sqrt(distSq);\n                    const falloff = 1.0 - (distance / halfSize);\n\n                    // Smooth falloff with slight hexagonal shape\n                    const angle = Math.atan2(dy, dx);\n                    const hexFactor = 0.95 + 0.05 * Math.cos(angle * 6); // 6-sided approximation\n                    const smoothFalloff = falloff * falloff * hexFactor;\n                    const alpha = intensity * smoothFalloff * 0.6; // Reduced opacity for subtlety\n\n                    if (alpha > 0.01) {\n                        const pixelIdx = y * w + x;\n                        const existing = buffer32[pixelIdx];\n\n                        // Extract existing RGB\n                        const existingR = existing & 0xFF;\n                        const existingG = (existing >> 8) & 0xFF;\n                        const existingB = (existing >> 16) & 0xFF;\n\n                        // Additive blend with flare color\n                        const newR = Math.min(255, Math.round(existingR + color.r * alpha));\n                        const newG = Math.min(255, Math.round(existingG + color.g * alpha));\n                        const newB = Math.min(255, Math.round(existingB + color.b * alpha));\n\n                        buffer32[pixelIdx] = (255 << 24) | (newB << 16) | (newG << 8) | newR;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draw a lens streak effect (anamorphic flare)\n     * @param {Uint32Array} buffer32 - 32-bit pixel buffer\n     * @param {number} w - Width\n     * @param {number} h - Height\n     * @param {Vector2} sunPos - Sun position\n     * @param {number} centerX - Screen center X\n     * @param {number} centerY - Screen center Y\n     * @param {Object} color - RGB color object\n     * @param {number} falloff - Distance falloff\n     */\n    drawLensStreak(buffer32, w, h, sunPos, centerX, centerY, color, falloff) {\n        // Draw horizontal streak through sun position\n        const streakLength = w * 0.3 * falloff;\n        const streakThickness = 2;\n        const streakIntensity = this._lensFlareIntensity * falloff * 0.3;\n\n        const startX = Math.max(0, Math.floor(sunPos.x - streakLength));\n        const endX = Math.min(w - 1, Math.ceil(sunPos.x + streakLength));\n        const minY = Math.max(0, Math.floor(sunPos.y - streakThickness));\n        const maxY = Math.min(h - 1, Math.ceil(sunPos.y + streakThickness));\n\n        for (let y = minY; y <= maxY; y++) {\n            const dy = Math.abs(y - sunPos.y);\n            const yFalloff = 1.0 - (dy / streakThickness);\n\n            for (let x = startX; x <= endX; x++) {\n                const dx = Math.abs(x - sunPos.x);\n                const xFalloff = 1.0 - (dx / streakLength);\n                const alpha = streakIntensity * xFalloff * yFalloff;\n\n                if (alpha > 0.01) {\n                    const pixelIdx = y * w + x;\n                    const existing = buffer32[pixelIdx];\n\n                    const existingR = existing & 0xFF;\n                    const existingG = (existing >> 8) & 0xFF;\n                    const existingB = (existing >> 16) & 0xFF;\n\n                    const newR = Math.min(255, Math.round(existingR + color.r * alpha));\n                    const newG = Math.min(255, Math.round(existingG + color.g * alpha));\n                    const newB = Math.min(255, Math.round(existingB + color.b * alpha));\n\n                    buffer32[pixelIdx] = (255 << 24) | (newB << 16) | (newG << 8) | newR;\n                }\n            }\n        }\n    }\n\n    /**\n * Simple 2D Perlin-like noise function for clouds\n * @param {number} x - X coordinate\n * @param {number} y - Y coordinate\n * @returns {number} - Noise value 0-1\n */\n    generateCloudNoise(x, y) {\n        // Simple hash-based noise (fast but procedural)\n        const hash = (n) => {\n            n = (n << 13) ^ n;\n            return (1.0 - ((n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0);\n        };\n\n        const X = Math.floor(x);\n        const Y = Math.floor(y);\n        const xf = x - X;\n        const yf = y - Y;\n\n        // Smooth interpolation\n        const u = xf * xf * (3.0 - 2.0 * xf);\n        const v = yf * yf * (3.0 - 2.0 * yf);\n\n        // Hash corners\n        const a = hash(X + hash(Y));\n        const b = hash(X + 1 + hash(Y));\n        const c = hash(X + hash(Y + 1));\n        const d = hash(X + 1 + hash(Y + 1));\n\n        // Bilinear interpolation\n        const k0 = a;\n        const k1 = b - a;\n        const k2 = c - a;\n        const k3 = a - b - c + d;\n\n        return (k0 + k1 * u + k2 * v + k3 * u * v) * 0.5 + 0.5;\n    }\n\n    /**\n     * Fractional Brownian Motion for more detailed clouds\n     * @param {number} x - X coordinate\n     * @param {number} y - Y coordinate\n     * @param {number} octaves - Number of noise layers\n     * @returns {number} - Combined noise value 0-1\n     */\n    generateCloudFBM(x, y, octaves = 4) {\n        let value = 0;\n        let amplitude = 1.0;\n        let frequency = 1.0;\n        let maxValue = 0;\n\n        for (let i = 0; i < octaves; i++) {\n            value += this.generateCloudNoise(x * frequency, y * frequency) * amplitude;\n            maxValue += amplitude;\n            amplitude *= 0.5;\n            frequency *= 2.0;\n        }\n\n        return value / maxValue;\n    }\n\n    /**\n     * Render clouds in the sky portion of the skybox\n     * @param {Uint32Array} buffer32 - 32-bit pixel buffer\n     * @param {number} w - Width\n     * @param {number} h - Height\n     * @param {number} horizonY - Horizon line Y position\n     */\n    renderClouds(buffer32, w, h, horizonY) {\n        if (!this._cloudsEnabled) return;\n\n        // Update cloud animation\n        this._cloudTime += 0.016 * this._cloudSpeed;\n\n        // Calculate cloud layer bounds relative to UNCLAMPED horizon\n        // This allows clouds to render even when horizon is outside viewport\n        const cloudStartY = Math.floor(horizonY * this._cloudHeight);\n        const cloudEndY = Math.max(0, cloudStartY - Math.floor(Math.abs(horizonY) * this._cloudThickness));\n\n        // If cloud layer is completely outside viewport, skip\n        if (cloudStartY < 0 || cloudEndY >= h) return;\n\n        // Clamp rendering to viewport bounds\n        const renderStartY = Math.max(0, cloudEndY);\n        const renderEndY = Math.min(h, cloudStartY);\n\n        if (renderStartY >= renderEndY) return;\n\n        // Calculate step size based on resolution setting\n        const pixelStep = Math.max(1, Math.round(1 / this._cloudResolution));\n\n        // Get camera yaw (rotation around Z axis) to rotate clouds with camera\n        const parentAngleDeg = (this.gameObject && this.gameObject.getWorldRotation) ?\n            this.gameObject.getWorldRotation() : 0;\n        const yaw = -(parentAngleDeg + (this._rotation.z || 0)) * (Math.PI / 180);\n\n        // Get camera pitch (rotation around Y axis) for vertical offset\n        const pitch = (this._rotation.y || 0) * (Math.PI / 180);\n\n        // Calculate FOV factors for proper perspective\n        const fovRadians = this._fieldOfView * (Math.PI / 180);\n        const fovFactor = Math.tan(fovRadians / 2);\n\n        // Render clouds scanline by scanline with adaptive resolution\n        for (let y = renderStartY; y < renderEndY; y += pixelStep) {\n            // Calculate vertical position (0=horizon, 1=top of cloud layer)\n            // Use FULL cloud layer extent for proper interpolation\n            const verticalPos = (cloudStartY - y) / (cloudStartY - cloudEndY);\n\n            // Apply perspective depth (clouds closer to horizon are \"further away\")\n            const depthFactor = 1.0 - verticalPos; // 0 at top, 1 at horizon\n            const perspectiveScale = 1.0 + depthFactor * 2.0; // Clouds stretch near horizon\n\n            // Calculate atmospheric fade (clouds fade at edges of layer)\n            const layerFade = Math.sin(verticalPos * Math.PI); // Peaks at middle of layer\n\n            for (let x = 0; x < w; x += pixelStep) {\n                // Calculate normalized screen position (-1 to 1)\n                const screenX = (x / w - 0.5) * 2.0;\n                const screenY = (y / h - 0.5) * 2.0;\n\n                // Convert screen space to view direction (accounting for FOV)\n                const viewDirX = screenX * fovFactor * (w / h); // Horizontal direction\n                const viewDirY = screenY * fovFactor; // Vertical direction\n\n                // Apply camera yaw rotation to horizontal direction\n                const rotatedX = Math.cos(yaw) * viewDirX - Math.sin(yaw) * 1.0; // 1.0 is \"forward\"\n                const rotatedY = Math.sin(yaw) * viewDirX + Math.cos(yaw) * 1.0;\n\n                // Apply pitch offset to vertical sampling\n                const pitchAdjustedY = viewDirY - Math.tan(pitch);\n\n                // Calculate noise sampling coordinates with perspective and time offset\n                // Use rotated horizontal direction for proper camera rotation\n                const noiseX = (rotatedX * perspectiveScale + this._cloudTime * 0.1) / (this._cloudScale * 0.01);\n                const noiseY = (rotatedY * perspectiveScale + this._cloudTime * 0.05) / (this._cloudScale * 0.01);\n\n                // Sample multi-octave noise for detailed clouds\n                const cloudNoise = this.generateCloudFBM(noiseX, noiseY, 3);\n\n                // Apply density threshold to create cloud shapes\n                let cloudAlpha = (cloudNoise - (1.0 - this._cloudDensity)) / this._cloudDensity;\n                cloudAlpha = Math.max(0, Math.min(1, cloudAlpha));\n\n                // Apply softness (feathered edges)\n                if (this._cloudSoftness > 0) {\n                    cloudAlpha = Math.pow(cloudAlpha, 1.0 + this._cloudSoftness * 2);\n                }\n\n                // Apply atmospheric fade\n                cloudAlpha *= layerFade;\n\n                if (cloudAlpha > 0.01) {\n                    // Cloud color (bright white with slight blue tint, affected by light color)\n                    const lightRgb = this.hexToRgb(this._lightColor);\n                    const cloudR = Math.round(255 * this._cloudBrightness * (lightRgb.r / 255));\n                    const cloudG = Math.round(255 * this._cloudBrightness * (lightRgb.g / 255));\n                    const cloudB = Math.round(255 * this._cloudBrightness * (lightRgb.b / 255));\n\n                    // Fill block of pixels for lower resolutions\n                    for (let py = 0; py < pixelStep && y + py < renderEndY; py++) {\n                        const rowStart = (y + py) * w;\n                        for (let px = 0; px < pixelStep && x + px < w; px++) {\n                            const pixelIdx = rowStart + (x + px);\n                            const existing = buffer32[pixelIdx];\n\n                            const existingR = existing & 0xFF;\n                            const existingG = (existing >> 8) & 0xFF;\n                            const existingB = (existing >> 16) & 0xFF;\n\n                            // Alpha blend clouds over sky\n                            const newR = Math.round(existingR * (1 - cloudAlpha) + cloudR * cloudAlpha);\n                            const newG = Math.round(existingG * (1 - cloudAlpha) + cloudG * cloudAlpha);\n                            const newB = Math.round(existingB * (1 - cloudAlpha) + cloudB * cloudAlpha);\n\n                            buffer32[pixelIdx] = (255 << 24) | (newB << 16) | (newG << 8) | newR;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Fast background clearing using 32-bit writes\n     */\n    clearBackgroundFast(buffer32, w, h) {\n        if (this._backgroundType === \"solid\") {\n            const bgColor = this.hexToRgb(this._backgroundColor);\n            const bgPixel = (255 << 24) | (bgColor.b << 16) | (bgColor.g << 8) | bgColor.r;\n            buffer32.fill(bgPixel);\n        } else if (this._backgroundType === \"skybox\") {\n            const fovRadians = this._fieldOfView * (Math.PI / 180);\n            const pitchRadians = (this._rotation.y || 0) * (Math.PI / 180);\n            const maxPitch = fovRadians / 2;\n            const normalizedPitch = -Math.max(-1, Math.min(1, pitchRadians / maxPitch));\n            const horizonOffset = normalizedPitch * 0.5;\n            const horizonRatio = 0.5 + horizonOffset;\n            // Remove clamping to allow horizon to move outside viewport bounds\n            const horizonY = Math.floor(h * horizonRatio);\n\n            // Draw sky gradient (may extend beyond top of viewport)\n            const skyStartY = Math.max(0, 0); // Always start from top\n            const skyEndY = Math.min(h, horizonY); // End at horizon or bottom of viewport\n\n            for (let y = skyStartY; y < skyEndY; y++) {\n                // Calculate t based on full sky extent, not just visible portion\n                const t = horizonY > 0 ? y / horizonY : 0;\n                const color = this.interpolateColor(this._skyColor, this._skyColorHorizon, t);\n                const pixel = (255 << 24) | (color.b << 16) | (color.g << 8) | color.r;\n                const rowStart = y * w;\n                for (let x = 0; x < w; x++) {\n                    buffer32[rowStart + x] = pixel;\n                }\n            }\n\n            // Draw sun on top of sky gradient and clouds\n            const sunPos = this.calculateSunPosition();\n            if (sunPos) {\n                this.drawSun(buffer32, w, h, sunPos);\n\n                // Draw lens flare if enabled\n                if (this._lensFlareEnabled) {\n                    this.drawLensFlare(buffer32, w, h, sunPos);\n                }\n            }\n\n            if (this._cloudsEnabled) {\n                this.renderClouds(buffer32, w, h, horizonY);\n            }\n\n            // Draw floor gradient with optional water animation (may start above viewport)\n            const floorStartY = Math.max(0, horizonY);\n            const floorEndY = h;\n\n            if (this._waterEnabled) {\n                // Animate water time\n                this._waterTime += 0.016 * this._waterSpeed;\n\n                const floorHeight = floorEndY - floorStartY;\n\n                // Pre-calculate wave phases for rows (performance optimization)\n                for (let y = floorStartY; y < floorEndY; y++) {\n                    // Calculate t relative to full floor extent\n                    const baseT = horizonY < h ? (y - horizonY) / (h - horizonY) : 0;\n                    const perspectiveFactor = baseT * baseT;\n\n                    // Calculate primary wave for this row\n                    const yOffset = y - horizonY;\n                    const primaryWave = (yOffset / this._waterWaveHeight) + this._waterTime;\n                    const secondaryWave = (yOffset / (this._waterWaveHeight * 2.3)) + this._waterTime * 0.7;\n                    const tertiaryWave = (yOffset / (this._waterWaveHeight * 4.1)) + this._waterTime * 1.3;\n\n                    // Sample wave at row start for base offset\n                    const baseWaveOffset = (\n                        Math.sin(primaryWave) * 0.035 +\n                        Math.sin(secondaryWave) * 0.020 +\n                        Math.sin(tertiaryWave) * 0.015\n                    ) * perspectiveFactor;\n\n                    // Calculate animated t for this row\n                    const animatedT = Math.max(0, Math.min(1, baseT + baseWaveOffset));\n\n                    // Get color for this row\n                    const color = this.interpolateColor(this._floorColorHorizon, this._floorColor, animatedT);\n                    const pixel = (255 << 24) | (color.b << 16) | (color.g << 8) | color.r;\n\n                    // Fill entire row with this color (fast row-based approach)\n                    const rowStart = y * w;\n                    for (let x = 0; x < w; x++) {\n                        buffer32[rowStart + x] = pixel;\n                    }\n                }\n            } else {\n                // Standard floor gradient without animation\n                for (let y = floorStartY; y < floorEndY; y++) {\n                    const t = horizonY < h ? (y - horizonY) / (h - horizonY) : 0;\n                    const color = this.interpolateColor(this._floorColorHorizon, this._floorColor, t);\n                    const pixel = (255 << 24) | (color.b << 16) | (color.g << 8) | color.r;\n                    const rowStart = y * w;\n                    for (let x = 0; x < w; x++) {\n                        buffer32[rowStart + x] = pixel;\n                    }\n                }\n            }\n        } else if (this._backgroundType === \"transparent\") {\n            buffer32.fill(0);\n        }\n    }\n\n    /**\n     * Ultra-fast scanline triangle rasterization\n     * Uses edge-walking for maximum performance\n     */\n    rasterizeTriangleFast(tri, buffer32, w, h) {\n        const p0 = { x: Math.round(tri.v0.screen.x), y: Math.round(tri.v0.screen.y) };\n        const p1 = { x: Math.round(tri.v1.screen.x), y: Math.round(tri.v1.screen.y) };\n        const p2 = { x: Math.round(tri.v2.screen.x), y: Math.round(tri.v2.screen.y) };\n\n        // Calculate bounding box\n        const minX = Math.max(0, Math.min(p0.x, p1.x, p2.x));\n        const maxX = Math.min(w - 1, Math.max(p0.x, p1.x, p2.x));\n        const minY = Math.max(0, Math.min(p0.y, p1.y, p2.y));\n        const maxY = Math.min(h - 1, Math.max(p0.y, p1.y, p2.y));\n\n        if (minX > maxX || minY > maxY) return;\n\n        // Edge setup\n        const v0x = p0.x, v0y = p0.y;\n        const v1x = p1.x, v1y = p1.y;\n        const v2x = p2.x, v2y = p2.y;\n\n        const e0_dx = v1x - v0x, e0_dy = v1y - v0y;\n        const e1_dx = v2x - v1x, e1_dy = v2y - v1y;\n        const e2_dx = v0x - v2x, e2_dy = v0y - v2y;\n\n        const area = e0_dx * (v2y - v0y) - e0_dy * (v2x - v0x);\n        if (Math.abs(area) < 0.5) return;\n\n        // Check if material has a texture\n        const material = tri.material;\n        const hasTexture = material && (material.getDiffuseTexture() || material._useProceduralTexture);\n\n        if (hasTexture) {\n            // Get texture\n            const texture = material.getDiffuseTexture();\n            if (!texture) return; // Texture not loaded yet\n\n            // Get UVs\n            const uv0 = tri.uv0 || new Vector2(0, 0);\n            const uv1 = tri.uv1 || new Vector2(0, 0);\n            const uv2 = tri.uv2 || new Vector2(0, 0);\n\n            // Pre-calculate barycentric denominators\n            const invArea = 1.0 / area;\n\n            // Scanline loop with texture sampling\n            for (let y = minY; y <= maxY; y++) {\n                let w0 = e0_dx * (y - v0y) - e0_dy * (minX - v0x);\n                let w1 = e1_dx * (y - v1y) - e1_dy * (minX - v1x);\n                let w2 = e2_dx * (y - v2y) - e2_dy * (minX - v2x);\n\n                const w0_step = -e0_dy;\n                const w1_step = -e1_dy;\n                const w2_step = -e2_dy;\n\n                const rowOffset = y * w;\n\n                for (let x = minX; x <= maxX; x++) {\n                    if (w0 >= 0 && w1 >= 0 && w2 >= 0) {\n                        // Calculate barycentric coordinates\n                        const lambda0 = ((v1y - v2y) * (x - v2x) + (v2x - v1x) * (y - v2y)) * invArea;\n                        const lambda1 = ((v2y - v0y) * (x - v2x) + (v0x - v2x) * (y - v2y)) * invArea;\n                        const lambda2 = 1.0 - lambda0 - lambda1;\n\n                        // Interpolate UV coordinates\n                        const u = uv0.x * lambda0 + uv1.x * lambda1 + uv2.x * lambda2;\n                        const v = uv0.y * lambda0 + uv1.y * lambda1 + uv2.y * lambda2;\n\n                        // Sample texture\n                        const textureColor = material.sampleTexture(u, v, texture);\n\n                        // Parse texture color (returns rgba string)\n                        const match = textureColor.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)/);\n                        if (match) {\n                            const baseR = parseInt(match[1]);\n                            const baseG = parseInt(match[2]);\n                            const baseB = parseInt(match[3]);\n\n                            // Apply lighting (use pre-calculated lit color from tri.packedColor)\n                            // Extract RGB from packed color\n                            const litR = tri.packedColor & 0xFF;\n                            const litG = (tri.packedColor >> 8) & 0xFF;\n                            const litB = (tri.packedColor >> 16) & 0xFF;\n\n                            // Blend texture with lighting\n                            const finalR = Math.round((baseR / 255) * litR);\n                            const finalG = Math.round((baseG / 255) * litG);\n                            const finalB = Math.round((baseB / 255) * litB);\n\n                            // Pack into 32-bit color\n                            const packedColor = (255 << 24) | (finalB << 16) | (finalG << 8) | finalR;\n                            buffer32[rowOffset + x] = packedColor;\n                        }\n                    }\n\n                    w0 += w0_step;\n                    w1 += w1_step;\n                    w2 += w2_step;\n                }\n            }\n        } else {\n            // Original solid color rendering (existing code)\n            const packedColor = tri.packedColor;\n\n            for (let y = minY; y <= maxY; y++) {\n                let w0 = e0_dx * (y - v0y) - e0_dy * (minX - v0x);\n                let w1 = e1_dx * (y - v1y) - e1_dy * (minX - v1x);\n                let w2 = e2_dx * (y - v2y) - e2_dy * (minX - v2x);\n\n                const w0_step = -e0_dy;\n                const w1_step = -e1_dy;\n                const w2_step = -e2_dy;\n\n                const rowOffset = y * w;\n\n                for (let x = minX; x <= maxX; x++) {\n                    if (w0 >= 0 && w1 >= 0 && w2 >= 0) {\n                        buffer32[rowOffset + x] = packedColor;\n                    }\n\n                    w0 += w0_step;\n                    w1 += w1_step;\n                    w2 += w2_step;\n                }\n            }\n        }\n    }\n\n    /**\n     * Calculate specular highlight position in screen space\n     * @param {Object} tri - Triangle with world vertices and normal\n     * @param {Array} projectedVerts - Screen space vertices [p0, p1, p2]\n     * @returns {Object|null} - Specular data or null if no highlight\n     */\n    calculateSpecularHighlight(tri, projectedVerts) {\n        const material = tri.material;\n        if (!material) return null;\n\n        const specularColor = this.hexToRgb(material._specularColor || \"#FFFFFF\");\n        const shininess = material._shininess || 32;\n\n        // If specular color is black, skip\n        if (specularColor.r === 0 && specularColor.g === 0 && specularColor.b === 0) {\n            return null;\n        }\n\n        // Get camera world position\n        const goPos = (this.gameObject && this.gameObject.getWorldPosition) ?\n            this.gameObject.getWorldPosition() : { x: 0, y: 0 };\n        let goDepth = 0;\n        if (this.gameObject) {\n            if (typeof this.gameObject.getWorldDepth === 'function') {\n                goDepth = this.gameObject.getWorldDepth();\n            } else if (typeof this.gameObject.depth === 'number') {\n                goDepth = this.gameObject.depth;\n            }\n        }\n        const camWorldPos = {\n            x: (goPos.x || 0) + (this._position.x || 0),\n            y: (goPos.y || 0) + (this._position.y || 0),\n            z: goDepth + (this._position.z || 0)\n        };\n\n        // Calculate triangle center in world space\n        const worldVerts = tri.worldVerts || [tri.v0, tri.v1, tri.v2];\n        const centerX = (worldVerts[0].x + worldVerts[1].x + worldVerts[2].x) / 3;\n        const centerY = (worldVerts[0].y + worldVerts[1].y + worldVerts[2].y) / 3;\n        const centerZ = (worldVerts[0].z + worldVerts[1].z + worldVerts[2].z) / 3;\n\n        // View direction = camera position - triangle center\n        const viewDir = {\n            x: camWorldPos.x - centerX,\n            y: camWorldPos.y - centerY,\n            z: camWorldPos.z - centerZ\n        };\n        const viewLen = Math.sqrt(viewDir.x ** 2 + viewDir.y ** 2 + viewDir.z ** 2);\n        if (viewLen < 0.0001) return null;\n\n        viewDir.x /= viewLen;\n        viewDir.y /= viewLen;\n        viewDir.z /= viewLen;\n\n        // Normalize world normal\n        const worldNormal = tri.worldNormal;\n        const normalLen = Math.sqrt(worldNormal.x ** 2 + worldNormal.y ** 2 + worldNormal.z ** 2);\n        if (normalLen < 0.0001) return null;\n\n        const n = {\n            x: worldNormal.x / normalLen,\n            y: worldNormal.y / normalLen,\n            z: worldNormal.z / normalLen\n        };\n\n        // Normalize light direction\n        const lightDir = this._lightDirection;\n        const lightLen = Math.sqrt(lightDir.x ** 2 + lightDir.y ** 2 + lightDir.z ** 2);\n        const normalizedLightDir = {\n            x: lightDir.x / lightLen,\n            y: lightDir.y / lightLen,\n            z: lightDir.z / lightLen\n        };\n\n        // Calculate reflection direction: R = 2(NL)N - L\n        const dotNL = n.x * (-normalizedLightDir.x) + n.y * (-normalizedLightDir.y) + n.z * (-normalizedLightDir.z);\n\n        // Early exit if surface is facing away from light\n        if (dotNL <= 0) return null;\n\n        const reflectDir = {\n            x: 2 * dotNL * n.x - (-normalizedLightDir.x),\n            y: 2 * dotNL * n.y - (-normalizedLightDir.y),\n            z: 2 * dotNL * n.z - (-normalizedLightDir.z)\n        };\n\n        // Calculate specular intensity using Phong model: (RV)^shininess\n        const dotRV = Math.max(0, reflectDir.x * viewDir.x + reflectDir.y * viewDir.y + reflectDir.z * viewDir.z);\n        const specularIntensity = Math.pow(dotRV, shininess) * this._lightIntensity;\n\n        // Early exit if intensity too low\n        if (specularIntensity < 0.01) return null;\n\n        // Calculate specular highlight offset in world space\n        const offsetDistance = 0.5;\n        const highlightWorldPos = {\n            x: centerX + reflectDir.x * offsetDistance,\n            y: centerY + reflectDir.y * offsetDistance,\n            z: centerZ + reflectDir.z * offsetDistance\n        };\n\n        // Transform highlight position to camera space and project to screen\n        const highlightCameraPos = this.worldToCameraSpace(highlightWorldPos);\n\n        // Skip if highlight is behind camera\n        if (highlightCameraPos.x <= this._nearPlane) return null;\n\n        const highlightScreenPos = this.projectCameraPoint(highlightCameraPos);\n        if (!highlightScreenPos) return null;\n\n        // Calculate highlight radius based on triangle size, distance, and shininess\n        const triangleSize = Math.max(\n            Math.abs(projectedVerts[1].x - projectedVerts[0].x),\n            Math.abs(projectedVerts[2].x - projectedVerts[0].x),\n            Math.abs(projectedVerts[1].y - projectedVerts[0].y),\n            Math.abs(projectedVerts[2].y - projectedVerts[0].y)\n        );\n\n        // Radius decreases with higher shininess (tighter highlights) and distance\n        const baseRadius = triangleSize * 0.3;\n        const shininessScale = Math.max(0.1, 1.0 - (shininess / 256));\n        const distanceScale = Math.max(0.5, Math.min(1.0, 100 / highlightCameraPos.x));\n        const highlightRadius = baseRadius * shininessScale * distanceScale;\n\n        return {\n            centerX: highlightScreenPos.x,\n            centerY: highlightScreenPos.y,\n            radius: Math.max(3, highlightRadius), // Minimum radius to prevent division issues\n            intensity: specularIntensity,\n            color: specularColor,\n            depth: highlightCameraPos.x, // Store depth for occlusion testing\n            cameraPos: highlightCameraPos, // Store camera space position for occlusion testing\n            triangleBounds: {\n                minX: Math.min(projectedVerts[0].x, projectedVerts[1].x, projectedVerts[2].x),\n                maxX: Math.max(projectedVerts[0].x, projectedVerts[1].x, projectedVerts[2].x),\n                minY: Math.min(projectedVerts[0].y, projectedVerts[1].y, projectedVerts[2].y),\n                maxY: Math.max(projectedVerts[0].y, projectedVerts[1].y, projectedVerts[2].y),\n                v0: projectedVerts[0],\n                v1: projectedVerts[1],\n                v2: projectedVerts[2]\n            }\n        };\n    }\n\n    /**\n     * Calculate specular highlights per mesh instead of per triangle\n     * @param {Map} meshSpecularData - Map of mesh specular data\n     * @param {Array} specularHighlights - Array to store final specular highlights\n     */\n    calculateMeshSpecularHighlights(meshSpecularData, specularHighlights) {\n        meshSpecularData.forEach((meshData, mesh) => {\n            const material = meshData.mesh.material;\n            if (!material || !material._specularColor) return;\n\n            const specularColor = this.hexToRgb(material._specularColor || \"#FFFFFF\");\n            const shininess = material._shininess || 32;\n\n            // If specular color is black, skip\n            if (specularColor.r === 0 && specularColor.g === 0 && specularColor.b === 0) {\n                return;\n            }\n\n            // Get camera world position\n            const goPos = (this.gameObject && this.gameObject.getWorldPosition) ?\n                this.gameObject.getWorldPosition() : { x: 0, y: 0 };\n            let goDepth = 0;\n            if (this.gameObject) {\n                if (typeof this.gameObject.getWorldDepth === 'function') {\n                    goDepth = this.gameObject.getWorldDepth();\n                } else if (typeof this.gameObject.depth === 'number') {\n                    goDepth = this.gameObject.depth;\n                }\n            }\n            const camWorldPos = {\n                x: (goPos.x || 0) + (this._position.x || 0),\n                y: (goPos.y || 0) + (this._position.y || 0),\n                z: goDepth + (this._position.z || 0)\n            };\n\n            // Process each triangle to create individual specular highlights that respect triangle bounds\n            meshData.triangles.forEach((tri, triIndex) => {\n                const worldVerts = tri.worldVerts;\n                const worldNormal = meshData.worldNormals[triIndex];\n\n                // Calculate triangle center in world space\n                const centerX = (worldVerts[0].x + worldVerts[1].x + worldVerts[2].x) / 3;\n                const centerY = (worldVerts[0].y + worldVerts[1].y + worldVerts[2].y) / 3;\n                const centerZ = (worldVerts[0].z + worldVerts[1].z + worldVerts[2].z) / 3;\n\n                // View direction = camera position - triangle center\n                const viewDir = {\n                    x: camWorldPos.x - centerX,\n                    y: camWorldPos.y - centerY,\n                    z: camWorldPos.z - centerZ\n                };\n                const viewLen = Math.sqrt(viewDir.x ** 2 + viewDir.y ** 2 + viewDir.z ** 2);\n                if (viewLen < 0.0001) return;\n\n                viewDir.x /= viewLen;\n                viewDir.y /= viewLen;\n                viewDir.z /= viewLen;\n\n                // Normalize world normal\n                const normalLen = Math.sqrt(worldNormal.x ** 2 + worldNormal.y ** 2 + worldNormal.z ** 2);\n                if (normalLen < 0.0001) return;\n\n                const normalizedNormal = {\n                    x: worldNormal.x / normalLen,\n                    y: worldNormal.y / normalLen,\n                    z: worldNormal.z / normalLen\n                };\n\n                // Normalize light direction\n                const lightDir = this._lightDirection;\n                const lightLen = Math.sqrt(lightDir.x ** 2 + lightDir.y ** 2 + lightDir.z ** 2);\n                const normalizedLightDir = {\n                    x: lightDir.x / lightLen,\n                    y: lightDir.y / lightLen,\n                    z: lightDir.z / lightLen\n                };\n\n                // Calculate reflection direction: R = 2(NL)N - L\n                const dotNL = normalizedNormal.x * (-normalizedLightDir.x) + normalizedNormal.y * (-normalizedLightDir.y) + normalizedNormal.z * (-normalizedLightDir.z);\n\n                // Early exit if surface is facing away from light\n                if (dotNL <= 0) return;\n\n                const reflectDir = {\n                    x: 2 * dotNL * normalizedNormal.x - (-normalizedLightDir.x),\n                    y: 2 * dotNL * normalizedNormal.y - (-normalizedLightDir.y),\n                    z: 2 * dotNL * normalizedNormal.z - (-normalizedLightDir.z)\n                };\n\n                // Calculate specular intensity using Phong model: (RV)^shininess\n                const dotRV = Math.max(0, reflectDir.x * viewDir.x + reflectDir.y * viewDir.y + reflectDir.z * viewDir.z);\n                const specularIntensity = Math.pow(dotRV, shininess) * this._lightIntensity;\n\n                // Early exit if intensity too low\n                if (specularIntensity < 0.01) return;\n\n                // Calculate specular highlight offset in world space\n                const offsetDistance = 0.5;\n                const highlightWorldPos = {\n                    x: centerX + reflectDir.x * offsetDistance,\n                    y: centerY + reflectDir.y * offsetDistance,\n                    z: centerZ + reflectDir.z * offsetDistance\n                };\n\n                // Transform highlight position to camera space and project to screen\n                const highlightCameraPos = this.worldToCameraSpace(highlightWorldPos);\n\n                // Skip if highlight is behind camera\n                if (highlightCameraPos.x <= this._nearPlane) return;\n\n                const highlightScreenPos = this.projectCameraPoint(highlightCameraPos);\n                if (!highlightScreenPos) return;\n\n                // Get screen-space triangle vertices for this specific triangle\n                const projectedVerts = [\n                    tri.v0.screen,\n                    tri.v1.screen,\n                    tri.v2.screen\n                ];\n\n                // Calculate highlight radius based on triangle size\n                const triangleSize = Math.max(\n                    Math.abs(projectedVerts[1].x - projectedVerts[0].x),\n                    Math.abs(projectedVerts[2].x - projectedVerts[0].x),\n                    Math.abs(projectedVerts[1].y - projectedVerts[0].y),\n                    Math.abs(projectedVerts[2].y - projectedVerts[0].y)\n                );\n\n                // Radius decreases with higher shininess (tighter highlights)\n                const baseRadius = triangleSize * 0.3;\n                const shininessScale = Math.max(0.1, 1.0 - (shininess / 256));\n                const highlightRadius = baseRadius * shininessScale;\n\n                // Create specular highlight for this triangle\n                const specularHighlight = {\n                    centerX: highlightScreenPos.x,\n                    centerY: highlightScreenPos.y,\n                    radius: highlightRadius,\n                    intensity: specularIntensity,\n                    color: specularColor,\n                    depth: highlightCameraPos.x, // Store depth for occlusion testing\n                    cameraPos: highlightCameraPos, // Store camera space position for occlusion testing\n                    triangleBounds: {\n                        minX: Math.min(projectedVerts[0].x, projectedVerts[1].x, projectedVerts[2].x),\n                        maxX: Math.max(projectedVerts[0].x, projectedVerts[1].x, projectedVerts[2].x),\n                        minY: Math.min(projectedVerts[0].y, projectedVerts[1].y, projectedVerts[2].y),\n                        maxY: Math.max(projectedVerts[0].y, projectedVerts[1].y, projectedVerts[2].y),\n                        v0: projectedVerts[0],\n                        v1: projectedVerts[1],\n                        v2: projectedVerts[2]\n                    },\n                    isMeshSpecular: true\n                };\n\n                specularHighlights.push(specularHighlight);\n            });\n        });\n    }\n\n    /**\n     * Render specular highlights as circular gradients with occlusion testing\n     * @param {Array} specularHighlights - Array of specular highlight data\n     * @param {ImageData} imgData - Image data to draw on\n     * @param {number} w - Width\n     * @param {number} h - Height\n     */\n    renderSpecularHighlights(specularHighlights, imgData, w, h) {\n        const data = imgData.data;\n        const buffer32 = new Uint32Array(imgData.data.buffer);\n\n        const bgColors = [\n            this.hexToRgb(this._skyColor),\n            this.hexToRgb(this._floorColor),\n            this.hexToRgb(this._backgroundColor)\n        ];\n\n        specularHighlights.forEach(highlight => {\n            const { centerX, centerY, radius, intensity, color, triangleBounds, depth, cameraPos, fogFactor } = highlight;\n\n            // Skip specular if too much fog (>90% fog coverage)\n            if (fogFactor !== undefined && fogFactor > 0.9) {\n                return;\n            }\n\n            // Skip if highlight center is occluded\n            if (cameraPos && this.isPointOccluded(cameraPos, this._allTrianglesCache)) {\n                return;\n            }\n\n            // Reduce specular intensity based on fog\n            const fogAdjustedIntensity = fogFactor !== undefined ?\n                intensity * (1 - fogFactor) : intensity;\n\n            if (fogAdjustedIntensity < 0.01) return;\n\n            // Create fog-adjusted highlight\n            const fogAdjustedHighlight = {\n                ...highlight,\n                intensity: fogAdjustedIntensity\n            };\n\n            if (this._specularFullFace) {\n                this.renderFullFaceSpecular(fogAdjustedHighlight, buffer32, data, w, h, bgColors);\n            } else {\n                this.renderGradientSpecular(fogAdjustedHighlight, buffer32, data, w, h, bgColors);\n            }\n\n            // Add bloom effect if enabled and intensity is above threshold (also affected by fog)\n            if (this._specularBloomEnabled && fogAdjustedIntensity >= this._specularBloomThreshold) {\n                this.renderSpecularBloom(fogAdjustedHighlight, buffer32, data, w, h);\n            }\n        });\n    }\n\n    /**\n     * Render specular bloom effect (bleeding beyond geometry)\n     * @param {Object} highlight - Specular highlight data\n     * @param {Uint32Array} buffer32 - 32-bit pixel buffer\n     * @param {Uint8ClampedArray} data - Image data array\n     * @param {number} w - Width\n     * @param {number} h - Height\n     */\n    renderSpecularBloom(highlight, buffer32, data, w, h) {\n        const { centerX, centerY, radius, intensity, color } = highlight;\n\n        // Calculate bloom radius (larger than base specular)\n        const bloomRadius = radius * this._specularBloomRadius;\n        const bloomIntensity = intensity * this._specularBloomIntensity;\n\n        // Calculate bounding box (NOT constrained to triangle - full bleed)\n        const minX = Math.max(0, Math.floor(centerX - bloomRadius));\n        const maxX = Math.min(w - 1, Math.ceil(centerX + bloomRadius));\n        const minY = Math.max(0, Math.floor(centerY - bloomRadius));\n        const maxY = Math.min(h - 1, Math.ceil(centerY + bloomRadius));\n\n        if (minX > maxX || minY > maxY) return;\n\n        const radiusSq = bloomRadius * bloomRadius;\n        const invRadiusSq = 1.0 / radiusSq;\n\n        // Optimization: Sample every N pixels when radius is large\n        const pixelStep = bloomRadius > 80 ? 2 : 1;\n\n        // Render bloom with softer falloff - NO TRIANGLE BOUNDS CHECKING\n        for (let y = minY; y <= maxY; y += pixelStep) {\n            const dy = y - centerY;\n            const dySq = dy * dy;\n\n            for (let x = minX; x <= maxX; x += pixelStep) {\n                const dx = x - centerX;\n                const distSq = dx * dx + dySq;\n\n                if (distSq <= radiusSq) {\n                    const pixelIdx = y * w + x;\n                    const existing = buffer32[pixelIdx];\n                    const existingR = existing & 0xFF;\n                    const existingG = (existing >> 8) & 0xFF;\n                    const existingB = (existing >> 16) & 0xFF;\n\n                    // Calculate bloom falloff (softer than regular specular)\n                    const normalizedDistSq = distSq * invRadiusSq;\n                    const falloff = 1.0 - Math.sqrt(normalizedDistSq);\n\n                    // Extra smooth falloff for bloom (cubic for softer edges)\n                    const smoothFalloff = falloff * falloff * falloff;\n                    const alpha = bloomIntensity * smoothFalloff;\n\n                    if (alpha > 0.005) { // Lower threshold for bloom\n                        const dataIdx = pixelIdx * 4;\n\n                        // Additive blending for bloom effect\n                        const bloomR = Math.min(255, Math.round(existingR + color.r * alpha));\n                        const bloomG = Math.min(255, Math.round(existingG + color.g * alpha));\n                        const bloomB = Math.min(255, Math.round(existingB + color.b * alpha));\n\n                        data[dataIdx] = bloomR;\n                        data[dataIdx + 1] = bloomG;\n                        data[dataIdx + 2] = bloomB;\n\n                        // Fill adjacent pixels if using step optimization\n                        if (pixelStep > 1) {\n                            for (let py = 0; py < pixelStep && y + py <= maxY; py++) {\n                                for (let px = 0; px < pixelStep && x + px <= maxX; px++) {\n                                    if (px === 0 && py === 0) continue;\n                                    const fillIdx = (y + py) * w + (x + px);\n                                    const fillDataIdx = fillIdx * 4;\n\n                                    // Make sure we're within bounds\n                                    if (fillIdx >= 0 && fillIdx < w * h) {\n                                        data[fillDataIdx] = bloomR;\n                                        data[fillDataIdx + 1] = bloomG;\n                                        data[fillDataIdx + 2] = bloomB;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Render full-face specular highlighting\n     */\n    renderFullFaceSpecular(highlight, buffer32, data, w, h, bgColors) {\n        const { intensity, color, triangleBounds } = highlight;\n        const tolerance = 5;\n\n        // Get triangle bounds\n        const minX = Math.max(0, Math.floor(triangleBounds.minX));\n        const maxX = Math.min(w - 1, Math.ceil(triangleBounds.maxX));\n        const minY = Math.max(0, Math.floor(triangleBounds.minY));\n        const maxY = Math.min(h - 1, Math.ceil(triangleBounds.maxY));\n\n        if (minX > maxX || minY > maxY) return;\n\n        // Pre-calculate edge functions for triangle bounds checking\n        const p0 = { x: triangleBounds.v0.x, y: triangleBounds.v0.y };\n        const p1 = { x: triangleBounds.v1.x, y: triangleBounds.v1.y };\n        const p2 = { x: triangleBounds.v2.x, y: triangleBounds.v2.y };\n\n        const e0_dx = p1.x - p0.x; const e0_dy = p1.y - p0.y;\n        const e1_dx = p2.x - p1.x; const e1_dy = p2.y - p1.y;\n        const e2_dx = p0.x - p2.x; const e2_dy = p0.y - p2.y;\n\n        // Limit intensity\n        const maxIntensity = 1.0; // No longer limited by bleeding\n        const limitedIntensity = Math.min(intensity, maxIntensity);\n\n        // Apply uniform specular to all pixels in triangle\n        for (let y = minY; y <= maxY; y++) {\n            for (let x = minX; x <= maxX; x++) {\n                // Check if pixel is inside triangle\n                const w0 = e0_dx * (y - p0.y) - e0_dy * (x - p0.x);\n                const w1 = e1_dx * (y - p1.y) - e1_dy * (x - p1.x);\n                const w2 = e2_dx * (y - p2.y) - e2_dy * (x - p2.x);\n\n                if (w0 < 0 || w1 < 0 || w2 < 0) continue;\n\n                const pixelIdx = y * w + x;\n                const existing = buffer32[pixelIdx];\n                const existingR = existing & 0xFF;\n                const existingG = (existing >> 8) & 0xFF;\n                const existingB = (existing >> 16) & 0xFF;\n\n                // Check if pixel is background (skip if not bleeding)\n                if (!this._specularBleedingEnabled) {\n                    let isBackground = false;\n                    for (const bgColor of bgColors) {\n                        if (Math.abs(existingR - bgColor.r) <= tolerance &&\n                            Math.abs(existingG - bgColor.g) <= tolerance &&\n                            Math.abs(existingB - bgColor.b) <= tolerance) {\n                            isBackground = true;\n                            break;\n                        }\n                    }\n                    if (isBackground) continue;\n                }\n\n                // Apply uniform specular intensity\n                const dataIdx = pixelIdx * 4;\n                const specR = Math.min(255, existingR + color.r * limitedIntensity);\n                const specG = Math.min(255, existingG + color.g * limitedIntensity);\n                const specB = Math.min(255, existingB + color.b * limitedIntensity);\n\n                data[dataIdx] = specR;\n                data[dataIdx + 1] = specG;\n                data[dataIdx + 2] = specB;\n            }\n        }\n    }\n\n    /**\n     * Render gradient specular highlighting (existing circular gradient mode)\n     */\n    renderGradientSpecular(highlight, buffer32, data, w, h, bgColors) {\n        const { centerX, centerY, radius, intensity, color, triangleBounds } = highlight;\n        const tolerance = 5;\n\n        // Calculate bounding box - with or without triangle clipping based on setting\n        let minX, maxX, minY, maxY;\n\n        if (this._specularBleedingEnabled) {\n            // Allow bleeding - only screen bounds\n            minX = Math.max(0, Math.floor(centerX - radius));\n            maxX = Math.min(w - 1, Math.ceil(centerX + radius));\n            minY = Math.max(0, Math.floor(centerY - radius));\n            maxY = Math.min(h - 1, Math.ceil(centerY + radius));\n        } else {\n            // Constrain to triangle bounds\n            minX = Math.max(0, Math.floor(Math.max(triangleBounds.minX, centerX - radius)));\n            maxX = Math.min(w - 1, Math.ceil(Math.min(triangleBounds.maxX, centerX + radius)));\n            minY = Math.max(0, Math.floor(Math.max(triangleBounds.minY, centerY - radius)));\n            maxY = Math.min(h - 1, Math.ceil(Math.min(triangleBounds.maxY, centerY + radius)));\n        }\n\n        if (minX > maxX || minY > maxY) return;\n\n        const radiusSq = radius * radius;\n        const invRadiusSq = 1.0 / radiusSq;\n\n        // Pre-calculate edge functions for triangle bounds checking (only if not bleeding)\n        let p0, p1, p2, e0_dx, e0_dy, e1_dx, e1_dy, e2_dx, e2_dy;\n\n        if (!this._specularBleedingEnabled) {\n            p0 = { x: triangleBounds.v0.x, y: triangleBounds.v0.y };\n            p1 = { x: triangleBounds.v1.x, y: triangleBounds.v1.y };\n            p2 = { x: triangleBounds.v2.x, y: triangleBounds.v2.y };\n\n            e0_dx = p1.x - p0.x; e0_dy = p1.y - p0.y;\n            e1_dx = p2.x - p1.x; e1_dy = p2.y - p1.y;\n            e2_dx = p0.x - p2.x; e2_dy = p0.y - p2.y;\n        }\n\n        // No intensity limiting - full specular power\n        const maxIntensity = 1.0;\n        const limitedIntensity = Math.min(intensity, maxIntensity);\n\n        // Optimization: Sample every N pixels when radius is large\n        const pixelStep = radius > 50 ? 2 : 1;\n\n        // Render circular gradient with occlusion testing\n        for (let y = minY; y <= maxY; y += pixelStep) {\n            const dy = y - centerY;\n            const dySq = dy * dy;\n\n            for (let x = minX; x <= maxX; x += pixelStep) {\n                // Check if pixel is inside triangle (only if not bleeding)\n                if (!this._specularBleedingEnabled) {\n                    const w0 = e0_dx * (y - p0.y) - e0_dy * (x - p0.x);\n                    const w1 = e1_dx * (y - p1.y) - e1_dy * (x - p1.x);\n                    const w2 = e2_dx * (y - p2.y) - e2_dy * (x - p2.x);\n\n                    if (w0 < 0 || w1 < 0 || w2 < 0) continue;\n                }\n\n                const dx = x - centerX;\n                const distSq = dx * dx + dySq;\n\n                if (distSq <= radiusSq) {\n                    const pixelIdx = y * w + x;\n\n                    const existing = buffer32[pixelIdx];\n                    const existingR = existing & 0xFF;\n                    const existingG = (existing >> 8) & 0xFF;\n                    const existingB = (existing >> 16) & 0xFF;\n\n                    let isBackground = false;\n                    for (const bgColor of bgColors) {\n                        if (Math.abs(existingR - bgColor.r) <= tolerance &&\n                            Math.abs(existingG - bgColor.g) <= tolerance &&\n                            Math.abs(existingB - bgColor.b) <= tolerance) {\n                            isBackground = true;\n                            break;\n                        }\n                    }\n\n                    if (!this._specularBleedingEnabled && isBackground) {\n                        continue;\n                    }\n\n                    const normalizedDistSq = distSq * invRadiusSq;\n                    const falloff = 1.0 - Math.sqrt(normalizedDistSq);\n                    const smoothFalloff = falloff * falloff * (3 - 2 * falloff);\n                    const alpha = limitedIntensity * smoothFalloff;\n\n                    if (alpha > 0.01) {\n                        const dataIdx = pixelIdx * 4;\n\n                        const specR = Math.min(255, existingR + color.r * alpha);\n                        const specG = Math.min(255, existingG + color.g * alpha);\n                        const specB = Math.min(255, existingB + color.b * alpha);\n\n                        data[dataIdx] = specR;\n                        data[dataIdx + 1] = specG;\n                        data[dataIdx + 2] = specB;\n\n                        if (pixelStep > 1) {\n                            for (let py = 0; py < pixelStep && y + py <= maxY; py++) {\n                                for (let px = 0; px < pixelStep && x + px <= maxX; px++) {\n                                    if (px === 0 && py === 0) continue;\n                                    const fillIdx = (y + py) * w + (x + px);\n                                    const fillDataIdx = fillIdx * 4;\n                                    data[fillDataIdx] = specR;\n                                    data[fillDataIdx + 1] = specG;\n                                    data[fillDataIdx + 2] = specB;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    interpolateColor(color1, color2, t) {\n        const c1 = this.hexToRgb(color1);\n        const c2 = this.hexToRgb(color2);\n        return {\n            r: Math.round(c1.r + (c2.r - c1.r) * t),\n            g: Math.round(c1.g + (c2.g - c1.g) * t),\n            b: Math.round(c1.b + (c2.b - c1.b) * t)\n        };\n    }\n\n    calculateLighting(normal, baseColor) {\n        // Normalize light direction\n        const len = Math.sqrt(this._lightDirection.x ** 2 + this._lightDirection.y ** 2 + this._lightDirection.z ** 2);\n        const lightDir = {\n            x: this._lightDirection.x / len,\n            y: this._lightDirection.y / len,\n            z: this._lightDirection.z / len\n        };\n\n        // Calculate diffuse lighting (Lambertian)\n        const dotProduct = -(normal.x * lightDir.x + normal.y * lightDir.y + normal.z * lightDir.z);\n        const diffuse = Math.max(0, dotProduct) * this._lightIntensity;\n\n        // Combine ambient and diffuse\n        const lighting = this._ambientIntensity + diffuse * (1 - this._ambientIntensity);\n\n        // Apply light color\n        const lightRgb = this.hexToRgb(this._lightColor);\n        const baseRgb = typeof baseColor === 'string' ? this.hexToRgb(baseColor) : baseColor;\n\n        return {\n            r: Math.min(255, Math.round(baseRgb.r * lighting * (lightRgb.r / 255))),\n            g: Math.min(255, Math.round(baseRgb.g * lighting * (lightRgb.g / 255))),\n            b: Math.min(255, Math.round(baseRgb.b * lighting * (lightRgb.b / 255)))\n        };\n    }\n\n    calculateFaceNormal(v0, v1, v2) {\n        const e1 = { x: v1.x - v0.x, y: v1.y - v0.y, z: v1.z - v0.z };\n        const e2 = { x: v2.x - v0.x, y: v2.y - v0.y, z: v2.z - v0.z };\n        const normal = {\n            x: e1.y * e2.z - e1.z * e2.y,\n            y: e1.z * e2.x - e1.x * e2.z,\n            z: e1.x * e2.y - e1.y * e2.x\n        };\n        const len = Math.sqrt(normal.x ** 2 + normal.y ** 2 + normal.z ** 2);\n        if (len > 1e-10) {\n            return { x: normal.x / len, y: normal.y / len, z: normal.z / len };\n        }\n        // Return a default normal if calculation fails (shouldn't happen with valid triangles)\n        return { x: 0, y: 0, z: 1 };\n    }\n\n    // Improved backface culling that works consistently across all rendering methods\n    // Improved backface culling that works consistently across all rendering methods\n    shouldCullFace(cameraSpaceVertices) {\n        // If backface culling is disabled, never cull\n        if (!this._enableBackfaceCulling) {\n            return false;\n        }\n\n        if (cameraSpaceVertices.length < 3) return true;\n\n        const v0 = cameraSpaceVertices[0];\n        const v1 = cameraSpaceVertices[1];\n        const v2 = cameraSpaceVertices[2];\n\n        // Calculate face normal in camera space using cross product\n        const edge1 = { x: v1.x - v0.x, y: v1.y - v0.y, z: v1.z - v0.z };\n        const edge2 = { x: v2.x - v0.x, y: v2.y - v0.y, z: v2.z - v0.z };\n\n        // Cross product (edge1 x edge2)\n        const normal = {\n            x: edge1.y * edge2.z - edge1.z * edge2.y,\n            y: edge1.z * edge2.x - edge1.x * edge2.z,\n            z: edge1.x * edge2.y - edge1.y * edge2.x\n        };\n\n        // Normalize the normal\n        const normalLength = Math.sqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);\n        if (normalLength < 1e-10) return true; // Degenerate triangle\n\n        const normalizedNormal = {\n            x: normal.x / normalLength,\n            y: normal.y / normalLength,\n            z: normal.z / normalLength\n        };\n\n        // Use centroid of triangle for view direction\n        const centroidX = (v0.x + v1.x + v2.x) / 3;\n        const centroidY = (v0.y + v1.y + v2.y) / 3;\n        const centroidZ = (v0.z + v1.z + v2.z) / 3;\n\n        // View direction from centroid to camera (camera is at origin in camera space)\n        const viewDir = {\n            x: -centroidX,\n            y: -centroidY,\n            z: -centroidZ\n        };\n\n        const viewLen = Math.sqrt(viewDir.x * viewDir.x + viewDir.y * viewDir.y + viewDir.z * viewDir.z);\n        if (viewLen < 1e-10) return false;\n\n        viewDir.x /= viewLen;\n        viewDir.y /= viewLen;\n        viewDir.z /= viewLen;\n\n        // Dot product between normal and view direction\n        // If positive, face is front-facing; if negative, back-facing\n        const dotProduct = normalizedNormal.x * viewDir.x + normalizedNormal.y * viewDir.y + normalizedNormal.z * viewDir.z;\n\n        // More lenient culling threshold to prevent side-on faces from being culled\n        const isBackface = dotProduct < -0.05; // Reduced from 0.01 to -0.05 for more lenient culling\n\n        return isBackface;\n    }\n\n    render3D() {\n        if (!this._renderTextureCtx) return;\n\n        // Check if this camera should be active\n        if (!this._isActive) {\n            // Try to activate if no other camera is active\n            const allObjects = this.getGameObjects();\n            const activeCameras = allObjects.filter(obj => {\n                const camera = obj.getModule(\"Camera3DRasterizer\") || obj.getModule(\"Camera3D\");\n                return camera && camera._isActive && camera !== this;\n            });\n\n            if (activeCameras.length === 0) {\n                this._isActive = true;\n            }\n        }\n\n        if (!this._isActive) return;\n\n        this.renderRasterOptimized();\n    }\n\n    getRenderedTexture() {\n        if (!this._isActive) {\n            // Try to activate if no other camera is active\n            const allObjects = this.getGameObjects();\n            const activeCameras = allObjects.filter(obj => {\n                const camera = obj.getModule(\"Camera3DRasterizer\") || obj.getModule(\"Camera3D\");\n                return camera && camera._isActive && camera !== this;\n            });\n\n            if (activeCameras.length === 0) {\n                this._isActive = true;\n            }\n        }\n\n        if (!this._isActive) return null;\n\n        this.render3D();\n        return this._renderTexture;\n    }\n\n    drawRenderedTexture(ctx, x = 0, y = 0, width = null, height = null) {\n        if (!this._renderTexture || !this._isActive) return;\n        ctx.imageSmoothingEnabled = this._renderTextureSmoothing;\n        const drawWidth = width || this._renderTextureWidth;\n        const drawHeight = height || this._renderTextureHeight;\n        ctx.drawImage(this._renderTexture, x, y, drawWidth, drawHeight);\n    }\n\n    start() {\n        this.updateViewport();\n        this.updateRenderTexture();\n\n        // Check for other active cameras and auto-activate if this is the only one\n        const allObjects = this.getGameObjects();\n        const allCameras = allObjects\n            .map(obj => obj.getModule(\"Camera3DRasterizer\") || obj.getModule(\"Camera3D\"))\n            .filter(cam => cam !== null && cam !== undefined);\n\n        const activeCameras = allCameras.filter(cam => cam._isActive);\n\n        if (allCameras.length === 1 && allCameras[0] === this) {\n            // Only camera, auto-activate\n            this._isActive = true;\n        } else if (activeCameras.length === 0) {\n            // No active cameras, activate this one\n            this._isActive = true;\n        }\n    }\n\n    beginLoop() { this.updateViewport(); }\n    draw(ctx) { }\n    drawGizmos(ctx) {\n        ctx.save();\n        ctx.translate(this.gameObject.position.x, this.gameObject.position.y);\n        ctx.rotate((this.gameObject.angle * Math.PI) / 180);\n\n        // Draw a small camera icon at (0, 0)\n        ctx.fillStyle = '#ffffff';\n        ctx.fillRect(-3, -3, 6, 6); // Small body\n        ctx.beginPath();\n        ctx.arc(0, 0, 2, 0, 2 * Math.PI);\n        ctx.fillStyle = '#000000';\n        ctx.fill(); // Lens\n\n        // Draw frustum showing FOV, near, and far planes\n        const halfFovRad = (this._fieldOfView / 2) * (Math.PI / 180);\n        const near = this._nearPlane * 10; // Scale for visibility\n        const far = this._farPlane * 0.1; // Scale down far plane\n        const nearHalfWidth = near * Math.tan(halfFovRad);\n        const farHalfWidth = far * Math.tan(halfFovRad);\n\n        ctx.strokeStyle = '#ffff00'; // Yellow lines\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n\n        // Lines from camera to near plane\n        ctx.moveTo(0, 0);\n        ctx.lineTo(near, -nearHalfWidth);\n        ctx.moveTo(0, 0);\n        ctx.lineTo(near, nearHalfWidth);\n\n        // Near plane\n        ctx.moveTo(near, -nearHalfWidth);\n        ctx.lineTo(near, nearHalfWidth);\n\n        // Lines from near to far plane\n        ctx.moveTo(near, -nearHalfWidth);\n        ctx.lineTo(far, -farHalfWidth);\n        ctx.moveTo(near, nearHalfWidth);\n        ctx.lineTo(far, farHalfWidth);\n\n        // Far plane\n        ctx.moveTo(far, -farHalfWidth);\n        ctx.lineTo(far, farHalfWidth);\n\n        ctx.stroke();\n\n        ctx.restore();\n    }\n\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            _type: \"Camera3DRasterizer\", _position: { x: this._position.x, y: this._position.y, z: this._position.z },\n            _rotation: { x: this._rotation.x, y: this._rotation.y, z: this._rotation.z },\n            _fieldOfView: this._fieldOfView, _nearPlane: this._nearPlane, _farPlane: this._farPlane,\n            _isActive: this._isActive, _backgroundColor: this._backgroundColor,\n            _renderTextureWidth: this._renderTextureWidth, _renderTextureHeight: this._renderTextureHeight,\n            _renderTextureSmoothing: this._renderTextureSmoothing, drawGizmoInRuntime: this.drawGizmoInRuntime,\n            _renderingMethod: this._renderingMethod, _enableBackfaceCulling: this._enableBackfaceCulling,\n            _lightDirection: { x: this._lightDirection.x, y: this._lightDirection.y, z: this._lightDirection.z },\n            _lightColor: this._lightColor,\n            _lightIntensity: this._lightIntensity,\n            _ambientIntensity: this._ambientIntensity,\n            _skyColor: this._skyColor,\n            _skyColorHorizon: this._skyColorHorizon,\n            _floorColor: this._floorColor,\n            _floorColorHorizon: this._floorColorHorizon,\n            _backgroundType: this._backgroundType,\n            _showSun: this._showSun,\n            _sunSize: this._sunSize,\n            _sunGlowSize: this._sunGlowSize,\n            _specularEnabled: this._specularEnabled,\n            _specularBleedingEnabled: this._specularBleedingEnabled,\n            _specularPerMesh: this._specularPerMesh,\n            _specularFullFace: this._specularFullFace,\n            _specularBloomEnabled: this._specularBloomEnabled,\n            _specularBloomIntensity: this._specularBloomIntensity,\n            _specularBloomRadius: this._specularBloomRadius,\n            _specularBloomThreshold: this._specularBloomThreshold,\n            _showDebugInfo: this._showDebugInfo,\n            _maxLights: this._maxLights,\n            _lightFindDistance: this._lightFindDistance,\n            _useDynamicLighting: this._useDynamicLighting,\n            _lensFlareEnabled: this._lensFlareEnabled,\n            _lensFlareIntensity: this._lensFlareIntensity,\n            _lensFlareCount: this._lensFlareCount,\n            _lensFlareSpacing: this._lensFlareSpacing,\n            _lensFlareSize: this._lensFlareSize,\n            _lensFlareColorShift: this._lensFlareColorShift,\n            _fogEnabled: this._fogEnabled,\n            _fogColor: this._fogColor,\n            _fogStart: this._fogStart,\n            _fogEnd: this._fogEnd,\n            _fogDensity: this._fogDensity,\n            _waterEnabled: this._waterEnabled,\n            _waterSpeed: this._waterSpeed,\n            _waterWaveHeight: this._waterWaveHeight,\n            _cloudsEnabled: this._cloudsEnabled,\n            _cloudSpeed: this._cloudSpeed,\n            _cloudDensity: this._cloudDensity,\n            _cloudScale: this._cloudScale,\n            _cloudSoftness: this._cloudSoftness,\n            _cloudHeight: this._cloudHeight,\n            _cloudThickness: this._cloudThickness,\n            _cloudBrightness: this._cloudBrightness,\n            _cloudResolution: this._cloudResolution,\n            _emissiveIntensity: this._emissiveIntensity || 1.0\n        };\n    }\n\n    fromJSON(json) {\n        super.fromJSON(json);\n        if (json._position) this._position = new Vector3(json._position.x, json._position.y, json._position.z);\n        if (json._rotation) this._rotation = new Vector3(json._rotation.x, json._rotation.y, json._rotation.z);\n        if (json._fieldOfView !== undefined) this._fieldOfView = json._fieldOfView;\n        if (json._nearPlane !== undefined) this._nearPlane = json._nearPlane;\n        if (json._farPlane !== undefined) this._farPlane = json._farPlane;\n        if (json._isActive !== undefined) this._isActive = json._isActive;\n        if (json._backgroundColor !== undefined) this._backgroundColor = json._backgroundColor;\n        if (json._renderTextureWidth !== undefined) this._renderTextureWidth = json._renderTextureWidth;\n        if (json._renderTextureHeight !== undefined) this._renderTextureHeight = json._renderTextureHeight;\n        if (json._renderTextureSmoothing !== undefined) this._renderTextureSmoothing = json._renderTextureSmoothing;\n        if (json.drawGizmoInRuntime !== undefined) this.drawGizmoInRuntime = json.drawGizmoInRuntime;\n        if (json._renderingMethod !== undefined) this._renderingMethod = json._renderingMethod;\n        if (json._enableBackfaceCulling !== undefined) this._enableBackfaceCulling = json._enableBackfaceCulling;\n        if (json._lightDirection) this._lightDirection = new Vector3(json._lightDirection.x, json._lightDirection.y, json._lightDirection.z);\n        if (json._lightColor !== undefined) this._lightColor = json._lightColor;\n        if (json._lightIntensity !== undefined) this._lightIntensity = json._lightIntensity;\n        if (json._ambientIntensity !== undefined) this._ambientIntensity = json._ambientIntensity;\n        if (json._skyColor !== undefined) { this._skyColor = json._skyColor; } else { this._skyColor = \"#87CEEB\"; }\n        if (json._skyColorHorizon !== undefined) { this._skyColorHorizon = json._skyColorHorizon; } else { this._skyColorHorizon = \"#87CEEB\"; }\n        if (json._floorColor !== undefined) { this._floorColor = json._floorColor; } else { this._floorColor = \"#8B4513\"; }\n        if (json._floorColorHorizon !== undefined) { this._floorColorHorizon = json._floorColorHorizon; } else { this._floorColorHorizon = \"#654321\"; }\n        if (json._backgroundType !== undefined) { this._backgroundType = json._backgroundType; } else { this._backgroundType = \"skybox\"; }\n        if (json._showSun !== undefined) { this._showSun = json._showSun; } else { this._showSun = true; }\n        if (json._sunSize !== undefined) { this._sunSize = json._sunSize; } else { this._sunSize = 30; }\n        if (json._sunGlowSize !== undefined) { this._sunGlowSize = json._sunGlowSize; } else { this._sunGlowSize = 60; }\n        if (json._specularEnabled !== undefined) { this._specularEnabled = json._specularEnabled; } else { this._specularEnabled = true; }\n        if (json._specularBleedingEnabled !== undefined) { this._specularBleedingEnabled = json._specularBleedingEnabled; } else { this._specularBleedingEnabled = false; }\n        if (json._specularPerMesh !== undefined) { this._specularPerMesh = json._specularPerMesh; } else { this._specularPerMesh = false; }\n        if (json._specularFullFace !== undefined) { this._specularFullFace = json._specularFullFace; } else { this._specularFullFace = false; }\n        if (json._specularBloomEnabled !== undefined) { this._specularBloomEnabled = json._specularBloomEnabled; } else { this._specularBloomEnabled = false; }\n        if (json._specularBloomIntensity !== undefined) { this._specularBloomIntensity = json._specularBloomIntensity; } else { this._specularBloomIntensity = 0.5; }\n        if (json._specularBloomRadius !== undefined) { this._specularBloomRadius = json._specularBloomRadius; } else { this._specularBloomRadius = 1.5; }\n        if (json._specularBloomThreshold !== undefined) { this._specularBloomThreshold = json._specularBloomThreshold; } else { this._specularBloomThreshold = 0.3; }\n        if (json._showDebugInfo !== undefined) this._showDebugInfo = json._showDebugInfo;\n        if (json._maxLights !== undefined) this._maxLights = json._maxLights;\n        if (json._lightFindDistance !== undefined) this._lightFindDistance = json._lightFindDistance;\n        if (json._useDynamicLighting !== undefined) this._useDynamicLighting = json._useDynamicLighting;\n        if (json._lensFlareEnabled !== undefined) { this._lensFlareEnabled = json._lensFlareEnabled; } else { this._lensFlareEnabled = true; }\n        if (json._lensFlareIntensity !== undefined) { this._lensFlareIntensity = json._lensFlareIntensity; } else { this._lensFlareIntensity = 0.8; }\n        if (json._lensFlareCount !== undefined) { this._lensFlareCount = json._lensFlareCount; } else { this._lensFlareCount = 5; }\n        if (json._lensFlareSpacing !== undefined) { this._lensFlareSpacing = json._lensFlareSpacing; } else { this._lensFlareSpacing = 0.15; }\n        if (json._lensFlareSize !== undefined) { this._lensFlareSize = json._lensFlareSize; } else { this._lensFlareSize = 20; }\n        if (json._lensFlareColorShift !== undefined) { this._lensFlareColorShift = json._lensFlareColorShift; } else { this._lensFlareColorShift = true; }\n        if (json._fogEnabled !== undefined) { this._fogEnabled = json._fogEnabled; } else { this._fogEnabled = false; }\n        if (json._fogColor !== undefined) { this._fogColor = json._fogColor; } else { this._fogColor = \"#a0a0a0\"; }\n        if (json._fogStart !== undefined) { this._fogStart = json._fogStart; } else { this._fogStart = 100; }\n        if (json._fogEnd !== undefined) { this._fogEnd = json._fogEnd; } else { this._fogEnd = 500; }\n        if (json._fogDensity !== undefined) { this._fogDensity = json._fogDensity; } else { this._fogDensity = 1.0; }\n        if (json._waterEnabled !== undefined) { this._waterEnabled = json._waterEnabled; } else { this._waterEnabled = false; }\n        if (json._waterSpeed !== undefined) { this._waterSpeed = json._waterSpeed; } else { this._waterSpeed = 1.0; }\n        if (json._waterWaveHeight !== undefined) { this._waterWaveHeight = json._waterWaveHeight; } else { this._waterWaveHeight = 10; }\n        if (json._cloudsEnabled !== undefined) { this._cloudsEnabled = json._cloudsEnabled; } else { this._cloudsEnabled = false; }\n        if (json._cloudSpeed !== undefined) { this._cloudSpeed = json._cloudSpeed; } else { this._cloudSpeed = 0.5; }\n        if (json._cloudDensity !== undefined) { this._cloudDensity = json._cloudDensity; } else { this._cloudDensity = 0.4; }\n        if (json._cloudScale !== undefined) { this._cloudScale = json._cloudScale; } else { this._cloudScale = 150; }\n        if (json._cloudSoftness !== undefined) { this._cloudSoftness = json._cloudSoftness; } else { this._cloudSoftness = 0.6; }\n        if (json._cloudHeight !== undefined) { this._cloudHeight = json._cloudHeight; } else { this._cloudHeight = 0.3; }\n        if (json._cloudThickness !== undefined) { this._cloudThickness = json._cloudThickness; } else { this._cloudThickness = 0.4; }\n        if (json._cloudBrightness !== undefined) { this._cloudBrightness = json._cloudBrightness; } else { this._cloudBrightness = 1.0; }\n        if (json._cloudResolution !== undefined) { this._cloudResolution = json._cloudResolution; } else { this._cloudResolution = 0.5; }\n        if (json._emissiveIntensity !== undefined) {\n            this._emissiveIntensity = json._emissiveIntensity;\n        } else {\n            this._emissiveIntensity = 1.0;\n        }\n\n        this.updateRenderTexture();\n    }\n\n    get renderTextureWidth() { return this._renderTextureWidth; }\n    set renderTextureWidth(value) { this._renderTextureWidth = Math.max(64, Math.min(2048, value)); this.updateRenderTexture(); }\n    get renderTextureHeight() { return this._renderTextureHeight; }\n    set renderTextureHeight(value) { this._renderTextureHeight = Math.max(64, Math.min(2048, value)); this.updateRenderTexture(); }\n    get renderTextureSmoothing() { return this._renderTextureSmoothing; }\n    set renderTextureSmoothing(value) { this._renderTextureSmoothing = value; }\n    get backgroundColor() { return this._backgroundColor; }\n    set backgroundColor(value) { this._backgroundColor = value; }\n    get position() { return this._position; }\n    set position(value) { this._position = value; }\n    get rotation() { return this._rotation; }\n    set rotation(value) { this._rotation = value; }\n    get fieldOfView() { return this._fieldOfView; }\n    set fieldOfView(value) { this._fieldOfView = Math.max(1, Math.min(179, value)); }\n    get nearPlane() { return this._nearPlane; }\n    set nearPlane(value) { this._nearPlane = Math.max(0.01, value); }\n    get farPlane() { return this._farPlane; }\n    set farPlane(value) { this._farPlane = Math.max(1, value); }\n    get isActive() { return this._isActive; }\n    set isActive(value) { this._isActive = value; }\n}\n\nwindow.Camera3DRasterizer = Camera3DRasterizer;",
      "type": "file",
      "name": "Camera3DRasterizer.js",
      "parentPath": "/Assets/2D Context 3D Renderer",
      "created": 1759623950553,
      "modified": 1759624799660
    },
    {
      "path": "/Assets/2D Context 3D Renderer/FlyCamera.js",
      "content": "/**\r\n * FlyCamera - Module for camera movement with WASD controls\r\n * \r\n * This module allows for flying camera controls using WASD keys and QE for up/down.\r\n * It needs to be attached to a GameObject with a Camera3D module.\r\n * \r\n * COORDINATE SYSTEM:\r\n * - X axis: forward/back (W/S)\r\n * - Y axis: left/right (A/D)\r\n * - Z axis: up/down (E/Q)\r\n * \r\n * MOVEMENT:    \r\n * - W: Move forward\r\n * - S: Move backward\r\n * - A: Strafe left\r\n * - D: Strafe right\r\n * - E: Move up\r\n * - Q: Move down\r\n * - Shift: Sprint (increases movement speed)\r\n */\r\nclass FlyCamera extends Module {\r\n    static namespace = \"3D\";\r\n    \r\n    /**\r\n     * Create a new FlyCamera\r\n     */\r\n    constructor() {\r\n        super(\"FlyCamera\");\r\n        \r\n        // Setup requirements\r\n        this.requires(\"Camera3DRasterizer\"); // Requires a Camera3D module on the same GameObject\r\n        \r\n        // Movement settings\r\n        this._moveSpeed = 200; // Units per second\r\n        this._sprintMultiplier = 2.5;\r\n        this._verticalSpeed = 150; // Units per second for up/down movement\r\n        \r\n        // Smoothing settings\r\n        this._smoothing = 0.2; // Lower = more responsive, higher = smoother\r\n        this._currentVelocity = new Vector3(0, 0, 0);\r\n\r\n        // Z Axis Movement\r\n        this._useZAxis = true; // Enable vertical movement by default\r\n        this._lockZAxisPosition = false; // Lock camera at current Z position\r\n        \r\n        // Key mapping (can be customized)\r\n        this._keyMapping = {\r\n            forward: \"w\",\r\n            backward: \"s\",\r\n            left: \"a\",\r\n            right: \"d\",\r\n            up: \"e\",\r\n            down: \"q\",\r\n            sprint: \"shift\"\r\n        };\r\n        \r\n        // Camera reference (will be set in start())\r\n        this.camera = null;\r\n        \r\n        // Expose properties to the inspector\r\n        this.exposeProperty(\"moveSpeed\", \"number\", 200, {\r\n            min: 1,\r\n            max: 1000,\r\n            onChange: (val) => this._moveSpeed = val\r\n        });\r\n\r\n        this.exposeProperty(\"sprintMultiplier\", \"number\", 2.5, {\r\n            min: 1,\r\n            max: 10,\r\n            onChange: (val) => this._sprintMultiplier = val\r\n        });\r\n\r\n        this.exposeProperty(\"verticalSpeed\", \"number\", 150, {\r\n            min: 1,\r\n            max: 500,\r\n            onChange: (val) => this._verticalSpeed = val\r\n        });\r\n\r\n        this.exposeProperty(\"smoothing\", \"number\", 0.2, {\r\n            min: 0,\r\n            max: 0.99,\r\n            step: 0.01,\r\n            onChange: (val) => this._smoothing = val\r\n        });\r\n\r\n        this.exposeProperty(\"keyMapping\", \"object\", this._keyMapping, {\r\n            onChange: (val) => this._keyMapping = val\r\n        });\r\n\r\n        this.exposeProperty(\"useZAxis\", \"boolean\", true, {\r\n            onChange: (val) => this._useZAxis = val\r\n        });\r\n\r\n        this.exposeProperty(\"lockZAxisPosition\", \"boolean\", false, {\r\n            onChange: (val) => this._lockZAxisPosition = val\r\n        });\r\n\r\n        // Collision detection settings\r\n        this._collisionRadius = 50; // Radius to search for collidable objects\r\n        this._collisionEnabled = true; // Enable collision detection\r\n        this._slideAlongWalls = true; // Enable wall sliding instead of just stopping\r\n\r\n        this.exposeProperty(\"collisionRadius\", \"number\", 50, {\r\n            min: 1,\r\n            max: 1000,\r\n            onChange: (val) => this._collisionRadius = val\r\n        });\r\n\r\n        this.exposeProperty(\"collisionEnabled\", \"boolean\", true, {\r\n            onChange: (val) => this._collisionEnabled = val\r\n        });\r\n\r\n        this.exposeProperty(\"slideAlongWalls\", \"boolean\", true, {\r\n            onChange: (val) => this._slideAlongWalls = val\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Called when the module starts\r\n     */\r\n    start() {\r\n        // Get camera reference\r\n        this.camera = this.getModule(\"Camera3DRasterizer\");// || this.getModule(\"Camera3D\");\r\n        \r\n        if (!this.camera) {\r\n            console.error(\"FlyCamera requires a Camera3D module on the same GameObject\");\r\n        }\r\n        \r\n        // Make sure input manager is available\r\n        if (!window.input) {\r\n            console.error(\"FlyCamera requires InputManager to be initialized\");\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Handle camera movement each frame\r\n     * @param {number} deltaTime - Time since last frame in seconds\r\n     */\r\n    loop(deltaTime) {\r\n        if (!this.camera || !window.input) return;\r\n        \r\n        // Calculate target velocity based on key presses\r\n        const targetVelocity = this.calculateTargetVelocity();\r\n        \r\n        // Apply smoothing\r\n        this._currentVelocity.x += (targetVelocity.x - this._currentVelocity.x) * (1 - this.smoothing);\r\n        this._currentVelocity.y += (targetVelocity.y - this._currentVelocity.y) * (1 - this.smoothing);\r\n        this._currentVelocity.z += (targetVelocity.z - this._currentVelocity.z) * (1 - this.smoothing);\r\n        \r\n        // Move the camera\r\n        if (this._currentVelocity.magnitude() > 0.01) {\r\n            this.moveCamera(deltaTime);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Calculate target velocity based on key presses\r\n     * @returns {Vector3} Target velocity\r\n     */\r\n    calculateTargetVelocity() {\r\n        // Start with zero velocity\r\n        const targetVelocity = new Vector3(0, 0, 0);\r\n        \r\n        // Check if input manager is available\r\n        if (!window.input) return targetVelocity;\r\n        \r\n        // Check sprint key\r\n        const sprinting = window.input.keyDown(this.keyMapping.sprint);\r\n        const speedMultiplier = sprinting ? this.sprintMultiplier : 1;\r\n        \r\n        // Calculate movement direction in camera space\r\n        // NOTE: X = forward/back, Y = left/right, Z = up/down\r\n        if (window.input.keyDown(this.keyMapping.forward)) {\r\n            targetVelocity.x += this.moveSpeed * speedMultiplier;   // forward -> +X\r\n        }\r\n        if (window.input.keyDown(this.keyMapping.backward)) {\r\n            targetVelocity.x -= this.moveSpeed * speedMultiplier;   // backward -> -X\r\n        }\r\n        if (window.input.keyDown(this.keyMapping.left)) {\r\n            targetVelocity.y -= this.moveSpeed * speedMultiplier;   // left -> -Y\r\n        }\r\n        if (window.input.keyDown(this.keyMapping.right)) {\r\n            targetVelocity.y += this.moveSpeed * speedMultiplier;   // right -> +Y\r\n        }\r\n        if (this._useZAxis) {\r\n            if (window.input.keyDown(this.keyMapping.up)) {\r\n                targetVelocity.z += this.verticalSpeed * speedMultiplier; // up -> +Z\r\n            }\r\n            if (window.input.keyDown(this.keyMapping.down)) {\r\n                targetVelocity.z -= this.verticalSpeed * speedMultiplier; // down -> -Z\r\n            }\r\n        }\r\n        \r\n        return targetVelocity;\r\n    }\r\n    \r\n    /**\r\n     * Find collidable game objects within a radius of the camera\r\n     * @param {number} radius - Search radius\r\n     * @returns {Array} Array of game objects with colliders\r\n     */\r\n    findCollidableObjects(radius) {\r\n        if (!window.engine || !window.engine.gameObjects) return [];\r\n\r\n        const collidableObjects = [];\r\n        const cameraPos = this.getCameraWorldPosition();\r\n\r\n        for (const gameObj of window.engine.gameObjects) {\r\n            if (!gameObj.active || gameObj === this.gameObject) continue;\r\n\r\n            // Check if object has collision capabilities\r\n            const hasCollider = gameObj.getModule && (\r\n                gameObj.getModule('Collider') ||\r\n                gameObj.getModule('RigidBody') ||\r\n                gameObj.getModule('BoundingBoxCollider')\r\n            );\r\n\r\n            if (hasCollider) {\r\n                const objPos = gameObj.getWorldPosition();\r\n                const distance = Math.sqrt(\r\n                    Math.pow(cameraPos.x - objPos.x, 2) +\r\n                    Math.pow(cameraPos.y - objPos.y, 2)\r\n                );\r\n\r\n                if (distance <= radius) {\r\n                    collidableObjects.push(gameObj);\r\n                }\r\n            }\r\n        }\r\n\r\n        return collidableObjects;\r\n    }\r\n\r\n    /**\r\n     * Get the camera's world position as a Vector2\r\n     * @returns {Object} Position object with x, y properties\r\n     */\r\n    getCameraWorldPosition() {\r\n        if (this.gameObject && this.gameObject.position) {\r\n            return {\r\n                x: this.gameObject.position.x || 0,\r\n                y: this.gameObject.position.y || 0\r\n            };\r\n        }\r\n        return { x: 0, y: 0 };\r\n    }\r\n\r\n    /**\r\n     * Check for collision along a movement vector\r\n     * @param {Vector3} movement - Movement vector\r\n     * @param {Array} collidableObjects - Objects to check collision against\r\n     * @returns {Object} Collision information or null\r\n     */\r\n    checkMovementCollision(movement, collidableObjects) {\r\n        if (!movement || movement.magnitude() < 0.01) return null;\r\n\r\n        const startPos = this.getCameraWorldPosition();\r\n\r\n        for (const obj of collidableObjects) {\r\n            const boundingBox = obj.getBoundingBox();\r\n            if (!boundingBox) continue;\r\n\r\n            // Create ray from current position in movement direction\r\n            const ray = {\r\n                origin: new Vector2(startPos.x, startPos.y),\r\n                direction: new Vector2(movement.x, movement.y).normalize()\r\n            };\r\n\r\n            const hit = window.collisionSystem.raycast(ray, boundingBox);\r\n            if (hit && hit.distance <= movement.magnitude()) {\r\n                return {\r\n                    object: obj,\r\n                    hit: hit,\r\n                    distance: hit.distance\r\n                };\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Apply collision response to movement\r\n     * @param {Vector3} originalMovement - Original movement vector\r\n     * @param {Object} collision - Collision information\r\n     * @returns {Vector3} Modified movement vector\r\n     */\r\n    applyCollisionResponse(originalMovement, collision) {\r\n        if (!this._slideAlongWalls) {\r\n            // Just stop movement in collision direction\r\n            return new Vector3(0, 0, originalMovement.z);\r\n        }\r\n\r\n        // Calculate slide direction\r\n        const hitNormal = collision.hit.normal;\r\n        const movementDir = new Vector2(originalMovement.x, originalMovement.y);\r\n\r\n        // Project movement onto the wall normal to get the component to remove\r\n        const dotProduct = movementDir.dot(hitNormal);\r\n        if (dotProduct >= 0) return originalMovement; // Moving away from wall\r\n\r\n        // Remove the component that's penetrating the wall\r\n        const slideMovement = movementDir.subtract(hitNormal.multiply(dotProduct));\r\n\r\n        return new Vector3(slideMovement.x, slideMovement.y, originalMovement.z);\r\n    }\r\n\r\n    /**\r\n     * Move the camera based on current velocity\r\n     * @param {number} deltaTime - Time since last frame in seconds\r\n     */\r\n    moveCamera(deltaTime) {\r\n        // Use parent's world rotation if available, fallback to local rotation or 0\r\n        const parentRotDeg = (this.gameObject && typeof this.gameObject.getWorldRotation === 'function')\r\n            ? this.gameObject.getWorldRotation()\r\n            : (typeof this.gameObject.rotation === 'number' ? this.gameObject.rotation : 0);\r\n\r\n        // Camera Euler (degrees)\r\n        const cameraYawDeg = (this.camera && this.camera.rotation && typeof this.camera.rotation.z === 'number') ? (this.camera.rotation.z || 0) : 0;\r\n        const cameraPitchDeg = (this.camera && this.camera.rotation && typeof this.camera.rotation.y === 'number') ? (this.camera.rotation.y || 0) : 0;\r\n        const cameraRollDeg = (this.camera && this.camera.rotation && typeof this.camera.rotation.x === 'number') ? (this.camera.rotation.x || 0) : 0;\r\n\r\n        // Combined yaw = parent yaw + camera local yaw\r\n        const combinedYawDeg = parentRotDeg + cameraYawDeg;\r\n\r\n        // Ensure gameObject.position exists and has numeric x/y (engine uses Vector2 by default)\r\n        if (!this.gameObject.position || typeof this.gameObject.position.x !== 'number' || typeof this.gameObject.position.y !== 'number') {\r\n            this.gameObject.position = { x: 0, y: 0 };\r\n        }\r\n\r\n        // Build forward and right vectors in world space using Vector3 helpers.\r\n        // Forward ignores pitch for forward/back movement (moves along x/y plane).\r\n        const forwardVec = Vector3.rotateByEulerDeg(Vector3.forward(), combinedYawDeg, 0, 0).normalize();\r\n        // Right vector only uses yaw for horizontal strafing (ignores pitch/roll)\r\n        const rightVec = Vector3.rotateByEulerDeg(Vector3.right(), combinedYawDeg, 0, 0).normalize();\r\n\r\n        // Compose horizontal movement vector in world space (velocity components are in camera local axes)\r\n        const horizontalMove = forwardVec.multiply(this._currentVelocity.x)\r\n            .add(rightVec.multiply(this._currentVelocity.y));\r\n\r\n        // Guard against invalid numbers and apply deltaTime\r\n        const dx = Number.isFinite(horizontalMove.x) ? horizontalMove.x * deltaTime : 0;\r\n        const dy = Number.isFinite(horizontalMove.y) ? horizontalMove.y * deltaTime : 0;\r\n        // Up/down movement is purely along world Z axis, ignoring rotation\r\n        const dz = Number.isFinite(this._currentVelocity.z) ? this._currentVelocity.z * deltaTime : 0;\r\n\r\n        // Apply collision detection if enabled\r\n        let finalDx = dx;\r\n        let finalDy = dy;\r\n        let finalDz = dz;\r\n\r\n        if (this._collisionEnabled && (Math.abs(dx) > 0.01 || Math.abs(dy) > 0.01)) {\r\n            // Find collidable objects within radius\r\n            const collidableObjects = this.findCollidableObjects(this._collisionRadius);\r\n\r\n            if (collidableObjects.length > 0) {\r\n                // Create movement vector for collision checking\r\n                const movementVector = new Vector3(dx, dy, 0);\r\n\r\n                // Check for collisions\r\n                const collision = this.checkMovementCollision(movementVector, collidableObjects);\r\n\r\n                if (collision) {\r\n                    // Apply collision response\r\n                    const collisionMovement = this.applyCollisionResponse(movementVector, collision);\r\n\r\n                    // Check if we still collide after applying slide\r\n                    if (collisionMovement.magnitude() > 0.01) {\r\n                        const slideCollision = this.checkMovementCollision(collisionMovement, collidableObjects);\r\n                        if (slideCollision) {\r\n                            // If still colliding after slide, stop movement\r\n                            finalDx = 0;\r\n                            finalDy = 0;\r\n                        } else {\r\n                            finalDx = collisionMovement.x;\r\n                            finalDy = collisionMovement.y;\r\n                        }\r\n                    } else {\r\n                        finalDx = 0;\r\n                        finalDy = 0;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Apply movement to GameObject's 2D position\r\n        this.gameObject.position.x += finalDx;\r\n        this.gameObject.position.y += finalDy;\r\n\r\n        // Apply vertical movement to the Camera3D's position.z (avoid adding z to parent Vector2)\r\n        if (this.camera && !this._lockZAxisPosition) {\r\n            if (!this.camera.position || typeof this.camera.position.z !== 'number') {\r\n                // ensure camera.position is a Vector3-like object\r\n                this.camera.position = new Vector3(\r\n                    (this.camera.position && this.camera.position.x) || 0,\r\n                    (this.camera.position && this.camera.position.y) || 0,\r\n                    (this.camera.position && this.camera.position.z) || 0\r\n                );\r\n            }\r\n\r\n            // Prefer updating gameObject.depth so Z maps to GameObject depth (negative=up, positive=down).\r\n            if (this.gameObject) {\r\n                if (typeof this.gameObject.depth === 'number') {\r\n                    this.gameObject.depth = (this.gameObject.depth || 0) + dz;\r\n                } else if (this.gameObject.position && typeof this.gameObject.position.z === 'number') {\r\n                    this.gameObject.position.z += dz;\r\n                } else {\r\n                    // Fallback: update camera local Z\r\n                    this.camera.position.z = (this.camera.position.z || 0) + dz;\r\n                }\r\n            } else {\r\n                // Fallback: update camera local Z\r\n                this.camera.position.z = (this.camera.position.z || 0) + dz;\r\n            }\r\n        } else {\r\n            // Fallback: only modify gameObject.position.z if it already exists as a number\r\n            if (this.gameObject && !this._lockZAxisPosition) {\r\n                if (typeof this.gameObject.depth === 'number') {\r\n                    this.gameObject.depth = (this.gameObject.depth || 0) + dz;\r\n                } else if (typeof this.gameObject.position.z === 'number') {\r\n                    this.gameObject.position.z += dz;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Serialize the fly camera to JSON\r\n     * @returns {Object} JSON representation of the fly camera\r\n     */\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            _type: \"FlyCamera\",\r\n            _moveSpeed: this._moveSpeed,\r\n            _sprintMultiplier: this._sprintMultiplier,\r\n            _verticalSpeed: this._verticalSpeed,\r\n            _smoothing: this._smoothing,\r\n            _keyMapping: { ...this._keyMapping },\r\n            _useZAxis: this._useZAxis,\r\n            _lockZAxisPosition: this._lockZAxisPosition,\r\n            _collisionRadius: this._collisionRadius,\r\n            _collisionEnabled: this._collisionEnabled,\r\n            _slideAlongWalls: this._slideAlongWalls\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Deserialize the fly camera from JSON\r\n     * @param {Object} json - JSON representation of the fly camera\r\n     */\r\n    fromJSON(json) {\r\n        super.fromJSON(json);\r\n        if (json._moveSpeed !== undefined) this._moveSpeed = json._moveSpeed;\r\n        if (json._sprintMultiplier !== undefined) this._sprintMultiplier = json._sprintMultiplier;\r\n        if (json._verticalSpeed !== undefined) this._verticalSpeed = json._verticalSpeed;\r\n        if (json._smoothing !== undefined) this._smoothing = json._smoothing;\r\n        if (json._keyMapping) this._keyMapping = { ...json._keyMapping };\r\n        if (json._useZAxis !== undefined) this._useZAxis = json._useZAxis;\r\n        if (json._lockZAxisPosition !== undefined) this._lockZAxisPosition = json._lockZAxisPosition;\r\n        if (json._collisionRadius !== undefined) this._collisionRadius = json._collisionRadius;\r\n        if (json._collisionEnabled !== undefined) this._collisionEnabled = json._collisionEnabled;\r\n        if (json._slideAlongWalls !== undefined) this._slideAlongWalls = json._slideAlongWalls;\r\n    }\r\n\r\n    // Getters and setters for properties\r\n    get moveSpeed() { return this._moveSpeed; }\r\n    set moveSpeed(value) { this._moveSpeed = value; }\r\n\r\n    get sprintMultiplier() { return this._sprintMultiplier; }\r\n    set sprintMultiplier(value) { this._sprintMultiplier = value; }\r\n\r\n    get verticalSpeed() { return this._verticalSpeed; }\r\n    set verticalSpeed(value) { this._verticalSpeed = value; }\r\n\r\n    get smoothing() { return this._smoothing; }\r\n    set smoothing(value) { this._smoothing = Math.max(0, Math.min(0.99, value)); }\r\n\r\n    get keyMapping() { return this._keyMapping; }\r\n    set keyMapping(value) { this._keyMapping = value; }\r\n\r\n    get useZAxis() { return this._useZAxis; }\r\n    set useZAxis(value) { this._useZAxis = value; }\r\n\r\n    get lockZAxisPosition() { return this._lockZAxisPosition; }\r\n    set lockZAxisPosition(value) { this._lockZAxisPosition = value; }\r\n\r\n    get collisionRadius() { return this._collisionRadius; }\r\n    set collisionRadius(value) { this._collisionRadius = Math.max(1, value); }\r\n\r\n    get collisionEnabled() { return this._collisionEnabled; }\r\n    set collisionEnabled(value) { this._collisionEnabled = value; }\r\n\r\n    get slideAlongWalls() { return this._slideAlongWalls; }\r\n    set slideAlongWalls(value) { this._slideAlongWalls = value; }\r\n}\r\n\r\n// Register the FlyCamera module\r\nwindow.FlyCamera = FlyCamera;",
      "type": "file",
      "name": "FlyCamera.js",
      "parentPath": "/Assets/2D Context 3D Renderer",
      "created": 1759623950572,
      "modified": 1759623950572
    },
    {
      "path": "/Assets/2D Context 3D Renderer/Light3D.js",
      "content": "/**\r\n * Light3D - Dynamic lighting system for 3D scenes\r\n * \r\n * Supports point and spot lights with color, intensity, and range.\r\n * Works in conjunction with Camera3DRasterizer for scene lighting.\r\n */\r\nclass Light3D extends Module {\r\n    static namespace = \"3D\";\r\n\r\n    constructor() {\r\n        super(\"Light3D\");\r\n\r\n        // Light type: \"point\" or \"spot\"\r\n        this._lightType = \"point\";\r\n\r\n        // Light properties\r\n        this._color = \"#FFFFFF\";\r\n        this._intensity = 1.0;\r\n        this._range = 100; // Maximum distance light reaches\r\n        this._attenuation = 2.0; // How quickly light falls off (quadratic by default)\r\n\r\n        // Spot light specific properties\r\n        this._spotAngle = 45; // Cone angle in degrees\r\n        this._spotSoftness = 0.1; // Edge softness (0-1)\r\n        this._spotDirection = new Vector3(0, 0, -1); // Direction in local space\r\n\r\n        // Visual representation properties\r\n        this._showLightSource = true; // Whether to draw the light as a visible glow\r\n        this._lightSourceSize = 10; // Size of the visible light source\r\n        this._lightSourceIntensity = 1.0; // Intensity of the glow (0-1)\r\n        this._lightSourceGlow = true; // Whether to draw a glow around the light\r\n\r\n        // Performance settings\r\n        this._castShadows = true; // Whether this light casts shadows\r\n        this._shadowQuality = \"medium\"; // \"low\", \"medium\", \"high\"\r\n\r\n        // Internal references\r\n        this._camera = null;\r\n        this._cameraSearchInterval = 0;\r\n\r\n        this.exposeProperty(\"lightType\", \"dropdown\", this._lightType, {\r\n            options: [\"point\", \"spot\"],\r\n            onChange: (val) => this._lightType = val\r\n        });\r\n\r\n        this.exposeProperty(\"color\", \"color\", this._color, {\r\n            onChange: (val) => this._color = val\r\n        });\r\n\r\n        this.exposeProperty(\"intensity\", \"number\", this._intensity, {\r\n            min: 0,\r\n            max: 5,\r\n            step: 0.1,\r\n            onChange: (val) => this._intensity = val\r\n        });\r\n\r\n        this.exposeProperty(\"range\", \"number\", this._range, {\r\n            min: 1,\r\n            max: 1000,\r\n            step: 1,\r\n            onChange: (val) => this._range = val\r\n        });\r\n\r\n        this.exposeProperty(\"attenuation\", \"number\", this._attenuation, {\r\n            min: 0.5,\r\n            max: 4,\r\n            step: 0.1,\r\n            onChange: (val) => this._attenuation = val\r\n        });\r\n\r\n        this.exposeProperty(\"spotAngle\", \"number\", this._spotAngle, {\r\n            min: 1,\r\n            max: 180,\r\n            step: 1,\r\n            onChange: (val) => this._spotAngle = val\r\n        });\r\n\r\n        this.exposeProperty(\"spotSoftness\", \"number\", this._spotSoftness, {\r\n            min: 0,\r\n            max: 1,\r\n            step: 0.01,\r\n            onChange: (val) => this._spotSoftness = val\r\n        });\r\n\r\n        this.exposeProperty(\"spotDirection\", \"vector3\", this._spotDirection, {\r\n            onChange: (val) => this._spotDirection = val\r\n        });\r\n\r\n        this.exposeProperty(\"showLightSource\", \"boolean\", this._showLightSource, {\r\n            onChange: (val) => this._showLightSource = val\r\n        });\r\n\r\n        this.exposeProperty(\"lightSourceSize\", \"number\", this._lightSourceSize, {\r\n            min: 1,\r\n            max: 50,\r\n            step: 1,\r\n            onChange: (val) => this._lightSourceSize = val\r\n        });\r\n\r\n        this.exposeProperty(\"lightSourceIntensity\", \"number\", this._lightSourceIntensity, {\r\n            min: 0,\r\n            max: 2,\r\n            step: 0.1,\r\n            onChange: (val) => this._lightSourceIntensity = val\r\n        });\r\n\r\n        this.exposeProperty(\"lightSourceGlow\", \"boolean\", this._lightSourceGlow, {\r\n            onChange: (val) => this._lightSourceGlow = val\r\n        });\r\n\r\n        this.exposeProperty(\"castShadows\", \"boolean\", this._castShadows, {\r\n            onChange: (val) => this._castShadows = val\r\n        });\r\n\r\n        this.exposeProperty(\"shadowQuality\", \"dropdown\", this._shadowQuality, {\r\n            options: [\"low\", \"medium\", \"high\"],\r\n            onChange: (val) => this._shadowQuality = val\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Find and register with the active camera\r\n     */\r\n    findAndRegisterCamera() {\r\n        if (this._camera) return true;\r\n\r\n        const allObjects = this.getAllGameObjects();\r\n\r\n        for (const obj of allObjects) {\r\n            const camera = obj.getModule(\"Camera3DRasterizer\");\r\n            if (camera && camera._isActive) {\r\n                this._camera = camera;\r\n                camera.registerLight(this);\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get world position of this light\r\n     */\r\n    getWorldPosition() {\r\n        if (!this.gameObject) return new Vector3(0, 0, 0);\r\n\r\n        const pos = this.gameObject.getWorldPosition ?\r\n            this.gameObject.getWorldPosition() :\r\n            { x: 0, y: 0 };\r\n\r\n        let depth = 0;\r\n        if (typeof this.gameObject.getWorldDepth === 'function') {\r\n            depth = this.gameObject.getWorldDepth();\r\n        } else if (typeof this.gameObject.depth === 'number') {\r\n            depth = this.gameObject.depth;\r\n        } else if (this.gameObject.position && this.gameObject.position.z) {\r\n            depth = this.gameObject.position.z;\r\n        }\r\n\r\n        return new Vector3(pos.x || 0, pos.y || 0, depth);\r\n    }\r\n\r\n    /**\r\n     * Get world-space direction for spot lights\r\n     */\r\n    getWorldDirection() {\r\n        if (this._lightType !== \"spot\") return new Vector3(0, 0, -1);\r\n\r\n        const rotation = this.gameObject.getWorldRotation ?\r\n            this.gameObject.getWorldRotation() : 0;\r\n\r\n        // Convert 2D rotation to 3D (assuming rotation around Z-axis)\r\n        const radZ = rotation * (Math.PI / 180);\r\n\r\n        // Apply rotation to local direction\r\n        const localDir = this._spotDirection;\r\n        const cos = Math.cos(radZ);\r\n        const sin = Math.sin(radZ);\r\n\r\n        return new Vector3(\r\n            localDir.x * cos - localDir.y * sin,\r\n            localDir.x * sin + localDir.y * cos,\r\n            localDir.z\r\n        ).normalize();\r\n    }\r\n\r\n    /**\r\n     * Calculate light contribution at a point\r\n     */\r\n    calculateLightContribution(worldPos, worldNormal) {\r\n        const lightPos = this.getWorldPosition();\r\n        const toLight = {\r\n            x: lightPos.x - worldPos.x,\r\n            y: lightPos.y - worldPos.y,\r\n            z: lightPos.z - worldPos.z\r\n        };\r\n\r\n        const distance = Math.sqrt(toLight.x ** 2 + toLight.y ** 2 + toLight.z ** 2);\r\n\r\n        // Check if point is within light range\r\n        if (distance > this._range || distance < 0.001) {\r\n            return { r: 0, g: 0, b: 0, intensity: 0 };\r\n        }\r\n\r\n        // Normalize light direction\r\n        const lightDir = {\r\n            x: toLight.x / distance,\r\n            y: toLight.y / distance,\r\n            z: toLight.z / distance\r\n        };\r\n\r\n        // Calculate attenuation (inverse square law by default)\r\n        const attenuation = Math.pow(1.0 - (distance / this._range), this._attenuation);\r\n\r\n        let spotFactor = 1.0;\r\n\r\n        // Spot light cone calculation\r\n        if (this._lightType === \"spot\") {\r\n            const spotDir = this.getWorldDirection();\r\n            const cosAngle = -(lightDir.x * spotDir.x + lightDir.y * spotDir.y + lightDir.z * spotDir.z);\r\n            const spotAngleRad = this._spotAngle * (Math.PI / 180);\r\n            const cosSpotAngle = Math.cos(spotAngleRad / 2);\r\n\r\n            if (cosAngle < cosSpotAngle) {\r\n                // Outside cone\r\n                return { r: 0, g: 0, b: 0, intensity: 0 };\r\n            }\r\n\r\n            // Smooth edge falloff\r\n            const softEdge = this._spotSoftness * (1.0 - cosSpotAngle);\r\n            if (cosAngle < cosSpotAngle + softEdge) {\r\n                spotFactor = (cosAngle - cosSpotAngle) / softEdge;\r\n                spotFactor = spotFactor * spotFactor * (3 - 2 * spotFactor); // Smoothstep\r\n            }\r\n        }\r\n\r\n        // Lambertian diffuse\r\n        const normalLen = Math.sqrt(worldNormal.x ** 2 + worldNormal.y ** 2 + worldNormal.z ** 2);\r\n        const normal = {\r\n            x: worldNormal.x / normalLen,\r\n            y: worldNormal.y / normalLen,\r\n            z: worldNormal.z / normalLen\r\n        };\r\n\r\n        const diffuse = Math.max(0, normal.x * lightDir.x + normal.y * lightDir.y + normal.z * lightDir.z);\r\n\r\n        // Final intensity\r\n        const finalIntensity = this._intensity * attenuation * spotFactor * diffuse;\r\n\r\n        if (finalIntensity < 0.001) {\r\n            return { r: 0, g: 0, b: 0, intensity: 0 };\r\n        }\r\n\r\n        // Parse light color\r\n        const color = this.hexToRgb(this._color);\r\n\r\n        return {\r\n            r: color.r * finalIntensity,\r\n            g: color.g * finalIntensity,\r\n            b: color.b * finalIntensity,\r\n            intensity: finalIntensity,\r\n            lightDir: lightDir,\r\n            distance: distance\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Helper to convert hex color to RGB\r\n     */\r\n    hexToRgb(hex) {\r\n        const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n        return result ? {\r\n            r: parseInt(result[1], 16),\r\n            g: parseInt(result[2], 16),\r\n            b: parseInt(result[3], 16)\r\n        } : { r: 255, g: 255, b: 255 };\r\n    }\r\n\r\n    /**\r\n * Draw visible light source in 3D space\r\n */\r\n    drawLightSource(camera) {\r\n        if (!this._showLightSource || !camera || !camera._renderTextureCtx) return;\r\n\r\n        const lightWorldPos = this.getWorldPosition();\r\n\r\n        // Check if light is in camera view\r\n        const cameraPos = camera.worldToCameraSpace(lightWorldPos);\r\n        if (cameraPos.x <= camera._nearPlane || cameraPos.x >= camera._farPlane) return;\r\n\r\n        // Project to screen space\r\n        const screenPos = camera.projectCameraPoint(cameraPos);\r\n        if (!screenPos) return;\r\n\r\n        const ctx = camera._renderTextureCtx;\r\n        const buffer32 = new Uint32Array(camera._imageData.data.buffer);\r\n        const w = camera._renderTextureWidth;\r\n        const h = camera._renderTextureHeight;\r\n\r\n        const centerX = Math.round(screenPos.x);\r\n        const centerY = Math.round(screenPos.y);\r\n\r\n        // Calculate size based on distance\r\n        const distanceScale = Math.max(0.3, Math.min(2.0, 50 / cameraPos.x));\r\n        const size = this._lightSourceSize * distanceScale;\r\n\r\n        // Parse light color\r\n        const lightColor = this.hexToRgb(this._color);\r\n\r\n        // Draw glow if enabled\r\n        if (this._lightSourceGlow) {\r\n            const glowRadius = size * 3;\r\n            const minX = Math.max(0, centerX - glowRadius);\r\n            const maxX = Math.min(w - 1, centerX + glowRadius);\r\n            const minY = Math.max(0, centerY - glowRadius);\r\n            const maxY = Math.min(h - 1, centerY + glowRadius);\r\n\r\n            for (let y = minY; y <= maxY; y++) {\r\n                for (let x = minX; x <= maxX; x++) {\r\n                    const dx = x - centerX;\r\n                    const dy = y - centerY;\r\n                    const distSq = dx * dx + dy * dy;\r\n                    const glowRadiusSq = glowRadius * glowRadius;\r\n\r\n                    if (distSq <= glowRadiusSq) {\r\n                        const distance = Math.sqrt(distSq);\r\n                        const falloff = 1.0 - (distance / glowRadius);\r\n                        const alpha = falloff * falloff * 0.2 * this._lightSourceIntensity;\r\n\r\n                        if (alpha > 0.01) {\r\n                            const pixelIdx = y * w + x;\r\n                            const existing = buffer32[pixelIdx];\r\n\r\n                            const existingR = existing & 0xFF;\r\n                            const existingG = (existing >> 8) & 0xFF;\r\n                            const existingB = (existing >> 16) & 0xFF;\r\n\r\n                            const newR = Math.min(255, Math.round(existingR + lightColor.r * alpha));\r\n                            const newG = Math.min(255, Math.round(existingG + lightColor.g * alpha));\r\n                            const newB = Math.min(255, Math.round(existingB + lightColor.b * alpha));\r\n\r\n                            buffer32[pixelIdx] = (255 << 24) | (newB << 16) | (newG << 8) | newR;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Draw bright core\r\n        const coreRadius = size;\r\n        const minCoreX = Math.max(0, centerX - coreRadius);\r\n        const maxCoreX = Math.min(w - 1, centerX + coreRadius);\r\n        const minCoreY = Math.max(0, centerY - coreRadius);\r\n        const maxCoreY = Math.min(h - 1, centerY + coreRadius);\r\n\r\n        for (let y = minCoreY; y <= maxCoreY; y++) {\r\n            for (let x = minCoreX; x <= maxCoreX; x++) {\r\n                const dx = x - centerX;\r\n                const dy = y - centerY;\r\n                const distSq = dx * dx + dy * dy;\r\n                const coreRadiusSq = coreRadius * coreRadius;\r\n\r\n                if (distSq <= coreRadiusSq) {\r\n                    const distance = Math.sqrt(distSq);\r\n                    const falloff = 1.0 - (distance / coreRadius);\r\n                    const smoothFalloff = falloff * falloff * (3 - 2 * falloff);\r\n\r\n                    const pixelIdx = y * w + x;\r\n                    const existing = buffer32[pixelIdx];\r\n\r\n                    const existingR = existing & 0xFF;\r\n                    const existingG = (existing >> 8) & 0xFF;\r\n                    const existingB = (existing >> 16) & 0xFF;\r\n\r\n                    const intensity = 0.5 + smoothFalloff * 0.5 * this._lightSourceIntensity;\r\n                    const newR = Math.min(255, Math.round(existingR * (1 - intensity) + lightColor.r * intensity));\r\n                    const newG = Math.min(255, Math.round(existingG * (1 - intensity) + lightColor.g * intensity));\r\n                    const newB = Math.min(255, Math.round(existingB * (1 - intensity) + lightColor.b * intensity));\r\n\r\n                    buffer32[pixelIdx] = (255 << 24) | (newB << 16) | (newG << 8) | newR;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Update image data\r\n        ctx.putImageData(camera._imageData, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * Check if this light should affect a triangle (shadow casting)\r\n     */\r\n    isTriangleLit(triangleCenter, triangleNormal, allTriangles) {\r\n        if (!this._castShadows || this._lightBleeding) return true;\r\n\r\n        const lightPos = this.getWorldPosition();\r\n\r\n        // Direction from triangle to light\r\n        const toLight = {\r\n            x: lightPos.x - triangleCenter.x,\r\n            y: lightPos.y - triangleCenter.y,\r\n            z: lightPos.z - triangleCenter.z\r\n        };\r\n\r\n        const distanceToLight = Math.sqrt(toLight.x ** 2 + toLight.y ** 2 + toLight.z ** 2);\r\n\r\n        if (distanceToLight < 0.001) return true;\r\n\r\n        // Normalize direction\r\n        const lightDir = {\r\n            x: toLight.x / distanceToLight,\r\n            y: toLight.y / distanceToLight,\r\n            z: toLight.z / distanceToLight\r\n        };\r\n\r\n        // Check if triangle is facing away from light (backface to light)\r\n        const normalLen = Math.sqrt(triangleNormal.x ** 2 + triangleNormal.y ** 2 + triangleNormal.z ** 2);\r\n        if (normalLen < 0.0001) return false;\r\n\r\n        const normal = {\r\n            x: triangleNormal.x / normalLen,\r\n            y: triangleNormal.y / normalLen,\r\n            z: triangleNormal.z / normalLen\r\n        };\r\n\r\n        const dotNL = normal.x * lightDir.x + normal.y * lightDir.y + normal.z * lightDir.z;\r\n        if (dotNL <= 0.05) return false; // Facing away from light\r\n\r\n        // Shadow quality determines how many triangles to check\r\n        const maxChecks = this._shadowQuality === \"high\" ? allTriangles.length :\r\n            this._shadowQuality === \"medium\" ? Math.min(50, allTriangles.length) :\r\n                Math.min(20, allTriangles.length);\r\n\r\n        // Check if any other triangle is blocking the light\r\n        for (let i = 0; i < maxChecks; i++) {\r\n            const otherTri = allTriangles[i];\r\n\r\n            // Skip self - compare triangle centers\r\n            const otherCenter = {\r\n                x: (otherTri.worldVerts[0].x + otherTri.worldVerts[1].x + otherTri.worldVerts[2].x) / 3,\r\n                y: (otherTri.worldVerts[0].y + otherTri.worldVerts[1].y + otherTri.worldVerts[2].y) / 3,\r\n                z: (otherTri.worldVerts[0].z + otherTri.worldVerts[1].z + otherTri.worldVerts[2].z) / 3\r\n            };\r\n\r\n            const dx = otherCenter.x - triangleCenter.x;\r\n            const dy = otherCenter.y - triangleCenter.y;\r\n            const dz = otherCenter.z - triangleCenter.z;\r\n            const distSq = dx * dx + dy * dy + dz * dz;\r\n\r\n            // Skip if it's the same triangle (or very close)\r\n            if (distSq < 0.01) continue;\r\n\r\n            // Check if this triangle blocks the light\r\n            if (this.isTriangleBlockingLight(triangleCenter, lightPos, distanceToLight, otherTri, lightDir)) {\r\n                return false; // This triangle IS in shadow\r\n            }\r\n        }\r\n\r\n        return true; // No blockers found, triangle is lit\r\n    }\r\n\r\n    /**\r\n     * Check if a triangle blocks light from reaching a point\r\n     */\r\n    isTriangleBlockingLight(point, lightPos, distanceToLight, blockingTriangle, lightDir) {\r\n        const blockerWorldVerts = blockingTriangle.worldVerts;\r\n        if (!blockerWorldVerts || blockerWorldVerts.length < 3) return false;\r\n\r\n        // Calculate blocker center\r\n        const blockerCenter = {\r\n            x: (blockerWorldVerts[0].x + blockerWorldVerts[1].x + blockerWorldVerts[2].x) / 3,\r\n            y: (blockerWorldVerts[0].y + blockerWorldVerts[1].y + blockerWorldVerts[2].y) / 3,\r\n            z: (blockerWorldVerts[0].z + blockerWorldVerts[1].z + blockerWorldVerts[2].z) / 3\r\n        };\r\n\r\n        // Vector from point to blocker\r\n        const toBlocker = {\r\n            x: blockerCenter.x - point.x,\r\n            y: blockerCenter.y - point.y,\r\n            z: blockerCenter.z - point.z\r\n        };\r\n\r\n        const distanceToBlocker = Math.sqrt(toBlocker.x ** 2 + toBlocker.y ** 2 + toBlocker.z ** 2);\r\n\r\n        if (distanceToBlocker < 0.1) return false; // Too close to be a blocker\r\n\r\n        // Blocker must be closer than light source\r\n        if (distanceToBlocker >= distanceToLight - 0.1) return false;\r\n\r\n        // Check if blocker is roughly in line with light direction\r\n        const normalizedToBlocker = {\r\n            x: toBlocker.x / distanceToBlocker,\r\n            y: toBlocker.y / distanceToBlocker,\r\n            z: toBlocker.z / distanceToBlocker\r\n        };\r\n\r\n        const alignment = normalizedToBlocker.x * lightDir.x +\r\n            normalizedToBlocker.y * lightDir.y +\r\n            normalizedToBlocker.z * lightDir.z;\r\n\r\n        // Must be well-aligned (within ~20 degrees) - blocker should be between point and light\r\n        if (alignment < 0.94) return false;\r\n\r\n        // Check if blocker triangle is facing toward the point (away from light)\r\n        const blockerNormal = blockingTriangle.worldNormal;\r\n        if (!blockerNormal) return false;\r\n\r\n        const blockerNormalLen = Math.sqrt(blockerNormal.x ** 2 + blockerNormal.y ** 2 + blockerNormal.z ** 2);\r\n        if (blockerNormalLen < 0.0001) return false;\r\n\r\n        const blockerNormalized = {\r\n            x: blockerNormal.x / blockerNormalLen,\r\n            y: blockerNormal.y / blockerNormalLen,\r\n            z: blockerNormal.z / blockerNormalLen\r\n        };\r\n\r\n        // Check if blocker is facing toward the light (to block it)\r\n        // The blocker should be facing in the opposite direction of the light\r\n        const dotBlockerLight = blockerNormalized.x * lightDir.x +\r\n            blockerNormalized.y * lightDir.y +\r\n            blockerNormalized.z * lightDir.z;\r\n\r\n        // Blocker must be facing toward light to cast shadow\r\n        if (dotBlockerLight <= 0.05) return false;\r\n\r\n        return true; // This triangle IS blocking the light\r\n    }\r\n\r\n    /**\r\n     * Loop method - try to find camera if not registered\r\n     */\r\n    beginLoop() {\r\n        if (!this._camera) {\r\n            // Only check every 60 frames to reduce overhead\r\n            if (this._cameraSearchInterval++ % 60 === 0) {\r\n                this.findAndRegisterCamera();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Cleanup when destroyed\r\n     */\r\n    onDestroy() {\r\n        if (this._camera) {\r\n            this._camera.unregisterLight(this);\r\n            this._camera = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draw gizmo showing light range and color\r\n     */\r\n    drawGizmos(ctx) {\r\n        if (!this.gameObject) return;\r\n\r\n        ctx.save();\r\n\r\n        const pos = this.gameObject.position;\r\n        ctx.translate(pos.x, pos.y);\r\n\r\n        // Draw light range circle\r\n        ctx.strokeStyle = this._color;\r\n        ctx.fillStyle = this._color + \"22\"; // Semi-transparent fill\r\n        ctx.lineWidth = 2;\r\n\r\n        ctx.beginPath();\r\n        ctx.arc(0, 0, this._range, 0, Math.PI * 2);\r\n        ctx.fill();\r\n        ctx.stroke();\r\n\r\n        // Draw inner bright circle\r\n        ctx.fillStyle = this._color + \"88\";\r\n        ctx.beginPath();\r\n        ctx.arc(0, 0, 10, 0, Math.PI * 2);\r\n        ctx.fill();\r\n\r\n        // Draw spot light cone if applicable\r\n        if (this._lightType === \"spot\") {\r\n            const angle = this.gameObject.angle || 0;\r\n            const direction = this._spotDirection;\r\n            const coneAngleRad = (this._spotAngle / 2) * (Math.PI / 180);\r\n\r\n            ctx.strokeStyle = this._color;\r\n            ctx.fillStyle = this._color + \"11\";\r\n            ctx.lineWidth = 1;\r\n\r\n            // Calculate cone direction in 2D\r\n            const dirAngle = Math.atan2(direction.y, direction.x) + (angle * Math.PI / 180);\r\n\r\n            ctx.beginPath();\r\n            ctx.moveTo(0, 0);\r\n            ctx.arc(0, 0, this._range, dirAngle - coneAngleRad, dirAngle + coneAngleRad);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n            ctx.stroke();\r\n\r\n            // Draw center line\r\n            ctx.beginPath();\r\n            ctx.moveTo(0, 0);\r\n            ctx.lineTo(\r\n                Math.cos(dirAngle) * this._range,\r\n                Math.sin(dirAngle) * this._range\r\n            );\r\n            ctx.stroke();\r\n        }\r\n\r\n        // Draw label\r\n        ctx.fillStyle = \"#FFFFFF\";\r\n        ctx.font = \"12px Arial\";\r\n        ctx.textAlign = \"center\";\r\n        ctx.fillText(this._lightType === \"spot\" ? \"SPOT\" : \"POINT\", 0, -this._range - 10);\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    /**\r\n     * Serialize to JSON\r\n     */\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            _type: \"Light3D\",\r\n            _lightType: this._lightType,\r\n            _color: this._color,\r\n            _intensity: this._intensity,\r\n            _range: this._range,\r\n            _attenuation: this._attenuation,\r\n            _spotAngle: this._spotAngle,\r\n            _spotSoftness: this._spotSoftness,\r\n            _spotDirection: { x: this._spotDirection.x, y: this._spotDirection.y, z: this._spotDirection.z },\r\n            _castShadows: this._castShadows,\r\n            _shadowQuality: this._shadowQuality,\r\n            _showLightSource: this._showLightSource,\r\n            _lightSourceSize: this._lightSourceSize,\r\n            _lightSourceIntensity: this._lightSourceIntensity,\r\n            _lightSourceGlow: this._lightSourceGlow\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Deserialize from JSON\r\n     */\r\n    fromJSON(json) {\r\n        super.fromJSON(json);\r\n        if (json._lightType !== undefined) this._lightType = json._lightType;\r\n        if (json._color !== undefined) this._color = json._color;\r\n        if (json._intensity !== undefined) this._intensity = json._intensity;\r\n        if (json._range !== undefined) this._range = json._range;\r\n        if (json._attenuation !== undefined) this._attenuation = json._attenuation;\r\n        if (json._spotAngle !== undefined) this._spotAngle = json._spotAngle;\r\n        if (json._spotSoftness !== undefined) this._spotSoftness = json._spotSoftness;\r\n        if (json._spotDirection) this._spotDirection = new Vector3(json._spotDirection.x, json._spotDirection.y, json._spotDirection.z);\r\n        if (json._castShadows !== undefined) this._castShadows = json._castShadows;\r\n        if (json._shadowQuality !== undefined) this._shadowQuality = json._shadowQuality;\r\n        if (json._showLightSource !== undefined) this._showLightSource = json._showLightSource;\r\n        if (json._lightSourceSize !== undefined) this._lightSourceSize = json._lightSourceSize;\r\n        if (json._lightSourceIntensity !== undefined) this._lightSourceIntensity = json._lightSourceIntensity;\r\n        if (json._lightSourceGlow !== undefined) this._lightSourceGlow = json._lightSourceGlow;\r\n    }\r\n\r\n    // Getters and setters\r\n    get lightType() { return this._lightType; }\r\n    set lightType(value) { this._lightType = value; }\r\n\r\n    get color() { return this._color; }\r\n    set color(value) { this._color = value; }\r\n\r\n    get intensity() { return this._intensity; }\r\n    set intensity(value) { this._intensity = Math.max(0, value); }\r\n\r\n    get range() { return this._range; }\r\n    set range(value) { this._range = Math.max(1, value); }\r\n\r\n    get attenuation() { return this._attenuation; }\r\n    set attenuation(value) { this._attenuation = Math.max(0.5, value); }\r\n\r\n    get spotAngle() { return this._spotAngle; }\r\n    set spotAngle(value) { this._spotAngle = Math.max(1, Math.min(180, value)); }\r\n\r\n    get spotSoftness() { return this._spotSoftness; }\r\n    set spotSoftness(value) { this._spotSoftness = Math.max(0, Math.min(1, value)); }\r\n\r\n    get showLightSource() { return this._showLightSource; }\r\n    set showLightSource(value) { this._showLightSource = value; }\r\n\r\n    get lightSourceSize() { return this._lightSourceSize; }\r\n    set lightSourceSize(value) { this._lightSourceSize = Math.max(1, value); }\r\n\r\n    get lightSourceIntensity() { return this._lightSourceIntensity; }\r\n    set lightSourceIntensity(value) { this._lightSourceIntensity = Math.max(0, value); }\r\n\r\n    get lightSourceGlow() { return this._lightSourceGlow; }\r\n    set lightSourceGlow(value) { this._lightSourceGlow = value; }\r\n\r\n    get castShadows() { return this._castShadows; }\r\n    set castShadows(value) { this._castShadows = value; }\r\n\r\n    get shadowQuality() { return this._shadowQuality; }\r\n    set shadowQuality(value) { this._shadowQuality = value; }\r\n}\r\n\r\nwindow.Light3D = Light3D;",
      "type": "file",
      "name": "Light3D.js",
      "parentPath": "/Assets/2D Context 3D Renderer",
      "created": 1759623950579,
      "modified": 1759623950579
    },
    {
      "path": "/Assets/2D Context 3D Renderer/Material.js",
      "content": "/**\r\n * Material - A comprehensive material system for 3D meshes\r\n * \r\n * Supports textures, procedural generation, colors, and UV mapping\r\n * for the Dark Matter JS 3D engine.\r\n */\r\nclass Material extends Module {\r\n    static namespace = \"3D\";\r\n\r\n    /**\r\n     * Create a new Material\r\n     */\r\n    constructor() {\r\n        super(\"Material\");\r\n\r\n        // Material properties\r\n        this._diffuseColor = \"#FFFFFF\";\r\n        this._specularColor = \"#FFFFFF\";\r\n        this._emissiveColor = \"#000000\";\r\n        this._shininess = 6;\r\n        this._opacity = 1.0;\r\n\r\n        // Texture properties\r\n        this._diffuseTexture = null; // Image URL or canvas\r\n        this._normalTexture = null;\r\n        this._specularTexture = null;\r\n        this._emissiveTexture = null;\r\n\r\n        // Procedural texture generation\r\n        this._useProceduralTexture = false;\r\n        this._proceduralType = \"noise\"; // \"noise\", \"checker\", \"gradient\", \"cellular\"\r\n        this._proceduralSeed = 12345;\r\n        this._proceduralScale = 1.0;\r\n        this._proceduralColor1 = \"#4CAF50\";\r\n        this._proceduralColor2 = \"#2196F3\";\r\n        this._proceduralOctaves = 4;\r\n        this._proceduralPersistence = 0.5;\r\n        this._proceduralLacunarity = 2.0;\r\n\r\n        // UV mapping properties\r\n        this._uvScale = new Vector2(1, 1);\r\n        this._uvOffset = new Vector2(0, 0);\r\n        this._uvRotation = 0;\r\n\r\n        // Material flags\r\n        this._transparent = false;\r\n        this._doubleSided = false;\r\n        this._wireframe = false;\r\n\r\n        // Generated texture cache\r\n        this._generatedTexture = null;\r\n        this._textureSize = 512;\r\n\r\n        // Enhanced texture management\r\n        this._loadedTextures = new Map(); // Cache for loaded textures\r\n        this._texturePromises = new Map(); // Track loading promises\r\n        this._textureLoadQueue = []; // Queue for background loading\r\n\r\n        // Expose properties to inspector\r\n        this.exposeProperty(\"diffuseColor\", \"color\", this._diffuseColor, {\r\n            onChange: (val) => this._diffuseColor = val\r\n        });\r\n\r\n        this.exposeProperty(\"specularColor\", \"color\", this._specularColor, {\r\n            onChange: (val) => this._specularColor = val\r\n        });\r\n\r\n        /*this.exposeProperty(\"emissiveColor\", \"color\", this._emissiveColor, {\r\n            onChange: (val) => this._emissiveColor = val\r\n        });*/\r\n\r\n        this.exposeProperty(\"shininess\", \"number\", this._shininess, {\r\n            min: 1,\r\n            max: 128,\r\n            onChange: (val) => this._shininess = val\r\n        });\r\n\r\n        /*this.exposeProperty(\"opacity\", \"number\", this._opacity, {\r\n            min: 0,\r\n            max: 1,\r\n            step: 0.01,\r\n            onChange: (val) => {\r\n                this._opacity = val;\r\n                this._transparent = val < 1.0;\r\n            }\r\n        });*/\r\n\r\n        /*this.exposeProperty(\"diffuseTexture\", \"asset\", this._diffuseTexture, {\r\n            assetType: \"image\",\r\n            fileTypes: ['png', 'jpg', 'jpeg', 'gif', 'webp', 'svg', 'bmp'],\r\n            onChange: (val) => {\r\n                this._diffuseTexture = val;\r\n                this._useProceduralTexture = false;\r\n                this._generatedTexture = null;\r\n\r\n                // Preload texture if it's a path\r\n                if (typeof val === 'string') {\r\n                    this.preloadTexture(val);\r\n                }\r\n            }\r\n        });*/\r\n\r\n        /*this.exposeProperty(\"useProceduralTexture\", \"boolean\", this._useProceduralTexture, {\r\n            onChange: (val) => {\r\n                this._useProceduralTexture = val;\r\n                if (val) {\r\n                    this._diffuseTexture = null;\r\n                    this.generateProceduralTexture();\r\n                }\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"proceduralType\", \"enum\", this._proceduralType, {\r\n            options: [\"noise\", \"checker\", \"gradient\", \"cellular\"],\r\n            onChange: (val) => {\r\n                this._proceduralType = val;\r\n                if (this._useProceduralTexture) {\r\n                    this.generateProceduralTexture();\r\n                }\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"proceduralSeed\", \"number\", this._proceduralSeed, {\r\n            onChange: (val) => {\r\n                this._proceduralSeed = val;\r\n                if (this._useProceduralTexture) {\r\n                    this.generateProceduralTexture();\r\n                }\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"proceduralScale\", \"number\", this._proceduralScale, {\r\n            min: 0.1,\r\n            max: 10,\r\n            step: 0.1,\r\n            onChange: (val) => {\r\n                this._proceduralScale = val;\r\n                if (this._useProceduralTexture) {\r\n                    this.generateProceduralTexture();\r\n                }\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"proceduralColor1\", \"color\", this._proceduralColor1, {\r\n            onChange: (val) => {\r\n                this._proceduralColor1 = val;\r\n                if (this._useProceduralTexture) {\r\n                    this.generateProceduralTexture();\r\n                }\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"proceduralColor2\", \"color\", this._proceduralColor2, {\r\n            onChange: (val) => {\r\n                this._proceduralColor2 = val;\r\n                if (this._useProceduralTexture) {\r\n                    this.generateProceduralTexture();\r\n                }\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"proceduralOctaves\", \"number\", this._proceduralOctaves, {\r\n            min: 1,\r\n            max: 8,\r\n            onChange: (val) => {\r\n                this._proceduralOctaves = val;\r\n                if (this._useProceduralTexture) {\r\n                    this.generateProceduralTexture();\r\n                }\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"proceduralPersistence\", \"number\", this._proceduralPersistence, {\r\n            min: 0.1,\r\n            max: 1,\r\n            step: 0.01,\r\n            onChange: (val) => {\r\n                this._proceduralPersistence = val;\r\n                if (this._useProceduralTexture) {\r\n                    this.generateProceduralTexture();\r\n                }\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"proceduralLacunarity\", \"number\", this._proceduralLacunarity, {\r\n            min: 1,\r\n            max: 4,\r\n            step: 0.1,\r\n            onChange: (val) => {\r\n                this._proceduralLacunarity = val;\r\n                if (this._useProceduralTexture) {\r\n                    this.generateProceduralTexture();\r\n                }\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"uvScale\", \"vector2\", this._uvScale, {\r\n            onChange: (val) => this._uvScale = val\r\n        });\r\n\r\n        this.exposeProperty(\"uvOffset\", \"vector2\", this._uvOffset, {\r\n            onChange: (val) => this._uvOffset = val\r\n        });\r\n\r\n        this.exposeProperty(\"uvRotation\", \"number\", this._uvRotation, {\r\n            min: 0,\r\n            max: 360,\r\n            onChange: (val) => this._uvRotation = val\r\n        });*/\r\n\r\n        /*this.exposeProperty(\"transparent\", \"boolean\", this._transparent, {\r\n            onChange: (val) => this._transparent = val\r\n        });\r\n\r\n        this.exposeProperty(\"doubleSided\", \"boolean\", this._doubleSided, {\r\n            onChange: (val) => this._doubleSided = val\r\n        });\r\n\r\n        this.exposeProperty(\"wireframe\", \"boolean\", this._wireframe, {\r\n            onChange: (val) => this._wireframe = val\r\n        });*/\r\n    }\r\n\r\n    /**\r\n     * Generate a procedural texture based on current settings\r\n     */\r\n    generateProceduralTexture() {\r\n        const size = this._textureSize;\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = size;\r\n        canvas.height = size;\r\n        const ctx = canvas.getContext('2d');\r\n        const imageData = ctx.createImageData(size, size);\r\n        const data = imageData.data;\r\n\r\n        const color1 = this._parseColor(this._proceduralColor1);\r\n        const color2 = this._parseColor(this._proceduralColor2);\r\n\r\n        for (let y = 0; y < size; y++) {\r\n            for (let x = 0; x < size; x++) {\r\n                const u = x / size;\r\n                const v = y / size;\r\n\r\n                let value = 0;\r\n\r\n                switch (this._proceduralType) {\r\n                    case \"noise\":\r\n                        value = this._generateNoise(u * this._proceduralScale, v * this._proceduralScale);\r\n                        break;\r\n                    case \"checker\":\r\n                        value = this._generateChecker(u * this._proceduralScale, v * this._proceduralScale);\r\n                        break;\r\n                    case \"gradient\":\r\n                        value = this._generateGradient(u, v);\r\n                        break;\r\n                    case \"cellular\":\r\n                        value = this._generateCellular(u * this._proceduralScale, v * this._proceduralScale);\r\n                        break;\r\n                }\r\n\r\n                // Normalize value to 0-1 range\r\n                value = Math.max(0, Math.min(1, (value + 1) / 2));\r\n\r\n                // Interpolate between colors\r\n                const color = this._lerpColor(color1, color2, value);\r\n\r\n                const index = (y * size + x) * 4;\r\n                data[index] = color.r;     // Red\r\n                data[index + 1] = color.g; // Green\r\n                data[index + 2] = color.b; // Blue\r\n                data[index + 3] = 255;     // Alpha\r\n            }\r\n        }\r\n\r\n        ctx.putImageData(imageData, 0, 0);\r\n        this._generatedTexture = canvas;\r\n\r\n        return canvas;\r\n    }\r\n\r\n    /**\r\n     * Generate noise value at given coordinates\r\n     */\r\n    _generateNoise(x, y) {\r\n        // Simple pseudo-random noise using the seed\r\n        const n = Math.sin(x * 12.9898 + y * 78.233 + this._proceduralSeed) * 43758.5453;\r\n        return (n - Math.floor(n)) * 2 - 1; // Normalize to -1 to 1\r\n    }\r\n\r\n    /**\r\n     * Generate checker pattern\r\n     */\r\n    _generateChecker(u, v) {\r\n        const x = Math.floor(u * 8); // 8x8 checker pattern\r\n        const y = Math.floor(v * 8);\r\n        return (x + y) % 2 === 0 ? 1 : -1;\r\n    }\r\n\r\n    /**\r\n     * Generate radial gradient\r\n     */\r\n    _generateGradient(u, v) {\r\n        const centerU = 0.5;\r\n        const centerV = 0.5;\r\n        const distance = Math.sqrt((u - centerU) ** 2 + (v - centerV) ** 2);\r\n        return Math.max(-1, Math.min(1, 1 - distance * 2));\r\n    }\r\n\r\n    /**\r\n     * Generate cellular/Worley noise\r\n     */\r\n    _generateCellular(u, v) {\r\n        let minDistance = Infinity;\r\n\r\n        // Sample a few random points\r\n        for (let i = 0; i < 8; i++) {\r\n            const px = this._hash(i * 2) + Math.sin(i + this._proceduralSeed) * 0.5;\r\n            const py = this._hash(i * 2 + 1) + Math.cos(i + this._proceduralSeed) * 0.5;\r\n\r\n            const distance = Math.sqrt((u - px) ** 2 + (v - py) ** 2);\r\n            minDistance = Math.min(minDistance, distance);\r\n        }\r\n\r\n        // Normalize distance (this is a simple approximation)\r\n        return Math.max(-1, Math.min(1, 1 - minDistance * 4));\r\n    }\r\n\r\n    /**\r\n     * Simple hash function for pseudo-random values\r\n     */\r\n    _hash(value) {\r\n        const hash = ((value * 73856093) ^ (value * 19349663)) >>> 0;\r\n        return (hash / 4294967295) * 2 - 1; // Normalize to -1 to 1\r\n    }\r\n\r\n    /**\r\n     * Parse color string to RGB object\r\n     */\r\n    _parseColor(color) {\r\n        if (!color) return { r: 255, g: 255, b: 255 };\r\n\r\n        // Handle hex colors\r\n        if (typeof color === 'string' && color.startsWith('#')) {\r\n            const hex = color.slice(1);\r\n            if (hex.length === 3) {\r\n                return {\r\n                    r: parseInt(hex[0] + hex[0], 16),\r\n                    g: parseInt(hex[1] + hex[1], 16),\r\n                    b: parseInt(hex[2] + hex[2], 16)\r\n                };\r\n            } else if (hex.length === 6) {\r\n                return {\r\n                    r: parseInt(hex.slice(0, 2), 16),\r\n                    g: parseInt(hex.slice(2, 4), 16),\r\n                    b: parseInt(hex.slice(4, 6), 16)\r\n                };\r\n            }\r\n        }\r\n\r\n        // Handle rgb() format\r\n        if (typeof color === 'string' && color.startsWith('rgb')) {\r\n            const match = color.match(/rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)/);\r\n            if (match) {\r\n                return {\r\n                    r: parseInt(match[1]),\r\n                    g: parseInt(match[2]),\r\n                    b: parseInt(match[3])\r\n                };\r\n            }\r\n        }\r\n\r\n        return { r: 255, g: 255, b: 255 };\r\n    }\r\n\r\n    /**\r\n     * Linear interpolation between two colors\r\n     */\r\n    _lerpColor(color1, color2, t) {\r\n        return {\r\n            r: Math.round(color1.r + (color2.r - color1.r) * t),\r\n            g: Math.round(color1.g + (color2.g - color1.g) * t),\r\n            b: Math.round(color1.b + (color2.b - color1.b) * t)\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get the diffuse texture (either loaded or generated)\r\n     */\r\n    getDiffuseTexture() {\r\n        if (this._useProceduralTexture) {\r\n            return this._generatedTexture;\r\n        }\r\n\r\n        // If texture is already loaded, return it\r\n        if (this._diffuseTexture && (this._diffuseTexture instanceof HTMLImageElement ||\r\n            this._diffuseTexture instanceof HTMLCanvasElement ||\r\n            this._diffuseTexture instanceof ImageData)) {\r\n            return this._diffuseTexture;\r\n        }\r\n\r\n        // If texture is a string path, try to load it\r\n        if (typeof this._diffuseTexture === 'string') {\r\n            return this.loadTextureFromPath(this._diffuseTexture);\r\n        }\r\n\r\n        return this._diffuseTexture;\r\n    }\r\n\r\n    /**\r\n     * Enhanced texture loading with caching and multiple fallback methods\r\n     * @param {string} path - Path to the texture\r\n     * @returns {Promise<HTMLImageElement|HTMLCanvasElement|null>} - Loaded texture\r\n     */\r\n    async loadTextureFromPath(path) {\r\n        if (!path) return null;\r\n\r\n        // Check cache first\r\n        if (this._loadedTextures.has(path)) {\r\n            return this._loadedTextures.get(path);\r\n        }\r\n\r\n        // Check if already loading\r\n        if (this._texturePromises.has(path)) {\r\n            return this._texturePromises.get(path);\r\n        }\r\n\r\n        // Create loading promise\r\n        const loadPromise = this._loadTextureWithFallbacks(path);\r\n        this._texturePromises.set(path, loadPromise);\r\n\r\n        try {\r\n            const texture = await loadPromise;\r\n            this._loadedTextures.set(path, texture);\r\n            return texture;\r\n        } catch (error) {\r\n            console.error('Failed to load texture:', path, error);\r\n            this._texturePromises.delete(path);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load texture with multiple fallback methods (similar to SpriteRenderer)\r\n     * @param {string} path - Path to the texture\r\n     * @returns {Promise<HTMLImageElement|HTMLCanvasElement|null>} - Loaded texture\r\n     */\r\n    async _loadTextureWithFallbacks(path) {\r\n        try {\r\n            // PRIORITY 1: Load from AssetManager\r\n            if (window.assetManager) {\r\n                const asset = await window.assetManager.getAssetByPath(path);\r\n                if (asset && (asset instanceof HTMLImageElement || asset instanceof HTMLCanvasElement)) {\r\n                    console.log('Texture loaded from AssetManager:', path);\r\n                    return asset;\r\n                }\r\n            }\r\n\r\n            // PRIORITY 2: Load from FileBrowser (editor mode)\r\n            if (window.editor && window.editor.fileBrowser) {\r\n                try {\r\n                    const texture = await this._loadTextureFromFileBrowser(path);\r\n                    if (texture) {\r\n                        console.log('Texture loaded via FileBrowser:', path);\r\n                        return texture;\r\n                    }\r\n                } catch (error) {\r\n                    console.warn('FileBrowser loading failed:', error);\r\n                }\r\n            }\r\n\r\n            // PRIORITY 3: Direct URL loading (fallback)\r\n            return await this._loadTextureDirect(path);\r\n\r\n        } catch (error) {\r\n            console.error('Error in texture loading pipeline:', error);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load texture from FileBrowser (editor mode)\r\n     * @param {string} path - Path to the texture\r\n     * @returns {Promise<HTMLImageElement|HTMLCanvasElement|null>} - Loaded texture\r\n     */\r\n    async _loadTextureFromFileBrowser(path) {\r\n        const fileBrowser = window.editor.fileBrowser;\r\n\r\n        // Try to read file content\r\n        const content = await fileBrowser.readFile(path);\r\n        if (!content) {\r\n            throw new Error(`Could not read texture file: ${path}`);\r\n        }\r\n\r\n        // Handle data URL\r\n        if (typeof content === 'string' && content.startsWith('data:image')) {\r\n            return this._loadTextureFromDataURL(content);\r\n        }\r\n\r\n        // Handle base64 or raw content\r\n        if (typeof content === 'string' && !content.startsWith('data:')) {\r\n            const extension = path.split('.').pop().toLowerCase();\r\n            const mimeType = this._getMimeType(extension);\r\n\r\n            let dataUrl;\r\n            if (content.startsWith('data:')) {\r\n                dataUrl = content;\r\n            } else {\r\n                dataUrl = `data:${mimeType};base64,${content}`;\r\n            }\r\n\r\n            return this._loadTextureFromDataURL(dataUrl);\r\n        }\r\n\r\n        // Handle binary content\r\n        if (content instanceof Blob || content instanceof ArrayBuffer) {\r\n            let blob = content;\r\n            if (content instanceof ArrayBuffer) {\r\n                const extension = path.split('.').pop().toLowerCase();\r\n                blob = new Blob([content], { type: `image/${extension}` });\r\n            }\r\n\r\n            const dataUrl = await this._blobToDataURL(blob);\r\n            return this._loadTextureFromDataURL(dataUrl);\r\n        }\r\n\r\n        throw new Error(`Unsupported texture content type: ${typeof content}`);\r\n    }\r\n\r\n    /**\r\n     * Load texture directly from URL/path\r\n     * @param {string} path - Path to the texture\r\n     * @returns {Promise<HTMLImageElement>} - Loaded texture\r\n     */\r\n    async _loadTextureDirect(path) {\r\n        return new Promise((resolve, reject) => {\r\n            const img = new Image();\r\n\r\n            img.onload = () => {\r\n                console.log('Texture loaded successfully:', path);\r\n                resolve(img);\r\n            };\r\n\r\n            img.onerror = () => {\r\n                reject(new Error(`Failed to load texture: ${path}`));\r\n            };\r\n\r\n            // Handle cross-origin if needed\r\n            if (path.startsWith('http') && !path.includes(window.location.hostname)) {\r\n                img.crossOrigin = 'anonymous';\r\n            }\r\n\r\n            img.src = path;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load texture from data URL\r\n     * @param {string} dataUrl - Data URL of the texture\r\n     * @returns {Promise<HTMLImageElement>} - Loaded texture\r\n     */\r\n    async _loadTextureFromDataURL(dataUrl) {\r\n        return new Promise((resolve, reject) => {\r\n            const img = new Image();\r\n\r\n            img.onload = () => resolve(img);\r\n            img.onerror = () => reject(new Error('Failed to load texture from data URL'));\r\n\r\n            img.src = dataUrl;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Convert blob to data URL\r\n     * @param {Blob} blob - Blob to convert\r\n     * @returns {Promise<string>} - Data URL\r\n     */\r\n    async _blobToDataURL(blob) {\r\n        return new Promise((resolve, reject) => {\r\n            const reader = new FileReader();\r\n            reader.onload = () => resolve(reader.result);\r\n            reader.onerror = reject;\r\n            reader.readAsDataURL(blob);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get MIME type from file extension\r\n     * @param {string} extension - File extension\r\n     * @returns {string} - MIME type\r\n     */\r\n    _getMimeType(extension) {\r\n        const mimeTypes = {\r\n            'png': 'image/png',\r\n            'jpg': 'image/jpeg',\r\n            'jpeg': 'image/jpeg',\r\n            'gif': 'image/gif',\r\n            'webp': 'image/webp',\r\n            'svg': 'image/svg+xml',\r\n            'bmp': 'image/bmp'\r\n        };\r\n\r\n        return mimeTypes[extension] || 'image/png';\r\n    }\r\n\r\n    /**\r\n     * Preload a texture for better performance\r\n     * @param {string} path - Path to the texture to preload\r\n     */\r\n    preloadTexture(path) {\r\n        if (!path || this._loadedTextures.has(path) || this._texturePromises.has(path)) {\r\n            return;\r\n        }\r\n\r\n        // Add to loading queue\r\n        this._textureLoadQueue.push(path);\r\n\r\n        // Process queue if not already processing\r\n        if (this._textureLoadQueue.length === 1) {\r\n            this._processTextureQueue();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Process the texture loading queue\r\n     */\r\n    async _processTextureQueue() {\r\n        while (this._textureLoadQueue.length > 0) {\r\n            const path = this._textureLoadQueue.shift();\r\n            try {\r\n                await this.loadTextureFromPath(path);\r\n            } catch (error) {\r\n                console.warn('Failed to preload texture:', path, error);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear texture cache\r\n     * @param {string} path - Specific path to clear, or null to clear all\r\n     */\r\n    clearTextureCache(path = null) {\r\n        if (path) {\r\n            this._loadedTextures.delete(path);\r\n            this._texturePromises.delete(path);\r\n        } else {\r\n            this._loadedTextures.clear();\r\n            this._texturePromises.clear();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get texture loading progress\r\n     * @returns {Object} - Loading statistics\r\n     */\r\n    getTextureLoadingStats() {\r\n        return {\r\n            cached: this._loadedTextures.size,\r\n            loading: this._texturePromises.size,\r\n            queued: this._textureLoadQueue.length\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Calculate lighting for a point on a surface\r\n     * @param {Vector3} point - World position of the point\r\n     * @param {Vector3} normal - Surface normal at the point\r\n     * @param {Vector3} viewDir - Direction from point to camera\r\n     * @param {Array} lights - Array of light objects with position, color, intensity\r\n     * @returns {Object} - Lighting result with diffuse, specular, ambient components\r\n     */\r\n    calculateLighting(point, normal, viewDir, lights = []) {\r\n        const result = {\r\n            diffuse: { r: 0, g: 0, b: 0 },\r\n            specular: { r: 0, g: 0, b: 0 },\r\n            ambient: this._parseColor(this._emissiveColor)\r\n        };\r\n\r\n        // Normalize vectors\r\n        const n = normal.clone().normalize();\r\n        const v = viewDir.clone().normalize();\r\n\r\n        for (const light of lights) {\r\n            const lightDir = light.position.clone().subtract(point).normalize();\r\n            const lightColor = this._parseColor(light.color || \"#FFFFFF\");\r\n            const intensity = light.intensity || 1.0;\r\n\r\n            // Diffuse lighting (Lambert's cosine law)\r\n            const diffuseFactor = Math.max(0, n.dot(lightDir));\r\n            result.diffuse.r += lightColor.r * diffuseFactor * intensity;\r\n            result.diffuse.g += lightColor.g * diffuseFactor * intensity;\r\n            result.diffuse.b += lightColor.b * diffuseFactor * intensity;\r\n\r\n            // Specular lighting (Phong reflection model)\r\n            if (diffuseFactor > 0) {\r\n                const reflectDir = n.clone().multiply(2 * n.dot(lightDir)).subtract(lightDir);\r\n                const specularFactor = Math.pow(Math.max(0, reflectDir.dot(v)), this._shininess);\r\n                const specularIntensity = intensity * specularFactor;\r\n\r\n                const specularColor = this._parseColor(this._specularColor);\r\n                result.specular.r += specularColor.r * specularIntensity;\r\n                result.specular.g += specularColor.g * specularIntensity;\r\n                result.specular.b += specularColor.b * specularIntensity;\r\n            }\r\n        }\r\n\r\n        // Clamp values to 0-255 range\r\n        const clampColor = (color) => ({\r\n            r: Math.max(0, Math.min(255, color.r)),\r\n            g: Math.max(0, Math.min(255, color.g)),\r\n            b: Math.max(0, Math.min(255, color.b))\r\n        });\r\n\r\n        result.diffuse = clampColor(result.diffuse);\r\n        result.specular = clampColor(result.specular);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get lit color for a surface point considering material properties\r\n     * @param {Vector3} point - World position of the point\r\n     * @param {Vector3} normal - Surface normal at the point\r\n     * @param {Vector3} viewDir - Direction from point to camera\r\n     * @param {Array} lights - Array of light objects\r\n     * @param {Vector2} uv - UV coordinates for texture sampling\r\n     * @returns {Object} - Final color with RGBA values\r\n     */\r\n    getLitSurfaceColor(point, normal, viewDir, lights = [], uv = new Vector2(0, 0)) {\r\n        // Get base material color from texture or diffuse color\r\n        let baseColor;\r\n        if (this._diffuseTexture) {\r\n            const textureColor = this.sampleTexture(uv.x, uv.y);\r\n            if (textureColor) {\r\n                // Parse RGBA from texture sample\r\n                const match = textureColor.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*([\\d.]+))?\\)/);\r\n                if (match) {\r\n                    baseColor = {\r\n                        r: parseInt(match[1]),\r\n                        g: parseInt(match[2]),\r\n                        b: parseInt(match[3]),\r\n                        a: match[4] ? parseFloat(match[4]) : 1.0\r\n                    };\r\n                } else {\r\n                    baseColor = this._parseColor(this._diffuseColor);\r\n                }\r\n            } else {\r\n                baseColor = this._parseColor(this._diffuseColor);\r\n            }\r\n        } else {\r\n            baseColor = this._parseColor(this._diffuseColor);\r\n        }\r\n\r\n        // Calculate lighting\r\n        const lighting = this.calculateLighting(point, normal, viewDir, lights);\r\n\r\n        // Combine base color with lighting\r\n        const finalColor = {\r\n            r: Math.round((baseColor.r * (lighting.ambient.r / 255 + lighting.diffuse.r / 255)) + lighting.specular.r),\r\n            g: Math.round((baseColor.g * (lighting.ambient.g / 255 + lighting.diffuse.g / 255)) + lighting.specular.g),\r\n            b: Math.round((baseColor.b * (lighting.ambient.b / 255 + lighting.diffuse.b / 255)) + lighting.specular.b),\r\n            a: baseColor.a * this._opacity\r\n        };\r\n\r\n        // Clamp final values\r\n        finalColor.r = Math.max(0, Math.min(255, finalColor.r));\r\n        finalColor.g = Math.max(0, Math.min(255, finalColor.g));\r\n        finalColor.b = Math.max(0, Math.min(255, finalColor.b));\r\n\r\n        return finalColor;\r\n    }\r\n\r\n    /**\r\n     * Simple lighting setup for scenes without explicit lights\r\n     * @param {Vector3} point - World position of the point\r\n     * @param {Vector3} normal - Surface normal at the point\r\n     * @param {Vector3} viewDir - Direction from point to camera\r\n     * @returns {Object} - Final color with RGBA values\r\n     */\r\n    getSimpleLitColor(point, normal, viewDir, uv = new Vector2(0, 0)) {\r\n        // Default lighting setup\r\n        const defaultLights = [\r\n            {\r\n                position: new Vector3(100, 100, 100),\r\n                color: \"#FFFFFF\",\r\n                intensity: 1.0\r\n            },\r\n            {\r\n                position: new Vector3(-50, -50, 50),\r\n                color: \"#8888FF\",\r\n                intensity: 0.3\r\n            }\r\n        ];\r\n\r\n        return this.getLitSurfaceColor(point, normal, viewDir, defaultLights, uv);\r\n    }\r\n\r\n    /**\r\n     * Sample texture color at UV coordinates\r\n     */\r\n    sampleTexture(u, v, texture = null) {\r\n        const tex = texture || this.getDiffuseTexture();\r\n        if (!tex) {\r\n            const color = this._parseColor(this._diffuseColor);\r\n            return `rgba(${color.r}, ${color.g}, ${color.b}, ${this._opacity})`;\r\n        }\r\n\r\n        // Apply UV transformations\r\n        let transformedU = u * this._uvScale.x + this._uvOffset.x;\r\n        let transformedV = v * this._uvScale.y + this._uvOffset.y;\r\n\r\n        // Apply rotation\r\n        if (this._uvRotation !== 0) {\r\n            const rad = this._uvRotation * Math.PI / 180;\r\n            const cos = Math.cos(rad);\r\n            const sin = Math.sin(rad);\r\n            const centerU = 0.5;\r\n            const centerV = 0.5;\r\n\r\n            transformedU -= centerU;\r\n            transformedV -= centerV;\r\n\r\n            const rotatedU = transformedU * cos - transformedV * sin;\r\n            const rotatedV = transformedU * sin + transformedV * cos;\r\n\r\n            transformedU = rotatedU + centerU;\r\n            transformedV = rotatedV + centerV;\r\n        }\r\n\r\n        // Wrap UV coordinates\r\n        transformedU = ((transformedU % 1) + 1) % 1;\r\n        transformedV = ((transformedV % 1) + 1) % 1;\r\n\r\n        // Sample the texture\r\n        const x = Math.floor(transformedU * tex.width);\r\n        const y = Math.floor(transformedV * tex.height);\r\n\r\n        if (x >= 0 && x < tex.width && y >= 0 && y < tex.height) {\r\n            // Cache context for better performance\r\n            if (!this._sampleCtx || this._sampleCtx.canvas !== tex) {\r\n                this._sampleCtx = tex.getContext('2d', { willReadFrequently: true });\r\n            }\r\n\r\n            try {\r\n                const imageData = this._sampleCtx.getImageData(x, y, 1, 1);\r\n                const data = imageData.data;\r\n                return `rgba(${data[0]}, ${data[1]}, ${data[2]}, ${data[3] * this._opacity / 255})`;\r\n            } catch (e) {\r\n                // Fallback if getImageData fails\r\n                const color = this._parseColor(this._diffuseColor);\r\n                return `rgba(${color.r}, ${color.g}, ${color.b}, ${this._opacity})`;\r\n            }\r\n        }\r\n\r\n        // Fallback\r\n        const color = this._parseColor(this._diffuseColor);\r\n        return `rgba(${color.r}, ${color.g}, ${color.b}, ${this._opacity})`;\r\n    }\r\n\r\n    /**\r\n     * Create a simple test texture for debugging\r\n     */\r\n    createTestTexture() {\r\n        const size = 256;\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = size;\r\n        canvas.height = size;\r\n        const ctx = canvas.getContext('2d');\r\n\r\n        // Create a colorful test pattern\r\n        for (let y = 0; y < size; y++) {\r\n            for (let x = 0; x < size; x++) {\r\n                const u = x / size;\r\n                const v = y / size;\r\n\r\n                const r = Math.floor(u * 255);\r\n                const g = Math.floor(v * 255);\r\n                const b = Math.floor((u + v) / 2 * 255);\r\n\r\n                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;\r\n                ctx.fillRect(x, y, 1, 1);\r\n            }\r\n        }\r\n\r\n        this._diffuseTexture = canvas;\r\n        this._useProceduralTexture = false;\r\n        this._generatedTexture = null;\r\n\r\n        return canvas;\r\n    }\r\n\r\n    /**\r\n     * Clone this material\r\n     */\r\n    clone() {\r\n        const cloned = new Material();\r\n        cloned._diffuseColor = this._diffuseColor;\r\n        cloned._specularColor = this._specularColor;\r\n        cloned._emissiveColor = this._emissiveColor;\r\n        cloned._shininess = this._shininess;\r\n        cloned._opacity = this._opacity;\r\n        cloned._diffuseTexture = this._diffuseTexture;\r\n        cloned._normalTexture = this._normalTexture;\r\n        cloned._specularTexture = this._specularTexture;\r\n        cloned._emissiveTexture = this._emissiveTexture;\r\n        cloned._useProceduralTexture = this._useProceduralTexture;\r\n        cloned._proceduralType = this._proceduralType;\r\n        cloned._proceduralSeed = this._proceduralSeed;\r\n        cloned._proceduralScale = this._proceduralScale;\r\n        cloned._proceduralColor1 = this._proceduralColor1;\r\n        cloned._proceduralColor2 = this._proceduralColor2;\r\n        cloned._proceduralOctaves = this._proceduralOctaves;\r\n        cloned._proceduralPersistence = this._proceduralPersistence;\r\n        cloned._proceduralLacunarity = this._proceduralLacunarity;\r\n        cloned._uvScale = this._uvScale.clone();\r\n        cloned._uvOffset = this._uvOffset.clone();\r\n        cloned._uvRotation = this._uvRotation;\r\n        cloned._transparent = this._transparent;\r\n        cloned._doubleSided = this._doubleSided;\r\n        cloned._wireframe = this._wireframe;\r\n\r\n        return cloned;\r\n    }\r\n\r\n    /**\r\n     * Serialize material to JSON\r\n     */\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            _type: \"Material\",\r\n            _diffuseColor: this._diffuseColor,\r\n            _specularColor: this._specularColor,\r\n            _emissiveColor: this._emissiveColor,\r\n            _shininess: this._shininess,\r\n            _opacity: this._opacity,\r\n            _diffuseTexture: this._diffuseTexture,\r\n            _normalTexture: this._normalTexture,\r\n            _specularTexture: this._specularTexture,\r\n            _emissiveTexture: this._emissiveTexture,\r\n            _useProceduralTexture: false,//this._useProceduralTexture,\r\n            _proceduralType: this._proceduralType,\r\n            _proceduralSeed: this._proceduralSeed,\r\n            _proceduralScale: this._proceduralScale,\r\n            _proceduralColor1: this._proceduralColor1,\r\n            _proceduralColor2: this._proceduralColor2,\r\n            _proceduralOctaves: this._proceduralOctaves,\r\n            _proceduralPersistence: this._proceduralPersistence,\r\n            _proceduralLacunarity: this._proceduralLacunarity,\r\n            _uvScale: { x: this._uvScale.x, y: this._uvScale.y },\r\n            _uvOffset: { x: this._uvOffset.x, y: this._uvOffset.y },\r\n            _uvRotation: this._uvRotation,\r\n            _transparent: this._transparent,\r\n            _doubleSided: this._doubleSided,\r\n            _wireframe: this._wireframe\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Deserialize material from JSON\r\n     */\r\n    fromJSON(json) {\r\n        super.fromJSON(json);\r\n        if (json._diffuseColor !== undefined) this._diffuseColor = json._diffuseColor;\r\n        if (json._specularColor !== undefined) this._specularColor = json._specularColor;\r\n        if (json._emissiveColor !== undefined) this._emissiveColor = json._emissiveColor;\r\n        if (json._shininess !== undefined) this._shininess = json._shininess;\r\n        if (json._opacity !== undefined) {\r\n            this._opacity = json._opacity;\r\n            this._transparent = json._opacity < 1.0;\r\n        }\r\n        if (json._diffuseTexture !== undefined) this._diffuseTexture = json._diffuseTexture;\r\n        if (json._normalTexture !== undefined) this._normalTexture = json._normalTexture;\r\n        if (json._specularTexture !== undefined) this._specularTexture = json._specularTexture;\r\n        if (json._emissiveTexture !== undefined) this._emissiveTexture = json._emissiveTexture;\r\n        if (json._useProceduralTexture !== undefined) this._useProceduralTexture = false;//json._useProceduralTexture;\r\n        if (json._proceduralType !== undefined) this._proceduralType = json._proceduralType;\r\n        if (json._proceduralSeed !== undefined) this._proceduralSeed = json._proceduralSeed;\r\n        if (json._proceduralScale !== undefined) this._proceduralScale = json._proceduralScale;\r\n        if (json._proceduralColor1 !== undefined) this._proceduralColor1 = json._proceduralColor1;\r\n        if (json._proceduralColor2 !== undefined) this._proceduralColor2 = json._proceduralColor2;\r\n        if (json._proceduralOctaves !== undefined) this._proceduralOctaves = json._proceduralOctaves;\r\n        if (json._proceduralPersistence !== undefined) this._proceduralPersistence = json._proceduralPersistence;\r\n        if (json._proceduralLacunarity !== undefined) this._proceduralLacunarity = json._proceduralLacunarity;\r\n        if (json._uvScale) this._uvScale = new Vector2(json._uvScale.x, json._uvScale.y);\r\n        if (json._uvOffset) this._uvOffset = new Vector2(json._uvOffset.x, json._uvOffset.y);\r\n        if (json._uvRotation !== undefined) this._uvRotation = json._uvRotation;\r\n        if (json._transparent !== undefined) this._transparent = json._transparent;\r\n        if (json._doubleSided !== undefined) this._doubleSided = json._doubleSided;\r\n        if (json._wireframe !== undefined) this._wireframe = json._wireframe;\r\n\r\n        // Regenerate procedural texture if needed\r\n        if (this._useProceduralTexture) {\r\n            this.generateProceduralTexture();\r\n        }\r\n    }\r\n\r\n    // Getters and setters\r\n    get diffuseColor() { return this._diffuseColor; }\r\n    set diffuseColor(value) { this._diffuseColor = value; }\r\n\r\n    get specularColor() { return this._specularColor; }\r\n    set specularColor(value) { this._specularColor = value; }\r\n\r\n    get emissiveColor() { return this._emissiveColor; }\r\n    set emissiveColor(value) { this._emissiveColor = value; }\r\n\r\n    get shininess() { return this._shininess; }\r\n    set shininess(value) { this._shininess = Math.max(1, Math.min(128, value)); }\r\n\r\n    get opacity() { return this._opacity; }\r\n    set opacity(value) {\r\n        this._opacity = Math.max(0, Math.min(1, value));\r\n        this._transparent = this._opacity < 1.0;\r\n    }\r\n\r\n    get diffuseTexture() { return this._diffuseTexture; }\r\n    set diffuseTexture(value) {\r\n        this._diffuseTexture = value;\r\n        this._useProceduralTexture = false;\r\n        this._generatedTexture = null;\r\n\r\n        // Preload texture if it's a path\r\n        if (typeof value === 'string') {\r\n            this.preloadTexture(value);\r\n        }\r\n    }\r\n\r\n    get useProceduralTexture() { return this._useProceduralTexture; }\r\n    set useProceduralTexture(value) {\r\n        this._useProceduralTexture = value;\r\n        if (value) {\r\n            this._diffuseTexture = null;\r\n            this.generateProceduralTexture();\r\n        }\r\n    }\r\n\r\n    get proceduralType() { return this._proceduralType; }\r\n    set proceduralType(value) { this._proceduralType = value; }\r\n\r\n    get proceduralSeed() { return this._proceduralSeed; }\r\n    set proceduralSeed(value) { this._proceduralSeed = value; }\r\n\r\n    get proceduralScale() { return this._proceduralScale; }\r\n    set proceduralScale(value) { this._proceduralScale = value; }\r\n\r\n    get proceduralColor1() { return this._proceduralColor1; }\r\n    set proceduralColor1(value) { this._proceduralColor1 = value; }\r\n\r\n    get proceduralColor2() { return this._proceduralColor2; }\r\n    set proceduralColor2(value) { this._proceduralColor2 = value; }\r\n\r\n    get uvScale() { return this._uvScale; }\r\n    set uvScale(value) { this._uvScale = value; }\r\n\r\n    get uvOffset() { return this._uvOffset; }\r\n    set uvOffset(value) { this._uvOffset = value; }\r\n\r\n    get uvRotation() { return this._uvRotation; }\r\n    set uvRotation(value) { this._uvRotation = value; }\r\n\r\n    get transparent() { return this._transparent; }\r\n    set transparent(value) { this._transparent = value; }\r\n\r\n    get doubleSided() { return this._doubleSided; }\r\n    set doubleSided(value) { this._doubleSided = value; }\r\n\r\n    get wireframe() { return this._wireframe; }\r\n    set wireframe(value) { this._wireframe = value; }\r\n}\r\n\r\n// Register the Material module\r\nwindow.Material = Material;",
      "type": "file",
      "name": "Material.js",
      "parentPath": "/Assets/2D Context 3D Renderer",
      "created": 1759623950588,
      "modified": 1759623950588
    },
    {
      "path": "/Assets/2D Context 3D Renderer/Mesh3D.js",
      "content": "/**\n * Mesh3D - A 3D mesh renderer for the Dark Matter JS engine\n * \n * This module renders 3D meshes using the 2D canvas API.\n */\nclass Mesh3D extends Module {\n    static namespace = \"3D\";\n\n    /**\n     * Create a new Mesh3D\n     */\n    constructor() {\n        super(\"Mesh3D\");\n\n        // Mesh data\n        this.vertices = []; // Array of Vector3 objects\n        this.edges = [];    // Array of pairs of vertex indices\n        this.faces = [];    // Array of arrays of vertex indices\n\n        // Mesh properties\n        this.position = new Vector3(0, 0, 0);\n        this.rotation = new Vector3(0, 0, 0);\n        this.scale = new Vector3(1, 1, 1);\n\n        // Rotation speed (degrees per second on each axis)\n        this.rotationSpeed = new Vector3(0, 0, 0);\n\n        // Appearance\n        this.wireframeColor = \"#FFFFFF\";\n        this.faceColor = \"#3F51B5\";\n        this.renderMode = \"solid\"; // \"wireframe\", \"solid\", or \"both\"\n\n        // Material system\n        this.material = null; // Material instance for advanced texturing\n\n        // Axis visualization\n        this._showAxisLines = false;\n        this._axisLength = 150;\n\n        // Shape selection\n        this._shape = \"cube\"; // \"cube\", \"pyramid\", \"sphere\", \"octahedron\", \"torus\", \"cone\", \"cylinder\", \"icosahedron\", \"quad\", \"plane\", \"custom\"\n\n        // Expose shape property\n        this.exposeProperty(\"_shape\", \"enum\", this._shape, {\n            options: [\"cube\", \"pyramid\", \"sphere\", \"octahedron\", \"torus\", \"cone\", \"cylinder\", \"icosahedron\",\n                \"quadCube\", \"capsule\", \"prism\", \"tetrahedron\", \"quad\", \"plane\", \"custom\"],\n            onChange: (val) => {\n                // console.log(`Mesh3D: Shape property changing from \"${this._shape}\" to \"${val}\"`);\n                this._shape = val;\n                this.updateShape();\n            }\n        });\n\n        // Expose properties to the inspector\n        this.exposeProperty(\"position\", \"vector3\", this.position, {\n            onChange: (val) => {\n                if (val && typeof val === 'object') {\n                    if (val.x !== undefined) this.position.x = val.x;\n                    if (val.y !== undefined) this.position.y = val.y;\n                    if (val.z !== undefined) this.position.z = val.z;\n                } else {\n                    this.position = val;\n                }\n            }\n        });\n        this.exposeProperty(\"rotation\", \"vector3\", this.rotation, {\n            onChange: (val) => {\n                if (val && typeof val === 'object') {\n                    if (val.x !== undefined) this.rotation.x = val.x;\n                    if (val.y !== undefined) this.rotation.y = val.y;\n                    if (val.z !== undefined) this.rotation.z = val.z;\n                } else {\n                    this.rotation = val;\n                }\n            }\n        });\n        this.exposeProperty(\"scale\", \"vector3\", this.scale, {\n            onChange: (val) => {\n                if (val && typeof val === 'object') {\n                    if (val.x !== undefined) this.scale.x = val.x;\n                    if (val.y !== undefined) this.scale.y = val.y;\n                    if (val.z !== undefined) this.scale.z = val.z;\n                } else {\n                    this.scale = val;\n                }\n            }\n        });\n\n        // Expose rotation speed\n        this.exposeProperty(\"rotationSpeed\", \"vector3\", this.rotationSpeed, {\n            onChange: (val) => {\n                if (val && typeof val === 'object') {\n                    // Handle both Vector3 objects and plain objects with x, y, z properties\n                    if (val.x !== undefined) this.rotationSpeed.x = val.x;\n                    if (val.y !== undefined) this.rotationSpeed.y = val.y;\n                    if (val.z !== undefined) this.rotationSpeed.z = val.z;\n                } else {\n                    this.rotationSpeed = val;\n                }\n            }\n        });\n\n        /*this.exposeProperty(\"wireframeColor\", \"color\", \"#FFFFFF\", {\n            onChange: (val) => this.wireframeColor = val\n        });\n        this.exposeProperty(\"faceColor\", \"color\", \"#3F51B5\", {\n            onChange: (val) => this.faceColor = val\n        });\n        this.exposeProperty(\"renderMode\", \"enum\", \"wireframe\", {\n            options: [\"wireframe\", \"solid\", \"both\"],\n            onChange: (val) => this.renderMode = val\n        });*/\n\n        /*this.exposeProperty(\"material\", \"module\", null, {\n            moduleType: \"Material\",\n            onChange: (val) => this.material = val\n        });*/\n\n        /*this.exposeProperty(\"showAxisLines\", \"boolean\", false, {\n            onChange: (val) => this._showAxisLines = val\n        });\n\n        this.exposeProperty(\"axisLength\", \"number\", 150, {\n            min: 50,\n            max: 500,\n            onChange: (val) => this._axisLength = val\n        });*/\n\n        // Shape-specific properties\n        this.cubeSize = 100;\n        this.exposeProperty(\"cubeSize\", \"number\", 100, {\n            min: 10,\n            max: 500,\n            step: 10,\n            onChange: (val) => {\n                this.cubeSize = val;\n                if (this._shape === \"cube\") this.createCube(val);\n            }\n        });\n\n        this.pyramidBaseSize = 100;\n        this.pyramidHeight = 150;\n        this.exposeProperty(\"pyramidBaseSize\", \"number\", 100, {\n            min: 10,\n            max: 500,\n            step: 10,\n            onChange: (val) => {\n                this.pyramidBaseSize = val;\n                if (this._shape === \"pyramid\") this.createPyramid(val, this.pyramidHeight);\n            }\n        });\n        this.exposeProperty(\"pyramidHeight\", \"number\", 150, {\n            min: 10,\n            max: 500,\n            step: 10,\n            onChange: (val) => {\n                this.pyramidHeight = val;\n                if (this._shape === \"pyramid\") this.createPyramid(this.pyramidBaseSize, val);\n            }\n        });\n\n        this.sphereRadius = 100;\n        this.sphereDetail = 12;\n        this.exposeProperty(\"sphereRadius\", \"number\", 100, {\n            min: 10,\n            max: 500,\n            step: 10,\n            onChange: (val) => {\n                this.sphereRadius = val;\n                if (this._shape === \"sphere\") this.createSphere(val, this.sphereDetail);\n            }\n        });\n        this.exposeProperty(\"sphereDetail\", \"number\", 12, {\n            min: 6,\n            max: 24,\n            step: 1,\n            onChange: (val) => {\n                this.sphereDetail = val;\n                if (this._shape === \"sphere\") this.createSphere(this.sphereRadius, val);\n            }\n        });\n\n        this.octahedronSize = 100;\n        this.exposeProperty(\"octahedronSize\", \"number\", 100, {\n            min: 10,\n            max: 500,\n            step: 10,\n            onChange: (val) => {\n                this.octahedronSize = val;\n                if (this._shape === \"octahedron\") this.createOctahedron(val);\n            }\n        });\n\n        this.planeSize = 200;\n        this.exposeProperty(\"planeSize\", \"number\", 200, {\n            min: 10,\n            max: 500,\n            step: 10,\n            onChange: (val) => {\n                this.planeSize = val;\n                if (this._shape === \"plane\") this.createPlane(val);\n            }\n        });\n\n        // Quad Cube properties\n        this.quadCubeSize = 100;\n        this.quadCubeSubdivisions = 2;\n        this.exposeProperty(\"quadCubeSize\", \"number\", 100, {\n            min: 10,\n            max: 500,\n            step: 10,\n            onChange: (val) => {\n                this.quadCubeSize = val;\n                if (this._shape === \"quadCube\") this.createQuadCube(val, this.quadCubeSubdivisions);\n            }\n        });\n        this.exposeProperty(\"quadCubeSubdivisions\", \"number\", 2, {\n            min: 1,\n            max: 10,\n            step: 1,\n            onChange: (val) => {\n                this.quadCubeSubdivisions = val;\n                if (this._shape === \"quadCube\") this.createQuadCube(this.quadCubeSize, val);\n            }\n        });\n\n        // Capsule properties\n        this.capsuleRadius = 50;\n        this.capsuleHeight = 150;\n        this.capsuleSegments = 16;\n        this.exposeProperty(\"capsuleRadius\", \"number\", 50, {\n            min: 10,\n            max: 200,\n            step: 5,\n            onChange: (val) => {\n                this.capsuleRadius = val;\n                if (this._shape === \"capsule\") this.createCapsule(val, this.capsuleHeight, this.capsuleSegments);\n            }\n        });\n        this.exposeProperty(\"capsuleHeight\", \"number\", 150, {\n            min: 20,\n            max: 500,\n            step: 10,\n            onChange: (val) => {\n                this.capsuleHeight = val;\n                if (this._shape === \"capsule\") this.createCapsule(this.capsuleRadius, val, this.capsuleSegments);\n            }\n        });\n        this.exposeProperty(\"capsuleSegments\", \"number\", 16, {\n            min: 6,\n            max: 32,\n            step: 1,\n            onChange: (val) => {\n                this.capsuleSegments = val;\n                if (this._shape === \"capsule\") this.createCapsule(this.capsuleRadius, this.capsuleHeight, val);\n            }\n        });\n\n        // Prism properties\n        this.prismSides = 6;\n        this.prismRadius = 100;\n        this.prismHeight = 150;\n        this.exposeProperty(\"prismSides\", \"number\", 6, {\n            min: 3,\n            max: 12,\n            step: 1,\n            onChange: (val) => {\n                this.prismSides = val;\n                if (this._shape === \"prism\") this.createPrism(val, this.prismRadius, this.prismHeight);\n            }\n        });\n        this.exposeProperty(\"prismRadius\", \"number\", 100, {\n            min: 10,\n            max: 300,\n            step: 10,\n            onChange: (val) => {\n                this.prismRadius = val;\n                if (this._shape === \"prism\") this.createPrism(this.prismSides, val, this.prismHeight);\n            }\n        });\n        this.exposeProperty(\"prismHeight\", \"number\", 150, {\n            min: 10,\n            max: 500,\n            step: 10,\n            onChange: (val) => {\n                this.prismHeight = val;\n                if (this._shape === \"prism\") this.createPrism(this.prismSides, this.prismRadius, val);\n            }\n        });\n\n        // Tetrahedron properties\n        this.tetrahedronSize = 100;\n        this.exposeProperty(\"tetrahedronSize\", \"number\", 100, {\n            min: 10,\n            max: 500,\n            step: 10,\n            onChange: (val) => {\n                this.tetrahedronSize = val;\n                if (this._shape === \"tetrahedron\") this.createTetrahedron(val);\n            }\n        });\n\n        this.torusMajorRadius = 100;\n        this.torusMinorRadius = 40;\n        this.torusMajorSegments = 16;\n        this.torusMinorSegments = 8;\n        this.exposeProperty(\"torusMajorRadius\", \"number\", 100, {\n            min: 20,\n            max: 300,\n            step: 10,\n            onChange: (val) => {\n                this.torusMajorRadius = val;\n                if (this._shape === \"torus\") this.createTorus(val, this.torusMinorRadius, this.torusMajorSegments, this.torusMinorSegments);\n            }\n        });\n        this.exposeProperty(\"torusMinorRadius\", \"number\", 40, {\n            min: 10,\n            max: 100,\n            step: 5,\n            onChange: (val) => {\n                this.torusMinorRadius = val;\n                if (this._shape === \"torus\") this.createTorus(this.torusMajorRadius, val, this.torusMajorSegments, this.torusMinorSegments);\n            }\n        });\n        this.exposeProperty(\"torusMajorSegments\", \"number\", 16, {\n            min: 8,\n            max: 32,\n            step: 1,\n            onChange: (val) => {\n                this.torusMajorSegments = val;\n                if (this._shape === \"torus\") this.createTorus(this.torusMajorRadius, this.torusMinorRadius, val, this.torusMinorSegments);\n            }\n        });\n        this.exposeProperty(\"torusMinorSegments\", \"number\", 8, {\n            min: 4,\n            max: 16,\n            step: 1,\n            onChange: (val) => {\n                this.torusMinorSegments = val;\n                if (this._shape === \"torus\") this.createTorus(this.torusMajorRadius, this.torusMinorRadius, this.torusMajorSegments, val);\n            }\n        });\n\n        this.coneRadius = 100;\n        this.coneHeight = 150;\n        this.coneSegments = 16;\n        this.exposeProperty(\"coneRadius\", \"number\", 100, {\n            min: 10,\n            max: 500,\n            step: 10,\n            onChange: (val) => {\n                this.coneRadius = val;\n                if (this._shape === \"cone\") this.createCone(val, this.coneHeight, this.coneSegments);\n            }\n        });\n        this.exposeProperty(\"coneHeight\", \"number\", 150, {\n            min: 10,\n            max: 500,\n            step: 10,\n            onChange: (val) => {\n                this.coneHeight = val;\n                if (this._shape === \"cone\") this.createCone(this.coneRadius, val, this.coneSegments);\n            }\n        });\n        this.exposeProperty(\"coneSegments\", \"number\", 16, {\n            min: 6,\n            max: 32,\n            step: 1,\n            onChange: (val) => {\n                this.coneSegments = val;\n                if (this._shape === \"cone\") this.createCone(this.coneRadius, this.coneHeight, val);\n            }\n        });\n\n        this.cylinderRadius = 100;\n        this.cylinderHeight = 150;\n        this.cylinderSegments = 16;\n        this.exposeProperty(\"cylinderRadius\", \"number\", 100, {\n            min: 10,\n            max: 500,\n            step: 10,\n            onChange: (val) => {\n                this.cylinderRadius = val;\n                if (this._shape === \"cylinder\") this.createCylinder(val, this.cylinderHeight, this.cylinderSegments);\n            }\n        });\n        this.exposeProperty(\"cylinderHeight\", \"number\", 150, {\n            min: 10,\n            max: 500,\n            step: 10,\n            onChange: (val) => {\n                this.cylinderHeight = val;\n                if (this._shape === \"cylinder\") this.createCylinder(this.cylinderRadius, val, this.cylinderSegments);\n            }\n        });\n        this.exposeProperty(\"cylinderSegments\", \"number\", 16, {\n            min: 6,\n            max: 32,\n            step: 1,\n            onChange: (val) => {\n                this.cylinderSegments = val;\n                if (this._shape === \"cylinder\") this.createCylinder(this.cylinderRadius, this.cylinderHeight, val);\n            }\n        });\n\n        this.icosahedronSize = 100;\n        this.exposeProperty(\"icosahedronSize\", \"number\", 100, {\n            min: 10,\n            max: 500,\n            step: 10,\n            onChange: (val) => {\n                this.icosahedronSize = val;\n                if (this._shape === \"icosahedron\") this.createIcosahedron(val);\n            }\n        });\n\n        this.quadWidth = 200;\n        this.quadHeight = 200;\n        this.quadSubdivisionsX = 4;\n        this.quadSubdivisionsY = 4;\n        this.exposeProperty(\"quadWidth\", \"number\", 200, {\n            min: 10,\n            max: 500,\n            step: 10,\n            onChange: (val) => {\n                this.quadWidth = val;\n                if (this._shape === \"quad\") this.createQuad(val, this.quadHeight, this.quadSubdivisionsX, this.quadSubdivisionsY);\n            }\n        });\n        this.exposeProperty(\"quadHeight\", \"number\", 200, {\n            min: 10,\n            max: 500,\n            step: 10,\n            onChange: (val) => {\n                this.quadHeight = val;\n                if (this._shape === \"quad\") this.createQuad(this.quadWidth, val, this.quadSubdivisionsX, this.quadSubdivisionsY);\n            }\n        });\n        this.exposeProperty(\"quadSubdivisionsX\", \"number\", 4, {\n            min: 1,\n            max: 20,\n            step: 1,\n            onChange: (val) => {\n                this.quadSubdivisionsX = val;\n                if (this._shape === \"quad\") this.createQuad(this.quadWidth, this.quadHeight, val, this.quadSubdivisionsY);\n            }\n        });\n        this.exposeProperty(\"quadSubdivisionsY\", \"number\", 4, {\n            min: 1,\n            max: 20,\n            step: 1,\n            onChange: (val) => {\n                this.quadSubdivisionsY = val;\n                if (this._shape === \"quad\") this.createQuad(this.quadWidth, this.quadHeight, this.quadSubdivisionsX, val);\n            }\n        });\n\n        this.planeSize = 200;\n        this.exposeProperty(\"planeSize\", \"number\", 200, {\n            min: 10,\n            max: 500,\n            step: 10,\n            onChange: (val) => {\n                this.planeSize = val;\n                if (this._shape === \"plane\") this.createPlane(val);\n            }\n        });\n\n        // Generate UV coordinates for texture mapping\n        this.generateUVCoordinates();\n\n        // Ensure material module exists on the game object\n        this.ensureMaterialModule();\n    }\n\n    /**\n     * Optional method for enhanced inspector UI using the Style helper\n     * This will be called by the Inspector if it exists\n     * @param {Style} style - Styling helper\n     */\n    style(style) {\n        style.startGroup(\"Shape Selection\", false, {\n            backgroundColor: 'rgba(100,150,255,0.08)',\n            borderRadius: '6px',\n            padding: '8px'\n        });\n        style.exposeProperty(\"shape\", \"enum\", this._shape, {\n            label: \"Mesh Shape\",\n            options: [\"cube\", \"pyramid\", \"sphere\", \"octahedron\", \"torus\", \"cone\", \"cylinder\", \"icosahedron\",\n                \"quadCube\", \"capsule\", \"prism\", \"tetrahedron\", \"quad\", \"plane\", \"custom\"]\n        });\n        style.endGroup();\n\n        style.addDivider();\n\n        style.startGroup(\"Transform\", false, {\n            backgroundColor: 'rgba(150,255,150,0.08)',\n            borderRadius: '6px',\n            padding: '8px'\n        });\n        style.exposeProperty(\"position\", \"vector3\", this.position, { label: \"Position\" });\n        style.exposeProperty(\"rotation\", \"vector3\", this.rotation, { label: \"Rotation\" });\n        style.exposeProperty(\"scale\", \"vector3\", this.scale, { label: \"Scale\" });\n        style.exposeProperty(\"rotationSpeed\", \"vector3\", this.rotationSpeed, { label: \"Rotation Speed (deg/s)\" });\n        style.endGroup();\n\n        style.addDivider();\n\n        // Show properties based on selected shape\n        if (this._shape === \"cube\") {\n            style.startGroup(\"Cube Settings\", false, {\n                backgroundColor: 'rgba(255,100,100,0.08)',\n                borderRadius: '6px',\n                padding: '8px'\n            });\n            style.exposeProperty(\"cubeSize\", \"number\", this.cubeSize, { label: \"Size\" });\n            style.endGroup();\n        }\n\n        if (this._shape === \"pyramid\") {\n            style.startGroup(\"Pyramid Settings\", false, {\n                backgroundColor: 'rgba(255,150,100,0.08)',\n                borderRadius: '6px',\n                padding: '8px'\n            });\n            style.exposeProperty(\"pyramidBaseSize\", \"number\", this.pyramidBaseSize, { label: \"Base Size\" });\n            style.exposeProperty(\"pyramidHeight\", \"number\", this.pyramidHeight, { label: \"Height\" });\n            style.endGroup();\n        }\n\n        if (this._shape === \"sphere\") {\n            style.startGroup(\"Sphere Settings\", false, {\n                backgroundColor: 'rgba(100,255,100,0.08)',\n                borderRadius: '6px',\n                padding: '8px'\n            });\n            style.exposeProperty(\"sphereRadius\", \"number\", this.sphereRadius, { label: \"Radius\" });\n            style.exposeProperty(\"sphereDetail\", \"number\", this.sphereDetail, { label: \"Detail Level\" });\n            style.endGroup();\n        }\n\n        if (this._shape === \"octahedron\") {\n            style.startGroup(\"Octahedron Settings\", false, {\n                backgroundColor: 'rgba(255,100,255,0.08)',\n                borderRadius: '6px',\n                padding: '8px'\n            });\n            style.exposeProperty(\"octahedronSize\", \"number\", this.octahedronSize, { label: \"Size\" });\n            style.endGroup();\n        }\n\n        if (this._shape === \"torus\") {\n            style.startGroup(\"Torus Settings\", false, {\n                backgroundColor: 'rgba(100,255,255,0.08)',\n                borderRadius: '6px',\n                padding: '8px'\n            });\n            style.exposeProperty(\"torusMajorRadius\", \"number\", this.torusMajorRadius, { label: \"Major Radius\" });\n            style.exposeProperty(\"torusMinorRadius\", \"number\", this.torusMinorRadius, { label: \"Minor Radius\" });\n            style.exposeProperty(\"torusMajorSegments\", \"number\", this.torusMajorSegments, { label: \"Major Segments\" });\n            style.exposeProperty(\"torusMinorSegments\", \"number\", this.torusMinorSegments, { label: \"Minor Segments\" });\n            style.endGroup();\n        }\n\n        if (this._shape === \"cone\") {\n            style.startGroup(\"Cone Settings\", false, {\n                backgroundColor: 'rgba(255,200,100,0.08)',\n                borderRadius: '6px',\n                padding: '8px'\n            });\n            style.exposeProperty(\"coneRadius\", \"number\", this.coneRadius, { label: \"Base Radius\" });\n            style.exposeProperty(\"coneHeight\", \"number\", this.coneHeight, { label: \"Height\" });\n            style.exposeProperty(\"coneSegments\", \"number\", this.coneSegments, { label: \"Segments\" });\n            style.endGroup();\n        }\n\n        if (this._shape === \"cylinder\") {\n            style.startGroup(\"Cylinder Settings\", false, {\n                backgroundColor: 'rgba(150,150,255,0.08)',\n                borderRadius: '6px',\n                padding: '8px'\n            });\n            style.exposeProperty(\"cylinderRadius\", \"number\", this.cylinderRadius, { label: \"Radius\" });\n            style.exposeProperty(\"cylinderHeight\", \"number\", this.cylinderHeight, { label: \"Height\" });\n            style.exposeProperty(\"cylinderSegments\", \"number\", this.cylinderSegments, { label: \"Segments\" });\n            style.endGroup();\n        }\n\n        if (this._shape === \"icosahedron\") {\n            style.startGroup(\"Icosahedron Settings\", false, {\n                backgroundColor: 'rgba(255,150,200,0.08)',\n                borderRadius: '6px',\n                padding: '8px'\n            });\n            style.exposeProperty(\"icosahedronSize\", \"number\", this.icosahedronSize, { label: \"Size\" });\n            style.endGroup();\n        }\n\n        if (this._shape === \"quadCube\") {\n            style.startGroup(\"Quad Cube Settings\", false, {\n                backgroundColor: 'rgba(200,150,100,0.08)',\n                borderRadius: '6px',\n                padding: '8px'\n            });\n            style.exposeProperty(\"quadCubeSize\", \"number\", this.quadCubeSize, { label: \"Size\" });\n            style.exposeProperty(\"quadCubeSubdivisions\", \"number\", this.quadCubeSubdivisions, { label: \"Subdivisions\" });\n            style.endGroup();\n        }\n\n        if (this._shape === \"capsule\") {\n            style.startGroup(\"Capsule Settings\", false, {\n                backgroundColor: 'rgba(150,255,200,0.08)',\n                borderRadius: '6px',\n                padding: '8px'\n            });\n            style.exposeProperty(\"capsuleRadius\", \"number\", this.capsuleRadius, { label: \"Radius\" });\n            style.exposeProperty(\"capsuleHeight\", \"number\", this.capsuleHeight, { label: \"Height\" });\n            style.exposeProperty(\"capsuleSegments\", \"number\", this.capsuleSegments, { label: \"Segments\" });\n            style.endGroup();\n        }\n\n        if (this._shape === \"prism\") {\n            style.startGroup(\"Prism Settings\", false, {\n                backgroundColor: 'rgba(200,150,255,0.08)',\n                borderRadius: '6px',\n                padding: '8px'\n            });\n            style.exposeProperty(\"prismSides\", \"number\", this.prismSides, { label: \"Sides\" });\n            style.exposeProperty(\"prismRadius\", \"number\", this.prismRadius, { label: \"Radius\" });\n            style.exposeProperty(\"prismHeight\", \"number\", this.prismHeight, { label: \"Height\" });\n            style.endGroup();\n        }\n\n        if (this._shape === \"tetrahedron\") {\n            style.startGroup(\"Tetrahedron Settings\", false, {\n                backgroundColor: 'rgba(255,200,150,0.08)',\n                borderRadius: '6px',\n                padding: '8px'\n            });\n            style.exposeProperty(\"tetrahedronSize\", \"number\", this.tetrahedronSize, { label: \"Size\" });\n            style.endGroup();\n        }\n\n        if (this._shape === \"quad\") {\n            style.startGroup(\"Quad Settings\", false, {\n                backgroundColor: 'rgba(200,100,255,0.08)',\n                borderRadius: '6px',\n                padding: '8px'\n            });\n            style.exposeProperty(\"quadWidth\", \"number\", this.quadWidth, { label: \"Width\" });\n            style.exposeProperty(\"quadHeight\", \"number\", this.quadHeight, { label: \"Height\" });\n            style.exposeProperty(\"quadSubdivisionsX\", \"number\", this.quadSubdivisionsX, { label: \"X Subdivisions\" });\n            style.exposeProperty(\"quadSubdivisionsY\", \"number\", this.quadSubdivisionsY, { label: \"Y Subdivisions\" });\n            style.endGroup();\n        }\n\n        if (this._shape === \"plane\") {\n            style.startGroup(\"Plane Settings\", false, {\n                backgroundColor: 'rgba(150,200,255,0.08)',\n                borderRadius: '6px',\n                padding: '8px'\n            });\n            style.exposeProperty(\"planeSize\", \"number\", this.planeSize, { label: \"Size\" });\n            style.endGroup();\n        }\n\n        if (this._shape === \"custom\") {\n            style.startGroup(\"Custom Model Settings\", false, {\n                backgroundColor: 'rgba(255,255,100,0.08)',\n                borderRadius: '6px',\n                padding: '8px'\n            });\n            style.exposeProperty(\"sphereRadius\", \"number\", this.sphereRadius, { label: \"Base Radius\" });\n            style.exposeProperty(\"sphereDetail\", \"number\", this.sphereDetail, { label: \"Detail Level\" });\n            style.endGroup();\n        }\n\n        style.addDivider();\n\n        /*style.startGroup(\"Appearance\", false, {\n            backgroundColor: 'rgba(200,200,200,0.08)',\n            borderRadius: '6px',\n            padding: '8px'\n        });\n        style.exposeProperty(\"wireframeColor\", \"color\", this.wireframeColor, { label: \"Wireframe Color\" });\n        style.exposeProperty(\"faceColor\", \"color\", this.faceColor, { label: \"Face Color\" });\n        style.exposeProperty(\"renderMode\", \"enum\", this.renderMode, { label: \"Render Mode\" });\n        style.endGroup();\n\n        style.addDivider();\n\n        style.startGroup(\"Material & Lighting\", false, {\n            backgroundColor: 'rgba(255,150,255,0.08)',\n            borderRadius: '6px',\n            padding: '8px'\n        });\n        style.exposeProperty(\"material\", \"module\", this.material, { label: \"Material\" });\n        style.endGroup();*/\n\n        //style.addDivider();\n\n        /*style.startGroup(\"Debug\", false, {\n            backgroundColor: 'rgba(255,255,150,0.08)',\n            borderRadius: '6px',\n            padding: '8px'\n        });\n        style.exposeProperty(\"_showAxisLines\", \"boolean\", this._showAxisLines, { label: \"Show Axis Lines\" });\n        style.exposeProperty(\"_axisLength\", \"number\", this._axisLength, { label: \"Axis Length\" });\n        style.endGroup();*/\n    }\n\n    start() {\n        // Ensure material module exists on the game object\n        this.ensureMaterialModule();\n\n        this.updateShape();\n    }\n\n    /**\n     * Update method called each frame\n     */\n    loop(deltaTime) {\n        // Apply automatic rotation based on rotation speed\n        //if (this.rotationSpeed && (this.rotationSpeed.x !== 0 || this.rotationSpeed.y !== 0 || this.rotationSpeed.z !== 0)) {\n            // Multiply by deltaTime to get rotation per second\n            this.rotation.x += this.rotationSpeed.x * deltaTime;\n            this.rotation.y += this.rotationSpeed.y * deltaTime;\n            this.rotation.z += this.rotationSpeed.z * deltaTime;\n\n            // Normalize angles to 0-360 range\n            this.rotation.x = ((this.rotation.x % 360) + 360) % 360;\n            this.rotation.y = ((this.rotation.y % 360) + 360) % 360;\n            this.rotation.z = ((this.rotation.z % 360) + 360) % 360;\n        //}\n\n        // Handle custom model interactions if enabled\n        if (this.isCustomModel && this._shape === \"custom\") {\n            this.handleCustomModelInput();\n        }\n\n        this.updateShape();\n    }\n\n    /**\n     * Ensure the game object has a Material module\n     */\n    ensureMaterialModule() {\n        if (!this.gameObject) return;\n\n        // Check if material module already exists\n        let materialModule = this.gameObject.getModule ? this.gameObject.getModule('Material') : null;\n        if (!materialModule) {\n            // Create and add a new material module\n            materialModule = new Material();\n            if (this.gameObject.addModule) {\n                this.gameObject.addModule(materialModule);\n            }\n        }\n\n        // Set the material reference\n        this.material = materialModule;\n    }\n\n    /**\n     * Generate UV coordinates for texture mapping\n     */\n    generateUVCoordinates() {\n        this.uvCoordinates = [];\n\n        for (let i = 0; i < this.vertices.length; i++) {\n            const vertex = this.vertices[i];\n\n            // Simple planar projection for UV mapping\n            // This is a basic implementation - can be improved for different mesh types\n            let u, v;\n\n            if (Math.abs(vertex.x) > Math.abs(vertex.y) && Math.abs(vertex.x) > Math.abs(vertex.z)) {\n                // X-dominant face\n                u = (vertex.y + 1) / 2;\n                v = (vertex.z + 1) / 2;\n            } else if (Math.abs(vertex.y) > Math.abs(vertex.x) && Math.abs(vertex.y) > Math.abs(vertex.z)) {\n                // Y-dominant face\n                u = (vertex.x + 1) / 2;\n                v = (vertex.z + 1) / 2;\n            } else {\n                // Z-dominant face\n                u = (vertex.x + 1) / 2;\n                v = (vertex.y + 1) / 2;\n            }\n\n            this.uvCoordinates.push(new Vector2(u, v));\n        }\n    }\n\n    /**\n     * Get material color for a face, considering texture if available\n     * @param {Array<number>} face - Array of vertex indices\n     * @param {Array<Vector3>} worldVertices - World-space vertex positions\n     * @param {Camera3D} camera - Camera for view direction calculation\n     * @param {Array<Vector3>} normals - Face normals (optional)\n     * @returns {string} - CSS color string\n     */\n    getMaterialColor(face, worldVertices, camera, normals = null) {\n        if (!this.material) {\n            return this.faceColor;\n        }\n\n        // For simple flat shading, use face center\n        const faceCenter = this.getFaceCenter(face, worldVertices);\n        const normal = normals ? normals[0] : this.calculateFaceNormal(face, worldVertices);\n\n        if (camera && camera.position) {\n            const viewDir = camera.position.clone().subtract(faceCenter).normalize();\n\n            // Calculate UV coordinates for face center (simple average)\n            const uvs = face.map(vertexIndex => this.uvCoordinates[vertexIndex] || new Vector2(0, 0));\n            const avgU = uvs.reduce((sum, uv) => sum + uv.x, 0) / uvs.length;\n            const avgV = uvs.reduce((sum, uv) => sum + uv.y, 0) / uvs.length;\n\n            // Get lit color from material\n            const litColor = this.material.getSimpleLitColor(faceCenter, normal, viewDir, new Vector2(avgU, avgV));\n\n            return `rgba(${Math.round(litColor.r)}, ${Math.round(litColor.g)}, ${Math.round(litColor.b)}, ${litColor.a})`;\n        }\n\n        // Fallback to diffuse color if no camera\n        return this.material.diffuseColor;\n    }\n\n    /**\n     * Calculate face center from vertex indices\n     * @param {Array<number>} face - Array of vertex indices\n     * @param {Array<Vector3>} vertices - Array of vertex positions\n     * @returns {Vector3} - Face center position\n     */\n    getFaceCenter(face, vertices) {\n        const center = new Vector3(0, 0, 0);\n        for (const vertexIndex of face) {\n            if (vertexIndex < vertices.length) {\n                center.add(vertices[vertexIndex]);\n            }\n        }\n        center.multiply(1 / face.length);\n        return center;\n    }\n\n    /**\n     * Calculate face normal from vertex positions\n     * @param {Array<number>} face - Array of vertex indices\n     * @param {Array<Vector3>} vertices - Array of vertex positions\n     * @returns {Vector3} - Face normal vector\n     */\n    calculateFaceNormal(face, vertices) {\n        if (face.length < 3) {\n            return new Vector3(0, 0, 1);\n        }\n\n        // Use first three vertices to calculate normal\n        const v1 = vertices[face[0]];\n        const v2 = vertices[face[1]];\n        const v3 = vertices[face[2]];\n\n        if (!v1 || !v2 || !v3) {\n            return new Vector3(0, 0, 1);\n        }\n\n        // Calculate two edges\n        const edge1 = v2.clone().subtract(v1);\n        const edge2 = v3.clone().subtract(v1);\n\n        // Calculate cross product for normal\n        const normal = edge1.clone().cross(edge2).normalize();\n\n        return normal;\n    }\n\n    /**\n     * Create a cube mesh\n     * @param {number} size - Size of the cube\n     */\n    createCube(size = 100) {\n        const s = size / 2;\n\n        // X=forward, Y=right, Z=up coordinate system\n        this.vertices = [\n            new Vector3(-s, -s, -s), // 0: back-left-bottom\n            new Vector3(-s, s, -s),  // 1: back-right-bottom\n            new Vector3(-s, s, s),   // 2: back-right-top\n            new Vector3(-s, -s, s),  // 3: back-left-top\n            new Vector3(s, -s, -s),  // 4: front-left-bottom\n            new Vector3(s, s, -s),   // 5: front-right-bottom\n            new Vector3(s, s, s),    // 6: front-right-top\n            new Vector3(s, -s, s)    // 7: front-left-top\n        ];\n\n        this.edges = [\n            [0, 1], [1, 2], [2, 3], [3, 0], // back face\n            [4, 5], [5, 6], [6, 7], [7, 4], // front face\n            [0, 4], [1, 5], [2, 6], [3, 7]  // connecting edges\n        ];\n\n        // Triangulated faces with correct winding (counter-clockwise from outside)\n        this.faces = [\n            // Back face (X = -s) - looking from behind\n            [0, 3, 2], [0, 2, 1],\n            // Front face (X = s) - looking from front\n            [4, 5, 6], [4, 6, 7],\n            // Bottom face (Z = -s) - looking from below\n            [0, 1, 5], [0, 5, 4],\n            // Top face (Z = s) - looking from above\n            [3, 7, 6], [3, 6, 2],\n            // Left face (Y = -s) - looking from left\n            [0, 4, 7], [0, 7, 3],\n            // Right face (Y = s) - looking from right\n            [1, 2, 6], [1, 6, 5]\n        ];\n\n        this.generateUVCoordinates();\n    }\n\n    /**\n     * Create a pyramid mesh\n     * @param {number} baseSize - Size of the base\n     * @param {number} height - Height of the pyramid\n     */\n    createPyramid(baseSize = 100, height = 150) {\n        const s = baseSize / 2;\n        const h = height / 2;\n\n        // X=forward, Y=right, Z=up\n        this.vertices = [\n            new Vector3(-s, -s, -h), // 0: base back-left\n            new Vector3(-s, s, -h),  // 1: base back-right\n            new Vector3(s, s, -h),   // 2: base front-right\n            new Vector3(s, -s, -h),  // 3: base front-left\n            new Vector3(0, 0, h)     // 4: apex\n        ];\n\n        this.edges = [\n            [0, 1], [1, 2], [2, 3], [3, 0], // base\n            [0, 4], [1, 4], [2, 4], [3, 4]  // edges to apex\n        ];\n\n        this.faces = [\n            [0, 1, 2, 3], // base (CCW from below)\n            [0, 4, 1],    // left face\n            [1, 4, 2],    // back face\n            [2, 4, 3],    // right face\n            [3, 4, 0]     // front face\n        ];\n\n        this.generateUVCoordinates();\n    }\n\n    /**\n     * Create a sphere mesh (approximation using triangles)\n     * @param {number} radius - Radius of the sphere\n     * @param {number} detail - Level of detail (segments)\n     */\n    createSphere(radius = 100, detail = 12) {\n        // Reset mesh data\n        this.vertices = [];\n        this.edges = [];\n        this.faces = [];\n\n        // Create vertices using spherical coordinates\n        for (let lat = 0; lat <= detail; lat++) {\n            const theta = lat * Math.PI / detail;\n            const sinTheta = Math.sin(theta);\n            const cosTheta = Math.cos(theta);\n\n            for (let lon = 0; lon <= detail; lon++) {\n                const phi = lon * 2 * Math.PI / detail;\n                const sinPhi = Math.sin(phi);\n                const cosPhi = Math.cos(phi);\n\n                const x = radius * sinTheta * cosPhi;\n                const y = radius * cosTheta;\n                const z = radius * sinTheta * sinPhi;\n\n                this.vertices.push(new Vector3(x, y, z));\n            }\n        }\n\n        // Create faces and edges with correct counter-clockwise winding\n        for (let lat = 0; lat < detail; lat++) {\n            for (let lon = 0; lon < detail; lon++) {\n                const first = lat * (detail + 1) + lon;\n                const second = first + detail + 1;\n\n                // Create two triangular faces with correct counter-clockwise winding (viewed from outside)\n                // First triangle: first -> first+1 -> second (counter-clockwise from outside)\n                this.faces.push([first, first + 1, second]);\n                // Second triangle: second -> first+1 -> second+1 (counter-clockwise from outside)\n                this.faces.push([second, first + 1, second + 1]);\n\n                // Add edges\n                this.edges.push([first, first + 1]);\n                this.edges.push([first, second]);\n\n                if (lat === detail - 1) {\n                    this.edges.push([second, second + 1]);\n                }\n\n                if (lon === detail - 1) {\n                    this.edges.push([first + 1, second + 1]);\n                }\n            }\n        }\n\n        // Regenerate UV coordinates after changing mesh data\n        this.generateUVCoordinates();\n    }\n\n    /**\n     * Create an octahedron mesh\n     * @param {number} size - Size of the octahedron\n     */\n    createOctahedron(size = 100) {\n        const s = size / 2;\n\n        this.vertices = [\n            new Vector3(0, s, 0),   // 0: top\n            new Vector3(s, 0, 0),   // 1: front\n            new Vector3(0, 0, s),   // 2: right\n            new Vector3(-s, 0, 0),  // 3: back\n            new Vector3(0, 0, -s),  // 4: left\n            new Vector3(0, -s, 0)   // 5: bottom\n        ];\n\n        this.edges = [\n            [0, 1], [0, 2], [0, 3], [0, 4],\n            [1, 2], [2, 3], [3, 4], [4, 1],\n            [5, 1], [5, 2], [5, 3], [5, 4]\n        ];\n\n        this.faces = [\n            [0, 2, 1], [0, 3, 2], [0, 4, 3], [0, 1, 4], // top faces\n            [5, 1, 2], [5, 2, 3], [5, 3, 4], [5, 4, 1]  // bottom faces\n        ];\n\n        // Regenerate UV coordinates after changing mesh data\n        this.generateUVCoordinates();\n    }\n\n    /**\n      * Create a torus (donut) mesh\n      * @param {number} majorRadius - Distance from center to tube center\n      * @param {number} minorRadius - Radius of the tube\n      * @param {number} majorSegments - Segments around the major radius\n      * @param {number} minorSegments - Segments around the minor radius\n      */\n    createTorus(majorRadius = 100, minorRadius = 40, majorSegments = 16, minorSegments = 8) {\n        this.vertices = [];\n        this.edges = [];\n        this.faces = [];\n\n        // Generate vertices\n        for (let i = 0; i < majorSegments; i++) {\n            const theta = (i / majorSegments) * Math.PI * 2;\n            const centerX = Math.cos(theta) * majorRadius;\n            const centerZ = Math.sin(theta) * majorRadius;\n\n            for (let j = 0; j < minorSegments; j++) {\n                const phi = (j / minorSegments) * Math.PI * 2;\n                const x = centerX + Math.cos(phi) * Math.cos(theta) * minorRadius;\n                const y = Math.sin(phi) * minorRadius;\n                const z = centerZ + Math.cos(phi) * Math.sin(theta) * minorRadius;\n\n                this.vertices.push(new Vector3(x, y, z));\n            }\n        }\n\n        // Generate faces and edges with correct winding order\n        for (let i = 0; i < majorSegments; i++) {\n            for (let j = 0; j < minorSegments; j++) {\n                const current = i * minorSegments + j;\n                const nextMajor = ((i + 1) % majorSegments) * minorSegments + j;\n                const nextMinor = i * minorSegments + ((j + 1) % minorSegments);\n                const nextBoth = ((i + 1) % majorSegments) * minorSegments + ((j + 1) % minorSegments);\n\n                // Create faces with correct counter-clockwise winding (from outside)\n                // First triangle: current -> nextMinor -> nextBoth\n                this.faces.push([current, nextMinor, nextBoth]);\n                // Second triangle: current -> nextBoth -> nextMajor\n                this.faces.push([current, nextBoth, nextMajor]);\n\n                // Create edges\n                this.edges.push([current, nextMinor]);\n                this.edges.push([current, nextMajor]);\n            }\n        }\n\n        // Regenerate UV coordinates after changing mesh data\n        this.generateUVCoordinates();\n    }\n\n    /**\n     * Create a cone mesh\n     * @param {number} radius - Base radius\n     * @param {number} height - Height of the cone\n     * @param {number} segments - Number of segments around the base\n     */\n    createCone(radius = 100, height = 150, segments = 16) {\n        this.vertices = [];\n        this.edges = [];\n        this.faces = [];\n\n        const h = height / 2;\n\n        // Apex at top (X=forward, Y=right, Z=up)\n        const apex = 0;\n        this.vertices.push(new Vector3(0, 0, h));\n\n        // Base center at bottom\n        const baseCenter = 1;\n        this.vertices.push(new Vector3(0, 0, -h));\n\n        // Base vertices (circle in XY plane at Z = -h)\n        for (let i = 0; i < segments; i++) {\n            const theta = (i / segments) * Math.PI * 2;\n            const x = Math.cos(theta) * radius;\n            const y = Math.sin(theta) * radius;\n            this.vertices.push(new Vector3(x, y, -h));\n        }\n\n        // Create side faces (triangles from apex to base edge)\n        // CCW from outside: apex -> current -> next\n        for (let i = 0; i < segments; i++) {\n            const current = 2 + i; // Base vertex index\n            const next = 2 + ((i + 1) % segments); // Next base vertex\n\n            // Side triangle: apex -> current -> next (CCW from outside)\n            this.faces.push([apex, current, next]);\n\n            // Edges\n            this.edges.push([apex, current]);\n            this.edges.push([current, next]);\n        }\n\n        // Create base face (polygon at bottom, winding CCW from below)\n        const baseFace = [];\n        for (let i = segments - 1; i >= 0; i--) {\n            baseFace.push(2 + i);\n        }\n        // When viewed from below (negative Z), this is now CCW\n        this.faces.push(baseFace);\n\n        // Add radial edges from base center to base vertices\n        for (let i = 0; i < segments; i++) {\n            this.edges.push([baseCenter, 2 + i]);\n        }\n\n        this.generateUVCoordinates();\n    }\n\n    /**\n     * Create a cylinder mesh\n     * @param {number} radius - Radius of the cylinder\n     * @param {number} height - Height of the cylinder\n     * @param {number} segments - Number of segments around the circumference\n     */\n    createCylinder(radius = 100, height = 150, segments = 16) {\n        this.vertices = [];\n        this.edges = [];\n        this.faces = [];\n\n        const h = height / 2;\n\n        // Bottom vertices (circle in XY plane at Z = -h)\n        for (let i = 0; i < segments; i++) {\n            const theta = (i / segments) * Math.PI * 2;\n            const x = Math.cos(theta) * radius;\n            const y = Math.sin(theta) * radius;\n            this.vertices.push(new Vector3(x, y, -h));\n        }\n\n        // Top vertices (circle in XY plane at Z = h)\n        for (let i = 0; i < segments; i++) {\n            const theta = (i / segments) * Math.PI * 2;\n            const x = Math.cos(theta) * radius;\n            const y = Math.sin(theta) * radius;\n            this.vertices.push(new Vector3(x, y, h));\n        }\n\n        // Create bottom face (winding CCW from below)\n        const bottomFace = [];\n        for (let i = 0; i < segments; i++) {\n            bottomFace.push(i);\n        }\n        bottomFace.reverse();\n        this.faces.push(bottomFace);\n\n        // Create top face (winding CCW from above)\n        const topFace = [];\n        for (let i = 0; i < segments; i++) {\n            topFace.push(segments + i);\n        }\n        this.faces.push(topFace);\n\n        // Create side faces (quads, CCW from outside)\n        for (let i = 0; i < segments; i++) {\n            const next = (i + 1) % segments;\n            const bottomCurrent = i;\n            const bottomNext = next;\n            const topCurrent = segments + i;\n            const topNext = segments + next;\n\n            // Quad: bottom-current -> bottom-next -> top-next -> top-current (CCW)\n            this.faces.push([bottomCurrent, bottomNext, topNext, topCurrent]);\n\n            // Create edges\n            this.edges.push([bottomCurrent, bottomNext]);\n            this.edges.push([topCurrent, topNext]);\n            this.edges.push([bottomCurrent, topCurrent]);\n        }\n\n        this.generateUVCoordinates();\n    }\n\n    /**\n     * Create an icosahedron mesh (20-faced polyhedron)\n     * @param {number} size - Size of the icosahedron\n     */\n    createIcosahedron(size = 100) {\n        this.vertices = [];\n        this.edges = [];\n        this.faces = [];\n\n        const phi = (1 + Math.sqrt(5)) / 2; // Golden ratio\n        const s = size / Math.sqrt(phi * phi + 1);\n\n        // Generate vertices using golden ratio\n        const vertexData = [\n            [-1, phi, 0], [1, phi, 0], [-1, -phi, 0], [1, -phi, 0],\n            [0, -1, phi], [0, 1, phi], [0, -1, -phi], [0, 1, -phi],\n            [phi, 0, -1], [phi, 0, 1], [-phi, 0, -1], [-phi, 0, 1]\n        ];\n\n        for (const v of vertexData) {\n            this.vertices.push(new Vector3(v[0] * s, v[1] * s, v[2] * s));\n        }\n\n        // Define faces (20 triangular faces)\n        const faceData = [\n            [0, 11, 5], [0, 5, 1], [0, 1, 7], [0, 7, 10], [0, 10, 11],\n            [1, 5, 9], [5, 11, 4], [11, 10, 2], [10, 7, 6], [7, 1, 8],\n            [3, 9, 4], [3, 4, 2], [3, 2, 6], [3, 6, 8], [3, 8, 9],\n            [4, 9, 5], [2, 4, 11], [6, 2, 10], [8, 6, 7], [9, 8, 1]\n        ];\n\n        this.faces = faceData;\n\n        // Generate edges from faces\n        const edgeSet = new Set();\n        for (const face of this.faces) {\n            for (let i = 0; i < face.length; i++) {\n                const a = Math.min(face[i], face[(i + 1) % face.length]);\n                const b = Math.max(face[i], face[(i + 1) % face.length]);\n                edgeSet.add(`${a},${b}`);\n            }\n        }\n\n        for (const edge of edgeSet) {\n            const [a, b] = edge.split(',').map(Number);\n            this.edges.push([a, b]);\n        }\n\n        // Regenerate UV coordinates after changing mesh data\n        this.generateUVCoordinates();\n    }\n\n    /**\n     * Create a subdivided cube (quad cube)\n     * @param {number} size - Size of the cube\n     * @param {number} subdivisions - Number of subdivisions per face\n     */\n    createQuadCube(size = 100, subdivisions = 2) {\n        this.vertices = [];\n        this.edges = [];\n        this.faces = [];\n\n        const s = size / 2;\n\n        // Helper function to add a subdivided face with proper winding\n        const addSubdividedFace = (corners, reverseWinding = false) => {\n            const vertexOffset = this.vertices.length;\n\n            // corners is [c0, c1, c2, c3] - corner order determines face orientation\n            const [c0, c1, c2, c3] = corners;\n\n            // Generate vertices for this face\n            for (let i = 0; i <= subdivisions; i++) {\n                for (let j = 0; j <= subdivisions; j++) {\n                    const u = i / subdivisions;\n                    const v = j / subdivisions;\n\n                    // Bilinear interpolation\n                    const vertex = new Vector3(\n                        c0.x * (1 - u) * (1 - v) + c1.x * u * (1 - v) + c2.x * u * v + c3.x * (1 - u) * v,\n                        c0.y * (1 - u) * (1 - v) + c1.y * u * (1 - v) + c2.y * u * v + c3.y * (1 - u) * v,\n                        c0.z * (1 - u) * (1 - v) + c1.z * u * (1 - v) + c2.z * u * v + c3.z * (1 - u) * v\n                    );\n                    this.vertices.push(vertex);\n                }\n            }\n\n            // Generate faces with proper winding (CCW from outside)\n            for (let i = 0; i < subdivisions; i++) {\n                for (let j = 0; j < subdivisions; j++) {\n                    const tl = vertexOffset + i * (subdivisions + 1) + j;\n                    const tr = tl + 1;\n                    const bl = tl + (subdivisions + 1);\n                    const br = bl + 1;\n\n                    if (reverseWinding) {\n                        // Reverse winding: tl -> tr -> br -> bl\n                        this.faces.push([tl, tr, br]);\n                        this.faces.push([tl, br, bl]);\n                    } else {\n                        // Normal CCW winding from outside: tl -> bl -> br -> tr\n                        this.faces.push([tl, bl, br]);\n                        this.faces.push([tl, br, tr]);\n                    }\n                }\n            }\n        };\n\n        // Front face (+X) - CCW from outside\n        addSubdividedFace([\n            new Vector3(s, -s, -s), // bottom-left\n            new Vector3(s, s, -s),  // bottom-right\n            new Vector3(s, s, s),   // top-right\n            new Vector3(s, -s, s)   // top-left\n        ], false);\n\n        // Back face (-X) - CCW from outside\n        addSubdividedFace([\n            new Vector3(-s, s, -s),  // bottom-right (from back view)\n            new Vector3(-s, -s, -s), // bottom-left\n            new Vector3(-s, -s, s),  // top-left\n            new Vector3(-s, s, s)    // top-right\n        ], false);\n\n        // Right face (+Y) - CCW from outside\n        addSubdividedFace([\n            new Vector3(s, s, -s),   // bottom-front\n            new Vector3(-s, s, -s),  // bottom-back\n            new Vector3(-s, s, s),   // top-back\n            new Vector3(s, s, s)     // top-front\n        ], false);\n\n        // Left face (-Y) - CCW from outside\n        addSubdividedFace([\n            new Vector3(-s, -s, -s), // bottom-back (from left view)\n            new Vector3(s, -s, -s),  // bottom-front\n            new Vector3(s, -s, s),   // top-front\n            new Vector3(-s, -s, s)   // top-back\n        ], false);\n\n        // Top face (+Z) - CCW from outside\n        addSubdividedFace([\n            new Vector3(-s, -s, s), // back-left\n            new Vector3(s, -s, s),  // front-left\n            new Vector3(s, s, s),   // front-right\n            new Vector3(-s, s, s)   // back-right\n        ], false);\n\n        // Bottom face (-Z) - CCW from outside\n        addSubdividedFace([\n            new Vector3(s, -s, -s),  // front-left (from below)\n            new Vector3(-s, -s, -s), // back-left\n            new Vector3(-s, s, -s),  // back-right\n            new Vector3(s, s, -s)    // front-right\n        ], false);\n\n        // Generate edges from faces\n        const edgeSet = new Set();\n        for (const face of this.faces) {\n            for (let i = 0; i < face.length; i++) {\n                const a = Math.min(face[i], face[(i + 1) % face.length]);\n                const b = Math.max(face[i], face[(i + 1) % face.length]);\n                edgeSet.add(`${a},${b}`);\n            }\n        }\n\n        for (const edge of edgeSet) {\n            const [a, b] = edge.split(',').map(Number);\n            this.edges.push([a, b]);\n        }\n\n        this.generateUVCoordinates();\n    }\n\n    /**\n     * Create a capsule mesh (cylinder with hemisphere caps)\n     * @param {number} radius - Radius of the capsule\n     * @param {number} height - Height of the cylindrical section\n     * @param {number} segments - Number of segments\n     */\n    createCapsule(radius = 50, height = 150, segments = 16) {\n        this.vertices = [];\n        this.edges = [];\n        this.faces = [];\n\n        const h = height / 2;\n        const rings = Math.floor(segments / 2);\n\n        // Top hemisphere (Z > h)\n        for (let lat = 0; lat <= rings; lat++) {\n            const theta = (lat / rings) * (Math.PI / 2);\n            const sinTheta = Math.sin(theta);\n            const cosTheta = Math.cos(theta);\n\n            for (let lon = 0; lon <= segments; lon++) {\n                const phi = (lon / segments) * Math.PI * 2;\n                const sinPhi = Math.sin(phi);\n                const cosPhi = Math.cos(phi);\n\n                const x = radius * sinTheta * cosPhi;\n                const y = radius * sinTheta * sinPhi;\n                const z = h + radius * cosTheta;\n\n                this.vertices.push(new Vector3(x, y, z));\n            }\n        }\n\n        // Cylindrical middle section - top ring (at Z = h)\n        for (let lon = 0; lon <= segments; lon++) {\n            const phi = (lon / segments) * Math.PI * 2;\n            const sinPhi = Math.sin(phi);\n            const cosPhi = Math.cos(phi);\n\n            const x = radius * cosPhi;\n            const y = radius * sinPhi;\n            const z = h;\n\n            this.vertices.push(new Vector3(x, y, z));\n        }\n\n        // Cylindrical middle section - bottom ring (at Z = -h)\n        for (let lon = 0; lon <= segments; lon++) {\n            const phi = (lon / segments) * Math.PI * 2;\n            const sinPhi = Math.sin(phi);\n            const cosPhi = Math.cos(phi);\n\n            const x = radius * cosPhi;\n            const y = radius * sinPhi;\n            const z = -h;\n\n            this.vertices.push(new Vector3(x, y, z));\n        }\n\n        // Bottom hemisphere (Z < -h)\n        for (let lat = 0; lat <= rings; lat++) {\n            const theta = (lat / rings) * (Math.PI / 2);\n            const sinTheta = Math.sin(theta);\n            const cosTheta = Math.cos(theta);\n\n            for (let lon = 0; lon <= segments; lon++) {\n                const phi = (lon / segments) * Math.PI * 2;\n                const sinPhi = Math.sin(phi);\n                const cosPhi = Math.cos(phi);\n\n                const x = radius * sinTheta * cosPhi;\n                const y = radius * sinTheta * sinPhi;\n                const z = -h - radius * cosTheta;\n\n                this.vertices.push(new Vector3(x, y, z));\n            }\n        }\n\n        // Generate faces\n        const topHemisphereOffset = 0;\n        const topRingOffset = (rings + 1) * (segments + 1);\n        const bottomRingOffset = topRingOffset + (segments + 1);\n        const bottomHemisphereOffset = bottomRingOffset + (segments + 1);\n\n        // Top hemisphere faces (CCW from outside)\n        for (let lat = 0; lat < rings; lat++) {\n            for (let lon = 0; lon < segments; lon++) {\n                const first = topHemisphereOffset + lat * (segments + 1) + lon;\n                const second = first + segments + 1;\n\n                this.faces.push([first, second, first + 1]);\n                this.faces.push([first + 1, second, second + 1]);\n            }\n        }\n\n        // Cylindrical middle section (CCW from outside) - FIXED WINDING\n        for (let lon = 0; lon < segments; lon++) {\n            const topCurrent = topRingOffset + lon;\n            const topNext = topRingOffset + lon + 1;\n            const bottomCurrent = bottomRingOffset + lon;\n            const bottomNext = bottomRingOffset + lon + 1;\n\n            // Two triangles forming a quad (CCW from outside)\n            this.faces.push([topCurrent, bottomCurrent, bottomNext]);\n            this.faces.push([topCurrent, bottomNext, topNext]);\n        }\n\n        // Bottom hemisphere faces (CCW from outside)\n        for (let lat = 0; lat < rings; lat++) {\n            for (let lon = 0; lon < segments; lon++) {\n                const first = bottomHemisphereOffset + lat * (segments + 1) + lon;\n                const second = first + segments + 1;\n\n                this.faces.push([first, first + 1, second]);\n                this.faces.push([second, first + 1, second + 1]);\n            }\n        }\n\n        // Generate edges\n        const edgeSet = new Set();\n        for (const face of this.faces) {\n            for (let i = 0; i < face.length; i++) {\n                const a = Math.min(face[i], face[(i + 1) % face.length]);\n                const b = Math.max(face[i], face[(i + 1) % face.length]);\n                edgeSet.add(`${a},${b}`);\n            }\n        }\n\n        for (const edge of edgeSet) {\n            const [a, b] = edge.split(',').map(Number);\n            this.edges.push([a, b]);\n        }\n\n        this.generateUVCoordinates();\n    }\n\n    /**\n     * Create a prism mesh (regular polygon extruded)\n     * @param {number} sides - Number of sides\n     * @param {number} radius - Radius of the base\n     * @param {number} height - Height of the prism\n     */\n    createPrism(sides = 6, radius = 100, height = 150) {\n        this.vertices = [];\n        this.edges = [];\n        this.faces = [];\n\n        const h = height / 2;\n\n        // Top vertices (circle in XY plane at Z = h)\n        for (let i = 0; i < sides; i++) {\n            const theta = (i / sides) * Math.PI * 2;\n            const x = Math.cos(theta) * radius;\n            const y = Math.sin(theta) * radius;\n            this.vertices.push(new Vector3(x, y, h));\n        }\n\n        // Bottom vertices (circle in XY plane at Z = -h)\n        for (let i = 0; i < sides; i++) {\n            const theta = (i / sides) * Math.PI * 2;\n            const x = Math.cos(theta) * radius;\n            const y = Math.sin(theta) * radius;\n            this.vertices.push(new Vector3(x, y, -h));\n        }\n\n        // Top face (CCW from above)\n        const topFace = [];\n        for (let i = 0; i < sides; i++) {\n            topFace.push(i);\n        }\n        this.faces.push(topFace);\n\n        // Bottom face (CCW from below)\n        const bottomFace = [];\n        for (let i = 0; i < sides; i++) {\n            bottomFace.push(sides + i);\n        }\n        bottomFace.reverse();\n        this.faces.push(bottomFace);\n\n        // Side faces (quads, CCW from outside)\n        for (let i = 0; i < sides; i++) {\n            const next = (i + 1) % sides;\n            const topCurrent = i;\n            const topNext = next;\n            const bottomCurrent = sides + i;\n            const bottomNext = sides + next;\n\n            // Quad face (CCW from outside): topCurrent -> bottomCurrent -> bottomNext -> topNext\n            this.faces.push([topCurrent, bottomCurrent, bottomNext, topNext]);\n\n            // Edges\n            this.edges.push([topCurrent, topNext]);\n            this.edges.push([bottomCurrent, bottomNext]);\n            this.edges.push([topCurrent, bottomCurrent]);\n        }\n\n        this.generateUVCoordinates();\n    }\n\n    /**\n     * Create a tetrahedron mesh (4-sided pyramid)\n     * @param {number} size - Size of the tetrahedron\n     */\n    createTetrahedron(size = 100) {\n        const s = size / Math.sqrt(2);\n\n        // Create vertices in X=forward, Y=right, Z=up system\n        this.vertices = [\n            new Vector3(s, s, s),    // 0: front-right-top\n            new Vector3(s, -s, -s),  // 1: front-left-bottom\n            new Vector3(-s, s, -s),  // 2: back-right-bottom\n            new Vector3(-s, -s, s)   // 3: back-left-top\n        ];\n\n        this.edges = [\n            [0, 1], [0, 2], [0, 3],\n            [1, 2], [1, 3], [2, 3]\n        ];\n\n        // All faces with CCW winding from outside\n        this.faces = [\n            [0, 1, 2], // Front-right face\n            [0, 3, 1], // Front-top face\n            [0, 2, 3], // Right-top face\n            [3, 2, 1]  // Bottom-back face\n        ];\n\n        this.generateUVCoordinates();\n    }\n\n    /**\n      * Create a subdivided quad (plane with subdivisions)\n      * @param {number} width - Width of the quad\n      * @param {number} height - Height of the quad\n      * @param {number} subdivisionsX - Number of subdivisions along X axis\n      * @param {number} subdivisionsY - Number of subdivisions along Y axis\n      */\n    createQuad(width = 200, height = 200, subdivisionsX = 4, subdivisionsY = 4) {\n        this.vertices = [];\n        this.edges = [];\n        this.faces = [];\n\n        const halfWidth = width / 2;\n        const halfHeight = height / 2;\n\n        // Generate vertices (ensure they lie flat on XY plane)\n        for (let y = 0; y <= subdivisionsY; y++) {\n            for (let x = 0; x <= subdivisionsX; x++) {\n                const px = (x / subdivisionsX) * width - halfWidth;\n                const py = (y / subdivisionsY) * height - halfHeight;\n                // Force Z to 0 for flat plane\n                this.vertices.push(new Vector3(px, py, 0));\n            }\n        }\n\n        // Generate faces and edges\n        for (let y = 0; y < subdivisionsY; y++) {\n            for (let x = 0; x < subdivisionsX; x++) {\n                const topLeft = y * (subdivisionsX + 1) + x;\n                const topRight = topLeft + 1;\n                const bottomLeft = (y + 1) * (subdivisionsX + 1) + x;\n                const bottomRight = bottomLeft + 1;\n\n                // Create quad face (counter-clockwise from front: top-left, top-right, bottom-right, bottom-left)\n                this.faces.push([topLeft, topRight, bottomRight, bottomLeft]);\n\n                // Create edges\n                this.edges.push([topLeft, topRight]);\n                this.edges.push([topLeft, bottomLeft]);\n                if (x === subdivisionsX - 1) {\n                    this.edges.push([topRight, bottomRight]);\n                }\n                if (y === subdivisionsY - 1) {\n                    this.edges.push([bottomLeft, bottomRight]);\n                }\n            }\n        }\n\n        // Regenerate UV coordinates after changing mesh data\n        this.generateUVCoordinates();\n    }\n\n    /**\n      * Create a simple plane (single quad)\n      * @param {number} size - Size of the plane\n      */\n    createPlane(size = 200) {\n        const s = size / 2;\n\n        // Plane in XY plane (perpendicular to Z axis)\n        this.vertices = [\n            new Vector3(-s, -s, 0), // back-left\n            new Vector3(-s, s, 0),  // back-right\n            new Vector3(s, s, 0),   // front-right\n            new Vector3(s, -s, 0)   // front-left\n        ];\n\n        this.edges = [\n            [0, 1], [1, 2], [2, 3], [3, 0]\n        ];\n\n        // Quad face (CCW from front/above)\n        this.faces = [\n            [3, 2, 1, 0]\n        ];\n\n        this.generateUVCoordinates();\n    }\n\n    /**\n     * Create a custom editable model (starts as a sphere with vertex handles)\n     * @param {number} radius - Initial radius\n     * @param {number} detail - Detail level\n     */\n    createCustomModel(radius = 100, detail = 6) {\n        // Start with a sphere as the base\n        this.createSphere(radius, detail);\n\n        // Mark this as a custom model\n        this.isCustomModel = true;\n\n        // Initialize vertex selection system\n        this.selectedVertexIndex = -1;\n        this.vertexHandleSize = 8;\n        this.isDraggingVertex = false;\n\n        // Store original vertices for reset functionality\n        this.originalVertices = this.vertices.map(v => v.clone());\n    }\n\n    /**\n      * Update the mesh shape based on current shape property\n      */\n    updateShape() {\n        // Clear existing mesh data before creating new shape\n        this.vertices = [];\n        this.edges = [];\n        this.faces = [];\n        this.uvCoordinates = [];\n\n        // Ensure _shape is set\n        if (!this._shape) {\n            this._shape = \"cube\";\n        }\n\n        switch (this._shape) {\n            case \"cube\":\n                this.createCube(this.cubeSize);\n                break;\n            case \"pyramid\":\n                this.createPyramid(this.pyramidBaseSize, this.pyramidHeight);\n                break;\n            case \"sphere\":\n                this.createSphere(this.sphereRadius, this.sphereDetail);\n                break;\n            case \"octahedron\":\n                this.createOctahedron(this.octahedronSize);\n                break;\n            case \"torus\":\n                this.createTorus(this.torusMajorRadius, this.torusMinorRadius, this.torusMajorSegments, this.torusMinorSegments);\n                break;\n            case \"cone\":\n                this.createCone(this.coneRadius, this.coneHeight, this.coneSegments);\n                break;\n            case \"cylinder\":\n                this.createCylinder(this.cylinderRadius, this.cylinderHeight, this.cylinderSegments);\n                break;\n            case \"icosahedron\":\n                this.createIcosahedron(this.icosahedronSize);\n                break;\n            case \"quad\":\n                this.createQuad(this.quadWidth, this.quadHeight, this.quadSubdivisionsX, this.quadSubdivisionsY);\n                break;\n            case \"plane\":\n                this.createPlane(this.planeSize);\n                break;\n            case \"quadCube\":\n                this.createQuadCube(this.quadCubeSize, this.quadCubeSubdivisions);\n                break;\n            case \"capsule\":\n                this.createCapsule(this.capsuleRadius, this.capsuleHeight, this.capsuleSegments);\n                break;\n            case \"prism\":\n                this.createPrism(this.prismSides, this.prismRadius, this.prismHeight);\n                break;\n            case \"tetrahedron\":\n                this.createTetrahedron(this.tetrahedronSize);\n                break;\n            case \"custom\":\n                this.createCustomModel(this.sphereRadius, this.sphereDetail);\n                break;\n            default:\n                this.createCube(this.cubeSize);\n        }\n\n        // Ensure UV coordinates are generated for the new shape\n        if (this.vertices.length > 0) {\n            this.generateUVCoordinates();\n        }\n    }\n\n    /**\n     * Create a custom mesh from vertices, edges, and faces\n     * @param {Array<Vector3>} vertices - Array of 3D points\n     * @param {Array<Array<number>>} edges - Array of vertex index pairs\n     * @param {Array<Array<number>>} faces - Array of vertex index arrays\n     */\n    setMeshData(vertices, edges, faces) {\n        this.vertices = vertices;\n        this.edges = edges || [];\n        this.faces = faces || [];\n\n        // Regenerate UV coordinates after changing mesh data\n        this.generateUVCoordinates();\n    }\n\n    drawGizmos(ctx) {\n        ctx.save();\n        ctx.translate(this.gameObject.position.x, this.gameObject.position.y);\n        ctx.rotate((this.gameObject.angle * Math.PI) / 180);\n        ctx.scale(this.gameObject.scale.x, this.gameObject.scale.y);\n        this.draw2DVisualization(ctx);\n        ctx.restore();\n    }\n\n    /**\n     * Draw the mesh to the canvas\n     * @param {CanvasRenderingContext2D} ctx - The canvas context to draw on\n     */\n    draw(ctx) {\n        // Find an active camera\n        const camera = this.findActiveCamera();\n        if (!camera) {\n            return;\n        }\n\n        // Use render texture method if camera supports it\n        if (camera.getRenderTextureContext && camera.render3D) {\n            this.drawToRenderTexture(camera.getRenderTextureContext(), camera);\n        } else {\n            // Fallback to direct drawing\n            this.drawDirect(ctx, camera);\n        }\n\n        // Draw vertex handles for custom models\n        if (this.isCustomModel && this._shape === \"custom\") {\n            this.drawVertexHandles(ctx, camera);\n        }\n    }\n\n    /**\n     * Draw a 2D visualization of the mesh shape when no camera is available\n     * @param {CanvasRenderingContext2D} ctx - The canvas context\n     */\n    draw2DVisualization(ctx) {\n        ctx.strokeStyle = this.wireframeColor;\n        ctx.fillStyle = this.faceColor;\n        ctx.lineWidth = 2;\n\n        switch (this._shape) {\n            case \"cube\":\n                this.draw2DCube(ctx);\n                break;\n            case \"pyramid\":\n                this.draw2DPyramid(ctx);\n                break;\n            case \"sphere\":\n                this.draw2DSphere(ctx);\n                break;\n            case \"octahedron\":\n                this.draw2DOctahedron(ctx);\n                break;\n            case \"torus\":\n                this.draw2DTorus(ctx);\n                break;\n            case \"cone\":\n                this.draw2DCone(ctx);\n                break;\n            case \"cylinder\":\n                this.draw2DCylinder(ctx);\n                break;\n            case \"icosahedron\":\n                this.draw2DIcosahedron(ctx);\n                break;\n            case \"quad\":\n            case \"plane\":\n                this.draw2DPlane(ctx);\n                break;\n            case \"custom\":\n                this.draw2DCustom(ctx);\n                break;\n            default:\n                this.drawPlaceholder(ctx);\n        }\n\n        if (this._shape === \"quadCube\") {\n            this.draw2DCube(ctx); // Reuse cube visualization\n        }\n\n        if (this._shape === \"capsule\") {\n            this.draw2DCapsule(ctx);\n        }\n\n        if (this._shape === \"prism\") {\n            this.draw2DPrism(ctx);\n        }\n\n        if (this._shape === \"tetrahedron\") {\n            this.draw2DTetrahedron(ctx);\n        }\n    }\n\n    /**\n     * Draw 2D cube visualization - Top-down isometric view\n     */\n    draw2DCube(ctx) {\n        const s = this.cubeSize / 2;\n        const isoOffset = s * 0.4; // Isometric offset for depth\n\n        // Draw top face (visible from top)\n        ctx.fillStyle = this.faceColor;\n        ctx.beginPath();\n        ctx.moveTo(0, -s - isoOffset); // Top point\n        ctx.lineTo(s, -isoOffset);      // Right point\n        ctx.lineTo(0, s - isoOffset);   // Bottom point\n        ctx.lineTo(-s, -isoOffset);     // Left point\n        ctx.closePath();\n        ctx.fill();\n        ctx.stroke();\n\n        // Draw front face (front side)\n        ctx.fillStyle = this.faceColor;\n        ctx.globalAlpha = 0.8;\n        ctx.beginPath();\n        ctx.moveTo(-s, -isoOffset);  // Top left\n        ctx.lineTo(s, -isoOffset);   // Top right\n        ctx.lineTo(s, s);            // Bottom right\n        ctx.lineTo(-s, s);           // Bottom left\n        ctx.closePath();\n        ctx.fill();\n        ctx.stroke();\n\n        // Draw right face (right side)\n        ctx.globalAlpha = 0.6;\n        ctx.beginPath();\n        ctx.moveTo(s, -isoOffset);       // Top\n        ctx.lineTo(0, s - isoOffset);    // Bottom inner\n        ctx.lineTo(0, s + s - isoOffset); // Bottom outer\n        ctx.lineTo(s, s);                // Front bottom\n        ctx.closePath();\n        ctx.fill();\n        ctx.stroke();\n\n        ctx.globalAlpha = 1.0;\n    }\n\n    /**\n     * Draw 2D pyramid visualization - Top-down view\n     */\n    draw2DPyramid(ctx) {\n        const base = this.pyramidBaseSize / 2;\n        const isoOffset = this.pyramidHeight * 0.3; // Depth based on height\n\n        // Draw apex point (top of pyramid)\n        ctx.fillStyle = this.faceColor;\n        ctx.globalAlpha = 0.9;\n\n        // Draw front faces\n        ctx.beginPath();\n        ctx.moveTo(0, -isoOffset); // Apex\n        ctx.lineTo(-base, base);   // Bottom left\n        ctx.lineTo(base, base);    // Bottom right\n        ctx.closePath();\n        ctx.fill();\n        ctx.stroke();\n\n        // Draw back face\n        ctx.globalAlpha = 0.6;\n        ctx.beginPath();\n        ctx.moveTo(0, -isoOffset);  // Apex\n        ctx.lineTo(-base, base);    // Left\n        ctx.lineTo(-base, -base);   // Back left\n        ctx.closePath();\n        ctx.fill();\n        ctx.stroke();\n\n        ctx.globalAlpha = 0.7;\n        ctx.beginPath();\n        ctx.moveTo(0, -isoOffset);  // Apex\n        ctx.lineTo(base, base);     // Right\n        ctx.lineTo(base, -base);    // Back right\n        ctx.closePath();\n        ctx.fill();\n        ctx.stroke();\n\n        // Draw base square\n        ctx.globalAlpha = 0.5;\n        ctx.strokeRect(-base, -base, this.pyramidBaseSize, this.pyramidBaseSize);\n\n        ctx.globalAlpha = 1.0;\n    }\n\n    /**\n     * Draw 2D sphere visualization - Top-down view (equator circle)\n     */\n    draw2DSphere(ctx) {\n        // Draw the sphere as a circle from top-down (equator view)\n        ctx.fillStyle = this.faceColor;\n        ctx.globalAlpha = 0.7;\n        ctx.beginPath();\n        ctx.arc(0, 0, this.sphereRadius / 2, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.globalAlpha = 1.0;\n        ctx.stroke();\n\n        // Draw latitude lines (concentric circles)\n        ctx.strokeStyle = this.wireframeColor;\n        ctx.globalAlpha = 0.3;\n        const segments = Math.min(this.sphereDetail, 8);\n        for (let i = 1; i < segments; i++) {\n            const radius = (i / segments) * (this.sphereRadius / 2);\n            ctx.beginPath();\n            ctx.arc(0, 0, radius, 0, Math.PI * 2);\n            ctx.stroke();\n        }\n\n        // Draw longitude lines (cross)\n        ctx.beginPath();\n        ctx.moveTo(-this.sphereRadius / 2, 0);\n        ctx.lineTo(this.sphereRadius / 2, 0);\n        ctx.moveTo(0, -this.sphereRadius / 2);\n        ctx.lineTo(0, this.sphereRadius / 2);\n        ctx.stroke();\n\n        ctx.globalAlpha = 1.0;\n    }\n\n    /**\n     * Draw 2D octahedron visualization - Top-down view (diamond shape at equator)\n     */\n    draw2DOctahedron(ctx) {\n        const s = this.octahedronSize;\n\n        // Draw equator diamond (middle cross-section)\n        ctx.fillStyle = this.faceColor;\n        ctx.globalAlpha = 0.7;\n        ctx.beginPath();\n        ctx.moveTo(0, -s);\n        ctx.lineTo(s, 0);\n        ctx.lineTo(0, s);\n        ctx.lineTo(-s, 0);\n        ctx.closePath();\n        ctx.fill();\n        ctx.stroke();\n\n        // Draw inner lines to show 3D structure\n        ctx.strokeStyle = this.wireframeColor;\n        ctx.globalAlpha = 0.4;\n        ctx.beginPath();\n        ctx.moveTo(-s, 0);\n        ctx.lineTo(s, 0);\n        ctx.moveTo(0, -s);\n        ctx.lineTo(0, s);\n        ctx.stroke();\n\n        ctx.globalAlpha = 1.0;\n    }\n\n    /**\n     * Draw 2D torus visualization - Top-down view (donut shape)\n     */\n    draw2DTorus(ctx) {\n        const major = this.torusMajorRadius;\n        const minor = this.torusMinorRadius;\n\n        // Fill the ring area\n        ctx.fillStyle = this.faceColor;\n        ctx.globalAlpha = 0.7;\n        ctx.beginPath();\n        ctx.arc(0, 0, major + minor, 0, Math.PI * 2);\n        ctx.arc(0, 0, major - minor, 0, Math.PI * 2, true);\n        ctx.fill();\n\n        ctx.globalAlpha = 1.0;\n\n        // Outer circle\n        ctx.strokeStyle = this.wireframeColor;\n        ctx.beginPath();\n        ctx.arc(0, 0, major + minor, 0, Math.PI * 2);\n        ctx.stroke();\n\n        // Inner circle\n        ctx.beginPath();\n        ctx.arc(0, 0, major - minor, 0, Math.PI * 2);\n        ctx.stroke();\n\n        // Draw cross lines to show tube detail\n        ctx.globalAlpha = 0.3;\n        const segments = Math.min(this.torusMinorSegments, 8);\n        for (let i = 0; i < segments; i++) {\n            const angle = (i / segments) * Math.PI * 2;\n            const x1 = Math.cos(angle) * (major - minor);\n            const y1 = Math.sin(angle) * (major - minor);\n            const x2 = Math.cos(angle) * (major + minor);\n            const y2 = Math.sin(angle) * (major + minor);\n\n            ctx.beginPath();\n            ctx.moveTo(x1, y1);\n            ctx.lineTo(x2, y2);\n            ctx.stroke();\n        }\n\n        ctx.globalAlpha = 1.0;\n    }\n\n    /**\n     * Draw 2D cone visualization - Top-down view showing base circle and apex point\n     */\n    draw2DCone(ctx) {\n        const r = this.coneRadius;\n        const apexOffset = this.coneHeight * 0.2; // Visual offset for apex\n\n        // Draw base circle\n        ctx.fillStyle = this.faceColor;\n        ctx.globalAlpha = 0.6;\n        ctx.beginPath();\n        ctx.arc(0, 0, r, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.globalAlpha = 1.0;\n        ctx.stroke();\n\n        // Draw lines from apex to base edge (showing cone structure)\n        ctx.strokeStyle = this.wireframeColor;\n        ctx.globalAlpha = 0.5;\n        const segments = 8;\n        for (let i = 0; i < segments; i++) {\n            const angle = (i / segments) * Math.PI * 2;\n            const x = Math.cos(angle) * r;\n            const y = Math.sin(angle) * r;\n\n            ctx.beginPath();\n            ctx.moveTo(0, -apexOffset); // Apex point\n            ctx.lineTo(x, y);           // Base edge\n            ctx.stroke();\n        }\n\n        // Draw apex point\n        ctx.globalAlpha = 1.0;\n        ctx.fillStyle = this.wireframeColor;\n        ctx.beginPath();\n        ctx.arc(0, -apexOffset, 3, 0, Math.PI * 2);\n        ctx.fill();\n    }\n\n    /**\n     * Draw 2D cylinder visualization - Top-down view showing circular cross-section\n     */\n    draw2DCylinder(ctx) {\n        const r = this.cylinderRadius;\n\n        // Draw cylinder as a circle from top (showing the circular cross-section)\n        ctx.fillStyle = this.faceColor;\n        ctx.globalAlpha = 0.7;\n        ctx.beginPath();\n        ctx.arc(0, 0, r, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.globalAlpha = 1.0;\n        ctx.stroke();\n\n        // Draw lines to indicate cylindrical segments\n        ctx.strokeStyle = this.wireframeColor;\n        ctx.globalAlpha = 0.3;\n        const segments = Math.min(this.cylinderSegments, 8);\n        for (let i = 0; i < segments; i++) {\n            const angle = (i / segments) * Math.PI * 2;\n            const x = Math.cos(angle) * r;\n            const y = Math.sin(angle) * r;\n\n            ctx.beginPath();\n            ctx.moveTo(0, 0);\n            ctx.lineTo(x, y);\n            ctx.stroke();\n        }\n\n        // Draw concentric circles to show height\n        ctx.globalAlpha = 0.2;\n        for (let i = 1; i <= 2; i++) {\n            ctx.beginPath();\n            ctx.arc(0, 0, (i / 3) * r, 0, Math.PI * 2);\n            ctx.stroke();\n        }\n\n        ctx.globalAlpha = 1.0;\n    }\n\n    /**\n     * Draw 2D icosahedron visualization - Top-down view (pentagonal cross-section)\n     */\n    draw2DIcosahedron(ctx) {\n        const s = this.icosahedronSize;\n        const segments = 5; // Pentagon for icosahedron\n\n        // Draw pentagonal cross-section\n        ctx.fillStyle = this.faceColor;\n        ctx.globalAlpha = 0.7;\n        ctx.beginPath();\n        for (let i = 0; i < segments; i++) {\n            const angle = (i / segments) * Math.PI * 2 - Math.PI / 2;\n            const x = Math.cos(angle) * s;\n            const y = Math.sin(angle) * s;\n            if (i === 0) ctx.moveTo(x, y);\n            else ctx.lineTo(x, y);\n        }\n        ctx.closePath();\n        ctx.fill();\n        ctx.globalAlpha = 1.0;\n        ctx.stroke();\n\n        // Draw inner star pattern\n        ctx.strokeStyle = this.wireframeColor;\n        ctx.globalAlpha = 0.4;\n        for (let i = 0; i < segments; i++) {\n            const angle1 = (i / segments) * Math.PI * 2 - Math.PI / 2;\n            const angle2 = ((i + 2) % segments / segments) * Math.PI * 2 - Math.PI / 2;\n            const x1 = Math.cos(angle1) * s;\n            const y1 = Math.sin(angle1) * s;\n            const x2 = Math.cos(angle2) * s;\n            const y2 = Math.sin(angle2) * s;\n\n            ctx.beginPath();\n            ctx.moveTo(x1, y1);\n            ctx.lineTo(x2, y2);\n            ctx.stroke();\n        }\n\n        ctx.globalAlpha = 1.0;\n    }\n\n    /**\n     * Draw 2D capsule visualization\n     */\n    draw2DCapsule(ctx) {\n        const r = this.capsuleRadius;\n        const h = this.capsuleHeight / 2;\n\n        // Draw capsule body (rectangle)\n        ctx.fillStyle = this.faceColor;\n        ctx.globalAlpha = 0.7;\n        ctx.fillRect(-r, -h, r * 2, h * 2);\n        ctx.globalAlpha = 1.0;\n        ctx.strokeRect(-r, -h, r * 2, h * 2);\n\n        // Draw top hemisphere\n        ctx.beginPath();\n        ctx.arc(0, -h, r, 0, Math.PI, true);\n        ctx.fill();\n        ctx.stroke();\n\n        // Draw bottom hemisphere\n        ctx.beginPath();\n        ctx.arc(0, h, r, 0, Math.PI);\n        ctx.fill();\n        ctx.stroke();\n    }\n\n    /**\n     * Draw 2D prism visualization\n     */\n    draw2DPrism(ctx) {\n        const r = this.prismRadius;\n        const sides = this.prismSides;\n\n        // Draw polygon\n        ctx.fillStyle = this.faceColor;\n        ctx.globalAlpha = 0.7;\n        ctx.beginPath();\n        for (let i = 0; i < sides; i++) {\n            const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;\n            const x = Math.cos(angle) * r;\n            const y = Math.sin(angle) * r;\n            if (i === 0) ctx.moveTo(x, y);\n            else ctx.lineTo(x, y);\n        }\n        ctx.closePath();\n        ctx.fill();\n        ctx.globalAlpha = 1.0;\n        ctx.stroke();\n\n        // Draw center lines\n        ctx.strokeStyle = this.wireframeColor;\n        ctx.globalAlpha = 0.3;\n        for (let i = 0; i < sides; i++) {\n            const angle = (i / sides) * Math.PI * 2 - Math.PI / 2;\n            const x = Math.cos(angle) * r;\n            const y = Math.sin(angle) * r;\n            ctx.beginPath();\n            ctx.moveTo(0, 0);\n            ctx.lineTo(x, y);\n            ctx.stroke();\n        }\n        ctx.globalAlpha = 1.0;\n    }\n\n    /**\n     * Draw 2D tetrahedron visualization\n     */\n    draw2DTetrahedron(ctx) {\n        const s = this.tetrahedronSize;\n\n        // Draw triangle from top view\n        ctx.fillStyle = this.faceColor;\n        ctx.globalAlpha = 0.7;\n        ctx.beginPath();\n        ctx.moveTo(0, -s);\n        ctx.lineTo(s * 0.866, s * 0.5);\n        ctx.lineTo(-s * 0.866, s * 0.5);\n        ctx.closePath();\n        ctx.fill();\n        ctx.globalAlpha = 1.0;\n        ctx.stroke();\n\n        // Draw internal lines\n        ctx.strokeStyle = this.wireframeColor;\n        ctx.globalAlpha = 0.4;\n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(0, -s);\n        ctx.moveTo(0, 0);\n        ctx.lineTo(s * 0.866, s * 0.5);\n        ctx.moveTo(0, 0);\n        ctx.lineTo(-s * 0.866, s * 0.5);\n        ctx.stroke();\n        ctx.globalAlpha = 1.0;\n    }\n\n    /**\n     * Draw 2D plane/quad visualization - Top-down view showing full dimensions\n     */\n    draw2DPlane(ctx) {\n        const w = this._shape === \"quad\" ? this.quadWidth / 2 : this.planeSize / 2;\n        const h = this._shape === \"quad\" ? this.quadHeight / 2 : this.planeSize / 2;\n\n        // Draw filled rectangle\n        ctx.fillStyle = this.faceColor;\n        ctx.globalAlpha = 0.7;\n        ctx.fillRect(-w, -h, w * 2, h * 2);\n        ctx.globalAlpha = 1.0;\n        ctx.strokeRect(-w, -h, w * 2, h * 2);\n\n        // Draw subdivision lines for quad\n        if (this._shape === \"quad\") {\n            ctx.strokeStyle = this.wireframeColor;\n            ctx.globalAlpha = 0.3;\n\n            // Vertical lines\n            for (let i = 1; i < this.quadSubdivisionsX; i++) {\n                const x = -w + (i / this.quadSubdivisionsX) * w * 2;\n                ctx.beginPath();\n                ctx.moveTo(x, -h);\n                ctx.lineTo(x, h);\n                ctx.stroke();\n            }\n\n            // Horizontal lines\n            for (let i = 1; i < this.quadSubdivisionsY; i++) {\n                const y = -h + (i / this.quadSubdivisionsY) * h * 2;\n                ctx.beginPath();\n                ctx.moveTo(-w, y);\n                ctx.lineTo(w, y);\n                ctx.stroke();\n            }\n\n            ctx.globalAlpha = 1.0;\n        } else {\n            // Draw center cross for plane\n            ctx.strokeStyle = this.wireframeColor;\n            ctx.globalAlpha = 0.3;\n            ctx.beginPath();\n            ctx.moveTo(-w, 0);\n            ctx.lineTo(w, 0);\n            ctx.moveTo(0, -h);\n            ctx.lineTo(0, h);\n            ctx.stroke();\n            ctx.globalAlpha = 1.0;\n        }\n    }\n\n    /**\n     * Draw 2D custom model visualization - Top-down view with indicator\n     */\n    draw2DCustom(ctx) {\n        // Calculate bounds of custom model\n        let maxDist = 50; // Default\n        if (this.vertices && this.vertices.length > 0) {\n            maxDist = 0;\n            for (const v of this.vertices) {\n                const dist = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);\n                maxDist = Math.max(maxDist, dist);\n            }\n        }\n\n        // Draw bounding circle\n        ctx.strokeStyle = this.wireframeColor;\n        ctx.fillStyle = this.faceColor;\n        ctx.globalAlpha = 0.3;\n        ctx.beginPath();\n        ctx.arc(0, 0, maxDist, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.globalAlpha = 1.0;\n        ctx.stroke();\n\n        // Draw vertex count indicator\n        ctx.fillStyle = '#ffff00';\n        ctx.font = 'bold 12px Arial';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        const vertCount = this.vertices ? this.vertices.length : 0;\n        ctx.fillText(`CUSTOM (${vertCount}v)`, 0, 0);\n    }\n\n    /**\n     * Draw directly to a canvas context (fallback method)\n     * @param {CanvasRenderingContext2D} ctx - The canvas context to draw on\n     * @param {Camera3D} camera - The camera to use for projection\n     */\n    drawDirect(ctx, camera) {\n        const transformedVertices = this.transformVertices();\n        const projectedVertices = transformedVertices.map(vertex =>\n            camera.projectPoint(vertex)\n        );\n\n        // Calculate camera-to-face distance for proper depth sorting\n        const sortedFaces = [...this.faces]\n            .map((face, index) => {\n                // Calculate average depth from camera\n                let avgDepth = 0;\n                let validVerts = 0;\n\n                for (const vertexIndex of face) {\n                    if (vertexIndex < transformedVertices.length) {\n                        const vert = transformedVertices[vertexIndex];\n                        // Distance along camera's forward direction (X-axis)\n                        avgDepth += vert.x;\n                        validVerts++;\n                    }\n                }\n\n                if (validVerts > 0) {\n                    avgDepth /= validVerts;\n                }\n\n                return { face, avgDepth };\n            })\n            .sort((a, b) => a.avgDepth - b.avgDepth) // Sort front-to-back (smaller X = closer)\n            .map(item => item.face);\n\n        // Draw faces in sorted order\n        if (this.renderMode === \"solid\" || this.renderMode === \"both\") {\n            for (const face of sortedFaces) {\n                if (face.length < 3) continue;\n\n                // Check if all vertices are visible\n                const isVisible = face.every(vertexIndex =>\n                    projectedVertices[vertexIndex] !== null &&\n                    vertexIndex < projectedVertices.length\n                );\n                if (!isVisible) continue;\n\n                // Backface culling check\n                const normal = this.calculateFaceNormal(face, transformedVertices);\n                const faceCenter = this.getFaceCenter(face, transformedVertices);\n                const viewDir = camera.position ?\n                    camera.position.clone().subtract(faceCenter).normalize() :\n                    new Vector3(-1, 0, 0); // Default view direction if no camera position\n\n                // If face normal points away from camera, skip it (backface)\n                if (normal.dot(viewDir) < 0) continue;\n\n                const faceColor = this.getMaterialColor(face, transformedVertices, camera);\n\n                ctx.fillStyle = faceColor;\n                ctx.beginPath();\n                ctx.moveTo(projectedVertices[face[0]].x, projectedVertices[face[0]].y);\n\n                for (let i = 1; i < face.length; i++) {\n                    ctx.lineTo(projectedVertices[face[i]].x, projectedVertices[face[i]].y);\n                }\n\n                ctx.closePath();\n                ctx.fill();\n            }\n        }\n\n        // Draw edges\n        if (this.renderMode === \"wireframe\" || this.renderMode === \"both\") {\n            ctx.strokeStyle = this.wireframeColor;\n            ctx.lineWidth = 1;\n\n            for (const [from, to] of this.edges) {\n                if (from >= projectedVertices.length ||\n                    to >= projectedVertices.length ||\n                    projectedVertices[from] === null ||\n                    projectedVertices[to] === null) {\n                    continue;\n                }\n\n                ctx.beginPath();\n                ctx.moveTo(projectedVertices[from].x, projectedVertices[from].y);\n                ctx.lineTo(projectedVertices[to].x, projectedVertices[to].y);\n                ctx.stroke();\n            }\n        }\n\n        if (this.showAxisLines) {\n            this.drawAxisLines(ctx, projectedVertices);\n        }\n    }\n\n    /**\n     * Draw the mesh to a render texture\n     * @param {CanvasRenderingContext2D} ctx - The render texture context\n     * @param {Camera3D} camera - The camera to use for projection\n     */\n    drawToRenderTexture(ctx, camera) {\n        const transformedVertices = this.transformVertices();\n        const projectedVertices = transformedVertices.map(vertex =>\n            camera.projectPoint(vertex)\n        );\n\n        // Calculate camera-to-face distance for proper depth sorting\n        const sortedFaces = [...this.faces]\n            .map((face, index) => {\n                // Calculate average depth from camera\n                let avgDepth = 0;\n                let validVerts = 0;\n\n                for (const vertexIndex of face) {\n                    if (vertexIndex < transformedVertices.length) {\n                        const vert = transformedVertices[vertexIndex];\n                        // Distance along camera's forward direction (X-axis)\n                        avgDepth += vert.x;\n                        validVerts++;\n                    }\n                }\n\n                if (validVerts > 0) {\n                    avgDepth /= validVerts;\n                }\n\n                return { face, avgDepth };\n            })\n            .sort((a, b) => a.avgDepth - b.avgDepth) // Sort front-to-back (smaller X = closer)\n            .map(item => item.face);\n\n        // Draw faces in sorted order\n        if (this.renderMode === \"solid\" || this.renderMode === \"both\") {\n            for (const face of sortedFaces) {\n                if (face.length < 3) continue;\n\n                const validVertices = [];\n                for (const vertexIndex of face) {\n                    if (vertexIndex < projectedVertices.length &&\n                        projectedVertices[vertexIndex] !== null) {\n                        validVertices.push(projectedVertices[vertexIndex]);\n                    }\n                }\n\n                if (validVertices.length < 3) continue;\n\n                // Backface culling check\n                const normal = this.calculateFaceNormal(face, transformedVertices);\n                const faceCenter = this.getFaceCenter(face, transformedVertices);\n                const viewDir = camera.position ?\n                    camera.position.clone().subtract(faceCenter).normalize() :\n                    new Vector3(-1, 0, 0);\n\n                // If face normal points away from camera, skip it (backface)\n                if (normal.dot(viewDir) < 0) continue;\n\n                const faceColor = this.getMaterialColor(face, transformedVertices, camera);\n\n                ctx.fillStyle = faceColor;\n                ctx.beginPath();\n                ctx.moveTo(validVertices[0].x, validVertices[0].y);\n\n                for (let i = 1; i < validVertices.length; i++) {\n                    ctx.lineTo(validVertices[i].x, validVertices[i].y);\n                }\n\n                ctx.closePath();\n                ctx.fill();\n            }\n        }\n\n        // Draw edges\n        if (this.renderMode === \"wireframe\" || this.renderMode === \"both\") {\n            ctx.strokeStyle = this.wireframeColor;\n            ctx.lineWidth = 2;\n\n            for (const [from, to] of this.edges) {\n                if (from >= projectedVertices.length ||\n                    to >= projectedVertices.length ||\n                    projectedVertices[from] === null ||\n                    projectedVertices[to] === null) {\n                    continue;\n                }\n\n                const fromVertex = projectedVertices[from];\n                const toVertex = projectedVertices[to];\n\n                ctx.beginPath();\n                ctx.moveTo(fromVertex.x, fromVertex.y);\n                ctx.lineTo(toVertex.x, toVertex.y);\n                ctx.stroke();\n            }\n        }\n\n        if (this.showAxisLines) {\n            this.drawAxisLines(ctx, projectedVertices);\n        }\n    }\n\n    /**\n      * Draw colored axis lines for visualization\n      * @param {CanvasRenderingContext2D} ctx - The render texture context\n      * @param {Array<Vector2>} vertices - The projected vertices array\n      */\n    drawAxisLines(ctx, vertices) {\n        if (vertices.length === 0) return;\n\n        // Calculate center point from valid vertices\n        let centerX = 0, centerY = 0;\n        let validVertices = 0;\n\n        for (const vertex of vertices) {\n            if (vertex !== null) {\n                centerX += vertex.x;\n                centerY += vertex.y;\n                validVertices++;\n            }\n        }\n\n        if (validVertices === 0) return;\n\n        centerX /= validVertices;\n        centerY /= validVertices;\n\n        const axisLength = this.axisLength;\n        const centerPoint = new Vector2(centerX, centerY);\n\n        // Define axis endpoints in 3D space (relative to mesh position) - Z-up coordinate system\n        const axes = {\n            x: new Vector3(axisLength, 0, 0),    // Red - X axis (forward/back)\n            y: new Vector3(0, axisLength, 0),    // Blue - Y axis (left/right)\n            z: new Vector3(0, 0, axisLength)     // Green - Z axis (up/down)\n        };\n\n        // Project axis endpoints to screen space\n        const projectedAxes = {};\n        for (const [axis, endpoint] of Object.entries(axes)) {\n            const worldPoint = new Vector3(\n                endpoint.x + this.position.x,\n                endpoint.y + this.position.y,\n                endpoint.z + this.position.z\n            );\n            projectedAxes[axis] = this.projectPointRelative(worldPoint, centerPoint);\n        }\n\n        // Draw axis lines with colors\n        const axisColors = {\n            x: '#ff0000', // Red - X axis (forward/back)\n            y: '#0000ff', // Blue - Y axis (left/right)\n            z: '#00ff00'  // Green - Z axis (up/down)\n        };\n\n        const axisLabels = {\n            x: 'X',\n            y: 'Y',\n            z: 'Z'\n        };\n\n        ctx.font = '12px Arial';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n\n        for (const [axis, color] of Object.entries(axisColors)) {\n            const endPoint = projectedAxes[axis];\n            if (!endPoint) continue;\n\n            // Draw axis line\n            ctx.strokeStyle = color;\n            ctx.lineWidth = 3;\n            ctx.beginPath();\n            ctx.moveTo(centerX, centerY);\n            ctx.lineTo(endPoint.x, endPoint.y);\n            ctx.stroke();\n\n            // Draw axis label at the end\n            ctx.fillStyle = color;\n            ctx.fillText(axisLabels[axis], endPoint.x, endPoint.y);\n\n            // Draw arrowhead (small triangle)\n            this.drawArrowhead(ctx, centerX, centerY, endPoint.x, endPoint.y, color);\n        }\n\n        // Draw axis legend\n        ctx.fillStyle = '#ffffff';\n        ctx.font = '10px Arial';\n        ctx.textAlign = 'left';\n        ctx.fillText('X: Forward/Back (Red)', centerX + 10, centerY - 30);\n        ctx.fillText('Y: Left/Right (Blue)', centerX + 10, centerY - 18);\n        ctx.fillText('Z: Up/Down (Green)', centerX + 10, centerY - 6);\n    }\n\n    /**\n      * Project a point relative to an origin for axis drawing\n      * @param {Vector3} worldPoint - The world point to project\n      * @param {Vector2} origin - The origin point\n      * @returns {Vector2|null} The projected point\n      */\n    projectPointRelative(worldPoint, origin) {\n        // Find active camera\n        const camera = this.findActiveCamera();\n        if (!camera) return null;\n\n        // Project the point\n        const projected = camera.projectPoint(worldPoint);\n        return projected;\n    }\n\n    /**\n      * Draw an arrowhead at the end of an axis line\n      * @param {CanvasRenderingContext2D} ctx - The canvas context\n      * @param {number} fromX - Start X coordinate\n      * @param {number} fromY - Start Y coordinate\n      * @param {number} toX - End X coordinate\n      * @param {number} toY - End Y coordinate\n      * @param {string} color - The color of the arrowhead\n      */\n    drawArrowhead(ctx, fromX, fromY, toX, toY, color) {\n        const headLength = 8;\n        const headAngle = Math.PI / 6; // 30 degrees\n\n        // Calculate direction vector\n        const dx = toX - fromX;\n        const dy = toY - fromY;\n        const length = Math.sqrt(dx * dx + dy * dy);\n\n        if (length === 0) return;\n\n        // Calculate unit vector\n        const unitX = dx / length;\n        const unitY = dy / length;\n\n        // Calculate perpendicular vector for arrowhead\n        const perpX = -unitY;\n        const perpY = unitX;\n\n        // Calculate arrowhead points\n        const arrowX1 = toX - headLength * (unitX * Math.cos(headAngle) - perpX * Math.sin(headAngle));\n        const arrowY1 = toY - headLength * (unitY * Math.cos(headAngle) - perpY * Math.sin(headAngle));\n        const arrowX2 = toX - headLength * (unitX * Math.cos(headAngle) + perpX * Math.sin(headAngle));\n        const arrowY2 = toY - headLength * (unitY * Math.cos(headAngle) + perpY * Math.sin(headAngle));\n\n        // Draw arrowhead\n        ctx.strokeStyle = color;\n        ctx.lineWidth = 2;\n        ctx.beginPath();\n        ctx.moveTo(toX, toY);\n        ctx.lineTo(arrowX1, arrowY1);\n        ctx.moveTo(toX, toY);\n        ctx.lineTo(arrowX2, arrowY2);\n        ctx.stroke();\n    }\n\n    /**\n      * Draw a placeholder shape when no camera is available\n      * @param {CanvasRenderingContext2D} ctx - The canvas context\n      */\n    drawPlaceholder(ctx) {\n        // Draw a simple cube wireframe\n        ctx.strokeStyle = this.wireframeColor;\n        ctx.lineWidth = 1;\n\n        // Size based on scale\n        const size = 25;\n\n        // Draw front face\n        ctx.beginPath();\n        ctx.rect(-size, -size, size * 2, size * 2);\n        ctx.stroke();\n\n        // Draw back face (offset for perspective effect)\n        ctx.beginPath();\n        ctx.rect(-size * 0.7, -size * 0.7, size * 1.4, size * 1.4);\n        ctx.stroke();\n\n        // Draw connecting lines\n        ctx.beginPath();\n        ctx.moveTo(-size, -size);\n        ctx.lineTo(-size * 0.7, -size * 0.7);\n        ctx.moveTo(size, -size);\n        ctx.lineTo(size * 0.7, -size * 0.7);\n        ctx.moveTo(size, size);\n        ctx.lineTo(size * 0.7, size * 0.7);\n        ctx.moveTo(-size, size);\n        ctx.lineTo(-size * 0.7, size * 0.7);\n        ctx.stroke();\n\n        // Draw \"Mesh3D\" text\n        ctx.fillStyle = this.wireframeColor;\n        ctx.font = '12px Arial';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText('Mesh3D', 0, 0);\n    }\n\n    /**\n      * Find the active camera in the scene\n      * @returns {Camera3D|null} The active camera or null\n      */\n    findActiveCamera() {\n        const allObjects = this.getAllGameObjects();\n\n        // Debug logging to help diagnose camera issues\n        // console.log(`Mesh3D: Looking for active camera among ${allObjects.length} game objects`);\n\n        for (const obj of allObjects) {\n            const camera = obj.getModule(\"Camera3DRasterizer\") || obj.getModule(\"Camera3D\");\n            if (camera) {\n                // console.log(`Mesh3D: Found camera on object ${obj.name || 'unnamed'}, isActive: ${camera.isActive}`);\n                if (camera.isActive) {\n                    // console.log(`Mesh3D: Found active camera!`);\n                    return camera;\n                }\n            }\n        }\n\n        // console.log(`Mesh3D: No active camera found`);\n        return null;\n    }\n\n    /**\n     * Get all game objects in the scene\n     * @returns {Array<GameObject>} All game objects\n     */\n    getAllGameObjects() {\n        if (!this.gameObject) return [];\n\n        // Use the editor's method to get all game objects if available\n        if (window.editor && window.editor.getAllGameObjects) {\n            return window.editor.getAllGameObjects();\n        }\n\n        // Fallback to recursively finding game objects\n        const allObjects = [];\n\n        const scene = window.editor ? window.editor.activeScene :\n            (window.engine ? window.engine.scene : null);\n\n        if (scene && scene.gameObjects) {\n            const findObjects = (objects) => {\n                objects.forEach(obj => {\n                    allObjects.push(obj);\n                    if (obj.children && obj.children.length > 0) {\n                        findObjects(obj.children);\n                    }\n                });\n            };\n\n            findObjects(scene.gameObjects);\n        }\n\n        return allObjects;\n    }\n\n    /**\n     * Rotate a Vector3 around the X axis\n     * @param {Vector3} vector - The vector to rotate\n     * @param {number} radians - Rotation angle in radians\n     * @returns {Vector3} Rotated vector\n     */\n    rotateVectorX(vector, radians) {\n        const cos = Math.cos(radians);\n        const sin = Math.sin(radians);\n        return new Vector3(\n            vector.x,\n            vector.y * cos - vector.z * sin,\n            vector.y * sin + vector.z * cos\n        );\n    }\n\n    /**\n     * Rotate a Vector3 around the Y axis\n     * @param {Vector3} vector - The vector to rotate\n     * @param {number} radians - Rotation angle in radians\n     * @returns {Vector3} Rotated vector\n     */\n    rotateVectorY(vector, radians) {\n        const cos = Math.cos(radians);\n        const sin = Math.sin(radians);\n        return new Vector3(\n            vector.x * cos + vector.z * sin,\n            vector.y,\n            -vector.x * sin + vector.z * cos\n        );\n    }\n\n    /**\n     * Rotate a Vector3 around the Z axis\n     * @param {Vector3} vector - The vector to rotate\n     * @param {number} radians - Rotation angle in radians\n     * @returns {Vector3} Rotated vector\n     */\n    rotateVectorZ(vector, radians) {\n        const cos = Math.cos(radians);\n        const sin = Math.sin(radians);\n        return new Vector3(\n            vector.x * cos - vector.y * sin,\n            vector.x * sin + vector.y * cos,\n            vector.z\n        );\n    }\n\n    /**\n     * Rotate a Vector3 around the Z axis\n     * @param {Vector3} vector - The vector to rotate\n     * @param {number} radians - Rotation angle in radians\n     * @returns {Vector3} Rotated vector\n     */\n    rotateVectorZ(vector, radians) {\n        const cos = Math.cos(radians);\n        const sin = Math.sin(radians);\n        return new Vector3(\n            vector.x * cos - vector.y * sin,\n            vector.x * sin + vector.y * cos,\n            vector.z\n        );\n    }\n\n    /**\n * Transform vertices based on mesh and game object transforms\n * @returns {Array<Vector3>} Transformed vertices\n */\n    transformVertices() {\n        // Get game object transforms if available\n        let objPos = { x: 0, y: 0 };\n        let objRot = 0;\n        let objScale = { x: 1, y: 1 };\n\n        if (this.gameObject) {\n            objPos = this.gameObject.getWorldPosition ? this.gameObject.getWorldPosition() : { x: 0, y: 0 };\n            objRot = this.gameObject.getWorldRotation ? this.gameObject.getWorldRotation() : 0;\n            objScale = this.gameObject.getWorldScale ? this.gameObject.getWorldScale() : { x: 1, y: 1 };\n        }\n\n        // Determine game object world depth (Z). Prefer getWorldDepth(), then depth, then position.z, else 0.\n        let objDepth = 0;\n        if (this.gameObject) {\n            if (typeof this.gameObject.getWorldDepth === 'function') {\n                objDepth = this.gameObject.getWorldDepth();\n            } else if (typeof this.gameObject.depth === 'number') {\n                objDepth = this.gameObject.depth;\n            } else if (this.gameObject.position && typeof this.gameObject.position.z === 'number') {\n                objDepth = this.gameObject.position.z;\n            }\n        }\n\n        // Convert to 3D (use game object depth for Z)\n        const objPos3D = new Vector3(objPos.x, objPos.y, objDepth);\n        const objScale3D = new Vector3(objScale.x, objScale.y, 1);\n\n        return this.vertices.map(vertex => {\n            // Start with the base vertex\n            let v = vertex.clone ? vertex.clone() : new Vector3(vertex.x, vertex.y, vertex.z);\n\n            // Step 1: Apply mesh scale\n            v.x *= this.scale.x;\n            v.y *= this.scale.y;\n            v.z *= this.scale.z;\n\n            // Step 2: Apply mesh rotation (convert degrees to radians)\n            // Rotation order: X (roll) -> Y (pitch) -> Z (yaw) for Z-up coordinate system\n            if (this.rotation.x !== 0) v = this.rotateVectorX(v, this.rotation.x * (Math.PI / 180)); // Roll around X\n            if (this.rotation.y !== 0) v = this.rotateVectorY(v, this.rotation.y * (Math.PI / 180)); // Pitch around Y\n            if (this.rotation.z !== 0) v = this.rotateVectorZ(v, this.rotation.z * (Math.PI / 180)); // Yaw around Z\n\n            // Step 3: Apply mesh position (translate)\n            v.x += this.position.x;\n            v.y += this.position.y;\n            v.z += this.position.z;\n\n            // Step 4: Apply game object scale\n            v.x *= objScale3D.x;\n            v.y *= objScale3D.y;\n            v.z *= objScale3D.z;\n\n            // Step 5: Apply game object rotation around Z-axis (convert degrees to radians)\n            // This is the 2D rotation from the game object's angle property\n            if (objRot !== 0) {\n                const rotRad = objRot * (Math.PI / 180);\n                v = this.rotateVectorZ(v, rotRad);\n            }\n\n            // Step 6: Apply game object position (translate) including depth\n            v.x += objPos3D.x;\n            v.y += objPos3D.y;\n            v.z += objPos3D.z;\n\n            return v;\n        });\n    }\n\n    /**\n     * Rotate the mesh by the given angles (in degrees)\n     * @param {number} x - Roll rotation (degrees) - rotation around X axis (forward/back)\n     * @param {number} y - Yaw rotation (degrees) - rotation around Y axis (left/right)\n     * @param {number} z - Pitch rotation (degrees) - rotation around Z axis (up/down)\n     */\n    rotate(x = 0, y = 0, z = 0) {\n        this.rotation.x += x;\n        this.rotation.y += y;\n        this.rotation.z += z;\n\n        // Normalize angles to 0-360 range\n        this.rotation.x = ((this.rotation.x % 360) + 360) % 360;\n        this.rotation.y = ((this.rotation.y % 360) + 360) % 360;\n        this.rotation.z = ((this.rotation.z % 360) + 360) % 360;\n    }\n\n    /**\n     * Set the mesh rotation to specific angles (in degrees)\n     * @param {number} x - Roll rotation (degrees) - rotation around X axis (forward/back)\n     * @param {number} y - Yaw rotation (degrees) - rotation around Y axis (left/right)\n     * @param {number} z - Pitch rotation (degrees) - rotation around Z axis (up/down)\n     */\n    setRotation(x = 0, y = 0, z = 0) {\n        this.rotation.x = x;\n        this.rotation.y = y;\n        this.rotation.z = z;\n\n        // Normalize angles to 0-360 range\n        this.rotation.x = ((this.rotation.x % 360) + 360) % 360;\n        this.rotation.y = ((this.rotation.y % 360) + 360) % 360;\n        this.rotation.z = ((this.rotation.z % 360) + 360) % 360;\n    }\n\n    /**\n     * Rotate around the X axis (roll - forward/back axis)\n     * @param {number} degrees - Rotation angle in degrees\n     */\n    rotateX(degrees) {\n        this.rotate(degrees, 0, 0);\n    }\n\n    /**\n     * Rotate around the Y axis (yaw - left/right axis)\n     * @param {number} degrees - Rotation angle in degrees\n     */\n    rotateY(degrees) {\n        this.rotate(0, degrees, 0);\n    }\n\n    /**\n     * Rotate around the Z axis (pitch - up/down axis)\n     * @param {number} degrees - Rotation angle in degrees\n     */\n    rotateZ(degrees) {\n        this.rotate(0, 0, degrees);\n    }\n\n    /**\n     * Set rotation speed for automatic rotation (degrees per second)\n     * @param {number} x - Roll speed (degrees/sec) - rotation around X axis\n     * @param {number} y - Yaw speed (degrees/sec) - rotation around Y axis\n     * @param {number} z - Pitch speed (degrees/sec) - rotation around Z axis\n     */\n    setRotationSpeed(x = 0, y = 0, z = 0) {\n        this.rotationSpeed.x = x;\n        this.rotationSpeed.y = y;\n        this.rotationSpeed.z = z;\n    }\n\n    /**\n     * Get the current rotation as a Vector3\n     * @returns {Vector3} Current rotation in degrees\n     */\n    getRotation() {\n        return this.rotation.clone();\n    }\n\n    /**\n     * Get the current rotation speed as a Vector3\n     * @returns {Vector3} Current rotation speed in degrees per second\n     */\n    getRotationSpeed() {\n        return this.rotationSpeed.clone();\n    }\n\n    /**\n     * Reset rotation to zero\n     */\n    resetRotation() {\n        this.rotation.x = 0;\n        this.rotation.y = 0;\n        this.rotation.z = 0;\n    }\n\n    /**\n     * Stop automatic rotation\n     */\n    stopRotation() {\n        this.rotationSpeed.x = 0;\n        this.rotationSpeed.y = 0;\n        this.rotationSpeed.z = 0;\n    }\n\n    /**\n     * Look at a target position (rotates the mesh to face the target)\n     * @param {Vector3} target - Target position in world space\n     */\n    lookAt(target) {\n        // Get mesh world position\n        const meshPos = new Vector3(\n            this.position.x,\n            this.position.y,\n            this.position.z\n        );\n\n        // Calculate direction vector\n        const direction = target.clone().subtract(meshPos);\n\n        // Calculate yaw (rotation around Z-axis) - rotation in XY plane\n        const yaw = Math.atan2(direction.y, direction.x) * (180 / Math.PI);\n\n        // Calculate pitch (rotation around Y-axis) - tilt up/down\n        const horizontalDistance = Math.sqrt(direction.x * direction.x + direction.y * direction.y);\n        const pitch = Math.atan2(direction.z, horizontalDistance) * (180 / Math.PI);\n\n        // Set rotation: x=roll (0), y=pitch, z=yaw\n        this.setRotation(0, pitch, yaw);\n    }\n\n    /**\n     * Rotate towards a target position over time\n     * @param {Vector3} target - Target position in world space\n     * @param {number} speed - Rotation speed in degrees per second\n     * @returns {boolean} True if rotation is complete\n     */\n    rotateTowards(target, speed = 90) {\n        // Calculate target rotation\n        const meshPos = new Vector3(this.position.x, this.position.y, this.position.z);\n        const direction = target.clone().subtract(meshPos);\n\n        const targetYaw = Math.atan2(direction.y, direction.x) * (180 / Math.PI);\n        const horizontalDistance = Math.sqrt(direction.x * direction.x + direction.y * direction.y);\n        const targetPitch = Math.atan2(direction.z, horizontalDistance) * (180 / Math.PI);\n\n        // Calculate rotation deltas\n        const deltaTime = this.gameObject?.scene?.engine?.deltaTime || 0;\n        const maxRotation = speed * deltaTime;\n\n        // Rotate yaw (around Z)\n        let yawDiff = targetYaw - this.rotation.z;\n        // Normalize to -180 to 180\n        while (yawDiff > 180) yawDiff -= 360;\n        while (yawDiff < -180) yawDiff += 360;\n\n        const yawStep = Math.min(Math.abs(yawDiff), maxRotation) * Math.sign(yawDiff);\n        this.rotation.z += yawStep;\n\n        // Rotate pitch (around Y)\n        let pitchDiff = targetPitch - this.rotation.y;\n        while (pitchDiff > 180) pitchDiff -= 360;\n        while (pitchDiff < -180) pitchDiff += 360;\n\n        const pitchStep = Math.min(Math.abs(pitchDiff), maxRotation) * Math.sign(pitchDiff);\n        this.rotation.y += pitchStep;\n\n        // Normalize angles\n        this.rotation.y = ((this.rotation.y % 360) + 360) % 360;\n        this.rotation.z = ((this.rotation.z % 360) + 360) % 360;\n\n        // Check if rotation is complete (within 1 degree threshold)\n        return Math.abs(yawDiff) < 1 && Math.abs(pitchDiff) < 1;\n    }\n\n    /**\n * Get the forward direction vector (local X-axis)\n * @returns {Vector3} Normalized forward vector\n */\n    getForward() {\n        const yawRad = this.rotation.z * (Math.PI / 180);\n        const pitchRad = this.rotation.y * (Math.PI / 180);\n\n        return new Vector3(\n            Math.cos(pitchRad) * Math.cos(yawRad),\n            Math.cos(pitchRad) * Math.sin(yawRad),\n            Math.sin(pitchRad)\n        ).normalize();\n    }\n\n    /**\n     * Get the right direction vector (local Y-axis)\n     * @returns {Vector3} Normalized right vector\n     */\n    getRight() {\n        const yawRad = this.rotation.z * (Math.PI / 180);\n\n        return new Vector3(\n            -Math.sin(yawRad),\n            Math.cos(yawRad),\n            0\n        ).normalize();\n    }\n\n    /**\n     * Get the up direction vector (local Z-axis)\n     * @returns {Vector3} Normalized up vector\n     */\n    getUp() {\n        const rollRad = this.rotation.x * (Math.PI / 180);\n        const yawRad = this.rotation.z * (Math.PI / 180);\n\n        return new Vector3(\n            -Math.sin(rollRad) * Math.sin(yawRad),\n            Math.sin(rollRad) * Math.cos(yawRad),\n            Math.cos(rollRad)\n        ).normalize();\n    }\n\n    /**\n     * Draw in the editor\n     * @param {CanvasRenderingContext2D} ctx - The canvas context\n     */\n    drawInEditor(ctx) {\n        // Use the same draw method for both runtime and editor\n        this.draw(ctx);\n    }\n\n    /**\n     * Update method called each frame\n     */\n    update() {\n        \n    }\n\n    /**\n     * Handle input for custom model editing\n     */\n    handleCustomModelInput() {\n        // Get input manager if available\n        const inputManager = this.gameObject?.scene?.engine?.inputManager;\n        if (!inputManager) return;\n\n        const mouseX = inputManager.mouseX;\n        const mouseY = inputManager.mouseY;\n\n        // Handle mouse down\n        if (inputManager.isMousePressed(0) && !this.isDraggingVertex) {\n            this.onMouseDown(mouseX, mouseY);\n        }\n\n        // Handle mouse move while dragging\n        if (this.isDraggingVertex && inputManager.isMouseDown(0)) {\n            const deltaX = inputManager.mouseDeltaX || 0;\n            const deltaY = inputManager.mouseDeltaY || 0;\n            this.onMouseMove(mouseX, mouseY, deltaX, deltaY);\n        }\n\n        // Handle mouse up\n        if (!inputManager.isMouseDown(0) && this.isDraggingVertex) {\n            this.onMouseUp();\n        }\n    }\n\n    /**\n     * Draw vertex handles for custom model editing\n     * @param {CanvasRenderingContext2D} ctx - The canvas context\n     * @param {Camera3D} camera - The active camera\n     */\n    drawVertexHandles(ctx, camera) {\n        if (!this.isCustomModel) return;\n\n        const transformedVertices = this.transformVertices();\n        const projectedVertices = transformedVertices.map(vertex => camera.projectPoint(vertex));\n\n        // Draw green squares at each vertex\n        ctx.fillStyle = '#00ff00';\n        ctx.strokeStyle = '#ffffff';\n        ctx.lineWidth = 2;\n\n        for (let i = 0; i < projectedVertices.length; i++) {\n            const projected = projectedVertices[i];\n            if (!projected) continue;\n\n            const halfSize = this.vertexHandleSize / 2;\n\n            // Highlight selected vertex\n            if (i === this.selectedVertexIndex) {\n                ctx.fillStyle = '#ffff00';\n                ctx.strokeStyle = '#ff0000';\n                ctx.lineWidth = 3;\n            } else {\n                ctx.fillStyle = '#00ff00';\n                ctx.strokeStyle = '#ffffff';\n                ctx.lineWidth = 2;\n            }\n\n            ctx.fillRect(projected.x - halfSize, projected.y - halfSize, this.vertexHandleSize, this.vertexHandleSize);\n            ctx.strokeRect(projected.x - halfSize, projected.y - halfSize, this.vertexHandleSize, this.vertexHandleSize);\n        }\n    }\n\n    /**\n     * Handle mouse down for vertex selection\n     * @param {number} mouseX - Mouse X position\n     * @param {number} mouseY - Mouse Y position\n     * @returns {boolean} - True if a vertex was selected\n     */\n    onMouseDown(mouseX, mouseY) {\n        if (!this.isCustomModel || this._shape !== \"custom\") return false;\n\n        const camera = this.findActiveCamera();\n        if (!camera) return false;\n\n        const transformedVertices = this.transformVertices();\n        const projectedVertices = transformedVertices.map(vertex => camera.projectPoint(vertex));\n\n        // Check if click is near any vertex\n        for (let i = 0; i < projectedVertices.length; i++) {\n            const projected = projectedVertices[i];\n            if (!projected) continue;\n\n            const dx = mouseX - projected.x;\n            const dy = mouseY - projected.y;\n            const distance = Math.sqrt(dx * dx + dy * dy);\n\n            if (distance < this.vertexHandleSize) {\n                this.selectedVertexIndex = i;\n                this.isDraggingVertex = true;\n                return true;\n            }\n        }\n\n        this.selectedVertexIndex = -1;\n        return false;\n    }\n\n    /**\n     * Handle mouse move for vertex dragging\n     * @param {number} mouseX - Mouse X position\n     * @param {number} mouseY - Mouse Y position\n     * @param {number} deltaX - Mouse movement X\n     * @param {number} deltaY - Mouse movement Y\n     * @returns {boolean} - True if vertex was moved\n     */\n    onMouseMove(mouseX, mouseY, deltaX, deltaY) {\n        if (!this.isCustomModel || !this.isDraggingVertex || this.selectedVertexIndex === -1) return false;\n\n        const camera = this.findActiveCamera();\n        if (!camera) return false;\n\n        // Move vertex in world space based on camera orientation\n        const vertex = this.vertices[this.selectedVertexIndex];\n\n        // Simple screen-space to world-space conversion\n        // This is a basic implementation - could be improved with proper unprojection\n        const moveScale = 1.0;\n        vertex.x += deltaX * moveScale;\n        vertex.y += deltaY * moveScale;\n\n        return true;\n    }\n\n    /**\n     * Handle mouse up to stop dragging\n     */\n    onMouseUp() {\n        if (!this.isCustomModel) return false;\n\n        const wasDragging = this.isDraggingVertex;\n        this.isDraggingVertex = false;\n        return wasDragging;\n    }\n\n    /**\n     * Reset custom model to original sphere shape\n     */\n    resetCustomModel() {\n        if (!this.isCustomModel || !this.originalVertices) return;\n\n        this.vertices = this.originalVertices.map(v => v.clone());\n        this.selectedVertexIndex = -1;\n        this.isDraggingVertex = false;\n    }\n\n    /**\n       * Serialize the mesh to JSON\n       * @returns {Object} JSON representation of the mesh\n       */\n    toJSON() {\n        return {\n            ...super.toJSON(),\n            _type: \"Mesh3D\",\n            vertices: this.vertices.map(v => ({ x: v.x, y: v.y, z: v.z })),\n            edges: this.edges.map(edge => [...edge]),\n            faces: this.faces.map(face => [...face]),\n            uvCoordinates: this.uvCoordinates.map(uv => ({ x: uv.x, y: uv.y })),\n            position: this.position, //{ x: this.position.x, y: this.position.y, z: this.position.z },\n            rotation: this.rotation, //{ x: this.rotation.x, y: this.rotation.y, z: this.rotation.z },\n            scale: this.scale, //{ x: this.scale.x, y: this.scale.y, z: this.scale.z },\n            wireframeColor: this.wireframeColor,\n            faceColor: this.faceColor,\n            renderMode: this.renderMode,\n            _showAxisLines: this._showAxisLines,\n            _axisLength: this._axisLength,\n            _shape: this._shape,\n            cubeSize: this.cubeSize,\n            pyramidBaseSize: this.pyramidBaseSize,\n            pyramidHeight: this.pyramidHeight,\n            sphereRadius: this.sphereRadius,\n            sphereDetail: this.sphereDetail,\n            octahedronSize: this.octahedronSize,\n            torusMajorRadius: this.torusMajorRadius,\n            torusMinorRadius: this.torusMinorRadius,\n            torusMajorSegments: this.torusMajorSegments,\n            torusMinorSegments: this.torusMinorSegments,\n            coneRadius: this.coneRadius,\n            coneHeight: this.coneHeight,\n            coneSegments: this.coneSegments,\n            cylinderRadius: this.cylinderRadius,\n            cylinderHeight: this.cylinderHeight,\n            cylinderSegments: this.cylinderSegments,\n            icosahedronSize: this.icosahedronSize,\n            quadCubeSize: this.quadCubeSize,\n            quadCubeSubdivisions: this.quadCubeSubdivisions,\n            capsuleRadius: this.capsuleRadius,\n            capsuleHeight: this.capsuleHeight,\n            capsuleSegments: this.capsuleSegments,\n            prismSides: this.prismSides,\n            prismRadius: this.prismRadius,\n            prismHeight: this.prismHeight,\n            tetrahedronSize: this.tetrahedronSize,\n            quadWidth: this.quadWidth,\n            quadHeight: this.quadHeight,\n            quadSubdivisionsX: this.quadSubdivisionsX,\n            quadSubdivisionsY: this.quadSubdivisionsY,\n            planeSize: this.planeSize,\n            isCustomModel: this.isCustomModel,\n            originalVertices: this.originalVertices ? this.originalVertices.map(v => ({ x: v.x, y: v.y, z: v.z })) : null,\n            material: this.material ? this.material.toJSON() : null\n        };\n    }\n\n    /**\n       * Deserialize the mesh from JSON\n       * @param {Object} json - JSON representation of the mesh\n       */\n    fromJSON(json) {\n        super.fromJSON(json);\n        if (json.vertices) {\n            this.vertices = json.vertices.map(v => new Vector3(v.x, v.y, v.z));\n        }\n        if (json.edges) this.edges = json.edges;\n        if (json.faces) this.faces = json.faces;\n        if (json.uvCoordinates) {\n            this.uvCoordinates = json.uvCoordinates.map(uv => new Vector2(uv.x, uv.y));\n        } else {\n            // Regenerate UV coordinates if not present\n            this.generateUVCoordinates();\n        }\n        if (json.position) this.position = json.position; //new Vector3(json.position.x, json.position.y, json.position.z);\n        if (json.rotation) this.rotation = json.rotation; //new Vector3(json.rotation.x, json.rotation.y, json.rotation.z);\n        if (json.scale) this.scale = json.scale; //new Vector3(json.scale.x, json.scale.y, json.scale.z);\n        if (json.wireframeColor !== undefined) this.wireframeColor = json.wireframeColor;\n        if (json.faceColor !== undefined) this.faceColor = json.faceColor;\n        if (json.renderMode !== undefined) this.renderMode = json.renderMode;\n        if (json._showAxisLines !== undefined) this._showAxisLines = json._showAxisLines;\n        if (json._axisLength !== undefined) this._axisLength = json._axisLength;\n\n        // Restore shape and shape-specific properties\n        if (json._shape !== undefined) this._shape = json._shape;\n        if (json.cubeSize !== undefined) this.cubeSize = json.cubeSize;\n        if (json.pyramidBaseSize !== undefined) this.pyramidBaseSize = json.pyramidBaseSize;\n        if (json.pyramidHeight !== undefined) this.pyramidHeight = json.pyramidHeight;\n        if (json.sphereRadius !== undefined) this.sphereRadius = json.sphereRadius;\n        if (json.sphereDetail !== undefined) this.sphereDetail = json.sphereDetail;\n        if (json.octahedronSize !== undefined) this.octahedronSize = json.octahedronSize;\n        if (json.torusMajorRadius !== undefined) this.torusMajorRadius = json.torusMajorRadius;\n        if (json.torusMinorRadius !== undefined) this.torusMinorRadius = json.torusMinorRadius;\n        if (json.torusMajorSegments !== undefined) this.torusMajorSegments = json.torusMajorSegments;\n        if (json.torusMinorSegments !== undefined) this.torusMinorSegments = json.torusMinorSegments;\n        if (json.coneRadius !== undefined) this.coneRadius = json.coneRadius;\n        if (json.coneHeight !== undefined) this.coneHeight = json.coneHeight;\n        if (json.coneSegments !== undefined) this.coneSegments = json.coneSegments;\n        if (json.cylinderRadius !== undefined) this.cylinderRadius = json.cylinderRadius;\n        if (json.cylinderHeight !== undefined) this.cylinderHeight = json.cylinderHeight;\n        if (json.cylinderSegments !== undefined) this.cylinderSegments = json.cylinderSegments;\n        if (json.icosahedronSize !== undefined) this.icosahedronSize = json.icosahedronSize;\n        if (json.quadCubeSize !== undefined) this.quadCubeSize = json.quadCubeSize;\n        if (json.quadCubeSubdivisions !== undefined) this.quadCubeSubdivisions = json.quadCubeSubdivisions;\n        if (json.capsuleRadius !== undefined) this.capsuleRadius = json.capsuleRadius;\n        if (json.capsuleHeight !== undefined) this.capsuleHeight = json.capsuleHeight;\n        if (json.capsuleSegments !== undefined) this.capsuleSegments = json.capsuleSegments;\n        if (json.prismSides !== undefined) this.prismSides = json.prismSides;\n        if (json.prismRadius !== undefined) this.prismRadius = json.prismRadius;\n        if (json.prismHeight !== undefined) this.prismHeight = json.prismHeight;\n        if (json.tetrahedronSize !== undefined) this.tetrahedronSize = json.tetrahedronSize;\n        if (json.quadWidth !== undefined) this.quadWidth = json.quadWidth;\n        if (json.quadHeight !== undefined) this.quadHeight = json.quadHeight;\n        if (json.quadSubdivisionsX !== undefined) this.quadSubdivisionsX = json.quadSubdivisionsX;\n        if (json.quadSubdivisionsY !== undefined) this.quadSubdivisionsY = json.quadSubdivisionsY;\n        if (json.planeSize !== undefined) this.planeSize = json.planeSize;\n        if (json.isCustomModel !== undefined) this.isCustomModel = json.isCustomModel;\n        if (json.originalVertices) {\n            this.originalVertices = json.originalVertices.map(v => new Vector3(v.x, v.y, v.z));\n        }\n\n        // Update shape after loading properties\n        if (json._shape) {\n            this.updateShape();\n        }\n\n        // Deserialize material if present\n        if (json.material) {\n            if (!this.material) {\n                this.ensureMaterialModule();\n            }\n            if (this.material && this.material.fromJSON) {\n                this.material.fromJSON(json.material);\n            }\n        }\n    }\n\n    // Getters and setters for properties\n    get showAxisLines() { return this._showAxisLines; }\n    set showAxisLines(value) { this._showAxisLines = value; }\n\n    get axisLength() { return this._axisLength; }\n    set axisLength(value) { this._axisLength = Math.max(50, Math.min(500, value)); }\n\n    get shape() { return this._shape; }\n    set shape(value) {\n        // console.log(`Mesh3D: Shape setter called with value: ${value}`);\n        this._shape = value;\n    }\n}\n\n// Register the Mesh3D module\nwindow.Mesh3D = Mesh3D;",
      "type": "file",
      "name": "Mesh3D.js",
      "parentPath": "/Assets/2D Context 3D Renderer",
      "created": 1759623950596,
      "modified": 1759624920949
    },
    {
      "path": "/Assets/2D Context 3D Renderer/MouseLook.js",
      "content": "/**\r\n * MouseLook - Module for controlling camera rotation with the mouse\r\n * \r\n * This module allows for camera rotation using mouse movement.\r\n * It needs to be attached to a GameObject with a Camera3D module.\r\n */\r\nclass MouseLook extends Module {\r\n    static namespace = \"3D\";\r\n    static description = \"Controls camera rotation with mouse movement\";\r\n    static allowMultiple = false;\r\n    static icon = \"fa-mouse\";\r\n    \r\n    /**\r\n     * Create a new MouseLook\r\n     */\r\n    constructor() {\r\n        super(\"MouseLook\");\r\n        \r\n        // Setup requirements\r\n        this.requires(\"Camera3DRasterizer\");\r\n        \r\n        // Look settings\r\n        this._sensitivity = 0.2; // Lower = less sensitive\r\n        this._invertX = false;\r\n        this._invertY = false;\r\n        this._smoothing = 0.1; // Lower = more responsive, higher = smoother\r\n        this._lockX = false; // Lock horizontal rotation\r\n        this._lockY = false; // Lock vertical rotation\r\n        \r\n        // Range limits\r\n        this._minPitch = -89.9; // Minimum vertical angle (looking down)\r\n        this._maxPitch = 89.9;  // Maximum vertical angle (looking up)\r\n        \r\n        // Mouse state\r\n        this._isLooking = false;\r\n        this._lastMouseX = 0;\r\n        this._lastMouseY = 0;\r\n        \r\n        // Smoothing\r\n        this._targetRotation = new Vector3(0, 0, 0);\r\n        \r\n        // Camera reference (will be set in start())\r\n        this.camera = null;\r\n        \r\n        // Activate mode\r\n        this._activateMode = \"rightButton\"; // Options: \"always\", \"rightButton\", \"middleButton\", \"leftButton\", \"freeLook\"\r\n        \r\n        // Pointer lock settings\r\n        this._lockCursor = false;\r\n        this._isPointerLocked = false;\r\n\r\n        // Screen wrap settings\r\n        this._screenWrap = true; // Enable mouse wrap around screen edges\r\n        this._wrapSensitivity = 1.0; // Sensitivity multiplier when wrapping\r\n        \r\n        // Expose properties to the inspector\r\n        this.exposeProperty(\"sensitivity\", \"number\", 0.2, {\r\n            min: 0.01,\r\n            max: 2,\r\n            step: 0.01,\r\n            onChange: (val) => this._sensitivity = val\r\n        });\r\n\r\n        this.exposeProperty(\"invertX\", \"boolean\", false, {\r\n            onChange: (val) => this._invertX = val\r\n        });\r\n        this.exposeProperty(\"invertY\", \"boolean\", false, {\r\n            onChange: (val) => this._invertY = val\r\n        });\r\n\r\n        this.exposeProperty(\"lockX\", \"boolean\", false, {\r\n            onChange: (val) => this._lockX = val\r\n        });\r\n\r\n        this.exposeProperty(\"lockY\", \"boolean\", false, {\r\n            onChange: (val) => this._lockY = val\r\n        });\r\n\r\n        this.exposeProperty(\"smoothing\", \"number\", 0.1, {\r\n            min: 0,\r\n            max: 0.99,\r\n            step: 0.01,\r\n            onChange: (val) => this._smoothing = val\r\n        });\r\n\r\n        this.exposeProperty(\"minPitch\", \"number\", -89.9, {\r\n            min: -89.9,\r\n            max: 89.9,\r\n            onChange: (val) => this._minPitch = val\r\n        });\r\n\r\n        this.exposeProperty(\"maxPitch\", \"number\", 89.9, {\r\n            min: -89.9,\r\n            max: 89.9,\r\n            onChange: (val) => this._maxPitch = val\r\n        });\r\n\r\n        this.exposeProperty(\"activateMode\", \"enum\", \"rightButton\", {\r\n            options: [\"always\", \"rightButton\", \"middleButton\", \"leftButton\", \"freeLook\"],\r\n            onChange: (val) => this._activateMode = val\r\n        });\r\n\r\n        this.exposeProperty(\"lockCursor\", \"boolean\", false, {\r\n            onChange: (val) => this._lockCursor = val\r\n        });\r\n\r\n        this.exposeProperty(\"screenWrap\", \"boolean\", true, {\r\n            onChange: (val) => this._screenWrap = val\r\n        });\r\n\r\n        this.exposeProperty(\"wrapSensitivity\", \"number\", 1.0, {\r\n            min: 0.1,\r\n            max: 5.0,\r\n            step: 0.1,\r\n            onChange: (val) => this._wrapSensitivity = val\r\n        });\r\n        \r\n        // Bind methods to maintain 'this' context\r\n        this.handleMouseDown = this.handleMouseDown.bind(this);\r\n        this.handleMouseMove = this.handleMouseMove.bind(this);\r\n        this.handleMouseUp = this.handleMouseUp.bind(this);\r\n        this.handleMouseLeave = this.handleMouseLeave.bind(this);\r\n        this.handleMouseEnter = this.handleMouseEnter.bind(this);\r\n        this.handlePointerLockChange = this.handlePointerLockChange.bind(this);\r\n        this.handleKeyDown = this.handleKeyDown.bind(this);\r\n        this.handleCanvasFocus = this.handleCanvasFocus.bind(this);\r\n        this.handleCanvasBlur = this.handleCanvasBlur.bind(this);\r\n    }\r\n    \r\n    /**\r\n     * Called when the module starts\r\n     */\r\n    start() {\r\n        // Get camera reference\r\n        this.camera = this.gameObject.getModule(\"Camera3DRasterizer\") || this.gameObject.getModule(\"Camera3D\");\r\n        \r\n        if (!this.camera) {\r\n            console.error(\"MouseLook requires a Camera3D module on the same GameObject\");\r\n            return;\r\n        }\r\n        \r\n        // Initialize target rotation to camera's current rotation\r\n        this._targetRotation = new Vector3(\r\n            this.camera.rotation.x,\r\n            this.camera.rotation.y,\r\n            this.camera.rotation.z\r\n        );\r\n        \r\n        // Wait a short time to ensure engine is initialized\r\n        setTimeout(() => {\r\n            this.setupEventListeners();\r\n        }, 100);\r\n    }\r\n\r\n    /**\r\n     * Set up event listeners for mouse control\r\n     */\r\n    setupEventListeners() {\r\n        // Set up event listeners\r\n        if (window.engine && window.engine.canvas) {\r\n            const canvas = window.engine.canvas;\r\n            canvas.addEventListener('mousedown', this.handleMouseDown);\r\n            document.addEventListener('mousemove', this.handleMouseMove);\r\n            document.addEventListener('mouseup', this.handleMouseUp);\r\n            canvas.addEventListener('mouseleave', this.handleMouseLeave);\r\n            canvas.addEventListener('mouseenter', this.handleMouseEnter);\r\n            document.addEventListener('pointerlockchange', this.handlePointerLockChange);\r\n            document.addEventListener('keydown', this.handleKeyDown);\r\n            canvas.addEventListener('focus', this.handleCanvasFocus);\r\n            canvas.addEventListener('blur', this.handleCanvasBlur);\r\n            \r\n            // Make canvas focusable if it isn't already\r\n            if (!canvas.hasAttribute('tabindex')) {\r\n                canvas.setAttribute('tabindex', '0');\r\n            }\r\n        } else if (document.querySelector('canvas')) {\r\n            // Fallback to any canvas in the document\r\n            const canvas = document.querySelector('canvas');\r\n            canvas.addEventListener('mousedown', this.handleMouseDown);\r\n            document.addEventListener('mousemove', this.handleMouseMove);\r\n            document.addEventListener('mouseup', this.handleMouseUp);\r\n            canvas.addEventListener('mouseleave', this.handleMouseLeave);\r\n            canvas.addEventListener('mouseenter', this.handleMouseEnter);\r\n            document.addEventListener('pointerlockchange', this.handlePointerLockChange);\r\n            document.addEventListener('keydown', this.handleKeyDown);\r\n            canvas.addEventListener('focus', this.handleCanvasFocus);\r\n            canvas.addEventListener('blur', this.handleCanvasBlur);\r\n            \r\n            // Make canvas focusable if it isn't already\r\n            if (!canvas.hasAttribute('tabindex')) {\r\n                canvas.setAttribute('tabindex', '0');\r\n            }\r\n            console.log(\"MouseLook: Using fallback canvas\");\r\n        } else {\r\n            console.warn(\"MouseLook: No canvas found for mouse events\");\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Called when the module is destroyed\r\n     */\r\n    onDestroy() {\r\n        // Clean up event listeners\r\n        const canvas = window.engine?.canvas || document.querySelector('canvas');\r\n        if (canvas) {\r\n            canvas.removeEventListener('mousedown', this.handleMouseDown);\r\n            document.removeEventListener('mousemove', this.handleMouseMove);\r\n            document.removeEventListener('mouseup', this.handleMouseUp);\r\n            canvas.removeEventListener('mouseleave', this.handleMouseLeave);\r\n            canvas.removeEventListener('mouseenter', this.handleMouseEnter);\r\n            document.removeEventListener('pointerlockchange', this.handlePointerLockChange);\r\n            document.removeEventListener('keydown', this.handleKeyDown);\r\n            canvas.removeEventListener('focus', this.handleCanvasFocus);\r\n            canvas.removeEventListener('blur', this.handleCanvasBlur);\r\n        }\r\n        \r\n        // Release pointer lock if active\r\n        if (this._isPointerLocked) {\r\n            document.exitPointerLock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle canvas focus event\r\n     */\r\n    handleCanvasFocus() {\r\n        if (this._lockCursor && this._activateMode === \"freeLook\") {\r\n            this.requestPointerLock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle canvas blur event\r\n     */\r\n    handleCanvasBlur() {\r\n        if (this._isPointerLocked) {\r\n            document.exitPointerLock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle mouse leave event\r\n     * @param {MouseEvent} event - The mouse event\r\n     */\r\n    handleMouseLeave(event) {\r\n        if (!this._screenWrap || this._isPointerLocked) return;\r\n\r\n        // Store that we're wrapping so we don't process this as normal mouse movement\r\n        this._isWrapping = true;\r\n        this._wrapStartTime = Date.now();\r\n    }\r\n\r\n    /**\r\n     * Handle mouse enter event\r\n     * @param {MouseEvent} event - The mouse event\r\n     */\r\n    handleMouseEnter(event) {\r\n        if (!this._screenWrap || this._isPointerLocked) return;\r\n\r\n        // If we were wrapping, simulate the mouse movement that got cut off\r\n        if (this._isWrapping && this._lastMouseX !== undefined && this._lastMouseY !== undefined) {\r\n            // Calculate how much mouse movement we might have missed\r\n            const timeSinceLeave = Date.now() - this._wrapStartTime;\r\n            if (timeSinceLeave < 100) { // Only if it was a quick leave/re-enter\r\n                // Apply wrap movement based on the edge we left from\r\n                this.simulateWrapMovement(event);\r\n            }\r\n        }\r\n\r\n        this._isWrapping = false;\r\n    }\r\n\r\n    /**\r\n     * Simulate mouse movement when wrapping around screen edges\r\n     * @param {MouseEvent} event - The mouse enter event\r\n     */\r\n    simulateWrapMovement(event) {\r\n        if (!this._isLooking) return;\r\n\r\n        // Determine which edge we likely came from based on enter position\r\n        const canvas = window.engine?.canvas || document.querySelector('canvas');\r\n        if (!canvas) return;\r\n\r\n        const rect = canvas.getBoundingClientRect();\r\n        let simulatedDeltaX = 0;\r\n        let simulatedDeltaY = 0;\r\n\r\n        // If mouse entered from left edge, simulate rightward movement\r\n        if (event.clientX <= rect.left + 10) {\r\n            simulatedDeltaX = 50 * this._wrapSensitivity;\r\n        }\r\n        // If mouse entered from right edge, simulate leftward movement\r\n        else if (event.clientX >= rect.right - 10) {\r\n            simulatedDeltaX = -50 * this._wrapSensitivity;\r\n        }\r\n        // If mouse entered from top edge, simulate downward movement\r\n        else if (event.clientY <= rect.top + 10) {\r\n            simulatedDeltaY = 50 * this._wrapSensitivity;\r\n        }\r\n        // If mouse entered from bottom edge, simulate upward movement\r\n        else if (event.clientY >= rect.bottom - 10) {\r\n            simulatedDeltaY = -50 * this._wrapSensitivity;\r\n        }\r\n\r\n        if (simulatedDeltaX !== 0 || simulatedDeltaY !== 0) {\r\n            // Apply the simulated rotation\r\n            const yawDelta = this._lockX ? 0 : simulatedDeltaX * this.sensitivity * (this.invertX ? -1 : 1);\r\n            const pitchDelta = this._lockY ? 0 : simulatedDeltaY * this.sensitivity * (this.invertY ? -1 : 1);\r\n\r\n            this._targetRotation.z = (this._targetRotation.z + yawDelta) % 360;\r\n            this._targetRotation.y = this._targetRotation.y - pitchDelta;\r\n            this._targetRotation.y = Math.max(this.minPitch, Math.min(this.maxPitch, this._targetRotation.y));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle key down event\r\n     * @param {KeyboardEvent} event - The keyboard event\r\n     */\r\n    handleKeyDown(event) {\r\n        if (event.key === 'Escape' && this._isPointerLocked) {\r\n            document.exitPointerLock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle pointer lock change event\r\n     */\r\n    handlePointerLockChange() {\r\n        const canvas = window.engine?.canvas || document.querySelector('canvas');\r\n        this._isPointerLocked = document.pointerLockElement === canvas;\r\n        \r\n        if (this._isPointerLocked) {\r\n            this._isLooking = true;\r\n        } else if (this._activateMode === \"freeLook\") {\r\n            this._isLooking = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Request pointer lock on the canvas\r\n     */\r\n    requestPointerLock() {\r\n        const canvas = window.engine?.canvas || document.querySelector('canvas');\r\n        if (canvas && !this._isPointerLocked) {\r\n            canvas.requestPointerLock();\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Handle mouse down event\r\n     * @param {MouseEvent} event - The mouse event\r\n     */\r\n    handleMouseDown(event) {\r\n        if (!this.camera) return;\r\n        \r\n        // Handle freeLook mode with pointer lock\r\n        if (this._activateMode === \"freeLook\") {\r\n            if (this._lockCursor && !this._isPointerLocked) {\r\n                this.requestPointerLock();\r\n            } else if (!this._lockCursor) {\r\n                this._isLooking = true;\r\n                this._lastMouseX = event.clientX;\r\n                this._lastMouseY = event.clientY;\r\n            }\r\n            return;\r\n        }\r\n        \r\n        // Check if the correct mouse button was pressed\r\n        if (this._activateMode === \"always\" ||\r\n           (this._activateMode === \"rightButton\" && event.button === 2) ||\r\n           (this._activateMode === \"middleButton\" && event.button === 1) ||\r\n           (this._activateMode === \"leftButton\" && event.button === 0)) {\r\n            \r\n            this._isLooking = true;\r\n            this._lastMouseX = event.clientX;\r\n            this._lastMouseY = event.clientY;\r\n            \r\n            // Prevent default context menu if right click is used\r\n            if (event.button === 2) {\r\n                event.preventDefault();\r\n                \r\n                // Add a one-time event listener for context menu\r\n                const contextMenuHandler = (e) => {\r\n                    e.preventDefault();\r\n                    document.removeEventListener('contextmenu', contextMenuHandler);\r\n                };\r\n                \r\n                document.addEventListener('contextmenu', contextMenuHandler);\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Handle mouse move event\r\n     * @param {MouseEvent} event - The mouse event\r\n     */\r\n    handleMouseMove(event) {\r\n        if (!this.camera || !this._isLooking) return;\r\n        \r\n        let deltaX, deltaY;\r\n        \r\n        // Use movementX/Y for pointer lock, otherwise calculate delta\r\n        if (this._isPointerLocked) {\r\n            deltaX = event.movementX || 0;\r\n            deltaY = event.movementY || 0;\r\n        } else {\r\n            // Calculate mouse movement\r\n            deltaX = event.clientX - this._lastMouseX;\r\n            deltaY = event.clientY - this._lastMouseY;\r\n            \r\n            // Update last mouse position\r\n            this._lastMouseX = event.clientX;\r\n            this._lastMouseY = event.clientY;\r\n        }\r\n        \r\n        // Apply sensitivity and inversion, respecting axis locks\r\n        const yawDelta = this._lockX ? 0 : deltaX * this.sensitivity * (this.invertX ? -1 : 1);\r\n        const pitchDelta = this._lockY ? 0 : deltaY * this.sensitivity * (this.invertY ? -1 : 1);\r\n        \r\n        // Update target rotation using Z-up convention where:\r\n        // - Z = yaw (turn left/right)\r\n        // - Y = pitch (tilt up/down around right axis)\r\n        // - X = roll (unused by mouse look unless explicitly set)\r\n        this._targetRotation.z = (this._targetRotation.z + yawDelta) % 360;\r\n        this._targetRotation.y = this._targetRotation.y - pitchDelta;\r\n\r\n        // Clamp pitch (rotation.y) to prevent flipping\r\n        this._targetRotation.y = Math.max(this.minPitch, Math.min(this.maxPitch, this._targetRotation.y));\r\n    }\r\n    \r\n    /**\r\n     * Handle mouse up event\r\n     * @param {MouseEvent} event - The mouse event\r\n     */\r\n    handleMouseUp(event) {\r\n        if (!this.camera) return;\r\n        \r\n        // Don't stop looking in freeLook mode without cursor lock or if pointer is locked\r\n        if (this._activateMode === \"freeLook\" && (this._isPointerLocked || !this._lockCursor)) {\r\n            if (!this._lockCursor) {\r\n                this._isLooking = false;\r\n            }\r\n            return;\r\n        }\r\n        \r\n        // Check if the correct mouse button was released\r\n        if ((this._activateMode === \"rightButton\" && event.button === 2) ||\r\n            (this._activateMode === \"middleButton\" && event.button === 1) ||\r\n            (this._activateMode === \"leftButton\" && event.button === 0)) {\r\n            \r\n            this._isLooking = false;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Handle camera rotation each frame\r\n     * @param {number} deltaTime - Time since last frame in seconds\r\n     */\r\n    loop(deltaTime) {\r\n        if (!this.camera) return;\r\n        \r\n        // For \"always\" mode, automatically enable looking\r\n        if (this._activateMode === \"always\") {\r\n            this._isLooking = true;\r\n        }\r\n        \r\n        // For \"freeLook\" mode without cursor lock, enable looking\r\n        if (this._activateMode === \"freeLook\" && !this._lockCursor) {\r\n            this._isLooking = true;\r\n        }\r\n        \r\n        // Apply rotation with smoothing (Z-up: pitch = rotation.y, yaw = rotation.z, roll = rotation.x)\r\n        if (this.smoothing > 0) {\r\n            // Pitch -> rotation.y\r\n            this.camera.rotation.y += (this._targetRotation.y - this.camera.rotation.y) * (1 - this.smoothing);\r\n            // Roll -> rotation.x\r\n            this.camera.rotation.x += (this._targetRotation.x - this.camera.rotation.x) * (1 - this.smoothing);\r\n            // Yaw -> rotation.z\r\n            this.camera.rotation.z += (this._targetRotation.z - this.camera.rotation.z) * (1 - this.smoothing);\r\n        } else {\r\n            // Direct rotation without smoothing\r\n            this.camera.rotation.y = this._targetRotation.y; // Pitch (Y-axis)\r\n            this.camera.rotation.x = this._targetRotation.x; // Roll (X-axis)\r\n            this.camera.rotation.z = this._targetRotation.z; // Yaw (Z-axis)\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Serialize the mouse look to JSON\r\n     * @returns {Object} JSON representation of the mouse look\r\n     */\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            _type: \"MouseLook\",\r\n            _sensitivity: this._sensitivity,\r\n            _invertX: this._invertX,\r\n            _invertY: this._invertY,\r\n            _smoothing: this._smoothing,\r\n            _lockX: this._lockX,\r\n            _lockY: this._lockY,\r\n            _minPitch: this._minPitch,\r\n            _maxPitch: this._maxPitch,\r\n            _activateMode: this._activateMode,\r\n            _lockCursor: this._lockCursor,\r\n            _screenWrap: this._screenWrap,\r\n            _wrapSensitivity: this._wrapSensitivity\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Deserialize the mouse look from JSON\r\n     * @param {Object} json - JSON representation of the mouse look\r\n     */\r\n    fromJSON(json) {\r\n        super.fromJSON(json);\r\n        if (json._sensitivity !== undefined) this._sensitivity = json._sensitivity;\r\n        if (json._invertX !== undefined) this._invertX = json._invertX;\r\n        if (json._invertY !== undefined) this._invertY = json._invertY;\r\n        if (json._smoothing !== undefined) this._smoothing = json._smoothing;\r\n        if (json._lockX !== undefined) this._lockX = json._lockX;\r\n        if (json._lockY !== undefined) this._lockY = json._lockY;\r\n        if (json._minPitch !== undefined) this._minPitch = json._minPitch;\r\n        if (json._maxPitch !== undefined) this._maxPitch = json._maxPitch;\r\n        if (json._activateMode !== undefined) this._activateMode = json._activateMode;\r\n        if (json._lockCursor !== undefined) this._lockCursor = json._lockCursor;\r\n        if (json._screenWrap !== undefined) this._screenWrap = json._screenWrap;\r\n        if (json._wrapSensitivity !== undefined) this._wrapSensitivity = json._wrapSensitivity;\r\n    }\r\n\r\n    // Getters and setters for properties\r\n    get sensitivity() { return this._sensitivity; }\r\n    set sensitivity(value) { this._sensitivity = value; }\r\n\r\n    get invertX() { return this._invertX; }\r\n    set invertX(value) { this._invertX = value; }\r\n\r\n    get invertY() { return this._invertY; }\r\n    set invertY(value) { this._invertY = value; }\r\n\r\n    get lockX() { return this._lockX; }\r\n    set lockX(value) { this._lockX = value; }\r\n\r\n    get lockY() { return this._lockY; }\r\n    set lockY(value) { this._lockY = value; }\r\n\r\n    get smoothing() { return this._smoothing; }\r\n    set smoothing(value) { this._smoothing = Math.max(0, Math.min(0.99, value)); }\r\n\r\n    get minPitch() { return this._minPitch; }\r\n    set minPitch(value) { this._minPitch = Math.max(-89.9, Math.min(this.maxPitch, value)); }\r\n\r\n    get maxPitch() { return this._maxPitch; }\r\n    set maxPitch(value) { this._maxPitch = Math.min(89.9, Math.max(this.minPitch, value)); }\r\n\r\n    get activateMode() { return this._activateMode; }\r\n    set activateMode(value) { this._activateMode = value; }\r\n\r\n    get lockCursor() { return this._lockCursor; }\r\n    set lockCursor(value) { this._lockCursor = value; }\r\n\r\n    get screenWrap() { return this._screenWrap; }\r\n    set screenWrap(value) { this._screenWrap = value; }\r\n\r\n    get wrapSensitivity() { return this._wrapSensitivity; }\r\n    set wrapSensitivity(value) { this._wrapSensitivity = Math.max(0.1, Math.min(5.0, value)); }\r\n}\r\n\r\n// Register the MouseLook module\r\nwindow.MouseLook = MouseLook;",
      "type": "file",
      "name": "MouseLook.js",
      "parentPath": "/Assets/2D Context 3D Renderer",
      "created": 1759623950607,
      "modified": 1759623950607
    },
    {
      "path": "/Assets/2D Context 3D Renderer/TopDownCamera.js",
      "content": "/**\r\n  * TopDownCamera - Module for top-down camera movement (Z-up coordinate system)\r\n  *\r\n  * This module provides top-down camera controls that lock the camera\r\n  * at a top-down angle while allowing movement in the X/Y plane.\r\n  * Coordinate system: Z = up/down, Y = left/right, X = forward/back\r\n  * It needs to be attached to a GameObject with a Camera3D module.\r\n  */\r\nclass TopDownCamera extends Module {\r\n    static namespace = \"3D\";\r\n    static description = \"Top-down camera controller with Z-up coordinate system (Z=up/down, Y=left/right, X=forward/back)\";\r\n    static iconClass = \"fas fa-camera\";\r\n\r\n    /**\r\n     * Create a new TopDownCamera\r\n     */\r\n    constructor() {\r\n        super(\"TopDownCamera\");\r\n\r\n        // Setup requirements\r\n        this.requires(\"Camera3DRasterizer\");\r\n\r\n        // Camera settings\r\n        this._cameraDistance = 500; // Distance from target (Z-axis)\r\n        this._moveSpeed = 200; // Units per second\r\n        this._sprintMultiplier = 2.5;\r\n        this._smoothing = 0.2; // Lower = more responsive, higher = smoother\r\n        this._currentVelocity = new Vector3(0, 0, 0);\r\n\r\n        // Top-down angle settings (in degrees) - Z-up coordinate system\r\n        this._topDownAngleX = 90; // Pitch around Y axis (90 degrees = looking straight down)\r\n        this._topDownAngleY = 0;  // Yaw around Z axis (0 = no rotation)\r\n        this._topDownAngleZ = 0;  // Roll around X axis (0 = no roll)\r\n\r\n        // Key mapping (can be customized)\r\n        this._keyMapping = {\r\n            forward: \"w\",\r\n            backward: \"s\",\r\n            left: \"a\",\r\n            right: \"d\",\r\n            up: \"e\",        // Move up in Z (increase distance)\r\n            down: \"q\",      // Move down in Z (decrease distance)\r\n            sprint: \"shift\"\r\n        };\r\n\r\n        // Camera reference (will be set in start())\r\n        this.camera = null;\r\n\r\n        // Expose properties to the inspector\r\n        this.exposeProperty(\"cameraDistance\", \"number\", 500, {\r\n            min: 10,\r\n            max: 2000,\r\n            step: 10,\r\n            description: \"Distance from camera to target\",\r\n            onChange: (val) => this._cameraDistance = val\r\n        });\r\n\r\n        this.exposeProperty(\"moveSpeed\", \"number\", 200, {\r\n            min: 1,\r\n            max: 1000,\r\n            description: \"Movement speed in units per second\",\r\n            onChange: (val) => this._moveSpeed = val\r\n        });\r\n\r\n        this.exposeProperty(\"sprintMultiplier\", \"number\", 2.5, {\r\n            min: 1,\r\n            max: 10,\r\n            description: \"Speed multiplier when sprinting\",\r\n            onChange: (val) => this._sprintMultiplier = val\r\n        });\r\n\r\n        this.exposeProperty(\"smoothing\", \"number\", 0.2, {\r\n            min: 0,\r\n            max: 0.99,\r\n            step: 0.01,\r\n            description: \"Movement smoothing (0 = instant, 1 = very smooth)\",\r\n            onChange: (val) => this._smoothing = val\r\n        });\r\n\r\n        this.exposeProperty(\"topDownAngleX\", \"number\", 90, {\r\n            min: 45,\r\n            max: 90,\r\n            step: 1,\r\n            description: \"Camera pitch angle around Y axis (90 = straight down)\",\r\n            onChange: (val) => this._topDownAngleX = val\r\n        });\r\n\r\n        this.exposeProperty(\"topDownAngleY\", \"number\", 0, {\r\n            min: -180,\r\n            max: 180,\r\n            step: 1,\r\n            description: \"Camera yaw angle around Z axis (rotation around vertical axis)\",\r\n            onChange: (val) => this._topDownAngleY = val\r\n        });\r\n\r\n        this.exposeProperty(\"topDownAngleZ\", \"number\", 0, {\r\n            min: -180,\r\n            max: 180,\r\n            step: 1,\r\n            description: \"Camera roll angle around X axis (tilt)\",\r\n            onChange: (val) => this._topDownAngleZ = val\r\n        });\r\n\r\n        this.exposeProperty(\"keyMapping\", \"object\", this._keyMapping, {\r\n            description: \"Key mapping for camera controls\",\r\n            onChange: (val) => this._keyMapping = val\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Called when the module starts\r\n     */\r\n    start() {\r\n        // Get camera reference\r\n        this.camera = this.gameObject.getModule(\"Camera3D\");\r\n\r\n        if (!this.camera) {\r\n            console.error(\"TopDownCamera requires a Camera3D module on the same GameObject\");\r\n        }\r\n\r\n        // Make sure input manager is available\r\n        if (!window.input) {\r\n            console.error(\"TopDownCamera requires InputManager to be initialized\");\r\n        }\r\n\r\n        // Lock camera to top-down angle immediately\r\n        this.lockCameraAngle();\r\n    }\r\n\r\n    /**\r\n      * Lock the camera to the top-down angle\r\n      */\r\n     lockCameraAngle() {\r\n         if (!this.camera) return;\r\n \r\n         // Set camera rotation to top-down angles (Z-up coordinate system)\r\n         // rotation.x = roll (around X axis) = 0 for no roll\r\n         // rotation.y = pitch (around Y axis) = 90 degrees for straight down\r\n         // rotation.z = yaw (around Z axis) = rotation angle\r\n         if (this.camera.rotation) {\r\n             this.camera.rotation.x = this._topDownAngleZ; // Roll (around X axis)\r\n             this.camera.rotation.y = this._topDownAngleX; // Pitch (around Y axis) - 90 degrees = straight down\r\n             this.camera.rotation.z = this._topDownAngleY; // Yaw (around Z axis)\r\n         }\r\n \r\n         // Also set the gameObject's rotation to match\r\n         if (this.gameObject) {\r\n             this.gameObject.angle = this._topDownAngleY; // Use yaw angle directly\r\n         }\r\n     }\r\n\r\n    /**\r\n     * Handle camera movement each frame\r\n     * @param {number} deltaTime - Time since last frame in seconds\r\n     */\r\n    loop(deltaTime) {\r\n        if (!this.camera || !window.input) return;\r\n\r\n        // Lock camera angle every frame to prevent changes\r\n        this.lockCameraAngle();\r\n\r\n        // Calculate target velocity based on key presses\r\n        const targetVelocity = this.calculateTargetVelocity();\r\n\r\n        // Apply smoothing\r\n        this._currentVelocity.x += (targetVelocity.x - this._currentVelocity.x) * (1 - this._smoothing);\r\n        this._currentVelocity.y += (targetVelocity.y - this._currentVelocity.y) * (1 - this._smoothing);\r\n        this._currentVelocity.z += (targetVelocity.z - this._currentVelocity.z) * (1 - this._smoothing);\r\n\r\n        // Move the camera\r\n        if (this._currentVelocity.magnitude() > 0.01) {\r\n            this.moveCamera(deltaTime);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate target velocity based on key presses\r\n     * @returns {Vector3} Target velocity\r\n     */\r\n    calculateTargetVelocity() {\r\n        // Start with zero velocity\r\n        const targetVelocity = new Vector3(0, 0, 0);\r\n\r\n        // Check if input manager is available\r\n        if (!window.input) return targetVelocity;\r\n\r\n        // Check sprint key\r\n        const sprinting = window.input.keyDown(this.keyMapping.sprint);\r\n        const speedMultiplier = sprinting ? this.sprintMultiplier : 1;\r\n\r\n        // Calculate movement direction in world space\r\n        // For top-down camera, we move in X/Y plane and Z (distance)\r\n        if (window.input.keyDown(this.keyMapping.forward)) {\r\n            targetVelocity.x += this.moveSpeed * speedMultiplier;   // Forward (X axis)\r\n        }\r\n        if (window.input.keyDown(this.keyMapping.backward)) {\r\n            targetVelocity.x -= this.moveSpeed * speedMultiplier;   // Backward (-X axis)\r\n        }\r\n        if (window.input.keyDown(this.keyMapping.left)) {\r\n            targetVelocity.y -= this.moveSpeed * speedMultiplier;   // Left (-Y axis)\r\n        }\r\n        if (window.input.keyDown(this.keyMapping.right)) {\r\n            targetVelocity.y += this.moveSpeed * speedMultiplier;   // Right (Y axis)\r\n        }\r\n        if (window.input.keyDown(this.keyMapping.up)) {\r\n            targetVelocity.z += this.moveSpeed * speedMultiplier;   // Up (+Z, increase distance)\r\n        }\r\n        if (window.input.keyDown(this.keyMapping.down)) {\r\n            targetVelocity.z -= this.moveSpeed * speedMultiplier;   // Down (-Z, decrease distance)\r\n        }\r\n\r\n        return targetVelocity;\r\n    }\r\n\r\n    /**\r\n     * Move the camera based on current velocity\r\n     * @param {number} deltaTime - Time since last frame in seconds\r\n     */\r\n    moveCamera(deltaTime) {\r\n        // Ensure gameObject.position exists and has numeric x/y\r\n        if (!this.gameObject.position || typeof this.gameObject.position.x !== 'number' || typeof this.gameObject.position.y !== 'number') {\r\n            this.gameObject.position = { x: 0, y: 0 };\r\n        }\r\n\r\n        // Apply horizontal movement (X/Y plane)\r\n        const dx = Number.isFinite(this._currentVelocity.x) ? this._currentVelocity.x * deltaTime : 0;\r\n        const dy = Number.isFinite(this._currentVelocity.y) ? this._currentVelocity.y * deltaTime : 0;\r\n\r\n        this.gameObject.position.x += dx;\r\n        this.gameObject.position.y += dy;\r\n\r\n        // Apply vertical movement (Z distance)\r\n        const dz = Number.isFinite(this._currentVelocity.z) ? this._currentVelocity.z * deltaTime : 0;\r\n\r\n        if (this.camera && this.camera.position) {\r\n            // Update camera's Z position for distance\r\n            if (!this.camera.position.z || typeof this.camera.position.z !== 'number') {\r\n                this.camera.position.z = this._cameraDistance;\r\n            } else {\r\n                this.camera.position.z += dz;\r\n                // Clamp camera distance to reasonable bounds\r\n                this.camera.position.z = Math.max(50, Math.min(2000, this.camera.position.z));\r\n                // Update our distance property to match\r\n                this._cameraDistance = this.camera.position.z;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the camera distance immediately\r\n     * @param {number} distance - New camera distance\r\n     */\r\n    setCameraDistance(distance) {\r\n        this._cameraDistance = Math.max(50, Math.min(2000, distance));\r\n\r\n        if (this.camera && this.camera.position) {\r\n            this.camera.position.z = this._cameraDistance;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the current camera distance\r\n     * @returns {number} Current camera distance\r\n     */\r\n    getCameraDistance() {\r\n        if (this.camera && this.camera.position && typeof this.camera.position.z === 'number') {\r\n            return this.camera.position.z;\r\n        }\r\n        return this._cameraDistance;\r\n    }\r\n\r\n    /**\r\n      * Set the top-down angles (Z-up coordinate system)\r\n      * @param {number} pitch - Pitch angle around Y axis (90 = straight down)\r\n      * @param {number} yaw - Yaw angle around Z axis (rotation)\r\n      * @param {number} roll - Roll angle around X axis (tilt)\r\n      */\r\n     setTopDownAngles(pitch = 90, yaw = 0, roll = 0) {\r\n         this._topDownAngleX = Math.max(45, Math.min(90, pitch)); // Pitch (Y axis)\r\n         this._topDownAngleY = yaw; // Yaw (Z axis)\r\n         this._topDownAngleZ = roll; // Roll (X axis)\r\n\r\n         // Apply immediately\r\n         this.lockCameraAngle();\r\n     }\r\n\r\n    /**\r\n     * Serialize the top-down camera to JSON\r\n     * @returns {Object} JSON representation of the top-down camera\r\n     */\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            _type: \"TopDownCamera\",\r\n            _cameraDistance: this._cameraDistance,\r\n            _moveSpeed: this._moveSpeed,\r\n            _sprintMultiplier: this._sprintMultiplier,\r\n            _smoothing: this._smoothing,\r\n            _topDownAngleX: this._topDownAngleX,\r\n            _topDownAngleY: this._topDownAngleY,\r\n            _topDownAngleZ: this._topDownAngleZ,\r\n            _keyMapping: { ...this._keyMapping }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Deserialize the top-down camera from JSON\r\n     * @param {Object} json - JSON representation of the top-down camera\r\n     */\r\n    fromJSON(json) {\r\n        super.fromJSON(json);\r\n        if (json._cameraDistance !== undefined) this._cameraDistance = json._cameraDistance;\r\n        if (json._moveSpeed !== undefined) this._moveSpeed = json._moveSpeed;\r\n        if (json._sprintMultiplier !== undefined) this._sprintMultiplier = json._sprintMultiplier;\r\n        if (json._smoothing !== undefined) this._smoothing = json._smoothing;\r\n        if (json._topDownAngleX !== undefined) this._topDownAngleX = json._topDownAngleX;\r\n        if (json._topDownAngleY !== undefined) this._topDownAngleY = json._topDownAngleY;\r\n        if (json._topDownAngleZ !== undefined) this._topDownAngleZ = json._topDownAngleZ;\r\n        if (json._keyMapping) this._keyMapping = { ...json._keyMapping };\r\n\r\n        // Apply the loaded settings\r\n        this.lockCameraAngle();\r\n    }\r\n\r\n    // Getters and setters for properties\r\n    get cameraDistance() { return this._cameraDistance; }\r\n    set cameraDistance(value) { this._cameraDistance = value; this.setCameraDistance(value); }\r\n\r\n    get moveSpeed() { return this._moveSpeed; }\r\n    set moveSpeed(value) { this._moveSpeed = value; }\r\n\r\n    get sprintMultiplier() { return this._sprintMultiplier; }\r\n    set sprintMultiplier(value) { this._sprintMultiplier = value; }\r\n\r\n    get smoothing() { return this._smoothing; }\r\n    set smoothing(value) { this._smoothing = Math.max(0, Math.min(0.99, value)); }\r\n\r\n    get topDownAngleX() { return this._topDownAngleX; }\r\n    set topDownAngleX(value) { this._topDownAngleX = value; this.lockCameraAngle(); }\r\n\r\n    get topDownAngleY() { return this._topDownAngleY; }\r\n    set topDownAngleY(value) { this._topDownAngleY = value; this.lockCameraAngle(); }\r\n\r\n    get topDownAngleZ() { return this._topDownAngleZ; }\r\n    set topDownAngleZ(value) { this._topDownAngleZ = value; this.lockCameraAngle(); }\r\n\r\n    get keyMapping() { return this._keyMapping; }\r\n    set keyMapping(value) { this._keyMapping = value; }\r\n}\r\n\r\n// Register the TopDownCamera module\r\nwindow.TopDownCamera = TopDownCamera;",
      "type": "file",
      "name": "TopDownCamera.js",
      "parentPath": "/Assets/2D Context 3D Renderer",
      "created": 1759623950612,
      "modified": 1759623950612
    }
  ],
  "metadata": {
    "exportedBy": "Dark Matter JS Game Engine",
    "exportVersion": "1.0",
    "engineVersion": "1.0.0",
    "selectionMode": "explicit-directories-only"
  }
}