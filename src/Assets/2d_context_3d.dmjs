{
  "name": "2D Context 3D",
  "description": "3D Rendering for the 2D Canvas Context. Not perfect by any means but good base to work from so far",
  "version": "1.4.0",
  "author": "SynKrown",
  "timestamp": 1759457390076,
  "icon": {
    "data": "data:image/png;base64,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",
    "originalName": "Generated Image October 03, 2025 - 3_09PM.png",
    "size": 329420
  },
  "directories": [],
  "totalFiles": 10,
  "totalDirectories": 0,
  "files": [
    {
      "path": "//Camera3DBasic.js",
      "content": "/**\r\n * Camera3D - Module for 3D perspective cameras\r\n * \r\n * This module provides 3D camera functionality with multiple rendering methods.\r\n * Supports: Painter's Algorithm, Z-Buffer, Scanline, and Raytracing.\r\n */\r\nclass Camera3D extends Module {\r\n    static namespace = \"WIP\";\r\n\r\n    constructor() {\r\n        super(\"Camera3D\");\r\n\r\n        this._position = new Vector3(0, 0, 0);\r\n        this._rotation = new Vector3(0, 0, 0);\r\n        this._fieldOfView = 60;\r\n        this._nearPlane = 0.1;\r\n        this._farPlane = 5000;\r\n        this._isActive = false;\r\n        this._backgroundColor = \"#000000\";\r\n        this._renderTextureWidth = 320;\r\n        this._renderTextureHeight = 240;\r\n        this._renderTextureSmoothing = false;\r\n        this._renderTexture = null;\r\n        this._renderTextureCtx = null;\r\n        this.viewportWidth = 800;\r\n        this.viewportHeight = 600;\r\n        this.drawGizmoInRuntime = false;\r\n        this._renderingMethod = \"painter\";\r\n        this._enableBackfaceCulling = true;\r\n        this._zBuffer = null;\r\n        this._imageData = null;\r\n\r\n        this.exposeProperty(\"position\", \"vector3\", this._position, {\r\n            onChange: (val) => this._position = val\r\n        });\r\n        this.exposeProperty(\"rotation\", \"vector3\", this._rotation, {\r\n            onChange: (val) => this._rotation = val\r\n        });\r\n        this.exposeProperty(\"fieldOfView\", \"number\", 60, {\r\n            min: 1, max: 179, onChange: (val) => this._fieldOfView = val\r\n        });\r\n        this.exposeProperty(\"nearPlane\", \"number\", 0.1, {\r\n            min: 0.01, max: 10, step: 0.01, onChange: (val) => this._nearPlane = val\r\n        });\r\n        this.exposeProperty(\"farPlane\", \"number\", 1000, {\r\n            min: 10, max: 10000, step: 1, onChange: (val) => this._farPlane = val\r\n        });\r\n        this.exposeProperty(\"isActive\", \"boolean\", false, {\r\n            onChange: (val) => {\r\n                this._isActive = val;\r\n                if (val) this.setAsActiveCamera();\r\n            }\r\n        });\r\n        this.exposeProperty(\"backgroundColor\", \"color\", \"#000000\", {\r\n            onChange: (val) => this._backgroundColor = val\r\n        });\r\n        this.exposeProperty(\"drawGizmoInRuntime\", \"boolean\", false, {\r\n            onChange: (val) => this.drawGizmoInRuntime = val\r\n        });\r\n        this.exposeProperty(\"renderTextureWidth\", \"number\", 512, {\r\n            min: 64, max: 2048, step: 64,\r\n            onChange: (val) => {\r\n                this._renderTextureWidth = val;\r\n                this.updateRenderTexture();\r\n            }\r\n        });\r\n        this.exposeProperty(\"renderTextureHeight\", \"number\", 512, {\r\n            min: 64, max: 2048, step: 64,\r\n            onChange: (val) => {\r\n                this._renderTextureHeight = val;\r\n                this.updateRenderTexture();\r\n            }\r\n        });\r\n        this.exposeProperty(\"renderTextureSmoothing\", \"boolean\", false, {\r\n            onChange: (val) => this._renderTextureSmoothing = val\r\n        });\r\n        this.exposeProperty(\"renderingMethod\", \"dropdown\", \"painter\", {\r\n            options: [\"painter\", \"zbuffer\", \"scanline\", \"raytrace\"],\r\n            onChange: (val) => this._renderingMethod = val\r\n        });\r\n        this.exposeProperty(\"enableBackfaceCulling\", \"boolean\", true, {\r\n            onChange: (val) => this._enableBackfaceCulling = val\r\n        });\r\n\r\n        this.updateRenderTexture();\r\n    }\r\n\r\n    setAsActiveCamera() {\r\n        if (!this.gameObject) return;\r\n        const allObjects = this.getGameObjects();\r\n        allObjects.forEach(obj => {\r\n            const camera = obj.getModule(\"Camera3D\");\r\n            if (camera && camera !== this) camera._isActive = false;\r\n        });\r\n        this._isActive = true;\r\n    }\r\n\r\n    getGameObjects() {\r\n        if (!this.gameObject) return [];\r\n        return this.getAllGameObjects();\r\n    }\r\n\r\n    projectPoint(point) {\r\n        const cameraPoint = this.worldToCameraSpace(point);\r\n        const depth = cameraPoint.x;\r\n        if (depth <= this.nearPlane || depth >= this.farPlane) return null;\r\n        const aspect = this.viewportWidth / this.viewportHeight;\r\n        const fovRadians = this.fieldOfView * (Math.PI / 180);\r\n        const f = 1.0 / Math.tan(fovRadians * 0.5);\r\n        if (depth < 1e-6) return null;\r\n        const ndcX = (cameraPoint.y / depth) * (f / aspect);\r\n        const ndcY = (cameraPoint.z / depth) * f;\r\n        const screenX = (ndcX * 0.5 + 0.5) * this.viewportWidth;\r\n        const screenY = (0.5 - ndcY * 0.5) * this.viewportHeight;\r\n        return new Vector2(screenX, screenY);\r\n    }\r\n\r\n    worldToCameraSpace(point) {\r\n        const goPos = (this.gameObject && this.gameObject.getWorldPosition) ?\r\n            this.gameObject.getWorldPosition() : { x: 0, y: 0 };\r\n        let goDepth = 0;\r\n        if (this.gameObject) {\r\n            if (typeof this.gameObject.getWorldDepth === 'function') {\r\n                goDepth = this.gameObject.getWorldDepth();\r\n            } else if (typeof this.gameObject.depth === 'number') {\r\n                goDepth = this.gameObject.depth;\r\n            } else if (this.gameObject.position && this.gameObject.position.z) {\r\n                goDepth = this.gameObject.position.z;\r\n            }\r\n        }\r\n        const camWorldX = (goPos.x || 0) + (this._position.x || 0);\r\n        const camWorldY = (goPos.y || 0) + (this._position.y || 0);\r\n        const camWorldZ = goDepth + (this._position.z || 0);\r\n        const cameraPos = new Vector3(camWorldX, camWorldY, camWorldZ);\r\n        const parentAngleDeg = (this.gameObject && this.gameObject.getWorldRotation) ?\r\n            this.gameObject.getWorldRotation() : 0;\r\n        const yaw = (parentAngleDeg + (this._rotation.z || 0)) * (Math.PI / 180);\r\n        const pitch = (this._rotation.y || 0) * (Math.PI / 180);\r\n        const roll = (this._rotation.x || 0) * (Math.PI / 180);\r\n        let relativePos = this.subtractVector3(point, cameraPos);\r\n        relativePos = this.rotateVectorZ(relativePos, -yaw);\r\n        relativePos = this.rotateVectorY(relativePos, -pitch);\r\n        relativePos = this.rotateVectorX(relativePos, -roll);\r\n        return relativePos;\r\n    }\r\n\r\n    subtractVector3(a, b) {\r\n        return new Vector3(a.x - b.x, a.y - b.y, a.z - b.z);\r\n    }\r\n\r\n    rotateVectorX(v, angle) {\r\n        const cos = Math.cos(angle), sin = Math.sin(angle);\r\n        return new Vector3(v.x, v.y * cos - v.z * sin, v.y * sin + v.z * cos);\r\n    }\r\n\r\n    rotateVectorY(v, angle) {\r\n        const cos = Math.cos(angle), sin = Math.sin(angle);\r\n        return new Vector3(v.x * cos + v.z * sin, v.y, -v.x * sin + v.z * cos);\r\n    }\r\n\r\n    rotateVectorZ(v, angle) {\r\n        const cos = Math.cos(angle), sin = Math.sin(angle);\r\n        return new Vector3(v.x * cos - v.y * sin, v.x * sin + v.y * cos, v.z);\r\n    }\r\n\r\n    clipPolygonAgainstNearPlane(vertices, nearPlane) {\r\n        if (!vertices || vertices.length === 0) return [];\r\n        const out = [];\r\n        const epsilon = 0.0001;\r\n        for (let i = 0; i < vertices.length; i++) {\r\n            const a = vertices[i];\r\n            const b = vertices[(i + 1) % vertices.length];\r\n            const aIn = a.x >= nearPlane - epsilon;\r\n            const bIn = b.x >= nearPlane - epsilon;\r\n            if (aIn && bIn) {\r\n                out.push(b);\r\n            } else if (aIn && !bIn) {\r\n                const t = Math.max(0, Math.min(1, (nearPlane - a.x) / (b.x - a.x)));\r\n                out.push(new Vector3(nearPlane, a.y + t * (b.y - a.y), a.z + t * (b.z - a.z)));\r\n            } else if (!aIn && bIn) {\r\n                const t = Math.max(0, Math.min(1, (nearPlane - a.x) / (b.x - a.x)));\r\n                out.push(new Vector3(nearPlane, a.y + t * (b.y - a.y), a.z + t * (b.z - a.z)));\r\n                out.push(b);\r\n            }\r\n        }\r\n        return out;\r\n    }\r\n\r\n    projectCameraPoint(cameraPoint) {\r\n        const depth = cameraPoint.x;\r\n        if (depth <= 1e-6) return null;\r\n        const aspect = this.viewportWidth / this.viewportHeight;\r\n        const fovRadians = this.fieldOfView * (Math.PI / 180);\r\n        const f = 1.0 / Math.tan(fovRadians * 0.5);\r\n        const ndcX = (cameraPoint.y / depth) * (f / aspect);\r\n        const ndcY = (cameraPoint.z / depth) * f;\r\n        const screenX = (ndcX * 0.5 + 0.5) * this.viewportWidth;\r\n        const screenY = (0.5 - ndcY * 0.5) * this.viewportHeight;\r\n        return new Vector2(screenX, screenY);\r\n    }\r\n\r\n    isPointVisible(point) {\r\n        const cameraPoint = this.worldToCameraSpace(point);\r\n        return cameraPoint.x >= this.nearPlane && cameraPoint.x <= this.farPlane;\r\n    }\r\n\r\n    updateRenderTexture() {\r\n        if (!this._renderTexture || this._renderTexture.width !== this._renderTextureWidth ||\r\n            this._renderTexture.height !== this._renderTextureHeight) {\r\n            this._renderTexture = document.createElement('canvas');\r\n            this._renderTexture.width = this._renderTextureWidth;\r\n            this._renderTexture.height = this._renderTextureHeight;\r\n            this._renderTextureCtx = this._renderTexture.getContext('2d');\r\n            this.viewportWidth = this._renderTextureWidth;\r\n            this.viewportHeight = this._renderTextureHeight;\r\n            this._zBuffer = new Float32Array(this._renderTextureWidth * this._renderTextureHeight);\r\n            this._imageData = this._renderTextureCtx.createImageData(this._renderTextureWidth, this._renderTextureHeight);\r\n        }\r\n    }\r\n\r\n    getRenderTexture() { return this._renderTexture; }\r\n    getRenderTextureContext() { return this._renderTextureCtx; }\r\n\r\n    clearRenderTexture() {\r\n        if (!this._renderTextureCtx) return;\r\n        this._renderTextureCtx.imageSmoothingEnabled = this._renderTextureSmoothing;\r\n        this._renderTextureCtx.fillStyle = this._backgroundColor;\r\n        this._renderTextureCtx.fillRect(0, 0, this._renderTextureWidth, this._renderTextureHeight);\r\n        if (this._zBuffer) this._zBuffer.fill(Infinity);\r\n    }\r\n\r\n    updateViewport() {\r\n        this.viewportWidth = this._renderTextureWidth;\r\n        this.viewportHeight = this._renderTextureHeight;\r\n    }\r\n\r\n    calculateScreenNormal(vertices) {\r\n        if (vertices.length < 3) return 0;\r\n        const v0 = vertices[0], v1 = vertices[1], v2 = vertices[2];\r\n        const edge1 = { x: v1.x - v0.x, y: v1.y - v0.y };\r\n        const edge2 = { x: v2.x - v0.x, y: v2.y - v0.y };\r\n        return edge1.x * edge2.y - edge1.y * edge2.x;\r\n    }\r\n\r\n    drawTexturedTriangle(ctx, vertices, uvs, texture) {\r\n        if (!texture || vertices.length !== 3 || uvs.length !== 3) return;\r\n        ctx.save();\r\n        ctx.beginPath();\r\n        ctx.moveTo(vertices[0].x, vertices[0].y);\r\n        ctx.lineTo(vertices[1].x, vertices[1].y);\r\n        ctx.lineTo(vertices[2].x, vertices[2].y);\r\n        ctx.closePath();\r\n        ctx.clip();\r\n        const x0 = vertices[0].x, y0 = vertices[0].y;\r\n        const x1 = vertices[1].x, y1 = vertices[1].y;\r\n        const x2 = vertices[2].x, y2 = vertices[2].y;\r\n        const u0 = uvs[0].x * texture.width, v0 = uvs[0].y * texture.height;\r\n        const u1 = uvs[1].x * texture.width, v1 = uvs[1].y * texture.height;\r\n        const u2 = uvs[2].x * texture.width, v2 = uvs[2].y * texture.height;\r\n        const det = u0 * (v1 - v2) - u1 * (v0 - v2) + u2 * (v0 - v1);\r\n        if (Math.abs(det) > 0.0001) {\r\n            const a = (x0 * (v1 - v2) - x1 * (v0 - v2) + x2 * (v0 - v1)) / det;\r\n            const b = (x0 * (u2 - u1) - x1 * (u2 - u0) + x2 * (u1 - u0)) / det;\r\n            const c = (x0 * (u1 * v2 - u2 * v1) - x1 * (u0 * v2 - u2 * v0) + x2 * (u0 * v1 - u1 * v0)) / det;\r\n            const d = (y0 * (v1 - v2) - y1 * (v0 - v2) + y2 * (v0 - v1)) / det;\r\n            const e = (y0 * (u2 - u1) - y1 * (u2 - u0) + y2 * (u1 - u0)) / det;\r\n            const f = (y0 * (u1 * v2 - u2 * v1) - y1 * (u0 * v2 - u2 * v0) + y2 * (u0 * v1 - u1 * v0)) / det;\r\n            ctx.transform(a, d, b, e, c, f);\r\n            ctx.drawImage(texture, 0, 0);\r\n        }\r\n        ctx.restore();\r\n    }\r\n\r\n    renderPainter() {\r\n        const allObjects = this.getGameObjects();\r\n        const allFaces = [];\r\n        allObjects.forEach(obj => {\r\n            if (!obj.active) return;\r\n            const mesh = obj.getModule(\"Mesh3D\") || obj.getModule(\"CubeMesh3D\");\r\n            if (!mesh) return;\r\n            const transformedVertices = mesh.transformVertices();\r\n            if (!transformedVertices || !mesh.faces) return;\r\n            let texture = null, uvCoords = null;\r\n            if (mesh.texture && (mesh.texture instanceof Image || mesh.texture instanceof HTMLCanvasElement)) {\r\n                texture = mesh.texture;\r\n                uvCoords = mesh.uvCoords || mesh.generateDefaultUVs();\r\n            }\r\n            mesh.faces.forEach((face, faceIndex) => {\r\n                const cameraSpaceVertices = face.map(idx => \r\n                    idx < transformedVertices.length ? this.worldToCameraSpace(transformedVertices[idx]) : null\r\n                ).filter(v => v);\r\n                if (cameraSpaceVertices.length > 0) {\r\n                    const visibleVerts = cameraSpaceVertices.filter(v => v.x > this._nearPlane);\r\n                    const centerDepth = visibleVerts.length > 0 ?\r\n                        visibleVerts.reduce((sum, v) => sum + v.x, 0) / visibleVerts.length :\r\n                        this._farPlane + 1;\r\n                    allFaces.push({\r\n                        face, depth: centerDepth, mesh, transformedVertices,\r\n                        cameraSpaceVertices, texture,\r\n                        faceUVs: texture && uvCoords && uvCoords[faceIndex] ? uvCoords[faceIndex] : null\r\n                    });\r\n                }\r\n            });\r\n        });\r\n        allFaces.sort((a, b) => b.depth - a.depth);\r\n        const ctx = this._renderTextureCtx;\r\n        allFaces.forEach(({ cameraSpaceVertices, mesh, texture, faceUVs }) => {\r\n            const clippedVerts = this.clipPolygonAgainstNearPlane(cameraSpaceVertices, this._nearPlane);\r\n            if (clippedVerts.length < 3) return;\r\n            const screenVerts = clippedVerts.map(cv => \r\n                cv.x < this._farPlane ? this.projectCameraPoint(cv) : null\r\n            ).filter(v => v);\r\n            if (screenVerts.length < 3) return;\r\n            if (this._enableBackfaceCulling && this.calculateScreenNormal(screenVerts) < 0) return;\r\n            ctx.save();\r\n            ctx.beginPath();\r\n            ctx.rect(0, 0, this.viewportWidth, this.viewportHeight);\r\n            ctx.clip();\r\n            if (texture && faceUVs && faceUVs.length >= 3) {\r\n                for (let i = 1; i < screenVerts.length - 1; i++) {\r\n                    this.drawTexturedTriangle(ctx, \r\n                        [screenVerts[0], screenVerts[i], screenVerts[i + 1]],\r\n                        [faceUVs[0], faceUVs[i] || faceUVs[1], faceUVs[i + 1] || faceUVs[2]],\r\n                        texture);\r\n                }\r\n            } else {\r\n                if (mesh.renderMode === \"solid\" || mesh.renderMode === \"both\") {\r\n                    ctx.fillStyle = mesh.faceColor || mesh._faceColor;\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(screenVerts[0].x, screenVerts[0].y);\r\n                    for (let i = 1; i < screenVerts.length; i++) ctx.lineTo(screenVerts[i].x, screenVerts[i].y);\r\n                    ctx.closePath();\r\n                    ctx.fill();\r\n                }\r\n            }\r\n            if (mesh.renderMode === \"wireframe\" || mesh.renderMode === \"both\") {\r\n                ctx.strokeStyle = mesh.wireframeColor || mesh._wireframeColor;\r\n                ctx.lineWidth = 1;\r\n                ctx.beginPath();\r\n                ctx.moveTo(screenVerts[0].x, screenVerts[0].y);\r\n                for (let i = 1; i < screenVerts.length; i++) ctx.lineTo(screenVerts[i].x, screenVerts[i].y);\r\n                ctx.closePath();\r\n                ctx.stroke();\r\n            }\r\n            ctx.restore();\r\n        });\r\n    }\r\n\r\n    renderZBuffer() {\r\n        const allObjects = this.getGameObjects();\r\n        const ctx = this._renderTextureCtx;\r\n        const imgData = this._imageData;\r\n        const data = imgData.data;\r\n        const w = this._renderTextureWidth, h = this._renderTextureHeight;\r\n        const bgColor = this.hexToRgb(this._backgroundColor);\r\n        for (let i = 0; i < data.length; i += 4) {\r\n            data[i] = bgColor.r; data[i + 1] = bgColor.g; data[i + 2] = bgColor.b; data[i + 3] = 255;\r\n        }\r\n        allObjects.forEach(obj => {\r\n            if (!obj.active) return;\r\n            const mesh = obj.getModule(\"Mesh3D\") || obj.getModule(\"CubeMesh3D\");\r\n            if (!mesh) return;\r\n            const transformedVertices = mesh.transformVertices();\r\n            if (!transformedVertices || !mesh.faces) return;\r\n            const faceColor = mesh.faceColor || mesh._faceColor || \"#888888\";\r\n            const rgb = this.hexToRgb(faceColor);\r\n            mesh.faces.forEach(face => {\r\n                const cameraVerts = face.map(idx => \r\n                    idx < transformedVertices.length ? this.worldToCameraSpace(transformedVertices[idx]) : null\r\n                ).filter(v => v);\r\n                const clippedVerts = this.clipPolygonAgainstNearPlane(cameraVerts, this._nearPlane);\r\n                if (clippedVerts.length < 3) return;\r\n                const screenVerts = clippedVerts.map(cv => {\r\n                    const proj = this.projectCameraPoint(cv);\r\n                    return proj ? { screen: proj, depth: cv.x } : null;\r\n                }).filter(v => v);\r\n                if (screenVerts.length < 3) return;\r\n                if (this._enableBackfaceCulling) {\r\n                    const sVerts = screenVerts.map(v => v.screen);\r\n                    if (this.calculateScreenNormal(sVerts) < 0) return;\r\n                }\r\n                for (let i = 1; i < screenVerts.length - 1; i++) {\r\n                    this.rasterizeTriangle(screenVerts[0], screenVerts[i], screenVerts[i + 1], rgb, data, w, h);\r\n                }\r\n            });\r\n        });\r\n        ctx.putImageData(imgData, 0, 0);\r\n    }\r\n\r\n    rasterizeTriangle(v0, v1, v2, color, data, w, h) {\r\n        const p0 = { x: Math.round(v0.screen.x), y: Math.round(v0.screen.y), z: v0.depth };\r\n        const p1 = { x: Math.round(v1.screen.x), y: Math.round(v1.screen.y), z: v1.depth };\r\n        const p2 = { x: Math.round(v2.screen.x), y: Math.round(v2.screen.y), z: v2.depth };\r\n        const minX = Math.max(0, Math.min(p0.x, p1.x, p2.x));\r\n        const maxX = Math.min(w - 1, Math.max(p0.x, p1.x, p2.x));\r\n        const minY = Math.max(0, Math.min(p0.y, p1.y, p2.y));\r\n        const maxY = Math.min(h - 1, Math.max(p0.y, p1.y, p2.y));\r\n        for (let y = minY; y <= maxY; y++) {\r\n            for (let x = minX; x <= maxX; x++) {\r\n                const bary = this.barycentric(p0, p1, p2, x, y);\r\n                if (bary.u >= 0 && bary.v >= 0 && bary.w >= 0) {\r\n                    const depth = bary.u * p0.z + bary.v * p1.z + bary.w * p2.z;\r\n                    const idx = y * w + x;\r\n                    if (depth < this._zBuffer[idx]) {\r\n                        this._zBuffer[idx] = depth;\r\n                        const pixelIdx = idx * 4;\r\n                        data[pixelIdx] = color.r; data[pixelIdx + 1] = color.g;\r\n                        data[pixelIdx + 2] = color.b; data[pixelIdx + 3] = 255;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    barycentric(p0, p1, p2, x, y) {\r\n        const denom = (p1.y - p2.y) * (p0.x - p2.x) + (p2.x - p1.x) * (p0.y - p2.y);\r\n        if (Math.abs(denom) < 0.001) return { u: -1, v: -1, w: -1 };\r\n        const u = ((p1.y - p2.y) * (x - p2.x) + (p2.x - p1.x) * (y - p2.y)) / denom;\r\n        const v = ((p2.y - p0.y) * (x - p2.x) + (p0.x - p2.x) * (y - p2.y)) / denom;\r\n        return { u, v, w: 1 - u - v };\r\n    }\r\n\r\n    hexToRgb(hex) {\r\n        const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n        return result ? {\r\n            r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16)\r\n        } : { r: 0, g: 0, b: 0 };\r\n    }\r\n\r\n    calculateTriangleColor(material, faceUVs, vertexIndices) {\r\n        if (!material) {\r\n            // No material, use default color\r\n            return this.hexToRgb(\"#888888\");\r\n        }\r\n\r\n        // If we have UV coordinates, sample texture at triangle center\r\n        if (faceUVs && faceUVs.length >= 3 && vertexIndices.length >= 3) {\r\n            // Calculate centroid UV coordinates\r\n            const u = (faceUVs[vertexIndices[0]].x + faceUVs[vertexIndices[1]].x + faceUVs[vertexIndices[2]].x) / 3;\r\n            const v = (faceUVs[vertexIndices[0]].y + faceUVs[vertexIndices[1]].y + faceUVs[vertexIndices[2]].y) / 3;\r\n\r\n            // Use material's texture sampling\r\n            if (typeof material.sampleTexture === 'function') {\r\n                const colorStr = material.sampleTexture(u, v);\r\n                return this.parseColorString(colorStr);\r\n            }\r\n        }\r\n\r\n        // No texture or no UVs, return diffuse color\r\n        const diffuseColor = material.diffuseColor || \"#FFFFFF\";\r\n        return this.hexToRgb(diffuseColor);\r\n    }\r\n\r\n    parseColorString(colorStr) {\r\n        // Parse rgba(r, g, b, a) format\r\n        const match = colorStr.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*([\\d.]+))?\\)/);\r\n        if (match) {\r\n            return {\r\n                r: parseInt(match[1]),\r\n                g: parseInt(match[2]),\r\n                b: parseInt(match[3]),\r\n                a: Math.floor((match[4] !== undefined ? parseFloat(match[4]) : 1.0) * 255)\r\n            };\r\n        }\r\n        return this.hexToRgb(\"#FFFFFF\");\r\n    }\r\n\r\n    renderScanline() {\r\n        const allObjects = this.getGameObjects();\r\n        const ctx = this._renderTextureCtx;\r\n        const w = this._renderTextureWidth, h = this._renderTextureHeight;\r\n        const scanlines = Array.from({ length: h }, () => []);\r\n        allObjects.forEach(obj => {\r\n            if (!obj.active) return;\r\n            const mesh = obj.getModule(\"Mesh3D\") || obj.getModule(\"CubeMesh3D\");\r\n            if (!mesh) return;\r\n            const transformedVertices = mesh.transformVertices();\r\n            if (!transformedVertices || !mesh.faces) return;\r\n            const faceColor = mesh.faceColor || mesh._faceColor || \"#888888\";\r\n            mesh.faces.forEach(face => {\r\n                const cameraVerts = face.map(idx => \r\n                    idx < transformedVertices.length ? this.worldToCameraSpace(transformedVertices[idx]) : null\r\n                ).filter(v => v);\r\n                const clippedVerts = this.clipPolygonAgainstNearPlane(cameraVerts, this._nearPlane);\r\n                if (clippedVerts.length < 3) return;\r\n                const screenVerts = clippedVerts.map(cv => {\r\n                    const proj = this.projectCameraPoint(cv);\r\n                    return proj ? { screen: proj, depth: cv.x } : null;\r\n                }).filter(v => v);\r\n                if (screenVerts.length < 3) return;\r\n                for (let i = 1; i < screenVerts.length - 1; i++) {\r\n                    const tri = [screenVerts[0], screenVerts[i], screenVerts[i + 1]];\r\n                    this.addTriangleToScanlines(tri, faceColor, scanlines, w, h);\r\n                }\r\n            });\r\n        });\r\n        for (let y = 0; y < h; y++) {\r\n            const edges = scanlines[y];\r\n            if (edges.length === 0) continue;\r\n            edges.sort((a, b) => a.x - b.x);\r\n            for (let i = 0; i < edges.length - 1; i += 2) {\r\n                const x1 = Math.max(0, Math.ceil(edges[i].x));\r\n                const x2 = Math.min(w - 1, Math.floor(edges[i + 1].x));\r\n                const z1 = edges[i].z, z2 = edges[i + 1].z;\r\n                ctx.fillStyle = edges[i].color;\r\n                for (let x = x1; x <= x2; x++) {\r\n                    const t = (x2 - x1) > 0 ? (x - x1) / (x2 - x1) : 0;\r\n                    const z = z1 + t * (z2 - z1);\r\n                    const idx = y * w + x;\r\n                    if (z < this._zBuffer[idx]) {\r\n                        this._zBuffer[idx] = z;\r\n                        ctx.fillRect(x, y, 1, 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    addTriangleToScanlines(tri, color, scanlines, w, h) {\r\n        for (let i = 0; i < 3; i++) {\r\n            const v0 = tri[i], v1 = tri[(i + 1) % 3];\r\n            let y0 = Math.round(v0.screen.y), y1 = Math.round(v1.screen.y);\r\n            let x0 = v0.screen.x, x1 = v1.screen.x, z0 = v0.depth, z1 = v1.depth;\r\n            if (y0 > y1) {\r\n                [y0, y1] = [y1, y0]; [x0, x1] = [x1, x0]; [z0, z1] = [z1, z0];\r\n            }\r\n            if (y0 === y1) continue;\r\n            for (let y = Math.max(0, y0); y <= Math.min(h - 1, y1); y++) {\r\n                const t = (y - y0) / (y1 - y0);\r\n                scanlines[y].push({ x: x0 + t * (x1 - x0), z: z0 + t * (z1 - z0), color });\r\n            }\r\n        }\r\n    }\r\n\r\n    renderRaytrace() {\r\n        const allObjects = this.getGameObjects();\r\n        const ctx = this._renderTextureCtx;\r\n        const imgData = this._imageData;\r\n        const data = imgData.data;\r\n        const w = this._renderTextureWidth, h = this._renderTextureHeight;\r\n        const bgColor = this.hexToRgb(this._backgroundColor);\r\n        const aspect = w / h;\r\n        const fovRadians = this.fieldOfView * (Math.PI / 180);\r\n        const tanHalfFov = Math.tan(fovRadians * 0.5);\r\n        const allTriangles = [];\r\n        allObjects.forEach(obj => {\r\n            if (!obj.active) return;\r\n            const mesh = obj.getModule(\"Mesh3D\") || obj.getModule(\"CubeMesh3D\");\r\n            if (!mesh) return;\r\n            const material = obj.getModule(\"Material\");\r\n            const transformedVertices = mesh.transformVertices();\r\n            if (!transformedVertices || !mesh.faces) return;\r\n\r\n            // Get UV coordinates for texture mapping\r\n            const uvCoords = mesh.uvCoords || mesh.generateDefaultUVs();\r\n\r\n            mesh.faces.forEach((face, faceIndex) => {\r\n                const cameraVerts = face.map(idx =>\r\n                    idx < transformedVertices.length ? this.worldToCameraSpace(transformedVertices[idx]) : null\r\n                ).filter(v => v);\r\n                if (cameraVerts.length < 3) return;\r\n\r\n                // Get UV coordinates for this face\r\n                const faceUVs = uvCoords && uvCoords[faceIndex] ? uvCoords[faceIndex] : null;\r\n\r\n                for (let i = 1; i < cameraVerts.length - 1; i++) {\r\n                    // Calculate average color for this triangle using material system\r\n                    const color = this.calculateTriangleColor(material, faceUVs, [0, i, i + 1]);\r\n\r\n                    allTriangles.push({\r\n                        v0: cameraVerts[0], v1: cameraVerts[i], v2: cameraVerts[i + 1],\r\n                        color: color\r\n                    });\r\n                }\r\n            });\r\n        });\r\n        for (let y = 0; y < h; y++) {\r\n            for (let x = 0; x < w; x++) {\r\n                const pixelIdx = (y * w + x) * 4;\r\n                const u = (x / w) * 2 - 1;\r\n                const v = 1 - (y / h) * 2;\r\n                const rayDirX = 1;\r\n                const rayDirY = u * tanHalfFov * aspect;\r\n                const rayDirZ = v * tanHalfFov;\r\n                const rayLen = Math.sqrt(rayDirX * rayDirX + rayDirY * rayDirY + rayDirZ * rayDirZ);\r\n                const rayDir = { x: rayDirX / rayLen, y: rayDirY / rayLen, z: rayDirZ / rayLen };\r\n                const rayOrigin = { x: 0, y: 0, z: 0 };\r\n                let closestT = Infinity;\r\n                let hitColor = null;\r\n                allTriangles.forEach(tri => {\r\n                    const t = this.rayTriangleIntersect(rayOrigin, rayDir, tri.v0, tri.v1, tri.v2);\r\n                    if (t !== null && t < closestT && t >= this._nearPlane && t <= this._farPlane) {\r\n                        closestT = t;\r\n                        hitColor = tri.color;\r\n                    }\r\n                });\r\n                if (hitColor) {\r\n                    data[pixelIdx] = hitColor.r;\r\n                    data[pixelIdx + 1] = hitColor.g;\r\n                    data[pixelIdx + 2] = hitColor.b;\r\n                    data[pixelIdx + 3] = 255;\r\n                } else {\r\n                    data[pixelIdx] = bgColor.r;\r\n                    data[pixelIdx + 1] = bgColor.g;\r\n                    data[pixelIdx + 2] = bgColor.b;\r\n                    data[pixelIdx + 3] = 255;\r\n                }\r\n            }\r\n        }\r\n        ctx.putImageData(imgData, 0, 0);\r\n    }\r\n\r\n    rayTriangleIntersect(origin, dir, v0, v1, v2) {\r\n        const edge1 = { x: v1.x - v0.x, y: v1.y - v0.y, z: v1.z - v0.z };\r\n        const edge2 = { x: v2.x - v0.x, y: v2.y - v0.y, z: v2.z - v0.z };\r\n        const h = {\r\n            x: dir.y * edge2.z - dir.z * edge2.y,\r\n            y: dir.z * edge2.x - dir.x * edge2.z,\r\n            z: dir.x * edge2.y - dir.y * edge2.x\r\n        };\r\n        const a = edge1.x * h.x + edge1.y * h.y + edge1.z * h.z;\r\n        if (Math.abs(a) < 0.0001) return null;\r\n        const f = 1 / a;\r\n        const s = { x: origin.x - v0.x, y: origin.y - v0.y, z: origin.z - v0.z };\r\n        const u = f * (s.x * h.x + s.y * h.y + s.z * h.z);\r\n        if (u < 0 || u > 1) return null;\r\n        const q = {\r\n            x: s.y * edge1.z - s.z * edge1.y,\r\n            y: s.z * edge1.x - s.x * edge1.z,\r\n            z: s.x * edge1.y - s.y * edge1.x\r\n        };\r\n        const v = f * (dir.x * q.x + dir.y * q.y + dir.z * q.z);\r\n        if (v < 0 || u + v > 1) return null;\r\n        const t = f * (edge2.x * q.x + edge2.y * q.y + edge2.z * q.z);\r\n        return t > 0.0001 ? t : null;\r\n    }\r\n\r\n    render3D() {\r\n        if (!this._renderTextureCtx || !this._isActive) return;\r\n        this.clearRenderTexture();\r\n        switch (this._renderingMethod) {\r\n            case \"painter\": this.renderPainter(); break;\r\n            case \"zbuffer\": this.renderZBuffer(); break;\r\n            case \"scanline\": this.renderScanline(); break;\r\n            case \"raytrace\": this.renderRaytrace(); break;\r\n            default: this.renderPainter();\r\n        }\r\n    }\r\n\r\n    getRenderedTexture() {\r\n        if (!this._isActive) return null;\r\n        this.render3D();\r\n        return this._renderTexture;\r\n    }\r\n\r\n    drawRenderedTexture(ctx, x = 0, y = 0, width = null, height = null) {\r\n        if (!this._renderTexture || !this._isActive) return;\r\n        ctx.imageSmoothingEnabled = this._renderTextureSmoothing;\r\n        const drawWidth = width || this._renderTextureWidth;\r\n        const drawHeight = height || this._renderTextureHeight;\r\n        ctx.drawImage(this._renderTexture, x, y, drawWidth, drawHeight);\r\n    }\r\n\r\n    start() {\r\n        this.updateViewport();\r\n        this.updateRenderTexture();\r\n        const cameras = this.getGameObjects()\r\n            .map(obj => obj.getModule(\"Camera3D\"))\r\n            .filter(cam => cam !== null);\r\n        if (cameras.length === 1 && cameras[0] === this) this._isActive = true;\r\n    }\r\n\r\n    beginLoop() { this.updateViewport(); }\r\n    draw(ctx) {}\r\n    drawGizmos(ctx) {} // Implement if needed\r\n\r\n    toJSON() {\r\n        return {\r\n            _type: \"Camera3D\", _position: { x: this._position.x, y: this._position.y, z: this._position.z },\r\n            _rotation: { x: this._rotation.x, y: this._rotation.y, z: this._rotation.z },\r\n            _fieldOfView: this._fieldOfView, _nearPlane: this._nearPlane, _farPlane: this._farPlane,\r\n            _isActive: this._isActive, _backgroundColor: this._backgroundColor,\r\n            _renderTextureWidth: this._renderTextureWidth, _renderTextureHeight: this._renderTextureHeight,\r\n            _renderTextureSmoothing: this._renderTextureSmoothing, drawGizmoInRuntime: this.drawGizmoInRuntime,\r\n            _renderingMethod: this._renderingMethod, _enableBackfaceCulling: this._enableBackfaceCulling\r\n        };\r\n    }\r\n\r\n    fromJSON(json) {\r\n        if (json._position) this._position = new Vector3(json._position.x, json._position.y, json._position.z);\r\n        if (json._rotation) this._rotation = new Vector3(json._rotation.x, json._rotation.y, json._rotation.z);\r\n        if (json._fieldOfView !== undefined) this._fieldOfView = json._fieldOfView;\r\n        if (json._nearPlane !== undefined) this._nearPlane = json._nearPlane;\r\n        if (json._farPlane !== undefined) this._farPlane = json._farPlane;\r\n        if (json._isActive !== undefined) this._isActive = json._isActive;\r\n        if (json._backgroundColor !== undefined) this._backgroundColor = json._backgroundColor;\r\n        if (json._renderTextureWidth !== undefined) this._renderTextureWidth = json._renderTextureWidth;\r\n        if (json._renderTextureHeight !== undefined) this._renderTextureHeight = json._renderTextureHeight;\r\n        if (json._renderTextureSmoothing !== undefined) this._renderTextureSmoothing = json._renderTextureSmoothing;\r\n        if (json.drawGizmoInRuntime !== undefined) this.drawGizmoInRuntime = json.drawGizmoInRuntime;\r\n        if (json._renderingMethod !== undefined) this._renderingMethod = json._renderingMethod;\r\n        if (json._enableBackfaceCulling !== undefined) this._enableBackfaceCulling = json._enableBackfaceCulling;\r\n        this.updateRenderTexture();\r\n    }\r\n\r\n    get renderTextureWidth() { return this._renderTextureWidth; }\r\n    set renderTextureWidth(value) { this._renderTextureWidth = Math.max(64, Math.min(2048, value)); this.updateRenderTexture(); }\r\n    get renderTextureHeight() { return this._renderTextureHeight; }\r\n    set renderTextureHeight(value) { this._renderTextureHeight = Math.max(64, Math.min(2048, value)); this.updateRenderTexture(); }\r\n    get renderTextureSmoothing() { return this._renderTextureSmoothing; }\r\n    set renderTextureSmoothing(value) { this._renderTextureSmoothing = value; }\r\n    get backgroundColor() { return this._backgroundColor; }\r\n    set backgroundColor(value) { this._backgroundColor = value; }\r\n    get position() { return this._position; }\r\n    set position(value) { this._position = value; }\r\n    get rotation() { return this._rotation; }\r\n    set rotation(value) { this._rotation = value; }\r\n    get fieldOfView() { return this._fieldOfView; }\r\n    set fieldOfView(value) { this._fieldOfView = Math.max(1, Math.min(179, value)); }\r\n    get nearPlane() { return this._nearPlane; }\r\n    set nearPlane(value) { this._nearPlane = Math.max(0.01, value); }\r\n    get farPlane() { return this._farPlane; }\r\n    set farPlane(value) { this._farPlane = Math.max(1, value); }\r\n    get isActive() { return this._isActive; }\r\n    set isActive(value) { this._isActive = value; }\r\n}\r\n\r\nwindow.Camera3D = Camera3D;",
      "type": "file",
      "name": "Camera3DBasic.js",
      "parentPath": "/",
      "created": 1759457099328,
      "modified": 1759457110312
    },
    {
      "path": "/Camera3D.js",
      "content": "/**\r\n * Camera3D - Module for 3D perspective cameras\r\n * \r\n * This module provides 3D camera functionality with multiple rendering methods.\r\n * Supports: Painter's Algorithm, Z-Buffer, Scanline, and Raytracing.\r\n */\r\nclass Camera3D extends Module {\r\n    static namespace = \"3D\";\r\n\r\n    constructor() {\r\n        super(\"Camera3D\");\r\n\r\n        this._renderTextureGL = null;\r\n        this._renderTextureGLCtx = null;\r\n        this._useWebGLAcceleration = false;\r\n\r\n        this._position = new Vector3(0, 0, 0);\r\n        this._rotation = new Vector3(0, 0, 0);\r\n        this._fieldOfView = 60;\r\n        this._nearPlane = 0.1;\r\n        this._farPlane = 5000;\r\n        this._isActive = false;\r\n        this._backgroundColor = \"#000000\";\r\n        this._skyColor = \"#87CEEB\";  // Sky blue\r\n        this._floorColor = \"#8B4513\"; // Brown\r\n        this._backgroundType = \"skyfloor\"; // \"skyfloor\", \"transparent\", \"solid\"\r\n        this._renderTextureWidth = 320;\r\n        this._renderTextureHeight = 240;\r\n        this._renderTextureSmoothing = false;\r\n        this._renderTexture = null;\r\n        this._renderTextureCtx = null;\r\n        this.viewportWidth = 800;\r\n        this.viewportHeight = 600;\r\n        this.drawGizmoInRuntime = false;\r\n        this._renderingMethod = \"fald\";\r\n        this._enableBackfaceCulling = false;\r\n        this._disableCulling = true;\r\n        this._cullingFieldOfView = 60; // Use same FOV as main camera for consistent culling\r\n        this._zBuffer = null;\r\n        this._imageData = null;\r\n\r\n        this._lightDirection = new Vector3(1, -1, -1); // Default light direction\r\n        this._lightColor = \"#ffffff\";\r\n        this._lightIntensity = 1.0;\r\n        this._ambientIntensity = 0.3;\r\n\r\n        // Depth of field properties\r\n        this._depthOfFieldEnabled = false;\r\n        this._focalDistance = 100;\r\n        this._aperture = 50;\r\n        this._maxBlurRadius = 3;\r\n\r\n        this.exposeProperty(\"position\", \"vector3\", this._position, {\r\n            onChange: (val) => this._position = val\r\n        });\r\n        this.exposeProperty(\"rotation\", \"vector3\", this._rotation, {\r\n            onChange: (val) => this._rotation = val\r\n        });\r\n        this.exposeProperty(\"fieldOfView\", \"number\", 60, {\r\n            min: 1, max: 179, onChange: (val) => this._fieldOfView = val\r\n        });\r\n        this.exposeProperty(\"nearPlane\", \"number\", 0.1, {\r\n            min: 0.01, max: 10, step: 0.01, onChange: (val) => this._nearPlane = val\r\n        });\r\n        this.exposeProperty(\"farPlane\", \"number\", 1000, {\r\n            min: 10, max: 10000, step: 1, onChange: (val) => this._farPlane = val\r\n        });\r\n        this.exposeProperty(\"isActive\", \"boolean\", false, {\r\n            onChange: (val) => {\r\n                this._isActive = val;\r\n                if (val) this.setAsActiveCamera();\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"lightDirection\", \"vector3\", this._lightDirection, {\r\n            onChange: (val) => this._lightDirection = val\r\n        });\r\n        this.exposeProperty(\"lightColor\", \"color\", \"#ffffff\", {\r\n            onChange: (val) => this._lightColor = val\r\n        });\r\n        this.exposeProperty(\"lightIntensity\", \"number\", 1.0, {\r\n            min: 0, max: 2, step: 0.1, onChange: (val) => this._lightIntensity = val\r\n        });\r\n        this.exposeProperty(\"ambientIntensity\", \"number\", 0.3, {\r\n            min: 0, max: 1, step: 0.05, onChange: (val) => this._ambientIntensity = val\r\n        });\r\n\r\n        /*this.exposeProperty(\"depthOfFieldEnabled\", \"boolean\", false, {\r\n            onChange: (val) => this._depthOfFieldEnabled = val\r\n        });\r\n        this.exposeProperty(\"focalDistance\", \"number\", 100, {\r\n            min: 1, max: 1000, step: 1, onChange: (val) => this._focalDistance = val\r\n        });\r\n        this.exposeProperty(\"aperture\", \"number\", 50, {\r\n            min: 1, max: 200, step: 1, onChange: (val) => this._aperture = val\r\n        });\r\n        this.exposeProperty(\"maxBlurRadius\", \"number\", 3, {\r\n            min: 1, max: 10, step: 0.5, onChange: (val) => this._maxBlurRadius = val\r\n        });*/\r\n\r\n        this.exposeProperty(\"backgroundColor\", \"color\", \"#000000\", {\r\n            onChange: (val) => this._backgroundColor = val\r\n        });\r\n        this.exposeProperty(\"skyColor\", \"color\", \"#87CEEB\", {\r\n            onChange: (val) => this._skyColor = val\r\n        });\r\n        this.exposeProperty(\"floorColor\", \"color\", \"#8B4513\", {\r\n            onChange: (val) => this._floorColor = val\r\n        });\r\n        this.exposeProperty(\"backgroundType\", \"dropdown\", \"skyfloor\", {\r\n            options: [\"skyfloor\", \"transparent\", \"solid\"],\r\n            onChange: (val) => this._backgroundType = val\r\n        });\r\n        this.exposeProperty(\"drawGizmoInRuntime\", \"boolean\", false, {\r\n            onChange: (val) => this.drawGizmoInRuntime = val\r\n        });\r\n        this.exposeProperty(\"renderTextureWidth\", \"number\", 320, {\r\n            min: 64, max: 2048, step: 64,\r\n            onChange: (val) => {\r\n                this._renderTextureWidth = this._renderingMethod === \"raytrace\" ? Math.min(val, 160) : val;\r\n                this.updateRenderTexture();\r\n            }\r\n        });\r\n        this.exposeProperty(\"renderTextureHeight\", \"number\", 240, {\r\n            min: 64, max: 2048, step: 64,\r\n            onChange: (val) => {\r\n                this._renderTextureHeight = this._renderingMethod === \"raytrace\" ? Math.min(val, 120) : val;\r\n                this.updateRenderTexture();\r\n            }\r\n        });\r\n        this.exposeProperty(\"renderTextureSmoothing\", \"boolean\", false, {\r\n            onChange: (val) => this._renderTextureSmoothing = val\r\n        });\r\n        this.exposeProperty(\"renderingMethod\", \"dropdown\", \"fald\", {\r\n            options: [\"raster\", \"zbuffer\", \"depthpass\", \"painter\", \"rasterRaytraceHybrid\", \"doom\", \"ilpc\", \"fald\"],\r\n            onChange: (val) => {\r\n                this._renderingMethod = val;\r\n                if (val === \"raytrace\") {\r\n                    this._renderTextureWidth = Math.min(this._renderTextureWidth, 160);\r\n                    this._renderTextureHeight = Math.min(this._renderTextureHeight, 120);\r\n                    this.updateRenderTexture();\r\n                }\r\n            }\r\n        });\r\n        this.exposeProperty(\"enableBackfaceCulling\", \"boolean\", false, {\r\n            onChange: (val) => this._enableBackfaceCulling = val\r\n        });\r\n        this.exposeProperty(\"disableCulling\", \"boolean\", false, {\r\n            onChange: (val) => this._disableCulling = val\r\n        });\r\n        this.exposeProperty(\"cullingFieldOfView\", \"number\", 90, {\r\n            min: 1, max: 179, onChange: (val) => this._cullingFieldOfView = val\r\n        });\r\n\r\n        this.updateRenderTexture();\r\n    }\r\n\r\n    setAsActiveCamera() {\r\n        if (!this.gameObject) return;\r\n        const allObjects = this.getGameObjects();\r\n        allObjects.forEach(obj => {\r\n            const camera = obj.getModule(\"Camera3D\");\r\n            if (camera && camera !== this) camera._isActive = false;\r\n        });\r\n        this._isActive = true;\r\n    }\r\n\r\n    getGameObjects() {\r\n        if (!this.gameObject) return [];\r\n        return this.getAllGameObjects();\r\n    }\r\n\r\n    projectPoint(point) {\r\n        const cameraPoint = this.worldToCameraSpace(point);\r\n        const depth = -cameraPoint.z;  // Use Z as depth (negative because camera looks down -Z)\r\n        if (depth <= this.nearPlane || depth >= this.farPlane) return null;\r\n        const aspect = this.viewportWidth / this.viewportHeight;\r\n        const fovRadians = this.fieldOfView * (Math.PI / 180);\r\n        const f = 1.0 / Math.tan(fovRadians * 0.5);\r\n        if (depth < 1e-4) return null; // Increased from 1e-6 for better stability\r\n        const ndcX = (cameraPoint.x / depth) * (f / aspect);  // X becomes screen X\r\n        const ndcY = (cameraPoint.y / depth) * f;           // Y becomes screen Y\r\n        const screenX = (ndcX * 0.5 + 0.5) * this.viewportWidth;\r\n        const screenY = (0.5 - ndcY * 0.5) * this.viewportHeight;\r\n        return new Vector2(screenX, screenY);\r\n    }\r\n\r\n    worldToCameraSpace(point) {\r\n        const goPos = (this.gameObject && this.gameObject.getWorldPosition) ?\r\n            this.gameObject.getWorldPosition() : { x: 0, y: 0 };\r\n        let goDepth = 0;\r\n        if (this.gameObject) {\r\n            if (typeof this.gameObject.getWorldDepth === 'function') {\r\n                goDepth = this.gameObject.getWorldDepth();\r\n            } else if (typeof this.gameObject.depth === 'number') {\r\n                goDepth = this.gameObject.depth;\r\n            } else if (this.gameObject.position && this.gameObject.position.z) {\r\n                goDepth = this.gameObject.position.z;\r\n            }\r\n        }\r\n        const camWorldX = (goPos.x || 0) + (this._position.x || 0);\r\n        const camWorldY = (goPos.y || 0) + (this._position.y || 0);\r\n        const camWorldZ = goDepth + (this._position.z || 0);\r\n        const cameraPos = new Vector3(camWorldX, camWorldY, camWorldZ);\r\n        const parentAngleDeg = (this.gameObject && this.gameObject.getWorldRotation) ?\r\n            this.gameObject.getWorldRotation() : 0;\r\n        const yaw = (parentAngleDeg + (this._rotation.z || 0)) * (Math.PI / 180);\r\n        const pitch = (this._rotation.y || 0) * (Math.PI / 180);\r\n        const roll = (this._rotation.x || 0) * (Math.PI / 180);\r\n        let relativePos = this.subtractVector3(point, cameraPos);\r\n        relativePos = this.rotateVectorZ(relativePos, -yaw);\r\n        relativePos = this.rotateVectorY(relativePos, -pitch);\r\n        relativePos = this.rotateVectorX(relativePos, -roll);\r\n        return relativePos;\r\n    }\r\n\r\n    createWebGLRenderTexture() {\r\n        if (!this._useWebGLAcceleration) return false;\r\n\r\n        try {\r\n            // Create offscreen canvas for WebGL\r\n            const glCanvas = document.createElement('canvas');\r\n            glCanvas.width = this._renderTextureWidth;\r\n            glCanvas.height = this._renderTextureHeight;\r\n\r\n            // Try to get WebGL context\r\n            const gl = glCanvas.getContext('webgl', {\r\n                alpha: true,\r\n                antialias: false,\r\n                preserveDrawingBuffer: true,\r\n                powerPreference: 'high-performance'\r\n            }) || glCanvas.getContext('experimental-webgl', {\r\n                alpha: true,\r\n                antialias: false,\r\n                preserveDrawingBuffer: true,\r\n                powerPreference: 'high-performance'\r\n            });\r\n\r\n            if (!gl) {\r\n                console.warn(\"WebGL not available, falling back to 2D canvas\");\r\n                return false;\r\n            }\r\n\r\n            this._renderTextureGL = glCanvas;\r\n            this._renderTextureGLCtx = gl;\r\n\r\n            // Initialize WebGL shaders for triangle rasterization\r\n            this.initWebGLShaders();\r\n\r\n            return true;\r\n        } catch (e) {\r\n            console.warn(\"WebGL initialization failed:\", e);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    initWebGLRaytracingShaders() {\r\n        const gl = this._renderTextureGLCtx;\r\n\r\n        // Enable float texture extension if available\r\n        const floatExt = gl.getExtension('OES_texture_float');\r\n        if (!floatExt) {\r\n            console.warn('Float textures not supported, raytracing may not work correctly');\r\n            return false;\r\n        }\r\n\r\n        // Vertex shader - simple fullscreen quad\r\n        const vertexShaderSource = `\r\n        attribute vec2 a_position;\r\n        varying vec2 v_uv;\r\n        \r\n        void main() {\r\n            gl_Position = vec4(a_position, 0.0, 1.0);\r\n            v_uv = a_position * 0.5 + 0.5;\r\n        }\r\n    `;\r\n\r\n        // Fragment shader - GPU raytracer\r\n        const fragmentShaderSource = `\r\n        precision highp float;\r\n        \r\n        varying vec2 v_uv;\r\n        \r\n        // Camera uniforms\r\n        uniform vec3 u_cameraPos;\r\n        uniform mat3 u_cameraRotation;\r\n        uniform float u_fov;\r\n        uniform float u_nearPlane;\r\n        uniform float u_farPlane;\r\n        uniform vec2 u_resolution;\r\n        \r\n        // Lighting uniforms\r\n        uniform vec3 u_lightDir;\r\n        uniform vec3 u_lightColor;\r\n        uniform float u_lightIntensity;\r\n        uniform float u_ambientIntensity;\r\n        \r\n        // Background uniforms\r\n        uniform vec3 u_skyColor;\r\n        uniform vec3 u_floorColor;\r\n        uniform float u_horizonY;\r\n        uniform int u_backgroundType;\r\n        uniform vec3 u_backgroundColor;\r\n        \r\n        // Triangle data\r\n        uniform sampler2D u_triangleData;\r\n        uniform int u_triangleCount;\r\n        uniform float u_texWidth;\r\n        \r\n        // Ray-triangle intersection (MllerTrumbore algorithm)\r\n        bool rayTriangle(vec3 ro, vec3 rd, vec3 v0, vec3 v1, vec3 v2, out float t, out vec3 normal) {\r\n            vec3 e1 = v1 - v0;\r\n            vec3 e2 = v2 - v0;\r\n            vec3 h = cross(rd, e2);\r\n            float a = dot(e1, h);\r\n            \r\n            if (abs(a) < 0.0001) return false;\r\n            \r\n            float f = 1.0 / a;\r\n            vec3 s = ro - v0;\r\n            float u = f * dot(s, h);\r\n            \r\n            if (u < 0.0 || u > 1.0) return false;\r\n            \r\n            vec3 q = cross(s, e1);\r\n            float v = f * dot(rd, q);\r\n            \r\n            if (v < 0.0 || u + v > 1.0) return false;\r\n            \r\n            t = f * dot(e2, q);\r\n            \r\n            if (t > 0.00001) {\r\n                normal = normalize(cross(e1, e2));\r\n                return true;\r\n            }\r\n            \r\n            return false;\r\n        }\r\n        \r\n        // Fetch triangle vertices from texture\r\n        void getTriangle(int idx, out vec3 v0, out vec3 v1, out vec3 v2, out vec3 color) {\r\n            float texHeight = ceil(float(u_triangleCount) * 5.0 / u_texWidth);\r\n            \r\n            // Each triangle takes 5 texels: v0, v1, v2, color, normal\r\n            float baseIdx = float(idx) * 5.0;\r\n            float row = floor(baseIdx / u_texWidth);\r\n            float col = mod(baseIdx, u_texWidth);\r\n            \r\n            vec2 uv0 = vec2((col + 0.5) / u_texWidth, (row + 0.5) / texHeight);\r\n            vec2 uv1 = vec2((col + 1.5) / u_texWidth, (row + 0.5) / texHeight);\r\n            vec2 uv2 = vec2((col + 2.5) / u_texWidth, (row + 0.5) / texHeight);\r\n            vec2 uvC = vec2((col + 3.5) / u_texWidth, (row + 0.5) / texHeight);\r\n            \r\n            v0 = texture2D(u_triangleData, uv0).xyz;\r\n            v1 = texture2D(u_triangleData, uv1).xyz;\r\n            v2 = texture2D(u_triangleData, uv2).xyz;\r\n            color = texture2D(u_triangleData, uvC).xyz;\r\n        }\r\n        \r\n        // Main raytracing function\r\n        vec3 trace(vec3 ro, vec3 rd) {\r\n            float minT = u_farPlane;\r\n            vec3 hitColor = vec3(0.0);\r\n            vec3 hitNormal = vec3(0.0, 0.0, 1.0);\r\n            bool hit = false;\r\n            \r\n            // Test all triangles\r\n            for (int i = 0; i < 4096; i++) {\r\n                if (i >= u_triangleCount) break;\r\n                \r\n                vec3 v0, v1, v2, triColor;\r\n                getTriangle(i, v0, v1, v2, triColor);\r\n                \r\n                float t;\r\n                vec3 normal;\r\n                if (rayTriangle(ro, rd, v0, v1, v2, t, normal)) {\r\n                    if (t > u_nearPlane && t < minT && t < u_farPlane) {\r\n                        minT = t;\r\n                        hitColor = triColor;\r\n                        hitNormal = normal;\r\n                        hit = true;\r\n                    }\r\n                }\r\n            }\r\n            \r\n            if (hit) {\r\n                // Apply lighting\r\n                vec3 lightDir = normalize(u_lightDir);\r\n                float diffuse = max(0.0, -dot(hitNormal, lightDir)) * u_lightIntensity;\r\n                float lighting = u_ambientIntensity + diffuse * (1.0 - u_ambientIntensity);\r\n                return hitColor * lighting * u_lightColor;\r\n            }\r\n            \r\n            // Background\r\n            if (u_backgroundType == 0) {\r\n                return mix(u_floorColor, u_skyColor, step(u_horizonY, v_uv.y));\r\n            } else if (u_backgroundType == 2) {\r\n                return u_backgroundColor;\r\n            } else {\r\n                return vec3(0.0);\r\n            }\r\n        }\r\n        \r\n        void main() {\r\n            vec2 ndc = v_uv * 2.0 - 1.0;\r\n            ndc.y = -ndc.y;\r\n            \r\n            float aspect = u_resolution.x / u_resolution.y;\r\n            float tanHalfFov = tan(radians(u_fov) * 0.5);\r\n            \r\n            // Ray in camera space (X=forward, Y=right, Z=up)\r\n            vec3 rayDir = normalize(vec3(\r\n                1.0,\r\n                ndc.x * tanHalfFov * aspect,\r\n                ndc.y * tanHalfFov\r\n            ));\r\n            \r\n            // Transform ray to world space\r\n            rayDir = u_cameraRotation * rayDir;\r\n            \r\n            // Trace ray\r\n            vec3 color = trace(u_cameraPos, rayDir);\r\n            \r\n            gl_FragColor = vec4(color, 1.0);\r\n        }\r\n    `;\r\n\r\n        // Compile shaders\r\n        const vertexShader = gl.createShader(gl.VERTEX_SHADER);\r\n        gl.shaderSource(vertexShader, vertexShaderSource);\r\n        gl.compileShader(vertexShader);\r\n\r\n        if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\r\n            console.error('Vertex shader compile error:', gl.getShaderInfoLog(vertexShader));\r\n            return false;\r\n        }\r\n\r\n        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\r\n        gl.shaderSource(fragmentShader, fragmentShaderSource);\r\n        gl.compileShader(fragmentShader);\r\n\r\n        if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\r\n            console.error('Fragment shader compile error:', gl.getShaderInfoLog(fragmentShader));\r\n            return false;\r\n        }\r\n\r\n        // Create program\r\n        const program = gl.createProgram();\r\n        gl.attachShader(program, vertexShader);\r\n        gl.attachShader(program, fragmentShader);\r\n        gl.linkProgram(program);\r\n\r\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n            console.error('Shader program link error:', gl.getProgramInfoLog(program));\r\n            return false;\r\n        }\r\n\r\n        this._glRaytraceProgram = program;\r\n\r\n        // Get uniform locations\r\n        this._glRaytraceUniforms = {\r\n            cameraPos: gl.getUniformLocation(program, 'u_cameraPos'),\r\n            cameraRotation: gl.getUniformLocation(program, 'u_cameraRotation'),\r\n            fov: gl.getUniformLocation(program, 'u_fov'),\r\n            nearPlane: gl.getUniformLocation(program, 'u_nearPlane'),\r\n            farPlane: gl.getUniformLocation(program, 'u_farPlane'),\r\n            resolution: gl.getUniformLocation(program, 'u_resolution'),\r\n            lightDir: gl.getUniformLocation(program, 'u_lightDir'),\r\n            lightColor: gl.getUniformLocation(program, 'u_lightColor'),\r\n            lightIntensity: gl.getUniformLocation(program, 'u_lightIntensity'),\r\n            ambientIntensity: gl.getUniformLocation(program, 'u_ambientIntensity'),\r\n            skyColor: gl.getUniformLocation(program, 'u_skyColor'),\r\n            floorColor: gl.getUniformLocation(program, 'u_floorColor'),\r\n            horizonY: gl.getUniformLocation(program, 'u_horizonY'),\r\n            backgroundType: gl.getUniformLocation(program, 'u_backgroundType'),\r\n            backgroundColor: gl.getUniformLocation(program, 'u_backgroundColor'),\r\n            triangleData: gl.getUniformLocation(program, 'u_triangleData'),\r\n            triangleCount: gl.getUniformLocation(program, 'u_triangleCount'),\r\n            texWidth: gl.getUniformLocation(program, 'u_texWidth')\r\n        };\r\n\r\n        // Create fullscreen quad\r\n        const quadBuffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, quadBuffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\r\n            -1, -1,\r\n            1, -1,\r\n            -1, 1,\r\n            1, 1\r\n        ]), gl.STATIC_DRAW);\r\n\r\n        this._glRaytraceQuadBuffer = quadBuffer;\r\n        this._glRaytracePositionAttrib = gl.getAttribLocation(program, 'a_position');\r\n\r\n        return true;\r\n    }\r\n\r\n    // Initialize WebGL shaders for triangle rendering\r\n    initWebGLShaders() {\r\n        const gl = this._renderTextureGLCtx;\r\n\r\n        // Vertex shader\r\n        const vertexShaderSource = `\r\n            attribute vec3 a_position;\r\n            attribute vec3 a_color;\r\n            varying vec3 v_color;\r\n            uniform mat4 u_projection;\r\n            \r\n            void main() {\r\n                gl_Position = u_projection * vec4(a_position, 1.0);\r\n                v_color = a_color;\r\n            }\r\n        `;\r\n\r\n        // Fragment shader\r\n        const fragmentShaderSource = `\r\n            precision mediump float;\r\n            varying vec3 v_color;\r\n            \r\n            void main() {\r\n                gl_FragColor = vec4(v_color, 1.0);\r\n            }\r\n        `;\r\n\r\n        // Compile shaders\r\n        const vertexShader = gl.createShader(gl.VERTEX_SHADER);\r\n        gl.shaderSource(vertexShader, vertexShaderSource);\r\n        gl.compileShader(vertexShader);\r\n\r\n        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\r\n        gl.shaderSource(fragmentShader, fragmentShaderSource);\r\n        gl.compileShader(fragmentShader);\r\n\r\n        // Create program\r\n        const program = gl.createProgram();\r\n        gl.attachShader(program, vertexShader);\r\n        gl.attachShader(program, fragmentShader);\r\n        gl.linkProgram(program);\r\n\r\n        this._glProgram = program;\r\n        this._glPositionAttrib = gl.getAttribLocation(program, 'a_position');\r\n        this._glColorAttrib = gl.getAttribLocation(program, 'a_color');\r\n        this._glProjectionUniform = gl.getUniformLocation(program, 'u_projection');\r\n\r\n        // Enable depth testing\r\n        gl.enable(gl.DEPTH_TEST);\r\n        gl.depthFunc(gl.LESS);\r\n        gl.enable(gl.CULL_FACE);\r\n        gl.cullFace(gl.BACK);\r\n    }\r\n\r\n    subtractVector3(a, b) {\r\n        return new Vector3(a.x - b.x, a.y - b.y, a.z - b.z);\r\n    }\r\n\r\n    rotateVectorX(v, angle) {\r\n        const cos = Math.cos(angle), sin = Math.sin(angle);\r\n        return new Vector3(v.x, v.y * cos - v.z * sin, v.y * sin + v.z * cos);\r\n    }\r\n\r\n    rotateVectorY(v, angle) {\r\n        const cos = Math.cos(angle), sin = Math.sin(angle);\r\n        return new Vector3(v.x * cos + v.z * sin, v.y, -v.x * sin + v.z * cos);\r\n    }\r\n\r\n    rotateVectorZ(v, angle) {\r\n        const cos = Math.cos(angle), sin = Math.sin(angle);\r\n        return new Vector3(v.x * cos - v.y * sin, v.x * sin + v.y * cos, v.z);\r\n    }\r\n\r\n    clipPolygonAgainstNearPlane(vertices, nearPlane) {\r\n        if (!vertices || vertices.length === 0) return [];\r\n        const out = [];\r\n        const epsilon = 0.01; // Increased for better edge case handling\r\n\r\n        for (let i = 0; i < vertices.length; i++) {\r\n            const a = vertices[i];\r\n            const b = vertices[(i + 1) % vertices.length];\r\n            const aIn = a.x >= nearPlane - epsilon;\r\n            const bIn = b.x >= nearPlane - epsilon;\r\n\r\n            if (aIn && bIn) {\r\n                // Both vertices in front of near plane\r\n                out.push(b);\r\n            } else if (aIn && !bIn) {\r\n                // Edge crosses near plane, going out\r\n                const t = (nearPlane - a.x) / (b.x - a.x);\r\n                const clampedT = Math.max(0, Math.min(1, t));\r\n                out.push(new Vector3(\r\n                    nearPlane,\r\n                    a.y + clampedT * (b.y - a.y),\r\n                    a.z + clampedT * (b.z - a.z)\r\n                ));\r\n            } else if (!aIn && bIn) {\r\n                // Edge crosses near plane, coming in\r\n                const t = (nearPlane - a.x) / (b.x - a.x);\r\n                const clampedT = Math.max(0, Math.min(1, t));\r\n                out.push(new Vector3(\r\n                    nearPlane,\r\n                    a.y + clampedT * (b.y - a.y),\r\n                    a.z + clampedT * (b.z - a.z)\r\n                ));\r\n                out.push(b);\r\n            }\r\n            // If both are behind (!aIn && !bIn), skip both vertices\r\n        }\r\n\r\n        return out;\r\n    }\r\n\r\n    clipPolygonAgainstFarPlane(vertices, farPlane) {\r\n        if (!vertices || vertices.length === 0) return [];\r\n        const out = [];\r\n        const epsilon = 0.01; // Increased for better edge case handling\r\n\r\n        for (let i = 0; i < vertices.length; i++) {\r\n            const a = vertices[i];\r\n            const b = vertices[(i + 1) % vertices.length];\r\n            const aIn = a.x <= farPlane + epsilon;\r\n            const bIn = b.x <= farPlane + epsilon;\r\n\r\n            if (aIn && bIn) {\r\n                out.push(b);\r\n            } else if (aIn && !bIn) {\r\n                const t = (farPlane - a.x) / (b.x - a.x);\r\n                const clampedT = Math.max(0, Math.min(1, t));\r\n                out.push(new Vector3(\r\n                    farPlane,\r\n                    a.y + clampedT * (b.y - a.y),\r\n                    a.z + clampedT * (b.z - a.z)\r\n                ));\r\n            } else if (!aIn && bIn) {\r\n                const t = (farPlane - a.x) / (b.x - a.x);\r\n                const clampedT = Math.max(0, Math.min(1, t));\r\n                out.push(new Vector3(\r\n                    farPlane,\r\n                    a.y + clampedT * (b.y - a.y),\r\n                    a.z + clampedT * (b.z - a.z)\r\n                ));\r\n                out.push(b);\r\n            }\r\n        }\r\n\r\n        return out;\r\n    }\r\n\r\n    projectCameraPoint(cameraPoint, useCullingFov = false) {\r\n        const depth = cameraPoint.x;\r\n        // Remove this check since we clip beforehand\r\n        // if (depth <= this.nearPlane || depth >= this.farPlane) return null;\r\n        if (depth <= 1e-4) return null; // Increased from 1e-6 for better stability\r\n\r\n        const aspect = this.viewportWidth / this.viewportHeight;\r\n        const fovToUse = useCullingFov ? this._cullingFieldOfView : this.fieldOfView;\r\n        const fovRadians = fovToUse * (Math.PI / 180);\r\n        const f = 1.0 / Math.tan(fovRadians * 0.5);\r\n        const ndcX = (cameraPoint.y / depth) * (f / aspect);\r\n        const ndcY = (cameraPoint.z / depth) * f;\r\n        const screenX = (ndcX * 0.5 + 0.5) * this.viewportWidth;\r\n        const screenY = (0.5 - ndcY * 0.5) * this.viewportHeight;\r\n        return new Vector2(screenX, screenY);\r\n    }\r\n\r\n    isPointVisible(point, checkFOV = true) {\r\n        const cameraPoint = this.worldToCameraSpace(point);\r\n\r\n        // Check depth planes first\r\n        if (cameraPoint.x < this.nearPlane || cameraPoint.x > this.farPlane) {\r\n            return false;\r\n        }\r\n\r\n        // If FOV checking is disabled, just check depth planes\r\n        if (!checkFOV || this._disableCulling) {\r\n            return true;\r\n        }\r\n\r\n        // Calculate if point is within FOV with tolerance for edge cases\r\n        const aspect = this.viewportWidth / this.viewportHeight;\r\n        const fovRadians = this.fieldOfView * (Math.PI / 180);\r\n        const tanHalfFov = Math.tan(fovRadians * 0.5);\r\n\r\n        // Add small tolerance to handle floating point precision issues at edges\r\n        const tolerance = 0.02; // 2% tolerance\r\n\r\n        // Check if point is within horizontal FOV (with tolerance)\r\n        // cameraPoint.y maps to horizontal screen position, so no aspect ratio needed\r\n        const horizontalBound = Math.abs(cameraPoint.y) / cameraPoint.x;\r\n        const maxHorizontal = tanHalfFov * (1 + tolerance);\r\n\r\n        // Check if point is within vertical FOV (with tolerance)\r\n        // cameraPoint.z maps to vertical screen position, apply aspect ratio\r\n        const verticalBound = Math.abs(cameraPoint.z) / cameraPoint.x;\r\n        const maxVertical = tanHalfFov * aspect * (1 + tolerance);\r\n\r\n        return horizontalBound <= maxHorizontal && verticalBound <= maxVertical;\r\n    }\r\n\r\n    updateRenderTexture() {\r\n        if (!this._renderTexture || this._renderTexture.width !== this._renderTextureWidth ||\r\n            this._renderTexture.height !== this._renderTextureHeight) {\r\n            this._renderTexture = document.createElement('canvas');\r\n            this._renderTexture.width = this._renderTextureWidth;\r\n            this._renderTexture.height = this._renderTextureHeight;\r\n            this._renderTextureCtx = this._renderTexture.getContext('2d');\r\n            this.viewportWidth = this._renderTextureWidth;\r\n            this.viewportHeight = this._renderTextureHeight;\r\n            this._zBuffer = new Float32Array(this._renderTextureWidth * this._renderTextureHeight);\r\n            this._imageData = this._renderTextureCtx.createImageData(this._renderTextureWidth, this._renderTextureHeight);\r\n        }\r\n\r\n        // Try to create WebGL context for acceleration\r\n        if (this._renderingMethod === \"raster\") {\r\n            this.createWebGLRenderTexture();\r\n        }\r\n    }\r\n\r\n    getRenderTexture() { return this._renderTexture; }\r\n    getRenderTextureContext() { return this._renderTextureCtx; }\r\n\r\n    clearRenderTexture() {\r\n        if (!this._renderTextureCtx) return;\r\n        this._renderTextureCtx.imageSmoothingEnabled = this._renderTextureSmoothing;\r\n\r\n        // Handle different background types\r\n        switch (this._backgroundType) {\r\n            case \"skyfloor\":\r\n                // Calculate dynamic horizon based on camera pitch and FOV for accuracy\r\n                const fovRadians = this._fieldOfView * (Math.PI / 180);\r\n                const pitchRadians = (this._rotation.y || 0) * (Math.PI / 180);\r\n                const maxPitch = fovRadians / 2;\r\n                const normalizedPitch = -Math.max(-1, Math.min(1, pitchRadians / maxPitch)); // Clamp to [-1, 1]\r\n                const horizonOffset = normalizedPitch * 0.5; // Scale to [-0.5, 0.5]\r\n                const horizonRatio = 0.5 + horizonOffset; // 0.5 when level, shifts based on pitch\r\n\r\n                // Clamp horizon between 0 and 1 to avoid extreme cases\r\n                const clampedHorizon = Math.max(0, Math.min(1, horizonRatio));\r\n                const horizonY = Math.floor(this._renderTextureHeight * clampedHorizon);\r\n\r\n                // Draw sky (from top to horizon)\r\n                this._renderTextureCtx.fillStyle = this._skyColor;\r\n                this._renderTextureCtx.fillRect(0, 0, this._renderTextureWidth, horizonY);\r\n\r\n                // Draw floor (from horizon to bottom)\r\n                this._renderTextureCtx.fillStyle = this._floorColor;\r\n                this._renderTextureCtx.fillRect(0, horizonY, this._renderTextureWidth, this._renderTextureHeight - horizonY);\r\n                break;\r\n\r\n            case \"transparent\":\r\n                // Don't clear the background - leave it transparent\r\n                // This allows 2D drawing beneath the 3D canvas\r\n                break;\r\n\r\n            case \"solid\":\r\n            default:\r\n                // Fill with solid background color\r\n                this._renderTextureCtx.fillStyle = this._backgroundColor;\r\n                this._renderTextureCtx.fillRect(0, 0, this._renderTextureWidth, this._renderTextureHeight);\r\n                break;\r\n        }\r\n\r\n        if (this._zBuffer) this._zBuffer.fill(Infinity);\r\n    }\r\n\r\n    updateViewport() {\r\n        this.viewportWidth = this._renderTextureWidth;\r\n        this.viewportHeight = this._renderTextureHeight;\r\n    }\r\n\r\n    calculateScreenNormal(vertices) {\r\n        if (vertices.length < 3) return 0;\r\n        const v0 = vertices[0], v1 = vertices[1], v2 = vertices[2];\r\n        const edge1 = { x: v1.x - v0.x, y: v1.y - v0.y };\r\n        const edge2 = { x: v2.x - v0.x, y: v2.y - v0.y };\r\n        return edge1.x * edge2.y - edge1.y * edge2.x;\r\n    }\r\n\r\n    // Improved backface culling that works consistently across all rendering methods\r\n    shouldCullFace(cameraSpaceVertices) {\r\n        if (cameraSpaceVertices.length < 3) return true;\r\n\r\n        const v0 = cameraSpaceVertices[0];\r\n        const v1 = cameraSpaceVertices[1];\r\n        const v2 = cameraSpaceVertices[2];\r\n\r\n        // Calculate face normal in camera space using cross product\r\n        // Camera looks along +X axis\r\n        const edge1 = { x: v1.x - v0.x, y: v1.y - v0.y, z: v1.z - v0.z };\r\n        const edge2 = { x: v2.x - v0.x, y: v2.y - v0.y, z: v2.z - v0.z };\r\n\r\n        // Cross product (edge1 x edge2) - use right-hand rule\r\n        const normal = {\r\n            x: edge1.y * edge2.z - edge1.z * edge2.y,\r\n            y: edge1.z * edge2.x - edge1.x * edge2.z,\r\n            z: edge1.x * edge2.y - edge1.y * edge2.x\r\n        };\r\n\r\n        // Normalize\r\n        const normalLength = Math.sqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);\r\n        if (normalLength < 1e-10) return true; // Degenerate triangle\r\n\r\n        const normalizedNormal = {\r\n            x: normal.x / normalLength,\r\n            y: normal.y / normalLength,\r\n            z: normal.z / normalLength\r\n        };\r\n\r\n        // View direction in camera space is along +X axis (camera looking towards +X)\r\n        // For a face to be front-facing, its normal should point towards the camera (negative X)\r\n        // So we want normalizedNormal.x < 0 for front faces\r\n        // Cull if normalizedNormal.x >= 0 (backfaces pointing away)\r\n\r\n        // Use the centroid for more accurate culling\r\n        const centroidX = (v0.x + v1.x + v2.x) / 3;\r\n        const centroidY = (v0.y + v1.y + v2.y) / 3;\r\n        const centroidZ = (v0.z + v1.z + v2.z) / 3;\r\n\r\n        // Vector from centroid to camera (at origin)\r\n        const toCameraX = -centroidX;\r\n        const toCameraY = -centroidY;\r\n        const toCameraZ = -centroidZ;\r\n\r\n        // Dot product with normal - if positive, face is front-facing\r\n        const dot = normalizedNormal.x * toCameraX + normalizedNormal.y * toCameraY + normalizedNormal.z * toCameraZ;\r\n\r\n        // Cull if dot < 0 (backface)\r\n        return dot < -0.01; // Small epsilon for numerical stability\r\n    }\r\n\r\n    drawTexturedTriangle(ctx, vertices, uvs, texture) {\r\n        if (!texture || vertices.length !== 3 || uvs.length !== 3) return;\r\n        ctx.save();\r\n        ctx.beginPath();\r\n        ctx.moveTo(vertices[0].x, vertices[0].y);\r\n        ctx.lineTo(vertices[1].x, vertices[1].y);\r\n        ctx.lineTo(vertices[2].x, vertices[2].y);\r\n        ctx.closePath();\r\n        ctx.clip();\r\n        const x0 = vertices[0].x, y0 = vertices[0].y;\r\n        const x1 = vertices[1].x, y1 = vertices[1].y;\r\n        const x2 = vertices[2].x, y2 = vertices[2].y;\r\n        const u0 = uvs[0].x * texture.width, v0 = uvs[0].y * texture.height;\r\n        const u1 = uvs[1].x * texture.width, v1 = uvs[1].y * texture.height;\r\n        const u2 = uvs[2].x * texture.width, v2 = uvs[2].y * texture.height;\r\n        const det = u0 * (v1 - v2) - u1 * (v0 - v2) + u2 * (v0 - v1);\r\n        if (Math.abs(det) > 0.0001) {\r\n            const a = (x0 * (v1 - v2) - x1 * (v0 - v2) + x2 * (v0 - v1)) / det;\r\n            const b = (x0 * (u2 - u1) - x1 * (u2 - u0) + x2 * (u1 - u0)) / det;\r\n            const c = (x0 * (u1 * v2 - u2 * v1) - x1 * (u0 * v2 - u2 * v0) + x2 * (u0 * v1 - u1 * v0)) / det;\r\n            const d = (y0 * (v1 - v2) - y1 * (v0 - v2) + y2 * (v0 - v1)) / det;\r\n            const e = (y0 * (u2 - u1) - y1 * (u2 - u0) + y2 * (u1 - u0)) / det;\r\n            const f = (y0 * (u1 * v2 - u2 * v1) - y1 * (u0 * v2 - u2 * v0) + y2 * (u0 * v1 - u1 * v0)) / det;\r\n            ctx.transform(a, d, b, e, c, f);\r\n            ctx.drawImage(texture, 0, 0);\r\n        }\r\n        ctx.restore();\r\n    }\r\n\r\n    renderPainter() {\r\n        const allObjects = this.getGameObjects();\r\n        const allFaces = [];\r\n\r\n        // Collect all faces with their data\r\n        allObjects.forEach(obj => {\r\n            if (!obj.active) return;\r\n            const mesh = obj.getModule(\"Mesh3D\") || obj.getModule(\"CubeMesh3D\") || obj.getModule(\"SphereMesh3D\");\r\n            if (!mesh) return;\r\n\r\n            const transformedVertices = mesh.transformVertices();\r\n            if (!transformedVertices || !mesh.faces) return;\r\n\r\n            let texture = null, uvCoords = null;\r\n            if (mesh.texture && (mesh.texture instanceof Image || mesh.texture instanceof HTMLCanvasElement)) {\r\n                texture = mesh.texture;\r\n                uvCoords = mesh.uvCoords || mesh.generateDefaultUVs();\r\n            }\r\n\r\n            mesh.faces.forEach((face, faceIndex) => {\r\n                const worldVerts = face.map(idx => transformedVertices[idx]).filter(Boolean);\r\n                if (worldVerts.length < 3) return;\r\n\r\n                let cameraVerts = worldVerts.map(v => this.worldToCameraSpace(v));\r\n\r\n                // Clip against near and far planes\r\n                cameraVerts = this.clipPolygonAgainstNearPlane(cameraVerts, this._nearPlane);\r\n                if (cameraVerts.length < 3) return;\r\n\r\n                cameraVerts = this.clipPolygonAgainstFarPlane(cameraVerts, this._farPlane);\r\n                if (cameraVerts.length < 3) return;\r\n\r\n                // Backface culling AFTER clipping\r\n                const material = mesh?.material;\r\n                const isDoubleSided = material ? material._doubleSided : false;\r\n                if (this._enableBackfaceCulling && !this._disableCulling && !isDoubleSided && this.shouldCullFace(cameraVerts)) return;\r\n\r\n                // Project to screen - use extended FOV only when culling is enabled\r\n                const useExtendedFOV = this._enableBackfaceCulling && !this._disableCulling;\r\n                const projectedVerts = cameraVerts.map(cv => this.projectCameraPoint(cv, useExtendedFOV));\r\n\r\n                // Filter out null projections\r\n                const validProjectedVerts = projectedVerts.filter(v => v !== null);\r\n\r\n                // Skip if we don't have enough valid vertices after projection\r\n                if (validProjectedVerts.length < 3) return;\r\n\r\n                // Use MINIMUM depth (closest vertex) for more accurate sorting\r\n                // This ensures faces with any close vertex are drawn after faces that are entirely farther\r\n                const sortDepth = Math.min(...cameraVerts.map(v => v.x));\r\n\r\n                allFaces.push({\r\n                    projectedVertices: validProjectedVerts,\r\n                    cameraSpaceVertices: cameraVerts,\r\n                    worldNormal: this.calculateFaceNormal(worldVerts[0], worldVerts[1], worldVerts[2]),\r\n                    mesh,\r\n                    texture,\r\n                    faceUVs: texture && uvCoords && uvCoords[faceIndex] ? uvCoords[faceIndex] : null,\r\n                    sortDepth\r\n                });\r\n            });\r\n        });\r\n\r\n        // Sort back-to-front (far to near) for proper painter's algorithm\r\n        allFaces.sort((a, b) => b.sortDepth - a.sortDepth);\r\n\r\n        const ctx = this._renderTextureCtx;\r\n        this.clearRenderTexture();\r\n\r\n        // Render each face\r\n        allFaces.forEach(({ projectedVertices, worldNormal, mesh, texture, faceUVs }) => {\r\n            // Calculate lighting\r\n            const baseColor = mesh.faceColor || mesh._faceColor || \"#888888\";\r\n            const litColor = this.calculateLighting(worldNormal, baseColor);\r\n\r\n            ctx.save();\r\n\r\n            if (texture && faceUVs && faceUVs.length >= 3) {\r\n                // Textured rendering - triangulate the polygon\r\n                for (let i = 1; i < projectedVertices.length - 1; i++) {\r\n                    const triVerts = [projectedVertices[0], projectedVertices[i], projectedVertices[i + 1]];\r\n                    const triUVs = [faceUVs[0], faceUVs[i], faceUVs[i + 1]];\r\n                    this.drawTexturedTriangle(ctx, triVerts, triUVs, texture);\r\n                }\r\n            } else {\r\n                // Solid color rendering\r\n                if (mesh.renderMode === \"solid\" || mesh.renderMode === \"both\") {\r\n                    ctx.fillStyle = `rgb(${litColor.r}, ${litColor.g}, ${litColor.b})`;\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(projectedVertices[0].x, projectedVertices[0].y);\r\n                    for (let i = 1; i < projectedVertices.length; i++) {\r\n                        ctx.lineTo(projectedVertices[i].x, projectedVertices[i].y);\r\n                    }\r\n                    ctx.closePath();\r\n                    ctx.fill();\r\n                }\r\n            }\r\n\r\n            // Wireframe rendering\r\n            if (mesh.renderMode === \"wireframe\" || mesh.renderMode === \"both\") {\r\n                ctx.strokeStyle = mesh.wireframeColor || mesh._wireframeColor || \"#ffffff\";\r\n                ctx.lineWidth = 1;\r\n                ctx.beginPath();\r\n                ctx.moveTo(projectedVertices[0].x, projectedVertices[0].y);\r\n                for (let i = 1; i < projectedVertices.length; i++) {\r\n                    ctx.lineTo(projectedVertices[i].x, projectedVertices[i].y);\r\n                }\r\n                ctx.closePath();\r\n                ctx.stroke();\r\n            }\r\n\r\n            ctx.restore();\r\n        });\r\n    }\r\n\r\n    rasterizeTriangleWithDepth(ctx, v0, v1, v2, color) {\r\n        const p0 = { x: Math.round(v0.screen.x), y: Math.round(v0.screen.y), z: v0.depth };\r\n        const p1 = { x: Math.round(v1.screen.x), y: Math.round(v1.screen.y), z: v1.depth };\r\n        const p2 = { x: Math.round(v2.screen.x), y: Math.round(v2.screen.y), z: v2.depth };\r\n\r\n        const minX = Math.max(0, Math.min(p0.x, p1.x, p2.x));\r\n        const maxX = Math.min(this._renderTextureWidth - 1, Math.max(p0.x, p1.x, p2.x));\r\n        const minY = Math.max(0, Math.min(p0.y, p1.y, p2.y));\r\n        const maxY = Math.min(this._renderTextureHeight - 1, Math.max(p0.y, p1.y, p2.y));\r\n\r\n        for (let y = minY; y <= maxY; y++) {\r\n            for (let x = minX; x <= maxX; x++) {\r\n                const bary = this.barycentric(p0, p1, p2, x, y);\r\n                if (bary.u >= 0 && bary.v >= 0 && bary.w >= 0) {\r\n                    const depth = bary.u * p0.z + bary.v * p1.z + bary.w * p2.z;\r\n                    const idx = y * this._renderTextureWidth + x;\r\n\r\n                    if (depth >= this._nearPlane && depth <= this._farPlane && depth < this._zBuffer[idx]) {\r\n                        this._zBuffer[idx] = depth;\r\n                        ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;\r\n                        ctx.fillRect(x, y, 1, 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Combines spatial subdivision with Z-buffering for better performance\r\n    renderHZB() {\r\n        const allObjects = this.getGameObjects();\r\n        const ctx = this._renderTextureCtx;\r\n        const imgData = this._imageData;\r\n        const data = imgData.data;\r\n        const w = this._renderTextureWidth, h = this._renderTextureHeight;\r\n\r\n        // Handle background clearing based on background type\r\n        if (this._backgroundType === \"transparent\") {\r\n            // For transparent background, only clear pixels that will have geometry\r\n            // Leave non-geometry pixels as they are (transparent)\r\n        } else {\r\n            // For solid or sky/floor backgrounds, clear all pixels first\r\n            if (this._backgroundType === \"solid\") {\r\n                const bgColor = this.hexToRgb(this._backgroundColor);\r\n                for (let i = 0; i < data.length; i += 4) {\r\n                    data[i] = bgColor.r; data[i + 1] = bgColor.g; data[i + 2] = bgColor.b; data[i + 3] = 255;\r\n                }\r\n            } else if (this._backgroundType === \"skyfloor\") {\r\n                // Calculate dynamic horizon based on camera pitch and FOV for accuracy\r\n                const fovRadians = this._fieldOfView * (Math.PI / 180);\r\n                const pitchRadians = (this._rotation.y || 0) * (Math.PI / 180);\r\n                const maxPitch = fovRadians / 2;\r\n                const normalizedPitch = -Math.max(-1, Math.min(1, pitchRadians / maxPitch)); // Clamp to [-1, 1]\r\n                const horizonOffset = normalizedPitch * 0.5; // Scale to [-0.5, 0.5]\r\n                const horizonRatio = 0.5 + horizonOffset; // 0.5 when level, shifts based on pitch\r\n\r\n                // Clamp horizon between 0 and 1 to avoid extreme cases\r\n                const clampedHorizon = Math.max(0, Math.min(1, horizonRatio));\r\n                const horizonY = Math.floor(h * clampedHorizon);\r\n\r\n                for (let i = 0; i < data.length; i += 4) {\r\n                    const y = Math.floor((i / 4) / w);\r\n                    if (y < horizonY) {\r\n                        data[i] = this.hexToRgb(this._skyColor).r;\r\n                        data[i + 1] = this.hexToRgb(this._skyColor).g;\r\n                        data[i + 2] = this.hexToRgb(this._skyColor).b;\r\n                    } else {\r\n                        data[i] = this.hexToRgb(this._floorColor).r;\r\n                        data[i + 1] = this.hexToRgb(this._floorColor).g;\r\n                        data[i + 2] = this.hexToRgb(this._floorColor).b;\r\n                    }\r\n                    data[i + 3] = 255;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Build hierarchical structure (16x16 tiles)\r\n        const tileSize = 16;\r\n        const tilesX = Math.ceil(w / tileSize);\r\n        const tilesY = Math.ceil(h / tileSize);\r\n        const tiles = Array.from({ length: tilesY }, () =>\r\n            Array.from({ length: tilesX }, () => ({ triangles: [], minDepth: Infinity }))\r\n        );\r\n\r\n        // Collect and bin triangles into tiles\r\n        allObjects.forEach(obj => {\r\n            if (!obj.active) return;\r\n            const mesh = obj.getModule(\"Mesh3D\") || obj.getModule(\"CubeMesh3D\") || obj.getModule(\"SphereMesh3D\");\r\n            if (!mesh) return;\r\n            const transformedVertices = mesh.transformVertices();\r\n            if (!transformedVertices || !mesh.faces) return;\r\n            const faceColor = mesh.faceColor || mesh._faceColor || \"#888888\";\r\n\r\n            mesh.faces.forEach(face => {\r\n                const cameraVerts = face.map(idx =>\r\n                    idx < transformedVertices.length ? this.worldToCameraSpace(transformedVertices[idx]) : null\r\n                ).filter(v => v);\r\n                //const clippedVerts = this.clipPolygonAgainstNearPlane(cameraVerts, this._nearPlane);\r\n                //if (clippedVerts.length < 3) return;\r\n\r\n\r\n                const worldVerts = face.map(idx => transformedVertices[idx]).filter(v => v);\r\n                const worldNormal = this.calculateFaceNormal(worldVerts[0], worldVerts[1], worldVerts[2]);\r\n                const litColor = this.calculateLighting(worldNormal, faceColor);\r\n\r\n                // Clip against near plane first\r\n                const clippedVerts = this.clipPolygonAgainstNearPlane(cameraVerts, this._nearPlane);\r\n                if (clippedVerts.length < 3) return;\r\n\r\n                // Backface culling using consistent method (after clipping)\r\n                if (this._enableBackfaceCulling && !this._disableCulling) {\r\n                    const material = mesh?.material;\r\n                    const isDoubleSided = material ? material._doubleSided : false;\r\n                    if (!isDoubleSided && this.shouldCullFace(clippedVerts)) {\r\n                        return; // Cull if facing away from camera (unless double-sided)\r\n                    }\r\n                }\r\n                const rgb = litColor;\r\n\r\n                const clippedFar = clippedVerts.filter(v => v.x <= this._farPlane);\r\n                if (clippedFar.length < 3) return;\r\n\r\n                const useExtendedFOV = this._enableBackfaceCulling && !this._disableCulling;\r\n                const screenVerts = clippedFar.map(cv => {\r\n                    const proj = this.projectCameraPoint(cv, useExtendedFOV);\r\n                    return proj ? { screen: proj, depth: cv.x } : null;\r\n                }).filter(v => v);\r\n                if (screenVerts.length < 3) {\r\n                    // When culling is disabled, check if we have any valid projections\r\n                    if (!this._disableCulling || screenVerts.length === 0) return;\r\n                }\r\n\r\n                // Triangulate and bin into tiles\r\n                for (let i = 1; i < screenVerts.length - 1; i++) {\r\n                    const tri = [screenVerts[0], screenVerts[i], screenVerts[i + 1]];\r\n                    const minDepth = Math.min(tri[0].depth, tri[1].depth, tri[2].depth);\r\n\r\n                    // Calculate bounding box in tile space\r\n                    const minX = Math.floor(Math.min(tri[0].screen.x, tri[1].screen.x, tri[2].screen.x) / tileSize);\r\n                    const maxX = Math.floor(Math.max(tri[0].screen.x, tri[1].screen.x, tri[2].screen.x) / tileSize);\r\n                    const minY = Math.floor(Math.min(tri[0].screen.y, tri[1].screen.y, tri[2].screen.y) / tileSize);\r\n                    const maxY = Math.floor(Math.max(tri[0].screen.y, tri[1].screen.y, tri[2].screen.y) / tileSize);\r\n\r\n                    // Add triangle to overlapping tiles\r\n                    for (let ty = Math.max(0, minY); ty <= Math.min(tilesY - 1, maxY); ty++) {\r\n                        for (let tx = Math.max(0, minX); tx <= Math.min(tilesX - 1, maxX); tx++) {\r\n                            tiles[ty][tx].triangles.push({ tri, color: rgb, minDepth });\r\n                            tiles[ty][tx].minDepth = Math.min(tiles[ty][tx].minDepth, minDepth);\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        });\r\n\r\n        // Render tiles front-to-back with early Z rejection\r\n        const tileOrder = [];\r\n        for (let ty = 0; ty < tilesY; ty++) {\r\n            for (let tx = 0; tx < tilesX; tx++) {\r\n                if (tiles[ty][tx].triangles.length > 0) {\r\n                    tileOrder.push({ tx, ty, depth: tiles[ty][tx].minDepth });\r\n                }\r\n            }\r\n        }\r\n        tileOrder.sort((a, b) => a.depth - b.depth);\r\n\r\n        // Render each tile\r\n        tileOrder.forEach(({ tx, ty }) => {\r\n            const tile = tiles[ty][tx];\r\n            const xStart = tx * tileSize;\r\n            const yStart = ty * tileSize;\r\n            const xEnd = Math.min(xStart + tileSize, w);\r\n            const yEnd = Math.min(yStart + tileSize, h);\r\n\r\n            // Sort triangles in tile by depth\r\n            tile.triangles.sort((a, b) => a.minDepth - b.minDepth);\r\n\r\n            // Rasterize triangles in tile\r\n            tile.triangles.forEach(({ tri, color }) => {\r\n                for (let y = yStart; y < yEnd; y++) {\r\n                    for (let x = xStart; x < xEnd; x++) {\r\n                        const p0 = { x: tri[0].screen.x, y: tri[0].screen.y, z: tri[0].depth };\r\n                        const p1 = { x: tri[1].screen.x, y: tri[1].screen.y, z: tri[1].depth };\r\n                        const p2 = { x: tri[2].screen.x, y: tri[2].screen.y, z: tri[2].depth };\r\n\r\n                        const bary = this.barycentric(p0, p1, p2, x, y);\r\n                        if (bary.u >= 0 && bary.v >= 0 && bary.w >= 0) {\r\n                            const depth = bary.u * p0.z + bary.v * p1.z + bary.w * p2.z;\r\n                            const idx = y * w + x;\r\n                            if (depth >= this._nearPlane && depth <= this._farPlane && depth < this._zBuffer[idx]) {\r\n                                this._zBuffer[idx] = depth;\r\n                                const pixelIdx = idx * 4;\r\n                                data[pixelIdx] = color.r;\r\n                                data[pixelIdx + 1] = color.g;\r\n                                data[pixelIdx + 2] = color.b;\r\n                                data[pixelIdx + 3] = 255;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        });\r\n\r\n        ctx.putImageData(imgData, 0, 0);\r\n    }\r\n\r\n    // Advanced depth-accurate rendering with hierarchical depth testing and depth of field\r\n    renderDepthPass() {\r\n        const allObjects = this.getGameObjects();\r\n        const ctx = this._renderTextureCtx;\r\n        const imgData = this._imageData;\r\n        const data = imgData.data;\r\n        const w = this._renderTextureWidth, h = this._renderTextureHeight;\r\n\r\n        // **OPTIMIZATION 1: Use Uint32Array for 4x faster pixel writes**\r\n        const buffer32 = new Uint32Array(imgData.data.buffer);\r\n\r\n        // **OPTIMIZATION 2: Pre-pack background colors**\r\n        const skyColor = this.hexToRgb(this._skyColor);\r\n        const floorColor = this.hexToRgb(this._floorColor);\r\n        const skyPixel = (255 << 24) | (skyColor.b << 16) | (skyColor.g << 8) | skyColor.r;\r\n        const floorPixel = (255 << 24) | (floorColor.b << 16) | (floorColor.g << 8) | floorColor.r;\r\n\r\n        // Clear background with single writes\r\n        if (this._backgroundType === \"skyfloor\") {\r\n            const fovRadians = this._fieldOfView * (Math.PI / 180);\r\n            const pitchRadians = (this._rotation.y || 0) * (Math.PI / 180);\r\n            const maxPitch = fovRadians / 2;\r\n            const normalizedPitch = -Math.max(-1, Math.min(1, pitchRadians / maxPitch));\r\n            const horizonOffset = normalizedPitch * 0.5;\r\n            const horizonRatio = 0.5 + horizonOffset;\r\n            const clampedHorizon = Math.max(0, Math.min(1, horizonRatio));\r\n            const horizonY = Math.floor(h * clampedHorizon);\r\n\r\n            for (let i = 0; i < buffer32.length; i++) {\r\n                const y = Math.floor(i / w);\r\n                buffer32[i] = y < horizonY ? skyPixel : floorPixel;\r\n            }\r\n        } else if (this._backgroundType === \"solid\") {\r\n            const bgColor = this.hexToRgb(this._backgroundColor);\r\n            const bgPixel = (255 << 24) | (bgColor.b << 16) | (bgColor.g << 8) | bgColor.r;\r\n            buffer32.fill(bgPixel);\r\n        }\r\n\r\n        this._zBuffer.fill(Infinity);\r\n\r\n        // **OPTIMIZATION 3: Pre-filter and batch triangles by depth ranges**\r\n        const allTriangles = [];\r\n\r\n        allObjects.forEach(obj => {\r\n            if (!obj.active) return;\r\n            const mesh = obj.getModule(\"Mesh3D\") || obj.getModule(\"CubeMesh3D\") || obj.getModule(\"SphereMesh3D\");\r\n            if (!mesh) return;\r\n            const transformedVertices = mesh.transformVertices();\r\n            if (!transformedVertices || !mesh.faces) return;\r\n            const faceColor = mesh.faceColor || mesh._faceColor || \"#888888\";\r\n\r\n            mesh.faces.forEach(face => {\r\n                const worldVerts = face.map(idx =>\r\n                    idx < transformedVertices.length ? transformedVertices[idx] : null\r\n                ).filter(v => v);\r\n\r\n                if (worldVerts.length < 3) return;\r\n\r\n                const cameraVerts = face.map(idx =>\r\n                    idx < transformedVertices.length ? this.worldToCameraSpace(transformedVertices[idx]) : null\r\n                ).filter(v => v);\r\n\r\n                if (cameraVerts.length < 3) return;\r\n\r\n                // **FIX 1: Do backface culling BEFORE clipping on original vertices**\r\n                if (this._enableBackfaceCulling && !this._disableCulling) {\r\n                    const material = mesh?.material;\r\n                    const isDoubleSided = material ? material._doubleSided : false;\r\n                    if (!isDoubleSided && this.shouldCullFace(cameraVerts)) {\r\n                        return; // Skip back-facing triangles entirely (unless double-sided)\r\n                    }\r\n                }\r\n\r\n                // **FIX 2: Calculate normal ONCE from original world vertices**\r\n                const worldNormal = this.calculateFaceNormal(worldVerts[0], worldVerts[1], worldVerts[2]);\r\n                const rgb = this.calculateLighting(worldNormal, faceColor);\r\n\r\n                for (let i = 1; i < cameraVerts.length - 1; i++) {\r\n                    const v0 = cameraVerts[0], v1 = cameraVerts[i], v2 = cameraVerts[i + 1];\r\n\r\n                    // Clip against near plane\r\n                    const clippedV0 = this.clipPolygonAgainstNearPlane([v0], this._nearPlane);\r\n                    const clippedV1 = this.clipPolygonAgainstNearPlane([v1], this._nearPlane);\r\n                    const clippedV2 = this.clipPolygonAgainstNearPlane([v2], this._nearPlane);\r\n\r\n                    if (clippedV0.length === 0 || clippedV1.length === 0 || clippedV2.length === 0) {\r\n                        continue;\r\n                    }\r\n\r\n                    const clippedTriangle = [clippedV0[0] || v0, clippedV1[0] || v1, clippedV2[0] || v2];\r\n\r\n                    // **OPTIMIZATION 4: Pre-pack color as 32-bit value**\r\n                    const packedColor = (255 << 24) | (rgb.b << 16) | (rgb.g << 8) | rgb.r;\r\n\r\n                    // **OPTIMIZATION 5: Calculate min/max depth for early rejection**\r\n                    const minDepth = Math.min(clippedTriangle[0].x, clippedTriangle[1].x, clippedTriangle[2].x);\r\n                    const maxDepth = Math.max(clippedTriangle[0].x, clippedTriangle[1].x, clippedTriangle[2].x);\r\n\r\n                    allTriangles.push({\r\n                        v0: clippedTriangle[0],\r\n                        v1: clippedTriangle[1],\r\n                        v2: clippedTriangle[2],\r\n                        packedColor,\r\n                        minDepth,\r\n                        maxDepth,\r\n                        avgDepth: (clippedTriangle[0].x + clippedTriangle[1].x + clippedTriangle[2].x) / 3\r\n                    });\r\n                }\r\n            });\r\n        });\r\n\r\n        // **OPTIMIZATION 6: Sort front-to-back for early Z rejection**\r\n        allTriangles.sort((a, b) => a.minDepth - b.minDepth);\r\n\r\n        // **OPTIMIZATION 7: Optimized rasterization with early Z rejection**\r\n        this.renderDepthPassOptimized(allTriangles, buffer32, w, h);\r\n\r\n        ctx.putImageData(imgData, 0, 0);\r\n    }\r\n\r\n    // **NEW: Highly optimized rasterization with tile-based early rejection**\r\n    renderDepthPassOptimized(triangles, buffer32, w, h) {\r\n        const zbuffer = this._zBuffer;\r\n        const tileSize = 16; // 16x16 tiles\r\n        const tilesX = Math.ceil(w / tileSize);\r\n        const tilesY = Math.ceil(h / tileSize);\r\n\r\n        // **OPTIMIZATION 8: Hierarchical Z-buffer (coarse depth map)**\r\n        const coarseZ = new Float32Array(tilesX * tilesY);\r\n        coarseZ.fill(Infinity);\r\n\r\n        triangles.forEach(tri => {\r\n            const { v0, v1, v2, packedColor, minDepth, maxDepth } = tri;\r\n\r\n            // Project to screen space\r\n            const useExtendedFOV = this._enableBackfaceCulling && !this._disableCulling;\r\n            const p0 = this.projectCameraPoint(v0, useExtendedFOV);\r\n            const p1 = this.projectCameraPoint(v1, useExtendedFOV);\r\n            const p2 = this.projectCameraPoint(v2, useExtendedFOV);\r\n\r\n            if (!p0 || !p1 || !p2) return;\r\n\r\n            // Calculate tight bounding box\r\n            const minX = Math.max(0, Math.floor(Math.min(p0.x, p1.x, p2.x)));\r\n            const maxX = Math.min(w - 1, Math.ceil(Math.max(p0.x, p1.x, p2.x)));\r\n            const minY = Math.max(0, Math.floor(Math.min(p0.y, p1.y, p2.y)));\r\n            const maxY = Math.min(h - 1, Math.ceil(Math.max(p0.y, p1.y, p2.y)));\r\n\r\n            if (minX > maxX || minY > maxY) return;\r\n\r\n            // **OPTIMIZATION 9: Coarse tile rejection**\r\n            const tileMinX = Math.floor(minX / tileSize);\r\n            const tileMaxX = Math.floor(maxX / tileSize);\r\n            const tileMinY = Math.floor(minY / tileSize);\r\n            const tileMaxY = Math.floor(maxY / tileSize);\r\n\r\n            // Check if triangle is behind ALL tiles it overlaps\r\n            let canReject = true;\r\n            for (let ty = tileMinY; ty <= tileMaxY && canReject; ty++) {\r\n                for (let tx = tileMinX; tx <= tileMaxX && canReject; tx++) {\r\n                    const tileIdx = ty * tilesX + tx;\r\n                    if (minDepth < coarseZ[tileIdx]) {\r\n                        canReject = false;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (canReject) return; // Triangle is fully occluded\r\n\r\n            // Edge setup\r\n            const x0 = Math.round(p0.x), y0 = Math.round(p0.y), z0 = v0.x;\r\n            const x1 = Math.round(p1.x), y1 = Math.round(p1.y), z1 = v1.x;\r\n            const x2 = Math.round(p2.x), y2 = Math.round(p2.y), z2 = v2.x;\r\n\r\n            const e0_dx = x1 - x0, e0_dy = y1 - y0;\r\n            const e1_dx = x2 - x1, e1_dy = y2 - y1;\r\n            const e2_dx = x0 - x2, e2_dy = y0 - y2;\r\n\r\n            const area = e0_dx * (y2 - y0) - e0_dy * (x2 - x0);\r\n            if (Math.abs(area) < 0.5) return;\r\n\r\n            const invArea = 1.0 / area;\r\n\r\n            // **OPTIMIZATION 10: Scanline with early Z rejection per row**\r\n            for (let y = minY; y <= maxY; y++) {\r\n                let w0 = e0_dx * (y - y0) - e0_dy * (minX - x0);\r\n                let w1 = e1_dx * (y - y1) - e1_dy * (minX - x1);\r\n                let w2 = e2_dx * (y - y2) - e2_dy * (minX - x2);\r\n\r\n                const w0_step = -e0_dy;\r\n                const w1_step = -e1_dy;\r\n                const w2_step = -e2_dy;\r\n\r\n                const rowOffset = y * w;\r\n\r\n                // **OPTIMIZATION 11: Track if ANY pixel in row passed Z test**\r\n                let rowHasWrites = false;\r\n\r\n                for (let x = minX; x <= maxX; x++) {\r\n                    if (w0 >= 0 && w1 >= 0 && w2 >= 0) {\r\n                        const u = w0 * invArea;\r\n                        const v = w1 * invArea;\r\n                        const ww = 1 - u - v;\r\n\r\n                        const depth = z0 * u + z1 * v + z2 * ww;\r\n                        const idx = rowOffset + x;\r\n\r\n                        // **OPTIMIZATION 12: Epsilon comparison to prevent z-fighting**\r\n                        if (depth >= this._nearPlane && depth <= this._farPlane && depth < zbuffer[idx] - 0.001) {\r\n                            zbuffer[idx] = depth;\r\n                            buffer32[idx] = packedColor;\r\n                            rowHasWrites = true;\r\n                        }\r\n                    }\r\n\r\n                    w0 += w0_step;\r\n                    w1 += w1_step;\r\n                    w2 += w2_step;\r\n                }\r\n\r\n                // Early exit if no pixels passed Z test (occluded row)\r\n                if (!rowHasWrites && y > minY + 2) {\r\n                    // Skip to next likely visible row\r\n                    y = Math.min(maxY, y + 2);\r\n                }\r\n            }\r\n\r\n            // **OPTIMIZATION 13: Update coarse Z-buffer**\r\n            for (let ty = tileMinY; ty <= tileMaxY; ty++) {\r\n                for (let tx = tileMinX; tx <= tileMaxX; tx++) {\r\n                    const tileIdx = ty * tilesX + tx;\r\n                    coarseZ[tileIdx] = Math.min(coarseZ[tileIdx], minDepth);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    // Primary depth pass with hierarchical Z-buffer optimization\r\n    renderDepthPassPrimary(triangles, data, w, h, hzbBuffers) {\r\n        // Sort triangles by average depth (back to front for proper depth testing)\r\n        triangles.sort((a, b) => {\r\n            const depthA = (a.v0.x + a.v1.x + a.v2.x) / 3;\r\n            const depthB = (b.v0.x + b.v1.x + b.v2.x) / 3;\r\n            return depthB - depthA; // Back to front\r\n        });\r\n\r\n        triangles.forEach(tri => {\r\n            const { v0, v1, v2, color } = tri;\r\n\r\n            // Project to screen space\r\n            const useExtendedFOV = this._enableBackfaceCulling && !this._disableCulling;\r\n            const p0 = this.projectCameraPoint(v0, useExtendedFOV);\r\n            const p1 = this.projectCameraPoint(v1, useExtendedFOV);\r\n            const p2 = this.projectCameraPoint(v2, useExtendedFOV);\r\n\r\n            if (!p0 || !p1 || !p2) return;\r\n\r\n            // Calculate triangle bounds\r\n            const minX = Math.max(0, Math.min(p0.x, p1.x, p2.x));\r\n            const maxX = Math.min(w - 1, Math.max(p0.x, p1.x, p2.x));\r\n            const minY = Math.max(0, Math.min(p0.y, p1.y, p2.y));\r\n            const maxY = Math.min(h - 1, Math.max(p0.y, p1.y, p2.y));\r\n\r\n            // Early hierarchical depth culling\r\n            const triDepth = (v0.x + v1.x + v2.x) / 3;\r\n            if (this.canCullTriangleHZB(minX, minY, maxX, maxY, triDepth, hzbBuffers)) {\r\n                return;\r\n            }\r\n\r\n            // Rasterize triangle with accurate depth testing\r\n            for (let y = Math.floor(minY); y <= Math.ceil(maxY); y++) {\r\n                for (let x = Math.floor(minX); x <= Math.ceil(maxX); x++) {\r\n                    const bary = this.barycentric(\r\n                        { x: p0.x, y: p0.y, z: v0.x },\r\n                        { x: p1.x, y: p1.y, z: v1.x },\r\n                        { x: p2.x, y: p2.y, z: v2.x },\r\n                        x, y\r\n                    );\r\n\r\n                    if (bary.u >= 0 && bary.v >= 0 && bary.w >= 0) {\r\n                        const depth = bary.u * v0.x + bary.v * v1.x + bary.w * v2.x;\r\n                        const idx = y * w + x;\r\n\r\n                        // Hierarchical depth test\r\n                        if (depth >= this._nearPlane && depth <= this._farPlane &&\r\n                            depth < this._zBuffer[idx] &&\r\n                            this.hierarchicalDepthTest(x, y, depth, hzbBuffers)) {\r\n\r\n                            this._zBuffer[idx] = depth;\r\n                            this.updateHZB(x, y, depth, hzbBuffers);\r\n\r\n                            const pixelIdx = idx * 4;\r\n                            data[pixelIdx] = color.r;\r\n                            data[pixelIdx + 1] = color.g;\r\n                            data[pixelIdx + 2] = color.b;\r\n                            data[pixelIdx + 3] = 255;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    // Check if triangle can be culled using hierarchical Z-buffer\r\n    canCullTriangleHZB(minX, minY, maxX, maxY, triDepth, hzbBuffers) {\r\n        const levels = hzbBuffers.length;\r\n        const startLevel = Math.max(0, Math.floor(Math.log2(Math.max(maxX - minX, maxY - minY))) - 2);\r\n\r\n        for (let level = startLevel; level < levels; level++) {\r\n            const levelSize = Math.max(1, hzbBuffers[0].length >> level);\r\n            const scale = levelSize / Math.max(1, hzbBuffers[0].length >> (level + 1) || 1);\r\n\r\n            const tileX = Math.floor((minX + maxX) * 0.5 / scale);\r\n            const tileY = Math.floor((minY + maxY) * 0.5 / scale);\r\n\r\n            if (tileX >= 0 && tileX < levelSize && tileY >= 0 && tileY < levelSize) {\r\n                const hzbIdx = tileY * levelSize + tileX;\r\n                if (hzbBuffers[level][hzbIdx] < triDepth) {\r\n                    return true; // Triangle is behind HZB, cull it\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // Hierarchical depth test\r\n    hierarchicalDepthTest(x, y, depth, hzbBuffers) {\r\n        const levels = hzbBuffers.length;\r\n\r\n        for (let level = 0; level < levels; level++) {\r\n            const levelSize = Math.max(1, hzbBuffers[0].length >> level);\r\n            const tileX = Math.floor(x * levelSize / this._renderTextureWidth);\r\n            const tileY = Math.floor(y * levelSize / this._renderTextureHeight);\r\n\r\n            if (tileX >= 0 && tileX < levelSize && tileY >= 0 && tileY < levelSize) {\r\n                const hzbIdx = tileY * levelSize + tileX;\r\n                if (depth >= hzbBuffers[level][hzbIdx]) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // Update hierarchical Z-buffer\r\n    updateHZB(x, y, depth, hzbBuffers) {\r\n        const levels = hzbBuffers.length;\r\n\r\n        for (let level = 0; level < levels; level++) {\r\n            const levelSize = Math.max(1, hzbBuffers[0].length >> level);\r\n            const tileX = Math.floor(x * levelSize / this._renderTextureWidth);\r\n            const tileY = Math.floor(y * levelSize / this._renderTextureHeight);\r\n\r\n            if (tileX >= 0 && tileX < levelSize && tileY >= 0 && tileY < levelSize) {\r\n                const hzbIdx = tileY * levelSize + tileX;\r\n                hzbBuffers[level][hzbIdx] = Math.min(hzbBuffers[level][hzbIdx], depth);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Apply depth of field effect\r\n    applyDepthOfField(data, w, h) {\r\n        if (!this._depthOfFieldEnabled) return;\r\n\r\n        const tempBuffer = new Uint8ClampedArray(data);\r\n\r\n        for (let y = 0; y < h; y++) {\r\n            for (let x = 0; x < w; x++) {\r\n                const idx = y * w + x;\r\n                const depth = this._zBuffer[idx];\r\n\r\n                if (depth === Infinity) continue;\r\n\r\n                // Calculate blur amount based on depth difference from focal plane\r\n                const depthDiff = Math.abs(depth - this._focalDistance);\r\n                const blurRadius = Math.min(this._maxBlurRadius, (depthDiff / this._aperture));\r\n\r\n                if (blurRadius < 1) continue;\r\n\r\n                // Apply Gaussian blur\r\n                let r = 0, g = 0, b = 0, samples = 0;\r\n                const radius = Math.ceil(blurRadius);\r\n\r\n                for (let by = -radius; by <= radius; by++) {\r\n                    for (let bx = -radius; bx <= radius; bx++) {\r\n                        const sx = x + bx;\r\n                        const sy = y + by;\r\n\r\n                        if (sx >= 0 && sx < w && sy >= 0 && sy < h) {\r\n                            const sIdx = sy * w + sx;\r\n                            const distance = Math.sqrt(bx * bx + by * by);\r\n                            const weight = Math.exp(-(distance * distance) / (2 * blurRadius * blurRadius));\r\n\r\n                            r += tempBuffer[sIdx * 4] * weight;\r\n                            g += tempBuffer[sIdx * 4 + 1] * weight;\r\n                            b += tempBuffer[sIdx * 4 + 2] * weight;\r\n                            samples += weight;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                data[idx * 4] = Math.round(r / samples);\r\n                data[idx * 4 + 1] = Math.round(g / samples);\r\n                data[idx * 4 + 2] = Math.round(b / samples);\r\n            }\r\n        }\r\n    }\r\n\r\n    renderZBuffer() {\r\n        const allObjects = this.getGameObjects();\r\n        const ctx = this._renderTextureCtx;\r\n        const imgData = this._imageData;\r\n        const data = imgData.data;\r\n        const w = this._renderTextureWidth, h = this._renderTextureHeight;\r\n\r\n        // Initialize z-buffer\r\n        if (this._zBuffer) this._zBuffer.fill(Infinity);\r\n\r\n        // Handle background clearing\r\n        if (this._backgroundType === \"transparent\") {\r\n            // Leave transparent pixels\r\n            for (let i = 0; i < data.length; i += 4) {\r\n                if (data[i + 3] === 0) continue; // Skip already transparent\r\n            }\r\n        } else if (this._backgroundType === \"solid\") {\r\n            const bgColor = this.hexToRgb(this._backgroundColor);\r\n            for (let i = 0; i < data.length; i += 4) {\r\n                data[i] = bgColor.r; data[i + 1] = bgColor.g; data[i + 2] = bgColor.b; data[i + 3] = 255;\r\n            }\r\n        } else if (this._backgroundType === \"skyfloor\") {\r\n            const fovRadians = this._fieldOfView * (Math.PI / 180);\r\n            const pitchRadians = (this._rotation.y || 0) * (Math.PI / 180);\r\n            const maxPitch = fovRadians / 2;\r\n            const normalizedPitch = -Math.max(-1, Math.min(1, pitchRadians / maxPitch));\r\n            const horizonOffset = normalizedPitch * 0.5;\r\n            const horizonRatio = 0.5 + horizonOffset;\r\n            const clampedHorizon = Math.max(0, Math.min(1, horizonRatio));\r\n            const horizonY = Math.floor(h * clampedHorizon);\r\n\r\n            for (let i = 0; i < data.length; i += 4) {\r\n                const y = Math.floor((i / 4) / w);\r\n                if (y < horizonY) {\r\n                    data[i] = this.hexToRgb(this._skyColor).r;\r\n                    data[i + 1] = this.hexToRgb(this._skyColor).g;\r\n                    data[i + 2] = this.hexToRgb(this._skyColor).b;\r\n                } else {\r\n                    data[i] = this.hexToRgb(this._floorColor).r;\r\n                    data[i + 1] = this.hexToRgb(this._floorColor).g;\r\n                    data[i + 2] = this.hexToRgb(this._floorColor).b;\r\n                }\r\n                data[i + 3] = 255;\r\n            }\r\n        }\r\n\r\n        // Use Uint32Array for 4x faster pixel writes\r\n        const buffer32 = new Uint32Array(imgData.data.buffer);\r\n\r\n        // Collect all triangles with metadata\r\n        const allTriangles = [];\r\n\r\n        allObjects.forEach(obj => {\r\n            if (!obj.active) return;\r\n            const mesh = obj.getModule(\"Mesh3D\") || obj.getModule(\"CubeMesh3D\") || obj.getModule(\"SphereMesh3D\");\r\n            if (!mesh) return;\r\n            const transformedVertices = mesh.transformVertices();\r\n            if (!transformedVertices || !mesh.faces) return;\r\n            const faceColor = mesh.faceColor || mesh._faceColor || \"#888888\";\r\n\r\n            mesh.faces.forEach(face => {\r\n                const cameraVerts = face.map(idx =>\r\n                    idx < transformedVertices.length ? this.worldToCameraSpace(transformedVertices[idx]) : null\r\n                ).filter(v => v);\r\n\r\n                if (cameraVerts.length < 3) return;\r\n\r\n                // Clip against near plane FIRST\r\n                const clippedVerts = this.clipPolygonAgainstNearPlane(cameraVerts, this._nearPlane);\r\n                if (clippedVerts.length < 3) return;\r\n\r\n                // Backface culling AFTER clipping\r\n                if (this._enableBackfaceCulling && !this._disableCulling) {\r\n                    const material = mesh?.material;\r\n                    const isDoubleSided = material ? material._doubleSided : false;\r\n                    if (!isDoubleSided && this.shouldCullFace(clippedVerts)) return;\r\n                }\r\n\r\n                // Calculate world vertices for normal (use original vertices for lighting)\r\n                const worldVerts = face.map(idx => transformedVertices[idx]).filter(v => v);\r\n                if (worldVerts.length < 3) return;\r\n                const worldNormal = this.calculateFaceNormal(worldVerts[0], worldVerts[1], worldVerts[2]);\r\n                const litColor = this.calculateLighting(worldNormal, faceColor);\r\n\r\n                // Project clipped vertices\r\n                const useExtendedFOV = this._enableBackfaceCulling && !this._disableCulling;\r\n                const screenVerts = clippedVerts.map(cv => {\r\n                    const proj = this.projectCameraPoint(cv, useExtendedFOV);\r\n                    return proj ? { screen: proj, depth: cv.x } : null;\r\n                }).filter(v => v);\r\n\r\n                if (screenVerts.length < 3) return;\r\n\r\n                // Pack color as 32-bit ABGR for fast writing\r\n                const packedColor = (255 << 24) | (litColor.b << 16) | (litColor.g << 8) | litColor.r;\r\n\r\n                // Triangulate polygon\r\n                for (let i = 1; i < screenVerts.length - 1; i++) {\r\n                    const tri = {\r\n                        v0: screenVerts[0],\r\n                        v1: screenVerts[i],\r\n                        v2: screenVerts[i + 1],\r\n                        packedColor: packedColor,\r\n                        minDepth: Math.min(screenVerts[0].depth, screenVerts[i].depth, screenVerts[i + 1].depth),\r\n                        avgDepth: (screenVerts[0].depth + screenVerts[i].depth + screenVerts[i + 1].depth) / 3\r\n                    };\r\n\r\n                    // Calculate tight screen-space bounding box\r\n                    const x0 = tri.v0.screen.x, x1 = tri.v1.screen.x, x2 = tri.v2.screen.x;\r\n                    const y0 = tri.v0.screen.y, y1 = tri.v1.screen.y, y2 = tri.v2.screen.y;\r\n\r\n                    tri.bounds = {\r\n                        minX: Math.max(0, Math.floor(Math.min(x0, x1, x2))),\r\n                        maxX: Math.min(w - 1, Math.ceil(Math.max(x0, x1, x2))),\r\n                        minY: Math.max(0, Math.floor(Math.min(y0, y1, y2))),\r\n                        maxY: Math.min(h - 1, Math.ceil(Math.max(y0, y1, y2)))\r\n                    };\r\n\r\n                    // Skip degenerate triangles\r\n                    if (tri.bounds.minX > tri.bounds.maxX || tri.bounds.minY > tri.bounds.maxY) continue;\r\n\r\n                    // Calculate area for importance\r\n                    const area = Math.abs((x1 - x0) * (y2 - y0) - (x2 - x0) * (y1 - y0)) / 2;\r\n                    if (area < 0.5) continue; // Skip tiny triangles\r\n\r\n                    tri.screenArea = area;\r\n                    allTriangles.push(tri);\r\n                }\r\n            });\r\n        });\r\n\r\n        // Sort front-to-back for early Z rejection\r\n        allTriangles.sort((a, b) => a.minDepth - b.minDepth);\r\n\r\n        // Optimized rasterization with scanline algorithm\r\n        allTriangles.forEach(tri => {\r\n            this.rasterizeTriangleZBuffer(tri, buffer32, this._zBuffer, w, h);\r\n        });\r\n\r\n        ctx.putImageData(imgData, 0, 0);\r\n    }\r\n\r\n    // Highly optimized scanline rasterizer with proper depth interpolation\r\n    rasterizeTriangleZBuffer(tri, buffer32, zBuffer, w, h) {\r\n        const { v0, v1, v2, packedColor, bounds } = tri;\r\n        const { minX, maxX, minY, maxY } = bounds;\r\n\r\n        // Convert to integer screen coordinates\r\n        const x0 = Math.round(v0.screen.x), y0 = Math.round(v0.screen.y), z0 = v0.depth;\r\n        const x1 = Math.round(v1.screen.x), y1 = Math.round(v1.screen.y), z1 = v1.depth;\r\n        const x2 = Math.round(v2.screen.x), y2 = Math.round(v2.screen.y), z2 = v2.depth;\r\n\r\n        // Edge setup for inside testing\r\n        const dx01 = x1 - x0, dy01 = y1 - y0;\r\n        const dx12 = x2 - x1, dy12 = y2 - y1;\r\n        const dx20 = x0 - x2, dy20 = y0 - y2;\r\n\r\n        // Calculate triangle area for barycentric coordinates\r\n        const area = dx01 * (y2 - y0) - dy01 * (x2 - x0);\r\n        if (Math.abs(area) < 0.5) return; // Degenerate triangle\r\n\r\n        const invArea = 1.0 / area;\r\n        const epsilon = 0.001; // Small depth bias to prevent z-fighting\r\n\r\n        // Scanline rasterization with edge coherence\r\n        for (let y = minY; y <= maxY; y++) {\r\n            // Calculate edge functions at scanline start\r\n            let e0 = dx01 * (y - y0) - dy01 * (minX - x0);\r\n            let e1 = dx12 * (y - y1) - dy12 * (minX - x1);\r\n            let e2 = dx20 * (y - y2) - dy20 * (minX - x2);\r\n\r\n            // Edge increments\r\n            const e0_step = -dy01;\r\n            const e1_step = -dy12;\r\n            const e2_step = -dy20;\r\n\r\n            const rowOffset = y * w;\r\n\r\n            for (let x = minX; x <= maxX; x++) {\r\n                // Inside test\r\n                if (e0 >= 0 && e1 >= 0 && e2 >= 0) {\r\n                    // Calculate barycentric coordinates\r\n                    const u = e0 * invArea;\r\n                    const v = e1 * invArea;\r\n                    const ww = 1 - u - v;\r\n\r\n                    // Interpolate depth with perspective correction\r\n                    const depth = u * z0 + v * z1 + ww * z2;\r\n                    const idx = rowOffset + x;\r\n\r\n                    // Depth test with epsilon for stability\r\n                    if (depth >= this._nearPlane && depth <= this._farPlane && depth < zBuffer[idx] - epsilon) {\r\n                        zBuffer[idx] = depth;\r\n                        buffer32[idx] = packedColor;\r\n                    }\r\n                }\r\n\r\n                // Increment edge values\r\n                e0 += e0_step;\r\n                e1 += e1_step;\r\n                e2 += e2_step;\r\n            }\r\n        }\r\n    }\r\n\r\n    // WebGL-accelerated Z-buffer renderer\r\n    renderZBufferWebGL() {\r\n        const gl = this._renderTextureGLCtx;\r\n        const allObjects = this.getGameObjects();\r\n\r\n        // Clear buffers - handle different background types\r\n        if (this._backgroundType === \"solid\") {\r\n            const bgColor = this.hexToRgb(this._backgroundColor);\r\n            gl.clearColor(bgColor.r / 255, bgColor.g / 255, bgColor.b / 255, 1.0);\r\n        } else if (this._backgroundType === \"skyfloor\") {\r\n            // For skyfloor, use a solid clear color (sky color) and let 2D rendering handle the gradient\r\n            const skyColor = this.hexToRgb(this._skyColor);\r\n            gl.clearColor(skyColor.r / 255, skyColor.g / 255, skyColor.b / 255, 1.0);\r\n        } else {\r\n            // Transparent\r\n            gl.clearColor(0, 0, 0, 0);\r\n        }\r\n\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n        gl.useProgram(this._glProgram);\r\n\r\n        // Build proper projection matrix for X=forward, Y=right, Z=up\r\n        const aspect = this._renderTextureWidth / this._renderTextureHeight;\r\n        const fovRadians = this._fieldOfView * (Math.PI / 180);\r\n        const tanHalfFov = Math.tan(fovRadians / 2);\r\n        const near = this._nearPlane;\r\n        const far = this._farPlane;\r\n\r\n        // Create perspective projection matrix that maps camera space to clip space\r\n        // Camera space: X=depth(forward), Y=right, Z=up\r\n        // Clip space: X=right, Y=up, Z=depth (with perspective divide)\r\n        const projectionMatrix = new Float32Array([\r\n            1 / (aspect * tanHalfFov), 0, 0, 0,                                    // Maps Y(right) to clip X\r\n            0, 1 / tanHalfFov, 0, 0,                                              // Maps Z(up) to clip Y\r\n            0, 0, -(far + near) / (far - near), -(2 * far * near) / (far - near), // Maps X(depth) to clip Z\r\n            0, 0, -1, 0                                                            // Perspective divide by -X\r\n        ]);\r\n\r\n        gl.uniformMatrix4fv(this._glProjectionUniform, false, projectionMatrix);\r\n\r\n        // Collect all triangles\r\n        const allTriangles = [];\r\n\r\n        allObjects.forEach(obj => {\r\n            if (!obj.active) return;\r\n            const mesh = obj.getModule(\"Mesh3D\") || obj.getModule(\"CubeMesh3D\") || obj.getModule(\"SphereMesh3D\");\r\n            if (!mesh) return;\r\n\r\n            const transformedVertices = mesh.transformVertices();\r\n            if (!transformedVertices || !mesh.faces) return;\r\n\r\n            const faceColor = mesh.faceColor || mesh._faceColor || \"#888888\";\r\n\r\n            mesh.faces.forEach(face => {\r\n                const worldVerts = face.map(idx => transformedVertices[idx]).filter(v => v);\r\n                if (worldVerts.length < 3) return;\r\n\r\n                const cameraVerts = worldVerts.map(v => this.worldToCameraSpace(v));\r\n                if (cameraVerts.length < 3) return;\r\n\r\n                const worldNormal = this.calculateFaceNormal(worldVerts[0], worldVerts[1], worldVerts[2]);\r\n                const litColor = this.calculateLighting(worldNormal, faceColor);\r\n\r\n                // Clip against near plane\r\n                const clippedVerts = this.clipPolygonAgainstNearPlane(cameraVerts, this._nearPlane);\r\n                if (clippedVerts.length < 3) return;\r\n\r\n                // Backface culling\r\n                if (this._enableBackfaceCulling && !this._disableCulling) {\r\n                    const material = mesh?.material;\r\n                    const isDoubleSided = material ? material._doubleSided : false;\r\n                    if (!isDoubleSided && this.shouldCullFace(clippedVerts)) return;\r\n                }\r\n\r\n                // Triangulate polygon\r\n                for (let i = 1; i < clippedVerts.length - 1; i++) {\r\n                    allTriangles.push({\r\n                        vertices: [clippedVerts[0], clippedVerts[i], clippedVerts[i + 1]],\r\n                        color: litColor\r\n                    });\r\n                }\r\n            });\r\n        });\r\n\r\n        if (allTriangles.length === 0) {\r\n            // Copy WebGL canvas to 2D canvas even if empty\r\n            this._renderTextureCtx.drawImage(this._renderTextureGL, 0, 0);\r\n            return;\r\n        }\r\n\r\n        // Batch render all triangles\r\n        const vertexData = [];\r\n        const colorData = [];\r\n\r\n        allTriangles.forEach(tri => {\r\n            tri.vertices.forEach(v => {\r\n                // Send vertices in camera space directly\r\n                // X=depth, Y=right, Z=up (shader will transform with projection matrix)\r\n                vertexData.push(v.x, v.y, v.z);\r\n                colorData.push(tri.color.r / 255, tri.color.g / 255, tri.color.b / 255);\r\n            });\r\n        });\r\n\r\n        // Create buffers\r\n        const vertexBuffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexData), gl.STATIC_DRAW);\r\n        gl.enableVertexAttribArray(this._glPositionAttrib);\r\n        gl.vertexAttribPointer(this._glPositionAttrib, 3, gl.FLOAT, false, 0, 0);\r\n\r\n        const colorBuffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colorData), gl.STATIC_DRAW);\r\n        gl.enableVertexAttribArray(this._glColorAttrib);\r\n        gl.vertexAttribPointer(this._glColorAttrib, 3, gl.FLOAT, false, 0, 0);\r\n\r\n        // Draw all triangles\r\n        gl.drawArrays(gl.TRIANGLES, 0, vertexData.length / 3);\r\n\r\n        // Copy WebGL canvas to 2D canvas\r\n        this._renderTextureCtx.drawImage(this._renderTextureGL, 0, 0);\r\n    }\r\n\r\n    // Highly optimized triangle rasterization with scanline + early Z rejection\r\n    rasterizeTriangleOptimized2(v0, v1, v2, color, data, w, h) {\r\n        // Round to integer coordinates\r\n        const p0 = { x: Math.round(v0.screen.x), y: Math.round(v0.screen.y), z: v0.depth };\r\n        const p1 = { x: Math.round(v1.screen.x), y: Math.round(v1.screen.y), z: v1.depth };\r\n        const p2 = { x: Math.round(v2.screen.x), y: Math.round(v2.screen.y), z: v2.depth };\r\n\r\n        // Calculate bounding box\r\n        const minX = Math.max(0, Math.min(p0.x, p1.x, p2.x));\r\n        const maxX = Math.min(w - 1, Math.max(p0.x, p1.x, p2.x));\r\n        const minY = Math.max(0, Math.min(p0.y, p1.y, p2.y));\r\n        const maxY = Math.min(h - 1, Math.max(p0.y, p1.y, p2.y));\r\n\r\n        // Early rejection if triangle is completely outside screen\r\n        if (minX > maxX || minY > maxY) return;\r\n\r\n        // Precompute edge equations for fast inside testing\r\n        const v0x = p0.x, v0y = p0.y;\r\n        const v1x = p1.x, v1y = p1.y;\r\n        const v2x = p2.x, v2y = p2.y;\r\n\r\n        // Edge equations: e = (x2-x1)(y-y1) - (y2-y1)(x-x1)\r\n        const e0_dx = v1x - v0x, e0_dy = v1y - v0y;\r\n        const e1_dx = v2x - v1x, e1_dy = v2y - v1y;\r\n        const e2_dx = v0x - v2x, e2_dy = v0y - v2y;\r\n\r\n        // Calculate triangle area for barycentric coordinates\r\n        const area = e0_dx * (v2y - v0y) - e0_dy * (v2x - v0x);\r\n        if (Math.abs(area) < 0.001) return; // Degenerate triangle\r\n\r\n        const invArea = 1.0 / area;\r\n\r\n        // Precompute color values\r\n        const r = color.r, g = color.g, b = color.b;\r\n\r\n        // Scanline rasterization with edge coherence\r\n        for (let y = minY; y <= maxY; y++) {\r\n            // Calculate edge values at start of scanline\r\n            let w0 = e0_dx * (y - v0y) - e0_dy * (minX - v0x);\r\n            let w1 = e1_dx * (y - v1y) - e1_dy * (minX - v1x);\r\n            let w2 = e2_dx * (y - v2y) - e2_dy * (minX - v2x);\r\n\r\n            // Edge increments for x-stepping\r\n            const w0_step = -e0_dy;\r\n            const w1_step = -e1_dy;\r\n            const w2_step = -e2_dy;\r\n\r\n            for (let x = minX; x <= maxX; x++) {\r\n                // Inside test using edge equations\r\n                if (w0 >= 0 && w1 >= 0 && w2 >= 0) {\r\n                    // Calculate barycentric coordinates for depth interpolation\r\n                    const u = w0 * invArea;\r\n                    const v = w1 * invArea;\r\n                    const ww = 1 - u - v;\r\n\r\n                    // Interpolate depth\r\n                    const depth = p0.z * u + p1.z * v + p2.z * ww;\r\n\r\n                    const idx = y * w + x;\r\n\r\n                    // Depth test with early rejection\r\n                    if (depth >= this._nearPlane && depth <= this._farPlane && depth < this._zBuffer[idx]) {\r\n                        this._zBuffer[idx] = depth;\r\n                        const pixelIdx = idx * 4;\r\n                        data[pixelIdx] = r;\r\n                        data[pixelIdx + 1] = g;\r\n                        data[pixelIdx + 2] = b;\r\n                        data[pixelIdx + 3] = 255;\r\n                    }\r\n                }\r\n\r\n                // Increment edge values\r\n                w0 += w0_step;\r\n                w1 += w1_step;\r\n                w2 += w2_step;\r\n            }\r\n        }\r\n    }\r\n\r\n    rasterizeTriangle(v0, v1, v2, color, data, w, h) {\r\n        const p0 = { x: Math.round(v0.screen.x), y: Math.round(v0.screen.y), z: v0.depth };\r\n        const p1 = { x: Math.round(v1.screen.x), y: Math.round(v1.screen.y), z: v1.depth };\r\n        const p2 = { x: Math.round(v2.screen.x), y: Math.round(v2.screen.y), z: v2.depth };\r\n        const minX = Math.max(0, Math.min(p0.x, p1.x, p2.x));\r\n        const maxX = Math.min(w - 1, Math.max(p0.x, p1.x, p2.x));\r\n        const minY = Math.max(0, Math.min(p0.y, p1.y, p2.y));\r\n        const maxY = Math.min(h - 1, Math.max(p0.y, p1.y, p2.y));\r\n        for (let y = minY; y <= maxY; y++) {\r\n            for (let x = minX; x <= maxX; x++) {\r\n                const bary = this.barycentric(p0, p1, p2, x, y);\r\n                if (bary.u >= 0 && bary.v >= 0 && bary.w >= 0) {\r\n                    const depth = bary.u * p0.z + bary.v * p1.z + bary.w * p2.z;\r\n                    const idx = y * w + x;\r\n                    if (depth >= this._nearPlane && depth <= this._farPlane && depth < this._zBuffer[idx]) {\r\n                        this._zBuffer[idx] = depth;\r\n                        const pixelIdx = idx * 4;\r\n                        data[pixelIdx] = color.r; data[pixelIdx + 1] = color.g;\r\n                        data[pixelIdx + 2] = color.b; data[pixelIdx + 3] = 255;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    barycentric(p0, p1, p2, x, y) {\r\n        const denom = (p1.y - p2.y) * (p0.x - p2.x) + (p2.x - p1.x) * (p0.y - p2.y);\r\n        if (Math.abs(denom) < 0.001) return { u: -1, v: -1, w: -1 };\r\n        const u = ((p1.y - p2.y) * (x - p2.x) + (p2.x - p1.x) * (y - p2.y)) / denom;\r\n        const v = ((p2.y - p0.y) * (x - p2.x) + (p0.x - p2.x) * (y - p2.y)) / denom;\r\n        return { u, v, w: 1 - u - v };\r\n    }\r\n\r\n    hexToRgb(hex) {\r\n        const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\r\n        return result ? {\r\n            r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16)\r\n        } : { r: 0, g: 0, b: 0 };\r\n    }\r\n\r\n    renderScanline() {\r\n        const allObjects = this.getGameObjects();\r\n        const ctx = this._renderTextureCtx;\r\n        const w = this._renderTextureWidth, h = this._renderTextureHeight;\r\n\r\n        // Clear buffers\r\n        this._zBuffer.fill(Infinity);\r\n        this.clearRenderTexture();\r\n\r\n        // Build edge table and active edge table\r\n        const edgeTable = Array.from({ length: h }, () => []);\r\n        const activeEdges = [];\r\n\r\n        allObjects.forEach(obj => {\r\n            if (!obj.active) return;\r\n            const mesh = obj.getModule(\"Mesh3D\") || obj.getModule(\"CubeMesh3D\") || obj.getModule(\"SphereMesh3D\");\r\n            if (!mesh) return;\r\n            const transformedVertices = mesh.transformVertices();\r\n            if (!transformedVertices || !mesh.faces) return;\r\n\r\n            mesh.faces.forEach(face => {\r\n                const cameraVerts = face.map(idx =>\r\n                    idx < transformedVertices.length ? this.worldToCameraSpace(transformedVertices[idx]) : null\r\n                ).filter(v => v);\r\n\r\n                if (cameraVerts.length < 3) return;\r\n\r\n                const clippedVerts = this.clipPolygonAgainstNearPlane(cameraVerts, this._nearPlane);\r\n                if (clippedVerts.length < 3) return;\r\n\r\n                // Backface culling using consistent method (after clipping)\r\n                if (this._enableBackfaceCulling && !this._disableCulling) {\r\n                    if (this.shouldCullFace(clippedVerts)) {\r\n                        return;\r\n                    }\r\n                }\r\n\r\n                const useExtendedFOV = this._enableBackfaceCulling && !this._disableCulling;\r\n                const screenVerts = clippedVerts.map(cv => {\r\n                    const proj = this.projectCameraPoint(cv, useExtendedFOV);\r\n                    return proj ? { screen: proj, depth: cv.x } : null;\r\n                }).filter(v => v);\r\n\r\n                if (screenVerts.length < 3) return;\r\n\r\n                // Add edges to edge table for each triangle in the polygon\r\n                for (let i = 1; i < screenVerts.length - 1; i++) {\r\n                    const tri = [screenVerts[0], screenVerts[i], screenVerts[i + 1]];\r\n                    this.addTriangleEdgesToEdgeTable(tri, edgeTable, h);\r\n                }\r\n            });\r\n        });\r\n\r\n        // Process scanlines using active edge table\r\n        for (let y = 0; y < h; y++) {\r\n            // Add edges that start at this scanline\r\n            edgeTable[y].forEach(edge => {\r\n                activeEdges.push(edge);\r\n            });\r\n\r\n            // Remove edges that end at this scanline\r\n            for (let i = activeEdges.length - 1; i >= 0; i--) {\r\n                if (Math.ceil(activeEdges[i].yEnd) <= y) {\r\n                    activeEdges.splice(i, 1);\r\n                }\r\n            }\r\n\r\n            if (activeEdges.length < 2) continue;\r\n\r\n            // Sort active edges by x coordinate\r\n            activeEdges.sort((a, b) => a.x - b.x);\r\n\r\n            // Fill between edge pairs\r\n            for (let i = 0; i < activeEdges.length - 1; i += 2) {\r\n                const leftEdge = activeEdges[i];\r\n                const rightEdge = activeEdges[i + 1];\r\n\r\n                const xStart = Math.max(0, Math.ceil(leftEdge.x));\r\n                const xEnd = Math.min(w - 1, Math.floor(rightEdge.x));\r\n\r\n                if (xStart > xEnd) continue;\r\n\r\n                // Calculate depth values for left and right edges\r\n                const leftZ = leftEdge.z + (y - leftEdge.yStart) * leftEdge.zSlope;\r\n                const rightZ = rightEdge.z + (y - rightEdge.yStart) * rightEdge.zSlope;\r\n\r\n                // Fill scanline\r\n                for (let x = xStart; x <= xEnd; x++) {\r\n                    if (x < 0 || x >= w) continue;\r\n\r\n                    const t = (xEnd - xStart) > 0 ? (x - xStart) / (xEnd - xStart) : 0;\r\n                    const z = leftZ + t * (rightZ - leftZ);\r\n                    const idx = y * w + x;\r\n\r\n                    if (z >= this._nearPlane && z <= this._farPlane && z < this._zBuffer[idx]) {\r\n                        this._zBuffer[idx] = z;\r\n\r\n                        // Set pixel color (use a default color for now)\r\n                        const color = leftEdge.color || \"#888888\";\r\n                        ctx.fillStyle = color;\r\n                        ctx.fillRect(x, y, 1, 1);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Update active edges for next scanline\r\n            activeEdges.forEach(edge => {\r\n                edge.x += edge.slope;\r\n                edge.z += edge.zSlope;\r\n            });\r\n        }\r\n    }\r\n\r\n    // WebGL-accelerated raster rendering\r\n    renderRasterWebGL() {\r\n        const gl = this._renderTextureGLCtx;\r\n        const allObjects = this.getGameObjects();\r\n\r\n        // Clear buffers - handle different background types\r\n        if (this._backgroundType === \"solid\") {\r\n            const bgColor = this.hexToRgb(this._backgroundColor);\r\n            gl.clearColor(bgColor.r / 255, bgColor.g / 255, bgColor.b / 255, 1.0);\r\n        } else if (this._backgroundType === \"skyfloor\") {\r\n            // For skyfloor, use a solid clear color (sky color) and let 2D rendering handle the gradient\r\n            const skyColor = this.hexToRgb(this._skyColor);\r\n            gl.clearColor(skyColor.r / 255, skyColor.g / 255, skyColor.b / 255, 1.0);\r\n        } else {\r\n            // Transparent\r\n            gl.clearColor(0, 0, 0, 0);\r\n        }\r\n\r\n        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\r\n\r\n        gl.useProgram(this._glProgram);\r\n\r\n        // Build proper projection matrix for X=forward, Y=right, Z=up\r\n        const aspect = this._renderTextureWidth / this._renderTextureHeight;\r\n        const fovRadians = this._fieldOfView * (Math.PI / 180);\r\n        const tanHalfFov = Math.tan(fovRadians / 2);\r\n        const near = this._nearPlane;\r\n        const far = this._farPlane;\r\n\r\n        // Create perspective projection matrix that maps camera space to clip space\r\n        // Camera space: X=depth(forward), Y=right, Z=up\r\n        // Clip space: X=right, Y=up, Z=depth (with perspective divide)\r\n        const projectionMatrix = new Float32Array([\r\n            1 / (aspect * tanHalfFov), 0, 0, 0,                                    // Maps Y(right) to clip X\r\n            0, 1 / tanHalfFov, 0, 0,                                              // Maps Z(up) to clip Y\r\n            0, 0, -(far + near) / (far - near), -(2 * far * near) / (far - near), // Maps X(depth) to clip Z\r\n            0, 0, -1, 0                                                            // Perspective divide by -X\r\n        ]);\r\n\r\n        gl.uniformMatrix4fv(this._glProjectionUniform, false, projectionMatrix);\r\n\r\n        // Collect all triangles\r\n        const allTriangles = [];\r\n\r\n        allObjects.forEach(obj => {\r\n            if (!obj.active) return;\r\n            const mesh = obj.getModule(\"Mesh3D\") || obj.getModule(\"CubeMesh3D\") || obj.getModule(\"SphereMesh3D\");\r\n            if (!mesh) return;\r\n\r\n            const transformedVertices = mesh.transformVertices();\r\n            if (!transformedVertices || !mesh.faces) return;\r\n\r\n            const faceColor = mesh.faceColor || mesh._faceColor || \"#888888\";\r\n\r\n            mesh.faces.forEach(face => {\r\n                const worldVerts = face.map(idx => transformedVertices[idx]).filter(v => v);\r\n                if (worldVerts.length < 3) return;\r\n\r\n                const cameraVerts = worldVerts.map(v => this.worldToCameraSpace(v));\r\n                if (cameraVerts.length < 3) return;\r\n\r\n                const worldNormal = this.calculateFaceNormal(worldVerts[0], worldVerts[1], worldVerts[2]);\r\n                const litColor = this.calculateLighting(worldNormal, faceColor);\r\n\r\n                // Clip against near plane\r\n                const clippedVerts = this.clipPolygonAgainstNearPlane(cameraVerts, this._nearPlane);\r\n                if (clippedVerts.length < 3) return;\r\n\r\n                // Backface culling\r\n                if (this._enableBackfaceCulling && !this._disableCulling) {\r\n                    const material = mesh?.material;\r\n                    const isDoubleSided = material ? material._doubleSided : false;\r\n                    if (!isDoubleSided && this.shouldCullFace(clippedVerts)) return;\r\n                }\r\n\r\n                // Triangulate polygon\r\n                for (let i = 1; i < clippedVerts.length - 1; i++) {\r\n                    allTriangles.push({\r\n                        vertices: [clippedVerts[0], clippedVerts[i], clippedVerts[i + 1]],\r\n                        color: litColor\r\n                    });\r\n                }\r\n            });\r\n        });\r\n\r\n        if (allTriangles.length === 0) {\r\n            // Copy WebGL canvas to 2D canvas even if empty\r\n            this._renderTextureCtx.drawImage(this._renderTextureGL, 0, 0);\r\n            return;\r\n        }\r\n\r\n        // Batch render all triangles\r\n        const vertexData = [];\r\n        const colorData = [];\r\n\r\n        allTriangles.forEach(tri => {\r\n            tri.vertices.forEach(v => {\r\n                // Send vertices in camera space directly\r\n                // X=depth, Y=right, Z=up (shader will transform with projection matrix)\r\n                vertexData.push(v.x, v.y, v.z);\r\n                colorData.push(tri.color.r / 255, tri.color.g / 255, tri.color.b / 255);\r\n            });\r\n        });\r\n\r\n        // Create buffers\r\n        const vertexBuffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexData), gl.STATIC_DRAW);\r\n        gl.enableVertexAttribArray(this._glPositionAttrib);\r\n        gl.vertexAttribPointer(this._glPositionAttrib, 3, gl.FLOAT, false, 0, 0);\r\n\r\n        const colorBuffer = gl.createBuffer();\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\r\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colorData), gl.STATIC_DRAW);\r\n        gl.enableVertexAttribArray(this._glColorAttrib);\r\n        gl.vertexAttribPointer(this._glColorAttrib, 3, gl.FLOAT, false, 0, 0);\r\n\r\n        // Draw all triangles\r\n        gl.drawArrays(gl.TRIANGLES, 0, vertexData.length / 3);\r\n\r\n        // Copy WebGL canvas to 2D canvas\r\n        this._renderTextureCtx.drawImage(this._renderTextureGL, 0, 0);\r\n    }\r\n\r\n    /**\r\n * Optimized pure raster rendering using scanline algorithm\r\n * Fast forward rasterization without Z-buffer overhead\r\n */\r\n    renderRasterOptimized() {\r\n        const allObjects = this.getGameObjects();\r\n        const ctx = this._renderTextureCtx;\r\n        const imgData = this._imageData;\r\n        const data = imgData.data;\r\n        const w = this._renderTextureWidth;\r\n        const h = this._renderTextureHeight;\r\n\r\n        // Use Uint32Array for faster pixel writes\r\n        const buffer32 = new Uint32Array(imgData.data.buffer);\r\n\r\n        // Clear background efficiently\r\n        this.clearBackgroundFast(buffer32, w, h);\r\n\r\n        // Collect all triangles\r\n        const allTriangles = [];\r\n\r\n        allObjects.forEach(obj => {\r\n            if (!obj.active) return;\r\n            const mesh = obj.getModule(\"Mesh3D\") || obj.getModule(\"CubeMesh3D\") || obj.getModule(\"SphereMesh3D\");\r\n            if (!mesh) return;\r\n\r\n            const transformedVertices = mesh.transformVertices();\r\n            if (!transformedVertices || !mesh.faces) return;\r\n\r\n            // Check for Material module and use it for colors and textures\r\n            const material = mesh.material;\r\n            const faceColor = material ? material.diffuseColor : (mesh.faceColor || mesh._faceColor || \"#888888\");\r\n\r\n            mesh.faces.forEach(face => {\r\n                const worldVerts = face.map(idx => transformedVertices[idx]).filter(v => v);\r\n                if (worldVerts.length < 3) return;\r\n\r\n                const cameraVerts = worldVerts.map(v => this.worldToCameraSpace(v));\r\n                if (cameraVerts.length < 3) return;\r\n\r\n                // Clip against near plane\r\n                const clippedVerts = this.clipPolygonAgainstNearPlane(cameraVerts, this._nearPlane);\r\n                if (clippedVerts.length < 3) return;\r\n\r\n                // Backface culling\r\n                if (this._enableBackfaceCulling && !this._disableCulling) {\r\n                    const material = mesh?.material;\r\n                    const isDoubleSided = material ? material._doubleSided : false;\r\n                    if (!isDoubleSided && this.shouldCullFace(clippedVerts)) return;\r\n                }\r\n\r\n                const worldNormal = this.calculateFaceNormal(worldVerts[0], worldVerts[1], worldVerts[2]);\r\n                const litColor = this.calculateLighting(worldNormal, faceColor);\r\n\r\n                // Project vertices\r\n                const useExtendedFOV = this._enableBackfaceCulling && !this._disableCulling;\r\n                const screenVerts = clippedVerts.map(cv => {\r\n                    const proj = this.projectCameraPoint(cv, useExtendedFOV);\r\n                    return proj ? { screen: proj, depth: cv.x } : null;\r\n                }).filter(v => v);\r\n\r\n                if (screenVerts.length < 3) return;\r\n\r\n                // Pack color as 32-bit value (ABGR format for little-endian)\r\n                const packedColor = (255 << 24) | (litColor.b << 16) | (litColor.g << 8) | litColor.r;\r\n\r\n                // Triangulate and add to list\r\n                for (let i = 1; i < screenVerts.length - 1; i++) {\r\n                    allTriangles.push({\r\n                        v0: screenVerts[0],\r\n                        v1: screenVerts[i],\r\n                        v2: screenVerts[i + 1],\r\n                        packedColor: packedColor,\r\n                        avgDepth: (screenVerts[0].depth + screenVerts[i].depth + screenVerts[i + 1].depth) / 3\r\n                    });\r\n                }\r\n            });\r\n        });\r\n\r\n        // Sort back-to-front for painter's algorithm\r\n        allTriangles.sort((a, b) => b.avgDepth - a.avgDepth);\r\n\r\n        // Rasterize all triangles\r\n        allTriangles.forEach(tri => {\r\n            this.rasterizeTriangleFast(tri, buffer32, w, h);\r\n        });\r\n\r\n        ctx.putImageData(imgData, 0, 0);\r\n    }\r\n\r\n    // Optimized pure raster renderer for better performance\r\n    renderRasterHybrid() {\r\n        const allObjects = this.getGameObjects();\r\n        const imgData = this._imageData;\r\n        const data = imgData.data;\r\n        const w = this._renderTextureWidth;\r\n        const h = this._renderTextureHeight;\r\n\r\n        // Use Uint32Array for faster pixel writes (write 4 bytes at once)\r\n        const buffer32 = new Uint32Array(imgData.data.buffer);\r\n        const zbuffer = this._zBuffer;\r\n\r\n        // Clear background with single color write\r\n        const bgColor = this.hexToRgb(this._backgroundColor);\r\n        const bgPixel = (255 << 24) | (bgColor.b << 16) | (bgColor.g << 8) | bgColor.r;\r\n\r\n        for (let i = 0; i < buffer32.length; i++) {\r\n            buffer32[i] = bgPixel;\r\n        }\r\n        zbuffer.fill(Infinity);\r\n\r\n        // Collect triangles (unchanged)\r\n        const allTriangles = [];\r\n\r\n        allObjects.forEach(obj => {\r\n            if (!obj.active) return;\r\n            const mesh = obj.getModule(\"Mesh3D\") || obj.getModule(\"CubeMesh3D\") || obj.getModule(\"SphereMesh3D\");\r\n            if (!mesh) return;\r\n\r\n            const transformedVertices = mesh.transformVertices();\r\n            if (!transformedVertices || !mesh.faces) return;\r\n            const faceColor = mesh.faceColor || mesh._faceColor || \"#888888\";\r\n\r\n            mesh.faces.forEach(face => {\r\n                const worldVerts = face.map(idx => transformedVertices[idx]).filter(v => v);\r\n                if (worldVerts.length < 3) return;\r\n\r\n                const cameraVerts = worldVerts.map(v => this.worldToCameraSpace(v));\r\n                if (cameraVerts.length < 3) return;\r\n\r\n                const worldNormal = this.calculateFaceNormal(worldVerts[0], worldVerts[1], worldVerts[2]);\r\n                const litColor = this.calculateLighting(worldNormal, faceColor);\r\n\r\n                let clippedVerts = this.clipPolygonAgainstNearPlane(cameraVerts, this._nearPlane);\r\n                if (clippedVerts.length < 3) return;\r\n\r\n                if (this._enableBackfaceCulling && !this._disableCulling) {\r\n                    if (this.shouldCullFace(clippedVerts)) return;\r\n                }\r\n\r\n                const useExtendedFOV = this._enableBackfaceCulling && !this._disableCulling;\r\n                const screenVerts = clippedVerts.map(cv => {\r\n                    const proj = this.projectCameraPoint(cv, useExtendedFOV);\r\n                    return proj ? { screen: proj, depth: cv.x } : null;\r\n                }).filter(v => v);\r\n\r\n                if (screenVerts.length < 3) return;\r\n\r\n                for (let i = 1; i < screenVerts.length - 1; i++) {\r\n                    allTriangles.push({\r\n                        v0: screenVerts[0],\r\n                        v1: screenVerts[i],\r\n                        v2: screenVerts[i + 1],\r\n                        color: litColor\r\n                    });\r\n                }\r\n            });\r\n        });\r\n\r\n        // Pre-compute color as packed 32-bit value\r\n        allTriangles.forEach(tri => {\r\n            const c = tri.color;\r\n            tri.packedColor = (255 << 24) | (c.b << 16) | (c.g << 8) | c.r;\r\n        });\r\n\r\n        // Rasterize with optimized inner loop\r\n        allTriangles.forEach(tri => {\r\n            this.rasterizeTriangleUltraFast(tri, buffer32, zbuffer, w, h);\r\n        });\r\n\r\n        this._renderTextureCtx.putImageData(imgData, 0, 0);\r\n    }\r\n\r\n    // Ultra-fast triangle rasterization using 32-bit writes\r\n    rasterizeTriangleUltraFast(tri, buffer32, zbuffer, w, h) {\r\n        const p0 = { x: Math.round(tri.v0.screen.x), y: Math.round(tri.v0.screen.y), z: tri.v0.depth };\r\n        const p1 = { x: Math.round(tri.v1.screen.x), y: Math.round(tri.v1.screen.y), z: tri.v1.depth };\r\n        const p2 = { x: Math.round(tri.v2.screen.x), y: Math.round(tri.v2.screen.y), z: tri.v2.depth };\r\n\r\n        const minX = Math.max(0, Math.min(p0.x, p1.x, p2.x));\r\n        const maxX = Math.min(w - 1, Math.max(p0.x, p1.x, p2.x));\r\n        const minY = Math.max(0, Math.min(p0.y, p1.y, p2.y));\r\n        const maxY = Math.min(h - 1, Math.max(p0.y, p1.y, p2.y));\r\n\r\n        if (minX > maxX || minY > maxY) return;\r\n\r\n        // Edge setup (once per triangle)\r\n        const v0x = p0.x, v0y = p0.y;\r\n        const v1x = p1.x, v1y = p1.y;\r\n        const v2x = p2.x, v2y = p2.y;\r\n\r\n        const e0_dx = v1x - v0x, e0_dy = v1y - v0y;\r\n        const e1_dx = v2x - v1x, e1_dy = v2y - v1y;\r\n        const e2_dx = v0x - v2x, e2_dy = v0y - v2y;\r\n\r\n        const area = e0_dx * (v2y - v0y) - e0_dy * (v2x - v0x);\r\n        if (Math.abs(area) < 0.001) return;\r\n\r\n        const invArea = 1.0 / area;\r\n        const packedColor = tri.packedColor;\r\n\r\n        // Scanline loop with edge coherence\r\n        for (let y = minY; y <= maxY; y++) {\r\n            let w0 = e0_dx * (y - v0y) - e0_dy * (minX - v0x);\r\n            let w1 = e1_dx * (y - v1y) - e1_dy * (minX - v1x);\r\n            let w2 = e2_dx * (y - v2y) - e2_dy * (minX - v2x);\r\n\r\n            const w0_step = -e0_dy;\r\n            const w1_step = -e1_dy;\r\n            const w2_step = -e2_dy;\r\n\r\n            const rowOffset = y * w;\r\n\r\n            for (let x = minX; x <= maxX; x++) {\r\n                if (w0 >= 0 && w1 >= 0 && w2 >= 0) {\r\n                    const u = w0 * invArea;\r\n                    const v = w1 * invArea;\r\n                    const ww = 1 - u - v;\r\n\r\n                    const depth = p0.z * u + p1.z * v + p2.z * ww;\r\n                    const idx = rowOffset + x;\r\n\r\n                    if (depth >= this._nearPlane && depth <= this._farPlane && depth < zbuffer[idx]) {\r\n                        zbuffer[idx] = depth;\r\n                        buffer32[idx] = packedColor;\r\n                    }\r\n                }\r\n\r\n                w0 += w0_step;\r\n                w1 += w1_step;\r\n                w2 += w2_step;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Optimized triangle rasterization with tight bounds and early rejection\r\n    rasterizeTriangleOptimized(tri, data, width, height, tileX, tileY, tileEndX, tileEndY) {\r\n        const { v0, v1, v2, color } = tri;\r\n\r\n        // Calculate triangle bounds within tile\r\n        const minX = Math.max(tileX, Math.floor(Math.min(v0.x, v1.x, v2.x)));\r\n        const maxX = Math.min(tileEndX - 1, Math.ceil(Math.max(v0.x, v1.x, v2.x)));\r\n        const minY = Math.max(tileY, Math.floor(Math.min(v0.y, v1.y, v2.y)));\r\n        const maxY = Math.min(tileEndY - 1, Math.ceil(Math.max(v0.y, v1.y, v2.y)));\r\n\r\n        if (minX > maxX || minY > maxY) return;\r\n\r\n        // Precompute edge equations for faster inside testing\r\n        const edge0 = this.computeEdgeFunction(v1, v2);\r\n        const edge1 = this.computeEdgeFunction(v2, v0);\r\n        const edge2 = this.computeEdgeFunction(v0, v1);\r\n\r\n        // Calculate area (for barycentric coordinates)\r\n        const area = edge0.c + edge1.c + edge2.c;\r\n        if (Math.abs(area) < 0.001) return;\r\n\r\n        const invArea = 1.0 / area;\r\n\r\n        // Scanline rasterization with edge stepping\r\n        for (let y = minY; y <= maxY; y++) {\r\n            for (let x = minX; x <= maxX; x++) {\r\n                // Evaluate edge functions\r\n                const w0 = edge0.a * x + edge0.b * y + edge0.c;\r\n                const w1 = edge1.a * x + edge1.b * y + edge1.c;\r\n                const w2 = edge2.a * x + edge2.b * y + edge2.c;\r\n\r\n                // Inside test\r\n                if (w0 >= 0 && w1 >= 0 && w2 >= 0) {\r\n                    // Calculate barycentric coordinates\r\n                    const baryU = w0 * invArea;\r\n                    const baryV = w1 * invArea;\r\n                    const baryW = w2 * invArea;\r\n\r\n                    // Interpolate depth\r\n                    const depth = baryU * v0.z + baryV * v1.z + baryW * v2.z;\r\n                    const idx = y * width + x;\r\n\r\n                    // Depth test with early rejection\r\n                    if (depth >= this._nearPlane && depth <= this._farPlane && depth < this._zBuffer[idx]) {\r\n                        this._zBuffer[idx] = depth;\r\n                        const pixelIdx = idx * 4;\r\n                        data[pixelIdx] = color.r;\r\n                        data[pixelIdx + 1] = color.g;\r\n                        data[pixelIdx + 2] = color.b;\r\n                        data[pixelIdx + 3] = 255;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Compute edge function coefficients for fast inside testing\r\n    computeEdgeFunction(v0, v1) {\r\n        const a = v0.y - v1.y;\r\n        const b = v1.x - v0.x;\r\n        const c = v0.x * v1.y - v0.y * v1.x;\r\n        return { a, b, c };\r\n    }\r\n\r\n    // Simple raytrace rendering method\r\n    renderRaytrace() {\r\n        const allObjects = this.getGameObjects();\r\n        const ctx = this._renderTextureCtx;\r\n        const imgData = this._imageData;\r\n        const data = imgData.data;\r\n        const w = this._renderTextureWidth, h = this._renderTextureHeight;\r\n        const bgColor = this.hexToRgb(this._backgroundColor);\r\n        const aspect = w / h;\r\n        const fovRadians = this.fieldOfView * (Math.PI / 180);\r\n        const tanHalfFov = Math.tan(fovRadians * 0.5);\r\n        const allTriangles = [];\r\n\r\n        // Fill with background color\r\n        for (let i = 0; i < data.length; i += 4) {\r\n            data[i] = bgColor.r; data[i + 1] = bgColor.g; data[i + 2] = bgColor.b; data[i + 3] = 255;\r\n        }\r\n\r\n        allObjects.forEach(obj => {\r\n            if (!obj.active) return;\r\n            const mesh = obj.getModule(\"Mesh3D\") || obj.getModule(\"CubeMesh3D\");\r\n            if (!mesh) return;\r\n            const material = obj.getModule(\"Material\");\r\n            const transformedVertices = mesh.transformVertices();\r\n            if (!transformedVertices || !mesh.faces) return;\r\n\r\n            // Get UV coordinates for texture mapping\r\n            const uvCoords = mesh.uvCoords || mesh.generateDefaultUVs();\r\n\r\n            mesh.faces.forEach((face, faceIndex) => {\r\n                const cameraVerts = face.map(idx =>\r\n                    idx < transformedVertices.length ? this.worldToCameraSpace(transformedVertices[idx]) : null\r\n                ).filter(v => v);\r\n                if (cameraVerts.length < 3) return;\r\n\r\n                // Get UV coordinates for this face\r\n                const faceUVs = uvCoords && uvCoords[faceIndex] ? uvCoords[faceIndex] : null;\r\n\r\n                for (let i = 1; i < cameraVerts.length - 1; i++) {\r\n                    // Calculate average color for this triangle using material system\r\n                    const color = this.calculateTriangleColor(material, faceUVs, [0, i, i + 1]);\r\n\r\n                    allTriangles.push({\r\n                        v0: cameraVerts[0], v1: cameraVerts[i], v2: cameraVerts[i + 1],\r\n                        color: color\r\n                    });\r\n                }\r\n            });\r\n        });\r\n\r\n        for (let y = 0; y < h; y++) {\r\n            for (let x = 0; x < w; x++) {\r\n                const pixelIdx = (y * w + x) * 4;\r\n                const u = (x / w) * 2 - 1;\r\n                const v = 1 - (y / h) * 2;\r\n                const rayDirX = 1;\r\n                const rayDirY = u * tanHalfFov * aspect;\r\n                const rayDirZ = v * tanHalfFov;\r\n                const rayLen = Math.sqrt(rayDirX * rayDirX + rayDirY * rayDirY + rayDirZ * rayDirZ);\r\n                const rayDir = { x: rayDirX / rayLen, y: rayDirY / rayLen, z: rayDirZ / rayLen };\r\n                const rayOrigin = { x: 0, y: 0, z: 0 };\r\n                let closestT = Infinity;\r\n                let hitColor = null;\r\n                allTriangles.forEach(tri => {\r\n                    const t = this.rayTriangleIntersect(rayOrigin, rayDir, tri.v0, tri.v1, tri.v2);\r\n                    if (t !== null && t < closestT && t >= this._nearPlane && t <= this._farPlane) {\r\n                        closestT = t;\r\n                        hitColor = tri.color;\r\n                    }\r\n                });\r\n                if (hitColor) {\r\n                    data[pixelIdx] = hitColor.r;\r\n                    data[pixelIdx + 1] = hitColor.g;\r\n                    data[pixelIdx + 2] = hitColor.b;\r\n                    data[pixelIdx + 3] = hitColor.a !== undefined ? hitColor.a : 255;\r\n                }\r\n            }\r\n        }\r\n        ctx.putImageData(imgData, 0, 0);\r\n    }\r\n\r\n    calculateTriangleColor(material, faceUVs, vertexIndices) {\r\n        if (!material) {\r\n            // No material, use default color\r\n            return this.hexToRgb(\"#888888\");\r\n        }\r\n\r\n        // If we have UV coordinates, sample texture at triangle center\r\n        if (faceUVs && faceUVs.length >= 3 && vertexIndices.length >= 3) {\r\n            // Calculate centroid UV coordinates\r\n            const u = (faceUVs[vertexIndices[0]].x + faceUVs[vertexIndices[1]].x + faceUVs[vertexIndices[2]].x) / 3;\r\n            const v = (faceUVs[vertexIndices[0]].y + faceUVs[vertexIndices[1]].y + faceUVs[vertexIndices[2]].y) / 3;\r\n\r\n            // Use material's texture sampling\r\n            if (typeof material.sampleTexture === 'function') {\r\n                const colorStr = material.sampleTexture(u, v);\r\n                return this.parseColorString(colorStr);\r\n            }\r\n        }\r\n\r\n        // No texture or no UVs, return diffuse color\r\n        const diffuseColor = material.diffuseColor || \"#FFFFFF\";\r\n        return this.hexToRgb(diffuseColor);\r\n    }\r\n\r\n    parseColorString(colorStr) {\r\n        // Parse rgba(r, g, b, a) format\r\n        const match = colorStr.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*([\\d.]+))?\\)/);\r\n        if (match) {\r\n            return {\r\n                r: parseInt(match[1]),\r\n                g: parseInt(match[2]),\r\n                b: parseInt(match[3]),\r\n                a: Math.floor((match[4] !== undefined ? parseFloat(match[4]) : 1.0) * 255)\r\n            };\r\n        }\r\n        return this.hexToRgb(\"#FFFFFF\");\r\n    }\r\n\r\n    // Ray-traced hybrid rendering with rasterized base and ray-traced enhancements\r\n    renderRaytraceHybrid() {\r\n        const allObjects = this.getGameObjects();\r\n        const ctx = this._renderTextureCtx;\r\n        const imgData = this._imageData;\r\n        const data = imgData.data;\r\n        const w = this._renderTextureWidth, h = this._renderTextureHeight;\r\n\r\n        // Handle background clearing based on background type\r\n        if (this._backgroundType === \"transparent\") {\r\n            // For transparent background, only clear pixels that will have geometry\r\n            // Leave non-geometry pixels as they are (transparent)\r\n        } else {\r\n            // For solid or sky/floor backgrounds, clear all pixels first\r\n            if (this._backgroundType === \"solid\") {\r\n                const bgColor = this.hexToRgb(this._backgroundColor);\r\n                for (let i = 0; i < data.length; i += 4) {\r\n                    data[i] = bgColor.r; data[i + 1] = bgColor.g; data[i + 2] = bgColor.b; data[i + 3] = 255;\r\n                }\r\n            } else if (this._backgroundType === \"skyfloor\") {\r\n                // Calculate dynamic horizon based on camera pitch and FOV for accuracy\r\n                const fovRadians = this._fieldOfView * (Math.PI / 180);\r\n                const pitchRadians = (this._rotation.y || 0) * (Math.PI / 180);\r\n                const maxPitch = fovRadians / 2;\r\n                const normalizedPitch = -Math.max(-1, Math.min(1, pitchRadians / maxPitch)); // Clamp to [-1, 1]\r\n                const horizonOffset = normalizedPitch * 0.5; // Scale to [-0.5, 0.5]\r\n                const horizonRatio = 0.5 + horizonOffset; // 0.5 when level, shifts based on pitch\r\n\r\n                // Clamp horizon between 0 and 1 to avoid extreme cases\r\n                const clampedHorizon = Math.max(0, Math.min(1, horizonRatio));\r\n                const horizonY = Math.floor(h * clampedHorizon);\r\n\r\n                for (let i = 0; i < data.length; i += 4) {\r\n                    const y = Math.floor((i / 4) / w);\r\n                    if (y < horizonY) {\r\n                        data[i] = this.hexToRgb(this._skyColor).r;\r\n                        data[i + 1] = this.hexToRgb(this._skyColor).g;\r\n                        data[i + 2] = this.hexToRgb(this._skyColor).b;\r\n                    } else {\r\n                        data[i] = this.hexToRgb(this._floorColor).r;\r\n                        data[i + 1] = this.hexToRgb(this._floorColor).g;\r\n                        data[i + 2] = this.hexToRgb(this._floorColor).b;\r\n                    }\r\n                    data[i + 3] = 255;\r\n                }\r\n            }\r\n        }\r\n        this._zBuffer.fill(Infinity);\r\n\r\n        // Collect triangles for both rasterization and ray tracing\r\n        // Collect triangles for both rasterization and ray tracing\r\n        const allTriangles = [];\r\n        allObjects.forEach(obj => {\r\n            if (!obj.active) return;\r\n            const mesh = obj.getModule(\"Mesh3D\") || obj.getModule(\"CubeMesh3D\") || obj.getModule(\"SphereMesh3D\");\r\n            if (!mesh) return;\r\n            const transformedVertices = mesh.transformVertices();\r\n            if (!transformedVertices || !mesh.faces) return;\r\n            const faceColor = mesh.faceColor || mesh._faceColor || \"#888888\";\r\n\r\n            mesh.faces.forEach(face => {\r\n                const worldVerts = face.map(idx =>\r\n                    idx < transformedVertices.length ? transformedVertices[idx] : null\r\n                ).filter(v => v);\r\n                if (worldVerts.length < 3) return;\r\n\r\n                const cameraVerts = worldVerts.map(v => this.worldToCameraSpace(v));\r\n                if (cameraVerts.length < 3) return;\r\n\r\n                const worldNormal = this.calculateFaceNormal(worldVerts[0], worldVerts[1], worldVerts[2]);\r\n\r\n                for (let i = 1; i < cameraVerts.length - 1; i++) {\r\n                    const v0 = cameraVerts[0], v1 = cameraVerts[i], v2 = cameraVerts[i + 1];\r\n\r\n                    // Backface culling BEFORE clipping using original camera space vertices\r\n                    if (this._enableBackfaceCulling && !this._disableCulling) {\r\n                        if (this.shouldCullFace([v0, v1, v2])) {\r\n                            continue; // Cull back-facing triangles\r\n                        }\r\n                    }\r\n\r\n                    // Clip triangle against near plane\r\n                    const clippedV0 = this.clipPolygonAgainstNearPlane([v0], this._nearPlane);\r\n                    const clippedV1 = this.clipPolygonAgainstNearPlane([v1], this._nearPlane);\r\n                    const clippedV2 = this.clipPolygonAgainstNearPlane([v2], this._nearPlane);\r\n\r\n                    if (clippedV0.length > 0 && clippedV1.length > 0 && clippedV2.length > 0) {\r\n                        allTriangles.push({\r\n                            v0: clippedV0[0] || v0,\r\n                            v1: clippedV1[0] || v1,\r\n                            v2: clippedV2[0] || v2,\r\n                            worldNormal,\r\n                            baseColor: faceColor\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        });\r\n\r\n        // Build BVH for ray tracing\r\n        const bvh = this.buildBVH(allTriangles, 8);\r\n\r\n        // Rasterize base geometry\r\n        allTriangles.forEach(tri => {\r\n            const useExtendedFOV = this._enableBackfaceCulling && !this._disableCulling;\r\n            const p0 = this.projectCameraPoint(tri.v0, useExtendedFOV);\r\n            const p1 = this.projectCameraPoint(tri.v1, useExtendedFOV);\r\n            const p2 = this.projectCameraPoint(tri.v2, useExtendedFOV);\r\n\r\n            if (!p0 || !p1 || !p2) return;\r\n\r\n            const screenTri = {\r\n                v0: { x: p0.x, y: p0.y, z: tri.v0.x },\r\n                v1: { x: p1.x, y: p1.y, z: tri.v1.x },\r\n                v2: { x: p2.x, y: p2.y, z: tri.v2.x },\r\n                color: this.calculateLighting(tri.worldNormal, tri.baseColor)\r\n            };\r\n\r\n            this.rasterizeTriangleOptimized(screenTri, data, w, h, 0, 0, w, h);\r\n        });\r\n\r\n        // Second pass: Ray-traced enhancements (reflections, shadows, etc.)\r\n        // Only process pixels that have geometry and sample every 4th pixel for performance\r\n        const rayStep = 4;\r\n        const aspect = w / h;\r\n        const fovRadians = this.fieldOfView * (Math.PI / 180);\r\n        const tanHalfFov = Math.tan(fovRadians * 0.5);\r\n\r\n        // Pre-filter triangles that are potentially visible for ray tracing\r\n        const visibleTriangles = [];\r\n        allTriangles.forEach(tri => {\r\n            // Quick frustum check - only include triangles that might be visible\r\n            // Camera looks along +X axis, so X coordinate represents depth\r\n            const avgDepth = (tri.v0.x + tri.v1.x + tri.v2.x) / 3;\r\n\r\n            // Check if triangle intersects frustum (between near and far planes)\r\n            const vertices = [tri.v0, tri.v1, tri.v2];\r\n            let inFrontNear = 0;\r\n            let behindFar = 0;\r\n\r\n            for (const vertex of vertices) {\r\n                if (vertex.x >= this._nearPlane) inFrontNear++;\r\n                if (vertex.x <= this._farPlane) behindFar++;\r\n            }\r\n\r\n            // Include triangle if it intersects the frustum\r\n            const isInFrustum = !(behindFar === 0) && (inFrontNear === 3 || inFrontNear > 0);\r\n\r\n            if (isInFrustum) {\r\n                // Additional FOV check for better culling\r\n                const useExtendedFov = !this._disableCulling;\r\n                const p0 = this.projectCameraPoint(tri.v0, useExtendedFov);\r\n                const p1 = this.projectCameraPoint(tri.v1, useExtendedFov);\r\n                const p2 = this.projectCameraPoint(tri.v2, useExtendedFov);\r\n\r\n                // If any vertex projects successfully, include triangle for ray tracing\r\n                if (p0 || p1 || p2) {\r\n                    visibleTriangles.push(tri);\r\n                }\r\n            }\r\n        });\r\n\r\n        for (let y = 0; y < h; y += rayStep) {\r\n            for (let x = 0; x < w; x += rayStep) {\r\n                const idx = y * w + x;\r\n                const depth = this._zBuffer[idx];\r\n\r\n                if (depth === Infinity || depth >= this._farPlane) continue;\r\n\r\n                // Cast ray for this pixel\r\n                const u = (x / w) * 2 - 1;\r\n                const v = 1 - (y / h) * 2;\r\n                const rayDirX = 1;\r\n                const rayDirY = u * tanHalfFov * aspect;\r\n                const rayDirZ = v * tanHalfFov;\r\n                const rayLen = Math.sqrt(rayDirX * rayDirX + rayDirY * rayDirY + rayDirZ * rayDirZ);\r\n                const rayDir = { x: rayDirX / rayLen, y: rayDirY / rayLen, z: rayDirZ / rayLen };\r\n                const rayOrigin = { x: 0, y: 0, z: 0 };\r\n\r\n                // Simple ambient occlusion approximation using pre-filtered triangles\r\n                const aoSamples = 3;\r\n                let occluded = 0;\r\n\r\n                for (let i = 0; i < aoSamples; i++) {\r\n                    const offset = { x: rayDir.x * depth, y: rayDir.y * depth, z: rayDir.z * depth };\r\n                    const sampleOrigin = {\r\n                        x: offset.x + (Math.random() - 0.5) * 0.5,\r\n                        y: offset.y + (Math.random() - 0.5) * 0.5,\r\n                        z: offset.z + (Math.random() - 0.5) * 0.5\r\n                    };\r\n\r\n                    const hit = this.traceRayBVH(sampleOrigin, this._lightDirection, bvh, 0.01, 10);\r\n                    if (hit) occluded++;\r\n                }\r\n\r\n                const ao = 1.0 - (occluded / aoSamples) * 0.5;\r\n                const pixelIdx = idx * 4;\r\n                data[pixelIdx] = Math.round(data[pixelIdx] * ao);\r\n                data[pixelIdx + 1] = Math.round(data[pixelIdx + 1] * ao);\r\n                data[pixelIdx + 2] = Math.round(data[pixelIdx + 2] * ao);\r\n            }\r\n        }\r\n\r\n        ctx.putImageData(imgData, 0, 0);\r\n    }\r\n\r\n    addTriangleEdgesToEdgeTable(tri, edgeTable, h) {\r\n        // Calculate face normal and apply lighting\r\n        const v0World = tri[0], v1World = tri[1], v2World = tri[2];\r\n        const normal = this.calculateFaceNormal(\r\n            { x: v0World.depth, y: v0World.screen.x, z: v0World.screen.y },\r\n            { x: v1World.depth, y: v1World.screen.x, z: v1World.screen.y },\r\n            { x: v2World.depth, y: v2World.screen.x, z: v2World.screen.y }\r\n        );\r\n        const litColor = this.calculateLighting(normal, \"#888888\");\r\n        const colorStr = `rgb(${litColor.r}, ${litColor.g}, ${litColor.b})`;\r\n\r\n        // Add all three edges of the triangle to the edge table\r\n        const edges = [\r\n            { v0: tri[0], v1: tri[1] },\r\n            { v0: tri[1], v1: tri[2] },\r\n            { v0: tri[2], v1: tri[0] }\r\n        ];\r\n\r\n        edges.forEach(edge => {\r\n            let y0 = Math.round(edge.v0.screen.y);\r\n            let y1 = Math.round(edge.v1.screen.y);\r\n            let x0 = edge.v0.screen.x;\r\n            let x1 = edge.v1.screen.x;\r\n            let z0 = edge.v0.depth;\r\n            let z1 = edge.v1.depth;\r\n\r\n            // Make sure y0 <= y1\r\n            if (y0 > y1) {\r\n                [y0, y1, x0, x1, z0, z1] = [y1, y0, x1, x0, z1, z0];\r\n            }\r\n\r\n            // Skip horizontal edges\r\n            if (y0 === y1) return;\r\n\r\n            const yStart = Math.max(0, y0);\r\n            const yEnd = Math.min(h - 1, y1);\r\n\r\n            if (yStart >= yEnd) return;\r\n\r\n            const deltaY = y1 - y0;\r\n            const deltaX = x1 - x0;\r\n            const deltaZ = z1 - z0;\r\n\r\n            const slope = deltaX / deltaY;\r\n            const zSlope = deltaZ / deltaY;\r\n\r\n            // Add edge to edge table at starting y coordinate\r\n            if (yStart < edgeTable.length) {\r\n                edgeTable[yStart].push({\r\n                    x: x0,\r\n                    yStart: y0,\r\n                    yEnd: y1,\r\n                    slope: slope,\r\n                    z: z0,\r\n                    zSlope: zSlope,\r\n                    color: colorStr\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    renderWebGLRaytrace() {\r\n        const gl = this._renderTextureGLCtx;\r\n\r\n        if (!this._glRaytraceProgram) {\r\n            const success = this.initWebGLRaytracingShaders();\r\n            if (!success) {\r\n                console.warn(\"Failed to initialize raytracing shaders, falling back to raster\");\r\n                this.renderRasterWebGL();\r\n                return;\r\n            }\r\n        }\r\n\r\n        const allObjects = this.getGameObjects();\r\n        const triangles = [];\r\n\r\n        allObjects.forEach(obj => {\r\n            if (!obj.active) return;\r\n            const mesh = obj.getModule(\"Mesh3D\") || obj.getModule(\"CubeMesh3D\") || obj.getModule(\"SphereMesh3D\");\r\n            if (!mesh) return;\r\n\r\n            const transformedVertices = mesh.transformVertices();\r\n            if (!transformedVertices || !mesh.faces) return;\r\n\r\n            const faceColor = mesh.faceColor || mesh._faceColor || \"#888888\";\r\n\r\n            mesh.faces.forEach(face => {\r\n                const worldVerts = face.map(idx => transformedVertices[idx]).filter(v => v);\r\n                if (worldVerts.length < 3) return;\r\n\r\n                const cameraVerts = worldVerts.map(v => this.worldToCameraSpace(v));\r\n                if (cameraVerts.length < 3) return;\r\n\r\n                // Clip against near plane\r\n                const clippedVerts = this.clipPolygonAgainstNearPlane(cameraVerts, this._nearPlane);\r\n                if (clippedVerts.length < 3) return;\r\n\r\n                // Backface culling\r\n                if (this._enableBackfaceCulling && !this._disableCulling) {\r\n                    if (this.shouldCullFace(clippedVerts)) return;\r\n                }\r\n\r\n                const worldNormal = this.calculateFaceNormal(worldVerts[0], worldVerts[1], worldVerts[2]);\r\n                const litColor = this.calculateLighting(worldNormal, faceColor);\r\n\r\n                for (let i = 1; i < clippedVerts.length - 1; i++) {\r\n                    triangles.push({\r\n                        v0: clippedVerts[0],\r\n                        v1: clippedVerts[i],\r\n                        v2: clippedVerts[i + 1],\r\n                        color: litColor,\r\n                        normal: worldNormal\r\n                    });\r\n                }\r\n            });\r\n        });\r\n\r\n        if (triangles.length === 0) {\r\n            gl.clearColor(0, 0, 0, 0);\r\n            gl.clear(gl.COLOR_BUFFER_BIT);\r\n            this._renderTextureCtx.drawImage(this._renderTextureGL, 0, 0);\r\n            return;\r\n        }\r\n\r\n        // Pack triangle data\r\n        const texWidth = 64;\r\n        const texHeight = Math.ceil((triangles.length * 5) / texWidth);\r\n        const triangleData = new Float32Array(texWidth * texHeight * 4);\r\n\r\n        triangles.forEach((tri, idx) => {\r\n            const baseIdx = idx * 20;\r\n\r\n            // Vertex 0 (camera space)\r\n            triangleData[baseIdx + 0] = tri.v0.x;\r\n            triangleData[baseIdx + 1] = tri.v0.y;\r\n            triangleData[baseIdx + 2] = tri.v0.z;\r\n            triangleData[baseIdx + 3] = 1.0;\r\n\r\n            // Vertex 1 (camera space)\r\n            triangleData[baseIdx + 4] = tri.v1.x;\r\n            triangleData[baseIdx + 5] = tri.v1.y;\r\n            triangleData[baseIdx + 6] = tri.v1.z;\r\n            triangleData[baseIdx + 7] = 1.0;\r\n\r\n            // Vertex 2 (camera space)\r\n            triangleData[baseIdx + 8] = tri.v2.x;\r\n            triangleData[baseIdx + 9] = tri.v2.y;\r\n            triangleData[baseIdx + 10] = tri.v2.z;\r\n            triangleData[baseIdx + 11] = 1.0;\r\n\r\n            // Color (pre-lit)\r\n            triangleData[baseIdx + 12] = tri.color.r / 255;\r\n            triangleData[baseIdx + 13] = tri.color.g / 255;\r\n            triangleData[baseIdx + 14] = tri.color.b / 255;\r\n            triangleData[baseIdx + 15] = 1.0;\r\n\r\n            // Normal\r\n            triangleData[baseIdx + 16] = tri.normal.x;\r\n            triangleData[baseIdx + 17] = tri.normal.y;\r\n            triangleData[baseIdx + 18] = tri.normal.z;\r\n            triangleData[baseIdx + 19] = 0.0;\r\n        });\r\n\r\n        // Create texture ONCE and reuse it\r\n        if (!this._glTriangleTexture) {\r\n            this._glTriangleTexture = gl.createTexture();\r\n            this._glTriangleTextureWidth = 0;\r\n            this._glTriangleTextureHeight = 0;\r\n        }\r\n\r\n        gl.bindTexture(gl.TEXTURE_2D, this._glTriangleTexture);\r\n\r\n        // Always update texture data every frame (not just when size changes)\r\n        if (this._glTriangleTextureWidth !== texWidth || this._glTriangleTextureHeight !== texHeight) {\r\n            // Reallocate texture\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texWidth, texHeight, 0, gl.RGBA, gl.FLOAT, triangleData);\r\n            this._glTriangleTextureWidth = texWidth;\r\n            this._glTriangleTextureHeight = texHeight;\r\n        } else {\r\n            // Update existing texture (this needs to happen every frame!)\r\n            gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, texWidth, texHeight, gl.RGBA, gl.FLOAT, triangleData);\r\n        }\r\n\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\r\n\r\n        // Calculate horizon for background\r\n        const fovRadians = this._fieldOfView * (Math.PI / 180);\r\n        const pitchRadians = (this._rotation.y || 0) * (Math.PI / 180);\r\n        const maxPitch = fovRadians / 2;\r\n        const normalizedPitch = -Math.max(-1, Math.min(1, pitchRadians / maxPitch));\r\n        const horizonOffset = normalizedPitch * 0.5;\r\n        const horizonRatio = 0.5 + horizonOffset;\r\n        const clampedHorizon = Math.max(0, Math.min(1, horizonRatio));\r\n\r\n        gl.useProgram(this._glRaytraceProgram);\r\n\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, this._glRaytraceQuadBuffer);\r\n        gl.enableVertexAttribArray(this._glRaytracePositionAttrib);\r\n        gl.vertexAttribPointer(this._glRaytracePositionAttrib, 2, gl.FLOAT, false, 0, 0);\r\n\r\n        // Camera is at origin in camera space (rays start from here)\r\n        gl.uniform3f(this._glRaytraceUniforms.cameraPos, 0, 0, 0);\r\n\r\n        // Camera rotation is identity in camera space (we already transformed to camera space)\r\n        gl.uniformMatrix3fv(this._glRaytraceUniforms.cameraRotation, false, [\r\n            1, 0, 0,\r\n            0, 1, 0,\r\n            0, 0, 1\r\n        ]);\r\n\r\n        gl.uniform1f(this._glRaytraceUniforms.fov, this._fieldOfView);\r\n        gl.uniform1f(this._glRaytraceUniforms.nearPlane, this._nearPlane);\r\n        gl.uniform1f(this._glRaytraceUniforms.farPlane, this._farPlane);\r\n        gl.uniform2f(this._glRaytraceUniforms.resolution, this._renderTextureWidth, this._renderTextureHeight);\r\n\r\n        const lightLen = Math.sqrt(this._lightDirection.x ** 2 + this._lightDirection.y ** 2 + this._lightDirection.z ** 2);\r\n        gl.uniform3f(this._glRaytraceUniforms.lightDir, this._lightDirection.x / lightLen, this._lightDirection.y / lightLen, this._lightDirection.z / lightLen);\r\n\r\n        const lightColor = this.hexToRgb(this._lightColor);\r\n        gl.uniform3f(this._glRaytraceUniforms.lightColor, lightColor.r / 255, lightColor.g / 255, lightColor.b / 255);\r\n\r\n        gl.uniform1f(this._glRaytraceUniforms.lightIntensity, this._lightIntensity);\r\n        gl.uniform1f(this._glRaytraceUniforms.ambientIntensity, this._ambientIntensity);\r\n\r\n        const skyColor = this.hexToRgb(this._skyColor);\r\n        const floorColor = this.hexToRgb(this._floorColor);\r\n        const bgColor = this.hexToRgb(this._backgroundColor);\r\n\r\n        gl.uniform3f(this._glRaytraceUniforms.skyColor, skyColor.r / 255, skyColor.g / 255, skyColor.b / 255);\r\n        gl.uniform3f(this._glRaytraceUniforms.floorColor, floorColor.r / 255, floorColor.g / 255, floorColor.b / 255);\r\n        gl.uniform1f(this._glRaytraceUniforms.horizonY, clampedHorizon);\r\n\r\n        let bgType = 0;\r\n        if (this._backgroundType === \"transparent\") bgType = 1;\r\n        else if (this._backgroundType === \"solid\") bgType = 2;\r\n        gl.uniform1i(this._glRaytraceUniforms.backgroundType, bgType);\r\n        gl.uniform3f(this._glRaytraceUniforms.backgroundColor, bgColor.r / 255, bgColor.g / 255, bgColor.b / 255);\r\n\r\n        gl.activeTexture(gl.TEXTURE0);\r\n        gl.bindTexture(gl.TEXTURE_2D, this._glTriangleTexture);\r\n        gl.uniform1i(this._glRaytraceUniforms.triangleData, 0);\r\n        gl.uniform1i(this._glRaytraceUniforms.triangleCount, triangles.length);\r\n        gl.uniform1f(this._glRaytraceUniforms.texWidth, texWidth);\r\n\r\n        // Clear with appropriate background\r\n        if (this._backgroundType === \"transparent\") {\r\n            gl.clearColor(0, 0, 0, 0);\r\n        } else {\r\n            gl.clearColor(0, 0, 0, 1);\r\n        }\r\n        gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n        // Draw the fullscreen quad\r\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n\r\n        // Check for GL errors\r\n        const error = gl.getError();\r\n        if (error !== gl.NO_ERROR) {\r\n            console.error('WebGL error:', error);\r\n        }\r\n\r\n        // Copy to 2D canvas\r\n        this._renderTextureCtx.drawImage(this._renderTextureGL, 0, 0);\r\n    }\r\n\r\n    calculateTriangleScreenBounds(tri, w, h, aspect, tanHalfFov) {\r\n        const verts = [tri.v0, tri.v1, tri.v2];\r\n        let minX = Infinity, maxX = -Infinity;\r\n        let minY = Infinity, maxY = -Infinity;\r\n        let anyVisible = false;\r\n\r\n        for (const v of verts) {\r\n            // Skip if behind camera\r\n            if (v.x <= this._nearPlane || v.x >= this._farPlane) continue;\r\n\r\n            // Project to screen space\r\n            const ndcY = (v.y / v.x) / (tanHalfFov * aspect);\r\n            const ndcZ = (v.z / v.x) / tanHalfFov;\r\n\r\n            const screenX = (ndcY * 0.5 + 0.5) * w;\r\n            const screenY = (0.5 - ndcZ * 0.5) * h;\r\n\r\n            minX = Math.min(minX, screenX);\r\n            maxX = Math.max(maxX, screenX);\r\n            minY = Math.min(minY, screenY);\r\n            maxY = Math.max(maxY, screenY);\r\n            anyVisible = true;\r\n        }\r\n\r\n        if (!anyVisible) return null;\r\n\r\n        // Clamp to screen with generous margin for edge cases\r\n        return {\r\n            minX: Math.max(0, Math.floor(minX) - 2),\r\n            maxX: Math.min(w - 1, Math.ceil(maxX) + 2),\r\n            minY: Math.max(0, Math.floor(minY) - 2),\r\n            maxY: Math.min(h - 1, Math.ceil(maxY) + 2)\r\n        };\r\n    }\r\n\r\n    rayTriangleIntersect(origin, dir, v0, v1, v2) {\r\n        const edge1 = { x: v1.x - v0.x, y: v1.y - v0.y, z: v1.z - v0.z };\r\n        const edge2 = { x: v2.x - v0.x, y: v2.y - v0.y, z: v2.z - v0.z };\r\n        const h = {\r\n            x: dir.y * edge2.z - dir.z * edge2.y,\r\n            y: dir.z * edge2.x - dir.x * edge2.z,\r\n            z: dir.x * edge2.y - dir.y * edge2.x\r\n        };\r\n        const a = edge1.x * h.x + edge1.y * h.y + edge1.z * h.z;\r\n        if (Math.abs(a) < 0.0001) return null;\r\n        const f = 1 / a;\r\n        const s = { x: origin.x - v0.x, y: origin.y - v0.y, z: origin.z - v0.z };\r\n        const u = f * (s.x * h.x + s.y * h.y + s.z * h.z);\r\n        if (u < 0 || u > 1) return null;\r\n        const q = {\r\n            x: s.y * edge1.z - s.z * edge1.y,\r\n            y: s.z * edge1.x - s.x * edge1.z,\r\n            z: s.x * edge1.y - s.y * edge1.x\r\n        };\r\n        const v = f * (dir.x * q.x + dir.y * q.y + dir.z * q.z);\r\n        if (v < 0 || u + v > 1) return null;\r\n        const t = f * (edge2.x * q.x + edge2.y * q.y + edge2.z * q.z);\r\n        return t > 0.0001 ? t : null;\r\n    }\r\n\r\n    /**\r\n     * Doom-style raycasting renderer\r\n     * Classic column-based raycasting similar to Doom (1993)\r\n     * - One ray per screen column\r\n     * - Vertical wall strips\r\n     * - Fast rendering optimized for corridor/maze environments\r\n     */\r\n    renderDoom() {\r\n        const ctx = this._renderTextureCtx;\r\n        const imgData = this._imageData;\r\n        const data = imgData.data;\r\n        const w = this._renderTextureWidth;\r\n        const h = this._renderTextureHeight;\r\n        const halfH = h / 2;\r\n\r\n        // Clear background with sky/floor\r\n        const fovRadians = this._fieldOfView * (Math.PI / 180);\r\n        const pitchRadians = (this._rotation.y || 0) * (Math.PI / 180);\r\n        const maxPitch = fovRadians / 2;\r\n        const normalizedPitch = -Math.max(-1, Math.min(1, pitchRadians / maxPitch));\r\n        const horizonOffset = normalizedPitch * 0.5;\r\n        const horizonRatio = 0.5 + horizonOffset;\r\n        const clampedHorizon = Math.max(0, Math.min(1, horizonRatio));\r\n        const horizonY = Math.floor(h * clampedHorizon);\r\n\r\n        // Draw sky and floor\r\n        const skyColor = this.hexToRgb(this._skyColor);\r\n        const floorColor = this.hexToRgb(this._floorColor);\r\n\r\n        for (let y = 0; y < h; y++) {\r\n            for (let x = 0; x < w; x++) {\r\n                const pixelIdx = (y * w + x) * 4;\r\n                if (y < horizonY) {\r\n                    data[pixelIdx] = skyColor.r;\r\n                    data[pixelIdx + 1] = skyColor.g;\r\n                    data[pixelIdx + 2] = skyColor.b;\r\n                } else {\r\n                    data[pixelIdx] = floorColor.r;\r\n                    data[pixelIdx + 1] = floorColor.g;\r\n                    data[pixelIdx + 2] = floorColor.b;\r\n                }\r\n                data[pixelIdx + 3] = 255;\r\n            }\r\n        }\r\n\r\n        // Get camera world position and rotation\r\n        const goPos = (this.gameObject && this.gameObject.getWorldPosition) ?\r\n            this.gameObject.getWorldPosition() : { x: 0, y: 0 };\r\n        let goDepth = 0;\r\n        if (this.gameObject) {\r\n            if (typeof this.gameObject.getWorldDepth === 'function') {\r\n                goDepth = this.gameObject.getWorldDepth();\r\n            } else if (typeof this.gameObject.depth === 'number') {\r\n                goDepth = this.gameObject.depth;\r\n            }\r\n        }\r\n        const camWorldX = (goPos.x || 0) + (this._position.x || 0);\r\n        const camWorldY = (goPos.y || 0) + (this._position.y || 0);\r\n        const camWorldZ = goDepth + (this._position.z || 0);\r\n\r\n        const parentAngleDeg = (this.gameObject && this.gameObject.getWorldRotation) ?\r\n            this.gameObject.getWorldRotation() : 0;\r\n        const camYaw = (parentAngleDeg + (this._rotation.z || 0)) * (Math.PI / 180);\r\n\r\n        // Collect wall segments from all geometry\r\n        const allObjects = this.getGameObjects();\r\n        const wallSegments = [];\r\n\r\n        allObjects.forEach(obj => {\r\n            if (!obj.active) return;\r\n            const mesh = obj.getModule(\"CubeMesh3D\");\r\n            if (!mesh) return;\r\n\r\n            const transformedVertices = mesh.transformVertices();\r\n            if (!transformedVertices || !mesh.faces) return;\r\n\r\n            const faceColor = mesh.faceColor || mesh._faceColor || \"#888888\";\r\n            const baseColor = this.hexToRgb(faceColor);\r\n\r\n            // For each face, extract wall-like edges (vertical segments)\r\n            mesh.faces.forEach(face => {\r\n                if (face.length < 3) return;\r\n\r\n                const worldVerts = face.map(idx => transformedVertices[idx]).filter(v => v);\r\n                if (worldVerts.length < 3) return;\r\n\r\n                // Calculate face normal for lighting\r\n                const normal = this.calculateFaceNormal(worldVerts[0], worldVerts[1], worldVerts[2]);\r\n                const litColor = this.calculateLighting(normal, baseColor);\r\n\r\n                // Check each edge of the face\r\n                for (let i = 0; i < worldVerts.length; i++) {\r\n                    const v0 = worldVerts[i];\r\n                    const v1 = worldVerts[(i + 1) % worldVerts.length];\r\n\r\n                    // Calculate vertical extent (Z difference)\r\n                    const zDiff = Math.abs(v0.z - v1.z);\r\n                    const xyDist = Math.sqrt((v0.x - v1.x) ** 2 + (v0.y - v1.y) ** 2);\r\n\r\n                    // Only consider edges that form vertical walls\r\n                    // Skip horizontal edges (floor/ceiling) and very short edges\r\n                    if (zDiff > 0.1 && xyDist > 0.01) {\r\n                        wallSegments.push({\r\n                            x0: v0.x - camWorldX,\r\n                            y0: v0.y - camWorldY,\r\n                            z0: v0.z - camWorldZ,\r\n                            x1: v1.x - camWorldX,\r\n                            y1: v1.y - camWorldY,\r\n                            z1: v1.z - camWorldZ,\r\n                            color: litColor\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        });\r\n\r\n        // Cast one ray per column\r\n        const aspect = w / h;\r\n        const tanHalfFov = Math.tan(fovRadians * 0.5);\r\n\r\n        for (let screenX = 0; screenX < w; screenX++) {\r\n            // Calculate ray angle relative to camera\r\n            const rayAngle = camYaw + Math.atan2(\r\n                (screenX / w - 0.5) * 2 * tanHalfFov * aspect,\r\n                1\r\n            );\r\n\r\n            const rayDirX = Math.cos(rayAngle);\r\n            const rayDirY = Math.sin(rayAngle);\r\n\r\n            // Find closest wall hit\r\n            let closestDist = Infinity;\r\n            let hitWall = null;\r\n            let hitZ = 0;\r\n            let wallT = 0; // Parameter along wall segment (0 to 1)\r\n\r\n            wallSegments.forEach(wall => {\r\n                // Convert wall to 2D line segment in world space\r\n                const x1 = wall.x0, y1 = wall.y0;\r\n                const x2 = wall.x1, y2 = wall.y1;\r\n\r\n                // Ray-line segment intersection (2D)\r\n                const dx = x2 - x1;\r\n                const dy = y2 - y1;\r\n\r\n                // Ray: (0,0) + t * (rayDirX, rayDirY)\r\n                // Line: (x1,y1) + s * (dx, dy)\r\n\r\n                const det = rayDirX * dy - rayDirY * dx;\r\n                if (Math.abs(det) < 0.0001) return; // Parallel\r\n\r\n                // Solve for t (distance along ray) and s (parameter along line segment)\r\n                const t = (x1 * dy - y1 * dx) / det;\r\n                const s = (x1 * rayDirY - y1 * rayDirX) / det;\r\n\r\n                // Check if intersection is valid\r\n                if (t <= 0 || t > this._farPlane) return; // Behind camera or too far\r\n                if (s < 0 || s > 1) return; // Outside line segment\r\n\r\n                // Calculate perpendicular distance (fisheye correction)\r\n                const hitX = rayDirX * t;\r\n                const hitY = rayDirY * t;\r\n                const perpDist = Math.sqrt(hitX * hitX + hitY * hitY) * Math.cos(rayAngle - camYaw);\r\n\r\n                if (perpDist < closestDist && perpDist > this._nearPlane) {\r\n                    closestDist = perpDist;\r\n                    hitWall = wall;\r\n                    wallT = s;\r\n\r\n                    // Interpolate Z coordinate along wall segment\r\n                    hitZ = wall.z0 + s * (wall.z1 - wall.z0);\r\n                }\r\n            });\r\n\r\n            // Draw the wall column if we hit something\r\n            if (hitWall && closestDist < Infinity) {\r\n                // Calculate wall height on screen\r\n                const wallHeight = Math.abs(hitWall.z1 - hitWall.z0);\r\n                const wallBottom = Math.min(hitWall.z0, hitWall.z1);\r\n                const wallTop = Math.max(hitWall.z0, hitWall.z1);\r\n\r\n                // Project wall heights to screen space\r\n                const projectedWallHeight = (wallHeight / closestDist) * (h / (2 * tanHalfFov));\r\n                const projectedWallBottom = halfH - ((wallBottom - camWorldZ) / closestDist) * (h / (2 * tanHalfFov));\r\n                const projectedWallTop = halfH - ((wallTop - camWorldZ) / closestDist) * (h / (2 * tanHalfFov));\r\n\r\n                // Clamp to screen bounds\r\n                const drawTop = Math.max(0, Math.floor(projectedWallTop));\r\n                const drawBottom = Math.min(h - 1, Math.ceil(projectedWallBottom));\r\n\r\n                // Distance-based shading (fog effect)\r\n                const shadeFactor = Math.max(0.2, 1.0 - closestDist / this._farPlane);\r\n                const wallColor = {\r\n                    r: Math.round(hitWall.color.r * shadeFactor),\r\n                    g: Math.round(hitWall.color.g * shadeFactor),\r\n                    b: Math.round(hitWall.color.b * shadeFactor)\r\n                };\r\n\r\n                // Draw the vertical wall strip\r\n                for (let y = drawTop; y <= drawBottom; y++) {\r\n                    const pixelIdx = (y * w + screenX) * 4;\r\n                    data[pixelIdx] = wallColor.r;\r\n                    data[pixelIdx + 1] = wallColor.g;\r\n                    data[pixelIdx + 2] = wallColor.b;\r\n                    data[pixelIdx + 3] = 255;\r\n                }\r\n\r\n                // Floor rendering (below wall) - use actual wall distance\r\n                for (let y = drawBottom + 1; y < h; y++) {\r\n                    const pixelIdx = (y * w + screenX) * 4;\r\n                    const floorShadeFactor = Math.max(0.1, 1.0 - closestDist / this._farPlane);\r\n                    data[pixelIdx] = Math.round(floorColor.r * floorShadeFactor);\r\n                    data[pixelIdx + 1] = Math.round(floorColor.g * floorShadeFactor);\r\n                    data[pixelIdx + 2] = Math.round(floorColor.b * floorShadeFactor);\r\n                    data[pixelIdx + 3] = 255;\r\n                }\r\n\r\n                // Ceiling rendering (above wall) - use actual wall distance\r\n                for (let y = 0; y < drawTop; y++) {\r\n                    const pixelIdx = (y * w + screenX) * 4;\r\n                    const ceilingShadeFactor = Math.max(0.1, 1.0 - closestDist / this._farPlane);\r\n                    data[pixelIdx] = Math.round(skyColor.r * ceilingShadeFactor);\r\n                    data[pixelIdx + 1] = Math.round(skyColor.g * ceilingShadeFactor);\r\n                    data[pixelIdx + 2] = Math.round(skyColor.b * ceilingShadeFactor);\r\n                    data[pixelIdx + 3] = 255;\r\n                }\r\n            }\r\n        }\r\n\r\n        ctx.putImageData(imgData, 0, 0);\r\n    }\r\n\r\n    // BVH Node class for acceleration structure\r\n    createBVHNode() {\r\n        return {\r\n            bounds: { min: { x: 0, y: 0, z: 0 }, max: { x: 0, y: 0, z: 0 } },\r\n            triangles: [],\r\n            left: null,\r\n            right: null,\r\n            isLeaf: false\r\n        };\r\n    }\r\n\r\n    // Calculate axis-aligned bounding box for a triangle\r\n    calculateTriangleBounds(v0, v1, v2) {\r\n        const min = {\r\n            x: Math.min(v0.x, v1.x, v2.x),\r\n            y: Math.min(v0.y, v1.y, v2.y),\r\n            z: Math.min(v0.z, v1.z, v2.z)\r\n        };\r\n        const max = {\r\n            x: Math.max(v0.x, v1.x, v2.x),\r\n            y: Math.max(v0.y, v1.y, v2.y),\r\n            z: Math.max(v0.z, v1.z, v2.z)\r\n        };\r\n        return { min, max };\r\n    }\r\n\r\n    // Calculate bounding box for multiple triangles\r\n    calculateBounds(triangles) {\r\n        if (triangles.length === 0) return null;\r\n\r\n        let min = { x: Infinity, y: Infinity, z: Infinity };\r\n        let max = { x: -Infinity, y: -Infinity, z: -Infinity };\r\n\r\n        triangles.forEach(tri => {\r\n            const bounds = this.calculateTriangleBounds(tri.v0, tri.v1, tri.v2);\r\n            min.x = Math.min(min.x, bounds.min.x);\r\n            min.y = Math.min(min.y, bounds.min.y);\r\n            min.z = Math.min(min.z, bounds.min.z);\r\n            max.x = Math.max(max.x, bounds.max.x);\r\n            max.y = Math.max(max.y, bounds.max.y);\r\n            max.z = Math.max(max.z, bounds.max.z);\r\n        });\r\n\r\n        return { min, max };\r\n    }\r\n\r\n    // Check if ray intersects AABB\r\n    rayAABBIntersect(origin, dir, min, max) {\r\n        const invDir = {\r\n            x: 1 / dir.x,\r\n            y: 1 / dir.y,\r\n            z: 1 / dir.z\r\n        };\r\n\r\n        const t1 = (min.x - origin.x) * invDir.x;\r\n        const t2 = (max.x - origin.x) * invDir.x;\r\n        const tmin = Math.min(t1, t2);\r\n        const tmax = Math.max(t1, t2);\r\n\r\n        const t1y = (min.y - origin.y) * invDir.y;\r\n        const t2y = (max.y - origin.y) * invDir.y;\r\n        const tminy = Math.min(t1y, t2y);\r\n        const tmaxy = Math.max(t1y, t2y);\r\n\r\n        if (tmin > tmaxy || tminy > tmax) return null;\r\n\r\n        const finalTmin = Math.max(tmin, tminy);\r\n        const finalTmax = Math.min(tmax, tmaxy);\r\n\r\n        const t1z = (min.z - origin.z) * invDir.z;\r\n        const t2z = (max.z - origin.z) * invDir.z;\r\n        const tminz = Math.min(t1z, t2z);\r\n        const tmaxz = Math.max(t1z, t2z);\r\n\r\n        if (finalTmin > tmaxz || tminz > finalTmax) return null;\r\n\r\n        const finalTminZ = Math.max(finalTmin, tminz);\r\n        const finalTmaxZ = Math.min(finalTmax, tmaxz);\r\n\r\n        return finalTmaxZ >= Math.max(finalTminZ, 0) ? finalTminZ : null;\r\n    }\r\n\r\n    // Build BVH acceleration structure\r\n    buildBVH(triangles, maxTrianglesPerLeaf = 4) {\r\n        if (triangles.length === 0) return null;\r\n\r\n        const axisNames = ['x', 'y', 'z'];\r\n        const root = this.createBVHNode();\r\n        root.bounds = this.calculateBounds(triangles);\r\n        root.triangles = triangles;\r\n\r\n        if (triangles.length <= maxTrianglesPerLeaf) {\r\n            root.isLeaf = true;\r\n            return root;\r\n        }\r\n\r\n        // Find the longest axis for splitting\r\n        const extent = {\r\n            x: root.bounds.max.x - root.bounds.min.x,\r\n            y: root.bounds.max.y - root.bounds.min.y,\r\n            z: root.bounds.max.z - root.bounds.min.z\r\n        };\r\n\r\n        let splitAxis = 0;\r\n        if (extent.y > extent.x) splitAxis = 1;\r\n        if (extent.z > extent.y && extent.z > extent.x) splitAxis = 2;\r\n\r\n        // Sort triangles by centroid along split axis\r\n        const sortedTriangles = [...triangles].sort((a, b) => {\r\n            const aCentroid = (a.v0[axisNames[splitAxis]] + a.v1[axisNames[splitAxis]] + a.v2[axisNames[splitAxis]]) / 3;\r\n            const bCentroid = (b.v0[axisNames[splitAxis]] + b.v1[axisNames[splitAxis]] + b.v2[axisNames[splitAxis]]) / 3;\r\n            return aCentroid - bCentroid;\r\n        });\r\n\r\n        const mid = Math.floor(sortedTriangles.length / 2);\r\n        const leftTriangles = sortedTriangles.slice(0, mid);\r\n        const rightTriangles = sortedTriangles.slice(mid);\r\n\r\n        root.left = this.buildBVH(leftTriangles, maxTrianglesPerLeaf);\r\n        root.right = this.buildBVH(rightTriangles, maxTrianglesPerLeaf);\r\n\r\n        return root;\r\n    }\r\n\r\n    // Accelerated ray tracing using BVH\r\n    traceRayBVH(origin, dir, bvhNode, tMin, tMax) {\r\n        if (!bvhNode) return null;\r\n\r\n        // Test ray against node bounds first\r\n        const t = this.rayAABBIntersect(origin, dir, bvhNode.bounds.min, bvhNode.bounds.max);\r\n        if (t === null || t > tMax || t < tMin) return null;\r\n\r\n        // If this is a leaf node, test all triangles\r\n        if (bvhNode.isLeaf) {\r\n            let closestHit = null;\r\n            let closestT = tMax;\r\n\r\n            for (const tri of bvhNode.triangles) {\r\n                const t = this.rayTriangleIntersect(origin, dir, tri.v0, tri.v1, tri.v2);\r\n                if (t !== null && t < closestT && t >= tMin) {\r\n                    closestT = t;\r\n                    closestHit = tri;\r\n                }\r\n            }\r\n\r\n            return closestHit;\r\n        }\r\n\r\n        // Test child nodes\r\n        const leftHit = this.traceRayBVH(origin, dir, bvhNode.left, tMin, tMax);\r\n        const rightHit = this.traceRayBVH(origin, dir, bvhNode.right, tMin, tMax);\r\n\r\n        // Return the closer hit\r\n        if (leftHit && rightHit) {\r\n            return leftHit; // For simplicity, return first hit found\r\n        }\r\n        return leftHit || rightHit;\r\n    }\r\n\r\n    /**\r\n * Fast background clearing using 32-bit writes\r\n */\r\n    clearBackgroundFast(buffer32, w, h) {\r\n        if (this._backgroundType === \"solid\") {\r\n            const bgColor = this.hexToRgb(this._backgroundColor);\r\n            const bgPixel = (255 << 24) | (bgColor.b << 16) | (bgColor.g << 8) | bgColor.r;\r\n            buffer32.fill(bgPixel);\r\n        } else if (this._backgroundType === \"skyfloor\") {\r\n            const fovRadians = this._fieldOfView * (Math.PI / 180);\r\n            const pitchRadians = (this._rotation.y || 0) * (Math.PI / 180);\r\n            const maxPitch = fovRadians / 2;\r\n            const normalizedPitch = -Math.max(-1, Math.min(1, pitchRadians / maxPitch));\r\n            const horizonOffset = normalizedPitch * 0.5;\r\n            const horizonRatio = 0.5 + horizonOffset;\r\n            const clampedHorizon = Math.max(0, Math.min(1, horizonRatio));\r\n            const horizonY = Math.floor(h * clampedHorizon);\r\n\r\n            const skyColor = this.hexToRgb(this._skyColor);\r\n            const floorColor = this.hexToRgb(this._floorColor);\r\n            const skyPixel = (255 << 24) | (skyColor.b << 16) | (skyColor.g << 8) | skyColor.r;\r\n            const floorPixel = (255 << 24) | (floorColor.b << 16) | (floorColor.g << 8) | floorColor.r;\r\n\r\n            for (let y = 0; y < h; y++) {\r\n                const pixel = y < horizonY ? skyPixel : floorPixel;\r\n                const rowStart = y * w;\r\n                for (let x = 0; x < w; x++) {\r\n                    buffer32[rowStart + x] = pixel;\r\n                }\r\n            }\r\n        } else if (this._backgroundType === \"transparent\") {\r\n            buffer32.fill(0); // Fully transparent\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Ultra-fast scanline triangle rasterization\r\n     * Uses edge-walking for maximum performance\r\n     */\r\n    rasterizeTriangleFast(tri, buffer32, w, h) {\r\n        const p0 = { x: Math.round(tri.v0.screen.x), y: Math.round(tri.v0.screen.y) };\r\n        const p1 = { x: Math.round(tri.v1.screen.x), y: Math.round(tri.v1.screen.y) };\r\n        const p2 = { x: Math.round(tri.v2.screen.x), y: Math.round(tri.v2.screen.y) };\r\n\r\n        // Calculate bounding box\r\n        const minX = Math.max(0, Math.min(p0.x, p1.x, p2.x));\r\n        const maxX = Math.min(w - 1, Math.max(p0.x, p1.x, p2.x));\r\n        const minY = Math.max(0, Math.min(p0.y, p1.y, p2.y));\r\n        const maxY = Math.min(h - 1, Math.max(p0.y, p1.y, p2.y));\r\n\r\n        if (minX > maxX || minY > maxY) return;\r\n\r\n        // Edge setup (once per triangle)\r\n        const v0x = p0.x, v0y = p0.y;\r\n        const v1x = p1.x, v1y = p1.y;\r\n        const v2x = p2.x, v2y = p2.y;\r\n\r\n        const e0_dx = v1x - v0x, e0_dy = v1y - v0y;\r\n        const e1_dx = v2x - v1x, e1_dy = v2y - v1y;\r\n        const e2_dx = v0x - v2x, e2_dy = v0y - v2y;\r\n\r\n        // Check if triangle is degenerate\r\n        const area = e0_dx * (v2y - v0y) - e0_dy * (v2x - v0x);\r\n        if (Math.abs(area) < 0.5) return;\r\n\r\n        const packedColor = tri.packedColor;\r\n\r\n        // Scanline loop with edge coherence\r\n        for (let y = minY; y <= maxY; y++) {\r\n            // Calculate edge values at start of scanline\r\n            let w0 = e0_dx * (y - v0y) - e0_dy * (minX - v0x);\r\n            let w1 = e1_dx * (y - v1y) - e1_dy * (minX - v1x);\r\n            let w2 = e2_dx * (y - v2y) - e2_dy * (minX - v2x);\r\n\r\n            // Edge increments for x-stepping\r\n            const w0_step = -e0_dy;\r\n            const w1_step = -e1_dy;\r\n            const w2_step = -e2_dy;\r\n\r\n            const rowOffset = y * w;\r\n\r\n            for (let x = minX; x <= maxX; x++) {\r\n                // Inside test using edge equations\r\n                if (w0 >= 0 && w1 >= 0 && w2 >= 0) {\r\n                    buffer32[rowOffset + x] = packedColor;\r\n                }\r\n\r\n                // Increment edge values\r\n                w0 += w0_step;\r\n                w1 += w1_step;\r\n                w2 += w2_step;\r\n            }\r\n        }\r\n    }\r\n\r\n    render3D() {\r\n        if (!this._renderTextureCtx || !this._isActive) return;\r\n        this.clearRenderTexture();\r\n        switch (this._renderingMethod) {\r\n            case \"painter\": this.renderPainter(); break;\r\n            case \"zbuffer\":\r\n                if (this._renderTextureGLCtx) {\r\n                    this.renderZBufferWebGL();\r\n                } else {\r\n                    this.renderZBuffer();\r\n                }\r\n                break;\r\n            case \"scanline\": this.renderScanline(); break;\r\n            case \"hzb\": this.renderHZB(); break;\r\n            case \"depthpass\": this.renderDepthPass(); break;\r\n            case \"raster\":\r\n                if (this._renderTextureGLCtx) {\r\n                    this.renderRasterWebGL();\r\n                } else {\r\n                    this.renderRasterOptimized();\r\n                }\r\n                break;\r\n            case \"rasterRaytraceHybrid\": this.renderRaytraceHybrid(); break;\r\n            case \"webglcanvas\":\r\n                this.renderWebGLRaytrace();\r\n                break;\r\n            case \"doom\": this.renderDoom(); break;\r\n            case \"ilpc\": this.renderILPC(); break;\r\n            case \"fald\": this.renderFALD(); break;\r\n            default: this.renderPainter();\r\n        }\r\n    }\r\n\r\n    getRenderedTexture() {\r\n        if (!this._isActive) return null;\r\n        this.render3D();\r\n        return this._renderTexture;\r\n    }\r\n\r\n    drawRenderedTexture(ctx, x = 0, y = 0, width = null, height = null) {\r\n        if (!this._renderTexture || !this._isActive) return;\r\n        ctx.imageSmoothingEnabled = this._renderTextureSmoothing;\r\n        const drawWidth = width || this._renderTextureWidth;\r\n        const drawHeight = height || this._renderTextureHeight;\r\n        ctx.drawImage(this._renderTexture, x, y, drawWidth, drawHeight);\r\n    }\r\n\r\n    calculateLighting(normal, baseColor) {\r\n        // Normalize light direction\r\n        const len = Math.sqrt(this._lightDirection.x ** 2 + this._lightDirection.y ** 2 + this._lightDirection.z ** 2);\r\n        const lightDir = {\r\n            x: this._lightDirection.x / len,\r\n            y: this._lightDirection.y / len,\r\n            z: this._lightDirection.z / len\r\n        };\r\n\r\n        // Calculate diffuse lighting (Lambertian)\r\n        const dotProduct = -(normal.x * lightDir.x + normal.y * lightDir.y + normal.z * lightDir.z);\r\n        const diffuse = Math.max(0, dotProduct) * this._lightIntensity;\r\n\r\n        // Combine ambient and diffuse\r\n        const lighting = this._ambientIntensity + diffuse * (1 - this._ambientIntensity);\r\n\r\n        // Apply light color\r\n        const lightRgb = this.hexToRgb(this._lightColor);\r\n        const baseRgb = typeof baseColor === 'string' ? this.hexToRgb(baseColor) : baseColor;\r\n\r\n        return {\r\n            r: Math.min(255, Math.round(baseRgb.r * lighting * (lightRgb.r / 255))),\r\n            g: Math.min(255, Math.round(baseRgb.g * lighting * (lightRgb.g / 255))),\r\n            b: Math.min(255, Math.round(baseRgb.b * lighting * (lightRgb.b / 255)))\r\n        };\r\n    }\r\n\r\n    calculateFaceNormal(v0, v1, v2) {\r\n        const e1 = { x: v1.x - v0.x, y: v1.y - v0.y, z: v1.z - v0.z };\r\n        const e2 = { x: v2.x - v0.x, y: v2.y - v0.y, z: v2.z - v0.z };\r\n        const normal = {\r\n            x: e1.y * e2.z - e1.z * e2.y,\r\n            y: e1.z * e2.x - e1.x * e2.z,\r\n            z: e1.x * e2.y - e1.y * e2.x\r\n        };\r\n        const len = Math.sqrt(normal.x ** 2 + normal.y ** 2 + normal.z ** 2);\r\n        if (len > 1e-10) {\r\n            return { x: normal.x / len, y: normal.y / len, z: normal.z / len };\r\n        }\r\n        // Return a default normal if calculation fails (shouldn't happen with valid triangles)\r\n        return { x: 0, y: 0, z: 1 };\r\n    }\r\n\r\n    /**\r\n     * Fragment-Agnostic Layered Depth (FALD) Rendering\r\n     * \r\n     * This rendering method combines:\r\n     * 1. Coarse back-to-front painter's algorithm sorting\r\n     * 2. Sparse depth grid for efficient occlusion testing\r\n     * 3. Two-pass rendering with conflict resolution\r\n     * \r\n     * Advantages:\r\n     * - Near-perfect Z-ordering without full Z-buffer\r\n     * - Leverages native ctx.fill() performance\r\n     * - Low memory footprint with sparse depth grid\r\n     * - Scalable performance based on conflict count\r\n     */\r\n    renderFALD() {\r\n        const allObjects = this.getGameObjects();\r\n        const ctx = this._renderTextureCtx;\r\n        const imgData = this._imageData;\r\n        const data = imgData.data;\r\n        const w = this._renderTextureWidth;\r\n        const h = this._renderTextureHeight;\r\n\r\n        // Clear background\r\n        this.clearFALDBackground(data, w, h);\r\n\r\n        // Configuration for depth grid\r\n        const CELL_SIZE = 16; // Pixels per depth cell\r\n        const gridWidth = Math.ceil(w / CELL_SIZE);\r\n        const gridHeight = Math.ceil(h / CELL_SIZE);\r\n\r\n        // Initialize sparse depth grid\r\n        const depthGrid = this.createDepthGrid(gridWidth, gridHeight);\r\n\r\n        // Phase 1: Collect and prepare triangles\r\n        const allTriangles = this.collectTrianglesForFALD(allObjects);\r\n\r\n        if (allTriangles.length === 0) {\r\n            ctx.putImageData(imgData, 0, 0);\r\n            return;\r\n        }\r\n\r\n        // Phase 2: Spatial partitioning and coarse sorting\r\n        const sortedChunks = this.partitionAndSortTriangles(allTriangles);\r\n\r\n        // Phase 3: Pass 1 - Back-to-front rendering with depth tracking\r\n        const conflictList = [];\r\n        this.renderFALDPass1(sortedChunks, ctx, depthGrid, CELL_SIZE, conflictList, w, h);\r\n\r\n        // Phase 4: Pass 2 - Front-to-back conflict resolution\r\n        if (conflictList.length > 0) {\r\n            this.renderFALDPass2(conflictList, ctx, depthGrid, CELL_SIZE, w, h);\r\n        }\r\n\r\n        ctx.putImageData(imgData, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * Clear background with appropriate color scheme\r\n     */\r\n    clearFALDBackground(data, w, h) {\r\n        if (this._backgroundType === \"transparent\") {\r\n            // Leave transparent\r\n            for (let i = 0; i < data.length; i += 4) {\r\n                data[i + 3] = 0; // Fully transparent\r\n            }\r\n        } else if (this._backgroundType === \"solid\") {\r\n            const bgColor = this.hexToRgb(this._backgroundColor);\r\n            for (let i = 0; i < data.length; i += 4) {\r\n                data[i] = bgColor.r;\r\n                data[i + 1] = bgColor.g;\r\n                data[i + 2] = bgColor.b;\r\n                data[i + 3] = 255;\r\n            }\r\n        } else if (this._backgroundType === \"skyfloor\") {\r\n            const fovRadians = this._fieldOfView * (Math.PI / 180);\r\n            const pitchRadians = (this._rotation.y || 0) * (Math.PI / 180);\r\n            const maxPitch = fovRadians / 2;\r\n            const normalizedPitch = -Math.max(-1, Math.min(1, pitchRadians / maxPitch));\r\n            const horizonOffset = normalizedPitch * 0.5;\r\n            const horizonRatio = 0.5 + horizonOffset;\r\n            const clampedHorizon = Math.max(0, Math.min(1, horizonRatio));\r\n            const horizonY = Math.floor(h * clampedHorizon);\r\n\r\n            const skyColor = this.hexToRgb(this._skyColor);\r\n            const floorColor = this.hexToRgb(this._floorColor);\r\n\r\n            for (let i = 0; i < data.length; i += 4) {\r\n                const y = Math.floor((i / 4) / w);\r\n                if (y < horizonY) {\r\n                    data[i] = skyColor.r;\r\n                    data[i + 1] = skyColor.g;\r\n                    data[i + 2] = skyColor.b;\r\n                } else {\r\n                    data[i] = floorColor.r;\r\n                    data[i + 1] = floorColor.g;\r\n                    data[i + 2] = floorColor.b;\r\n                }\r\n                data[i + 3] = 255;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create sparse depth grid structure\r\n     */\r\n    createDepthGrid(gridWidth, gridHeight) {\r\n        const grid = [];\r\n        for (let y = 0; y < gridHeight; y++) {\r\n            grid[y] = [];\r\n            for (let x = 0; x < gridWidth; x++) {\r\n                grid[y][x] = {\r\n                    minDepth: Infinity,\r\n                    maxDepth: -Infinity,\r\n                    polygonId: -1,\r\n                    isDirty: false\r\n                };\r\n            }\r\n        }\r\n        return grid;\r\n    }\r\n\r\n    /**\r\n     * Collect all triangles from the scene with necessary metadata\r\n     */\r\n    collectTrianglesForFALD(allObjects) {\r\n        const triangles = [];\r\n        let triangleId = 0;\r\n\r\n        allObjects.forEach(obj => {\r\n            if (!obj.active) return;\r\n            const mesh = obj.getModule(\"Mesh3D\") || obj.getModule(\"CubeMesh3D\") || obj.getModule(\"SphereMesh3D\");\r\n            if (!mesh) return;\r\n\r\n            const transformedVertices = mesh.transformVertices();\r\n            if (!transformedVertices || !mesh.faces) return;\r\n            const faceColor = mesh.faceColor || mesh._faceColor || \"#888888\";\r\n\r\n            mesh.faces.forEach(face => {\r\n                const worldVerts = face.map(idx => transformedVertices[idx]).filter(v => v);\r\n                if (worldVerts.length < 3) return;\r\n\r\n                const cameraVerts = worldVerts.map(v => this.worldToCameraSpace(v));\r\n                if (cameraVerts.length < 3) return;\r\n\r\n                // Clip against near plane BEFORE backface culling\r\n                const clippedVerts = this.clipPolygonAgainstNearPlane(cameraVerts, this._nearPlane);\r\n                if (clippedVerts.length < 3) return;\r\n\r\n                // Backface culling using consistent method (after clipping)\r\n                // This is the key fix - we need to cull based on the clipped vertices\r\n                if (this._enableBackfaceCulling && !this._disableCulling) {\r\n                    const material = mesh?.material;\r\n                    const isDoubleSided = material ? material._doubleSided : false;\r\n                    if (!isDoubleSided && this.shouldCullFace(clippedVerts)) {\r\n                        return; // Skip back-facing triangles (unless double-sided)\r\n                    }\r\n                }\r\n\r\n                const worldNormal = this.calculateFaceNormal(worldVerts[0], worldVerts[1], worldVerts[2]);\r\n                const litColor = this.calculateLighting(worldNormal, faceColor);\r\n\r\n                // Get UV coordinates for texture mapping if material exists\r\n                let faceUVs = null;\r\n                if (mesh?.material && mesh.uvCoordinates && face.length >= 3) {\r\n                    // For triangulated faces, we need to interpolate UVs\r\n                    // For now, use the UV of the first vertex as a simple approximation\r\n                    const firstVertexIndex = face[0];\r\n                    if (firstVertexIndex < mesh.uvCoordinates.length) {\r\n                        faceUVs = [\r\n                            mesh.uvCoordinates[firstVertexIndex] || new Vector2(0, 0),\r\n                            mesh.uvCoordinates[firstVertexIndex] || new Vector2(1, 0),\r\n                            mesh.uvCoordinates[firstVertexIndex] || new Vector2(0, 1)\r\n                        ];\r\n                    }\r\n                }\r\n\r\n                // Triangulate the face\r\n                for (let i = 1; i < clippedVerts.length - 1; i++) {\r\n                    const tri = {\r\n                        id: triangleId++,\r\n                        v0: clippedVerts[0],\r\n                        v1: clippedVerts[i],\r\n                        v2: clippedVerts[i + 1],\r\n                        color: litColor,\r\n                        material: mesh?.material || null,\r\n                        faceUVs: faceUVs,\r\n                        avgDepth: (clippedVerts[0].x + clippedVerts[i].x + clippedVerts[i + 1].x) / 3,\r\n                        minDepth: Math.min(clippedVerts[0].x, clippedVerts[i].x, clippedVerts[i + 1].x),\r\n                        maxDepth: Math.max(clippedVerts[0].x, clippedVerts[i].x, clippedVerts[i + 1].x),\r\n                        screenBounds: null // Will be calculated during projection\r\n                    };\r\n\r\n                    triangles.push(tri);\r\n                }\r\n            });\r\n        });\r\n\r\n        return triangles;\r\n    }\r\n\r\n    /**\r\n     * Partition triangles into spatial chunks and sort\r\n     */\r\n    partitionAndSortTriangles(triangles) {\r\n        // For now, use a simple depth-based chunking\r\n        // Sort all triangles by average depth (back to front)\r\n        const sorted = [...triangles].sort((a, b) => b.avgDepth - a.avgDepth);\r\n\r\n        // Group into chunks of roughly equal size\r\n        const CHUNK_SIZE = 50; // Triangles per chunk\r\n        const chunks = [];\r\n\r\n        for (let i = 0; i < sorted.length; i += CHUNK_SIZE) {\r\n            chunks.push(sorted.slice(i, i + CHUNK_SIZE));\r\n        }\r\n\r\n        return chunks;\r\n    }\r\n\r\n    /**\r\n * Pass 1: Back-to-front rendering with occlusion testing\r\n */\r\n    renderFALDPass1(chunks, ctx, depthGrid, cellSize, conflictList, w, h) {\r\n        const useExtendedFOV = this._enableBackfaceCulling && !this._disableCulling;\r\n        const imgData = this._imageData;\r\n        const data = imgData.data;\r\n\r\n        // Process each chunk from back to front\r\n        chunks.forEach(chunk => {\r\n            chunk.forEach(tri => {\r\n                // Project vertices to screen space\r\n                const p0 = this.projectCameraPoint(tri.v0, useExtendedFOV);\r\n                const p1 = this.projectCameraPoint(tri.v1, useExtendedFOV);\r\n                const p2 = this.projectCameraPoint(tri.v2, useExtendedFOV);\r\n\r\n                if (!p0 || !p1 || !p2) return;\r\n\r\n                // Calculate screen bounds\r\n                const minX = Math.max(0, Math.floor(Math.min(p0.x, p1.x, p2.x)));\r\n                const maxX = Math.min(w - 1, Math.ceil(Math.max(p0.x, p1.x, p2.x)));\r\n                const minY = Math.max(0, Math.floor(Math.min(p0.y, p1.y, p2.y)));\r\n                const maxY = Math.min(h - 1, Math.ceil(Math.max(p0.y, p1.y, p2.y)));\r\n\r\n                tri.screenBounds = { minX, maxX, minY, maxY };\r\n                tri.projectedVerts = [p0, p1, p2];\r\n\r\n                // Calculate which depth cells this triangle touches\r\n                const cellMinX = Math.floor(minX / cellSize);\r\n                const cellMaxX = Math.floor(maxX / cellSize);\r\n                const cellMinY = Math.floor(minY / cellSize);\r\n                const cellMaxY = Math.floor(maxY / cellSize);\r\n\r\n                // Improved occlusion test: check multiple cells\r\n                let visibleCellCount = 0;\r\n                let totalCells = 0;\r\n                let hasConflict = false;\r\n\r\n                for (let cy = cellMinY; cy <= cellMaxY; cy++) {\r\n                    for (let cx = cellMinX; cx <= cellMaxX; cx++) {\r\n                        if (cy < 0 || cy >= depthGrid.length || cx < 0 || cx >= depthGrid[0].length) continue;\r\n\r\n                        totalCells++;\r\n                        const cell = depthGrid[cy][cx];\r\n\r\n                        // If cell is uninitialized, triangle is visible in this cell\r\n                        if (cell.minDepth === Infinity) {\r\n                            visibleCellCount++;\r\n                        }\r\n                        // Use maxDepth for occlusion test - triangle must be COMPLETELY behind\r\n                        // This prevents clipping when triangles have overlapping depth ranges\r\n                        else if (tri.maxDepth < cell.minDepth - 0.1) {\r\n                            // Triangle is fully behind in this cell - check next cell\r\n                        }\r\n                        else {\r\n                            // Triangle is at least partially visible in this cell\r\n                            visibleCellCount++;\r\n\r\n                            // Check for depth conflicts - use a larger epsilon to reduce false conflicts\r\n                            if (tri.minDepth < cell.minDepth - 0.05) {\r\n                                hasConflict = true;\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Only skip if triangle is fully occluded in ALL cells it touches\r\n                // Be more conservative - require fewer visible cells\r\n                if (visibleCellCount === 0) {\r\n                    return; // Skip fully occluded triangles\r\n                }\r\n\r\n                // If there's a conflict, add to conflict list for second pass\r\n                if (hasConflict) {\r\n                    conflictList.push(tri);\r\n                }\r\n\r\n                // Draw the triangle directly to ImageData with material support\r\n                this.rasterizeFALDTriangle(p0, p1, p2, tri.color, data, w, h, tri.material, tri.faceUVs);\r\n\r\n                // Update depth grid more conservatively\r\n                // Only update minDepth if we're significantly closer\r\n                for (let cy = cellMinY; cy <= cellMaxY; cy++) {\r\n                    for (let cx = cellMinX; cx <= cellMaxX; cx++) {\r\n                        if (cy < 0 || cy >= depthGrid.length || cx < 0 || cx >= depthGrid[0].length) continue;\r\n\r\n                        const cell = depthGrid[cy][cx];\r\n\r\n                        // Use a larger epsilon to prevent z-fighting between coplanar triangles\r\n                        const epsilon = 0.05;\r\n\r\n                        // Only update if this triangle is actually closer\r\n                        if (tri.minDepth < cell.minDepth - epsilon) {\r\n                            cell.minDepth = tri.minDepth;\r\n                            cell.polygonId = tri.id;\r\n                            cell.isDirty = true;\r\n                        }\r\n                        // Always track the farthest point we've seen\r\n                        if (tri.maxDepth > cell.maxDepth) {\r\n                            cell.maxDepth = tri.maxDepth;\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Pass 2: Front-to-back conflict resolution\r\n     */\r\n    renderFALDPass2(conflictList, ctx, depthGrid, cellSize, w, h) {\r\n        // Sort conflicts front-to-back\r\n        conflictList.sort((a, b) => a.avgDepth - b.avgDepth);\r\n\r\n        const useExtendedFOV = this._enableBackfaceCulling && !this._disableCulling;\r\n        const imgData = this._imageData;\r\n        const data = imgData.data;\r\n\r\n        conflictList.forEach(tri => {\r\n            // Re-project if needed\r\n            if (!tri.projectedVerts) {\r\n                const p0 = this.projectCameraPoint(tri.v0, useExtendedFOV);\r\n                const p1 = this.projectCameraPoint(tri.v1, useExtendedFOV);\r\n                const p2 = this.projectCameraPoint(tri.v2, useExtendedFOV);\r\n\r\n                if (!p0 || !p1 || !p2) return;\r\n                tri.projectedVerts = [p0, p1, p2];\r\n            }\r\n\r\n            // Identify conflicting cells\r\n            const [p0, p1, p2] = tri.projectedVerts;\r\n            const { minX, maxX, minY, maxY } = tri.screenBounds;\r\n\r\n            const cellMinX = Math.floor(minX / cellSize);\r\n            const cellMaxX = Math.floor(maxX / cellSize);\r\n            const cellMinY = Math.floor(minY / cellSize);\r\n            const cellMaxY = Math.floor(maxY / cellSize);\r\n\r\n            // Check which cells have conflicts\r\n            const conflictCells = [];\r\n            for (let cy = cellMinY; cy <= cellMaxY; cy++) {\r\n                for (let cx = cellMinX; cx <= cellMaxX; cx++) {\r\n                    if (cy < 0 || cy >= depthGrid.length || cx < 0 || cx >= depthGrid[0].length) continue;\r\n\r\n                    const cell = depthGrid[cy][cx];\r\n                    // If this triangle is closer than what's in the cell, it's a conflict\r\n                    if (tri.minDepth < cell.minDepth - 0.01) { // Small epsilon for floating point\r\n                        conflictCells.push({ cx, cy });\r\n                    }\r\n                }\r\n            }\r\n\r\n            // If there are conflicts, redraw this triangle\r\n            if (conflictCells.length > 0) {\r\n                this.rasterizeFALDTriangle(p0, p1, p2, tri.color, data, w, h, tri.material, tri.faceUVs);\r\n\r\n                // Update depth grid\r\n                conflictCells.forEach(({ cx, cy }) => {\r\n                    const cell = depthGrid[cy][cx];\r\n                    cell.minDepth = Math.min(cell.minDepth, tri.minDepth);\r\n                    cell.maxDepth = Math.max(cell.maxDepth, tri.maxDepth);\r\n                    cell.polygonId = tri.id;\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n  * Rasterize triangle directly to ImageData buffer\r\n  * Uses edge function approach for fast inside testing\r\n  * Now supports full material properties including alpha, specular, emissive, etc.\r\n  */\r\n     rasterizeFALDTriangle(p0, p1, p2, color, data, w, h, material = null, faceUVs = null) {\r\n         // Round to integer coordinates\r\n         const x0 = Math.round(p0.x), y0 = Math.round(p0.y);\r\n         const x1 = Math.round(p1.x), y1 = Math.round(p1.y);\r\n         const x2 = Math.round(p2.x), y2 = Math.round(p2.y);\r\n\r\n         // Calculate bounding box\r\n         const minX = Math.max(0, Math.min(x0, x1, x2));\r\n         const maxX = Math.min(w - 1, Math.max(x0, x1, x2));\r\n         const minY = Math.max(0, Math.min(y0, y1, y2));\r\n         const maxY = Math.min(h - 1, Math.max(y0, y1, y2));\r\n\r\n         // Early rejection\r\n         if (minX > maxX || minY > maxY) return;\r\n\r\n         // Edge function setup\r\n         const e0_dx = x1 - x0, e0_dy = y1 - y0;\r\n         const e1_dx = x2 - x1, e1_dy = y2 - y1;\r\n         const e2_dx = x0 - x2, e2_dy = y0 - y2;\r\n\r\n         // Check if triangle is degenerate\r\n         const area = e0_dx * (y2 - y0) - e0_dy * (x2 - x0);\r\n         if (Math.abs(area) < 0.5) return;\r\n\r\n         const invArea = 1.0 / area;\r\n\r\n         // Get textures if material has them\r\n         const diffuseTexture = material ? material.getDiffuseTexture() : null;\r\n         const normalTexture = material ? material._normalTexture : null;\r\n         const specularTexture = material ? material._specularTexture : null;\r\n         const emissiveTexture = material ? material._emissiveTexture : null;\r\n\r\n         // Get material properties\r\n         const opacity = material ? material._opacity : 1.0;\r\n         const specularColor = material ? material._specularColor : \"#FFFFFF\";\r\n         const emissiveColor = material ? material._emissiveColor : \"#000000\";\r\n         const shininess = material ? material._shininess : 32;\r\n         const wireframe = material ? material._wireframe : false;\r\n         const doubleSided = material ? material._doubleSided : false;\r\n\r\n         // Parse material colors\r\n         const specularRgb = this.hexToRgb(specularColor);\r\n         const emissiveRgb = this.hexToRgb(emissiveColor);\r\n\r\n         // Precompute color values for solid color fallback\r\n         const baseR = color.r, baseG = color.g, baseB = color.b;\r\n\r\n         // Calculate lighting vectors (simplified)\r\n         const lightDir = this._lightDirection;\r\n         const lightLen = Math.sqrt(lightDir.x ** 2 + lightDir.y ** 2 + lightDir.z ** 2);\r\n         const normalizedLightDir = {\r\n             x: lightDir.x / lightLen,\r\n             y: lightDir.y / lightLen,\r\n             z: lightDir.z / lightLen\r\n         };\r\n\r\n         // Scanline rasterization\r\n         for (let y = minY; y <= maxY; y++) {\r\n             // Calculate edge values at start of scanline\r\n             let w0 = e0_dx * (y - y0) - e0_dy * (minX - x0);\r\n             let w1 = e1_dx * (y - y1) - e1_dy * (minX - x1);\r\n             let w2 = e2_dx * (y - y2) - e2_dy * (minX - x2);\r\n\r\n             // Edge increments for x-stepping\r\n             const w0_step = -e0_dy;\r\n             const w1_step = -e1_dy;\r\n             const w2_step = -e2_dy;\r\n\r\n             for (let x = minX; x <= maxX; x++) {\r\n                 // Inside test using edge equations\r\n                 if (w0 >= 0 && w1 >= 0 && w2 >= 0) {\r\n                     // Calculate barycentric coordinates for texture sampling and lighting\r\n                     const u = w0 * invArea;\r\n                     const v = w1 * invArea;\r\n                     const ww = 1 - u - v;\r\n\r\n                     let pixelR = baseR, pixelG = baseG, pixelB = baseB, pixelA = 255;\r\n\r\n                     // Sample diffuse texture if available\r\n                     if (diffuseTexture && faceUVs && faceUVs.length >= 3) {\r\n                         // Interpolate UV coordinates using barycentric coordinates\r\n                         const texU = u * faceUVs[0].x + v * faceUVs[1].x + ww * faceUVs[2].x;\r\n                         const texV = u * faceUVs[0].y + v * faceUVs[1].y + ww * faceUVs[2].y;\r\n\r\n                         // Sample texture color\r\n                         const textureColor = material.sampleTexture(texU, texV, diffuseTexture);\r\n                         if (textureColor) {\r\n                             // Parse rgba() color\r\n                             const rgbaMatch = textureColor.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+),\\s*([\\d.]+)\\)/);\r\n                             if (rgbaMatch) {\r\n                                 pixelR = parseInt(rgbaMatch[1]);\r\n                                 pixelG = parseInt(rgbaMatch[2]);\r\n                                 pixelB = parseInt(rgbaMatch[3]);\r\n                                 pixelA = parseInt(rgbaMatch[4] * 255 * opacity);\r\n                             }\r\n                         }\r\n                     } else {\r\n                         // Apply material opacity even without texture\r\n                         pixelA = Math.round(255 * opacity);\r\n                     }\r\n\r\n                     // Add emissive lighting if material has emissive color\r\n                     if (emissiveRgb.r > 0 || emissiveRgb.g > 0 || emissiveRgb.b > 0) {\r\n                         pixelR = Math.min(255, pixelR + emissiveRgb.r);\r\n                         pixelG = Math.min(255, pixelG + emissiveRgb.g);\r\n                         pixelB = Math.min(255, pixelB + emissiveRgb.b);\r\n                     }\r\n\r\n                     // Add specular lighting if material has specular properties\r\n                     if (specularRgb.r > 0 || specularRgb.g > 0 || specularRgb.b > 0) {\r\n                         // Simple specular calculation (can be enhanced with proper normal mapping)\r\n                         const specularIntensity = Math.pow(Math.max(0, -normalizedLightDir.z), shininess) * this._lightIntensity;\r\n                         pixelR = Math.min(255, pixelR + specularRgb.r * specularIntensity);\r\n                         pixelG = Math.min(255, pixelG + specularRgb.g * specularIntensity);\r\n                         pixelB = Math.min(255, pixelB + specularRgb.b * specularIntensity);\r\n                     }\r\n\r\n                     // Handle wireframe mode\r\n                     if (wireframe) {\r\n                         // Check if we're on the edge of the triangle\r\n                         const edgeDistance = Math.min(\r\n                             Math.min(w0, w1),\r\n                             Math.min(w2, Math.min(w0 + w1, w1 + w2))\r\n                         );\r\n                         if (edgeDistance < 2) { // Wireframe thickness\r\n                             pixelR = pixelG = pixelB = 255; // White wireframe\r\n                         }\r\n                     }\r\n\r\n                     const pixelIdx = (y * w + x) * 4;\r\n                     data[pixelIdx] = pixelR;\r\n                     data[pixelIdx + 1] = pixelG;\r\n                     data[pixelIdx + 2] = pixelB;\r\n                     data[pixelIdx + 3] = pixelA;\r\n                 }\r\n\r\n                 // Increment edge values\r\n                 w0 += w0_step;\r\n                 w1 += w1_step;\r\n                 w2 += w2_step;\r\n             }\r\n         }\r\n     }\r\n\r\n    /**\r\n     * Draw a triangle using native canvas fill (REMOVED - not used anymore)\r\n     */\r\n    drawFALDTriangle(ctx, p0, p1, p2, color) {\r\n        // This method is no longer used, but keeping for reference\r\n        ctx.fillStyle = `rgb(${color.r}, ${color.g}, ${color.b})`;\r\n        ctx.beginPath();\r\n        ctx.moveTo(p0.x, p0.y);\r\n        ctx.lineTo(p1.x, p1.y);\r\n        ctx.lineTo(p2.x, p2.y);\r\n        ctx.closePath();\r\n        ctx.fill();\r\n    }\r\n\r\n    /**\r\n * Iterative Layered Point Cloud (ILPC) Rendering\r\n * Renders 3D scenes as adaptive point clouds with progressive refinement\r\n */\r\n    renderILPC() {\r\n        const allObjects = this.getGameObjects();\r\n        const ctx = this._renderTextureCtx;\r\n        const imgData = this._imageData;\r\n        const data = imgData.data;\r\n        const w = this._renderTextureWidth;\r\n        const h = this._renderTextureHeight;\r\n\r\n        // Clear background\r\n        if (this._backgroundType === \"transparent\") {\r\n            // Leave transparent\r\n        } else if (this._backgroundType === \"solid\") {\r\n            const bgColor = this.hexToRgb(this._backgroundColor);\r\n            for (let i = 0; i < data.length; i += 4) {\r\n                data[i] = bgColor.r;\r\n                data[i + 1] = bgColor.g;\r\n                data[i + 2] = bgColor.b;\r\n                data[i + 3] = 255;\r\n            }\r\n        } else if (this._backgroundType === \"skyfloor\") {\r\n            const fovRadians = this._fieldOfView * (Math.PI / 180);\r\n            const pitchRadians = (this._rotation.y || 0) * (Math.PI / 180);\r\n            const maxPitch = fovRadians / 2;\r\n            const normalizedPitch = -Math.max(-1, Math.min(1, pitchRadians / maxPitch));\r\n            const horizonOffset = normalizedPitch * 0.5;\r\n            const horizonRatio = 0.5 + horizonOffset;\r\n            const clampedHorizon = Math.max(0, Math.min(1, horizonRatio));\r\n            const horizonY = Math.floor(h * clampedHorizon);\r\n\r\n            for (let i = 0; i < data.length; i += 4) {\r\n                const y = Math.floor((i / 4) / w);\r\n                if (y < horizonY) {\r\n                    data[i] = this.hexToRgb(this._skyColor).r;\r\n                    data[i + 1] = this.hexToRgb(this._skyColor).g;\r\n                    data[i + 2] = this.hexToRgb(this._skyColor).b;\r\n                } else {\r\n                    data[i] = this.hexToRgb(this._floorColor).r;\r\n                    data[i + 1] = this.hexToRgb(this._floorColor).g;\r\n                    data[i + 2] = this.hexToRgb(this._floorColor).b;\r\n                }\r\n                data[i + 3] = 255;\r\n            }\r\n        }\r\n\r\n        // Initialize 2D depth map (stores timestamp and radius for occlusion)\r\n        if (!this._ilpcDepthMap || this._ilpcDepthMap.length !== w * h) {\r\n            this._ilpcDepthMap = new Array(w * h);\r\n        }\r\n\r\n        // Clear depth map\r\n        for (let i = 0; i < this._ilpcDepthMap.length; i++) {\r\n            this._ilpcDepthMap[i] = { timestamp: 0, radius: 0, depth: Infinity };\r\n        }\r\n\r\n        // Current frame timestamp\r\n        const frameTimestamp = performance.now();\r\n\r\n        // Collect and generate point cloud from all meshes\r\n        const pointCloud = [];\r\n\r\n        allObjects.forEach(obj => {\r\n            if (!obj.active) return;\r\n            const mesh = obj.getModule(\"Mesh3D\") || obj.getModule(\"CubeMesh3D\") || obj.getModule(\"SphereMesh3D\");\r\n            if (!mesh) return;\r\n\r\n            const transformedVertices = mesh.transformVertices();\r\n            if (!transformedVertices || !mesh.faces) return;\r\n\r\n            const faceColor = mesh.faceColor || mesh._faceColor || \"#888888\";\r\n\r\n            // Generate points from mesh faces\r\n            mesh.faces.forEach(face => {\r\n                const worldVerts = face.map(idx => transformedVertices[idx]).filter(v => v);\r\n                if (worldVerts.length < 3) return;\r\n\r\n                // Calculate face normal for lighting\r\n                const worldNormal = this.calculateFaceNormal(worldVerts[0], worldVerts[1], worldVerts[2]);\r\n                const litColor = this.calculateLighting(worldNormal, faceColor);\r\n\r\n                // Transform to camera space\r\n                const cameraVerts = worldVerts.map(v => this.worldToCameraSpace(v));\r\n\r\n                // Backface culling\r\n                if (this._enableBackfaceCulling && !this._disableCulling) {\r\n                    if (this.shouldCullFace(cameraVerts)) return;\r\n                }\r\n\r\n                // Generate points for this face based on its area and distance\r\n                const points = this.generatePointsFromFace(cameraVerts, worldVerts, litColor);\r\n                pointCloud.push(...points);\r\n            });\r\n        });\r\n\r\n        // Frustum culling - remove points outside view\r\n        const frustumCulledPoints = pointCloud.filter(point => {\r\n            return point.cameraPos.x >= this._nearPlane &&\r\n                point.cameraPos.x <= this._farPlane;\r\n        });\r\n\r\n        // Sort points front-to-back by depth (camera X coordinate)\r\n        frustumCulledPoints.sort((a, b) => a.cameraPos.x - b.cameraPos.x);\r\n\r\n        // Calculate LOD pass count based on point density\r\n        const totalPoints = frustumCulledPoints.length;\r\n        const passCount = Math.min(3, Math.ceil(totalPoints / 1000) + 1);\r\n\r\n        // Render in multiple passes for progressive refinement\r\n        for (let pass = 0; pass < passCount; pass++) {\r\n            const passRatio = (pass + 1) / passCount;\r\n            const pointsThisPass = Math.ceil(totalPoints * passRatio);\r\n\r\n            // Determine which points to render this pass\r\n            let pointsToRender;\r\n            if (pass === 0) {\r\n                // First pass: evenly distributed sparse points\r\n                pointsToRender = frustumCulledPoints.filter((_, idx) => idx % 4 === 0);\r\n            } else if (pass === 1) {\r\n                // Second pass: fill in more points\r\n                pointsToRender = frustumCulledPoints.filter((_, idx) => idx % 2 === 0);\r\n            } else {\r\n                // Final pass: render all remaining points\r\n                pointsToRender = frustumCulledPoints;\r\n            }\r\n\r\n            // Render points for this pass\r\n            pointsToRender.forEach(point => {\r\n                this.renderILPCPoint(point, data, w, h, frameTimestamp);\r\n            });\r\n        }\r\n\r\n        ctx.putImageData(imgData, 0, 0);\r\n    }\r\n\r\n    /**\r\n     * Generate point samples from a mesh face\r\n     * Adaptive sampling based on face size and distance\r\n     */\r\n    generatePointsFromFace(cameraVerts, worldVerts, color) {\r\n        if (cameraVerts.length < 3) return [];\r\n\r\n        const points = [];\r\n\r\n        // Calculate average depth\r\n        const avgDepth = cameraVerts.reduce((sum, v) => sum + v.x, 0) / cameraVerts.length;\r\n\r\n        // Calculate face area in camera space (approximate)\r\n        const v0 = cameraVerts[0];\r\n        const v1 = cameraVerts[1];\r\n        const v2 = cameraVerts[2];\r\n\r\n        const edge1 = { x: v1.x - v0.x, y: v1.y - v0.y, z: v1.z - v0.z };\r\n        const edge2 = { x: v2.x - v0.x, y: v2.y - v0.y, z: v2.z - v0.z };\r\n\r\n        // Cross product magnitude / 2 = triangle area\r\n        const crossX = edge1.y * edge2.z - edge1.z * edge2.y;\r\n        const crossY = edge1.z * edge2.x - edge1.x * edge2.z;\r\n        const crossZ = edge1.x * edge2.y - edge1.y * edge2.x;\r\n        const area = Math.sqrt(crossX * crossX + crossY * crossY + crossZ * crossZ) / 2;\r\n\r\n        // Adaptive point density based on distance and area\r\n        // Closer and larger faces get more points\r\n        const distanceFactor = Math.max(1, avgDepth / 50);\r\n        const pointDensity = Math.max(1, Math.ceil((area * 20) / distanceFactor));\r\n        const numPoints = Math.min(pointDensity, 50); // Cap at 50 points per face\r\n\r\n        // Generate points using barycentric coordinates\r\n        for (let i = 0; i < numPoints; i++) {\r\n            // Random barycentric coordinates\r\n            let u = Math.random();\r\n            let v = Math.random();\r\n\r\n            // Ensure point is inside triangle\r\n            if (u + v > 1) {\r\n                u = 1 - u;\r\n                v = 1 - v;\r\n            }\r\n            const w = 1 - u - v;\r\n\r\n            // Interpolate position in camera space\r\n            const cameraPos = {\r\n                x: u * cameraVerts[0].x + v * cameraVerts[1].x + w * cameraVerts[2].x,\r\n                y: u * cameraVerts[0].y + v * cameraVerts[1].y + w * cameraVerts[2].y,\r\n                z: u * cameraVerts[0].z + v * cameraVerts[1].z + w * cameraVerts[2].z\r\n            };\r\n\r\n            // Calculate importance (edge points are more important)\r\n            const importance = Math.min(u, v, w) < 0.1 ? 2 : 1;\r\n\r\n            points.push({\r\n                cameraPos,\r\n                color,\r\n                importance,\r\n                radius: Math.max(1, 10 / avgDepth) // Screen-space radius based on depth\r\n            });\r\n        }\r\n\r\n        return points;\r\n    }\r\n\r\n    /**\r\n     * Render a single point with occlusion culling\r\n     */\r\n    renderILPCPoint(point, data, w, h, timestamp) {\r\n        const { cameraPos, color, radius } = point;\r\n\r\n        // Project to screen space\r\n        const useExtendedFOV = this._enableBackfaceCulling && !this._disableCulling;\r\n        const projected = this.projectCameraPoint(cameraPos, useExtendedFOV);\r\n\r\n        if (!projected) return;\r\n\r\n        const cx = Math.round(projected.x);\r\n        const cy = Math.round(projected.y);\r\n\r\n        // Check bounds\r\n        if (cx < 0 || cx >= w || cy < 0 || cy >= h) return;\r\n\r\n        // Calculate screen-space radius (perspective scaling)\r\n        const screenRadius = Math.max(1, Math.ceil(radius / cameraPos.x));\r\n\r\n        // Occlusion culling - check if this point is occluded\r\n        const depthMapIdx = cy * w + cx;\r\n        const existing = this._ilpcDepthMap[depthMapIdx];\r\n\r\n        // If an existing point completely covers this one, skip it\r\n        if (existing && existing.timestamp === timestamp) {\r\n            const depthDiff = cameraPos.x - existing.depth;\r\n            const radiusDiff = existing.radius - screenRadius;\r\n\r\n            // Skip if behind existing point and fully covered\r\n            if (depthDiff > 0 && radiusDiff >= screenRadius) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Draw the point\r\n        const halfRadius = Math.floor(screenRadius / 2);\r\n        const minX = Math.max(0, cx - halfRadius);\r\n        const maxX = Math.min(w - 1, cx + halfRadius);\r\n        const minY = Math.max(0, cy - halfRadius);\r\n        const maxY = Math.min(h - 1, cy + halfRadius);\r\n\r\n        // Draw as a small filled circle/square\r\n        for (let y = minY; y <= maxY; y++) {\r\n            for (let x = minX; x <= maxX; x++) {\r\n                // Optional: circular points (check distance from center)\r\n                const dx = x - cx;\r\n                const dy = y - cy;\r\n                const distSq = dx * dx + dy * dy;\r\n\r\n                if (distSq <= screenRadius * screenRadius) {\r\n                    const pixelIdx = (y * w + x) * 4;\r\n\r\n                    // Soft edges for better blending\r\n                    const falloff = 1.0 - Math.sqrt(distSq) / screenRadius;\r\n                    const alpha = Math.min(1, falloff * 1.5);\r\n\r\n                    // Blend with existing pixel\r\n                    const existingR = data[pixelIdx];\r\n                    const existingG = data[pixelIdx + 1];\r\n                    const existingB = data[pixelIdx + 2];\r\n\r\n                    data[pixelIdx] = Math.round(existingR * (1 - alpha) + color.r * alpha);\r\n                    data[pixelIdx + 1] = Math.round(existingG * (1 - alpha) + color.g * alpha);\r\n                    data[pixelIdx + 2] = Math.round(existingB * (1 - alpha) + color.b * alpha);\r\n                    data[pixelIdx + 3] = 255;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Update depth map at point center\r\n        this._ilpcDepthMap[depthMapIdx] = {\r\n            timestamp,\r\n            radius: screenRadius,\r\n            depth: cameraPos.x\r\n        };\r\n    }\r\n\r\n    start() {\r\n        this.updateViewport();\r\n        this.updateRenderTexture();\r\n        const cameras = this.getGameObjects()\r\n            .map(obj => obj.getModule(\"Camera3D\"))\r\n            .filter(cam => cam !== null);\r\n        if (cameras.length === 1 && cameras[0] === this) this._isActive = true;\r\n    }\r\n\r\n    beginLoop() { this.updateViewport(); }\r\n    draw(ctx) { }\r\n    drawGizmos(ctx) {\r\n        ctx.save();\r\n        ctx.translate(this.gameObject.position.x, this.gameObject.position.y);\r\n        ctx.rotate((this.gameObject.angle * Math.PI) / 180);\r\n\r\n        // Draw a small camera icon at (0, 0)\r\n        ctx.fillStyle = '#ffffff';\r\n        ctx.fillRect(-3, -3, 6, 6); // Small body\r\n        ctx.beginPath();\r\n        ctx.arc(0, 0, 2, 0, 2 * Math.PI);\r\n        ctx.fillStyle = '#000000';\r\n        ctx.fill(); // Lens\r\n\r\n        // Draw frustum showing FOV, near, and far planes\r\n        const halfFovRad = (this._fieldOfView / 2) * (Math.PI / 180);\r\n        const near = this._nearPlane * 10; // Scale for visibility\r\n        const far = this._farPlane * 0.1; // Scale down far plane\r\n        const nearHalfWidth = near * Math.tan(halfFovRad);\r\n        const farHalfWidth = far * Math.tan(halfFovRad);\r\n\r\n        ctx.strokeStyle = '#ffff00'; // Yellow lines\r\n        ctx.lineWidth = 1;\r\n        ctx.beginPath();\r\n\r\n        // Lines from camera to near plane\r\n        ctx.moveTo(0, 0);\r\n        ctx.lineTo(near, -nearHalfWidth);\r\n        ctx.moveTo(0, 0);\r\n        ctx.lineTo(near, nearHalfWidth);\r\n\r\n        // Near plane\r\n        ctx.moveTo(near, -nearHalfWidth);\r\n        ctx.lineTo(near, nearHalfWidth);\r\n\r\n        // Lines from near to far plane\r\n        ctx.moveTo(near, -nearHalfWidth);\r\n        ctx.lineTo(far, -farHalfWidth);\r\n        ctx.moveTo(near, nearHalfWidth);\r\n        ctx.lineTo(far, farHalfWidth);\r\n\r\n        // Far plane\r\n        ctx.moveTo(far, -farHalfWidth);\r\n        ctx.lineTo(far, farHalfWidth);\r\n\r\n        ctx.stroke();\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    toJSON() {\r\n        return {\r\n            _type: \"Camera3D\", _position: { x: this._position.x, y: this._position.y, z: this._position.z },\r\n            _rotation: { x: this._rotation.x, y: this._rotation.y, z: this._rotation.z },\r\n            _fieldOfView: this._fieldOfView, _nearPlane: this._nearPlane, _farPlane: this._farPlane,\r\n            _isActive: this._isActive, _backgroundColor: this._backgroundColor,\r\n            _renderTextureWidth: this._renderTextureWidth, _renderTextureHeight: this._renderTextureHeight,\r\n            _renderTextureSmoothing: this._renderTextureSmoothing, drawGizmoInRuntime: this.drawGizmoInRuntime,\r\n            _renderingMethod: this._renderingMethod, _enableBackfaceCulling: this._enableBackfaceCulling,\r\n            _cullingFieldOfView: this._cullingFieldOfView,\r\n            _lightDirection: { x: this._lightDirection.x, y: this._lightDirection.y, z: this._lightDirection.z },\r\n            _lightColor: this._lightColor,\r\n            _lightIntensity: this._lightIntensity,\r\n            _ambientIntensity: this._ambientIntensity,\r\n            _depthOfFieldEnabled: this._depthOfFieldEnabled,\r\n            _focalDistance: this._focalDistance,\r\n            _aperture: this._aperture,\r\n            _maxBlurRadius: this._maxBlurRadius,\r\n            _skyColor: this._skyColor,\r\n            _floorColor: this._floorColor,\r\n            _backgroundType: this._backgroundType\r\n        };\r\n    }\r\n\r\n    fromJSON(json) {\r\n        if (json._position) this._position = new Vector3(json._position.x, json._position.y, json._position.z);\r\n        if (json._rotation) this._rotation = new Vector3(json._rotation.x, json._rotation.y, json._rotation.z);\r\n        if (json._fieldOfView !== undefined) this._fieldOfView = json._fieldOfView;\r\n        if (json._nearPlane !== undefined) this._nearPlane = json._nearPlane;\r\n        if (json._farPlane !== undefined) this._farPlane = json._farPlane;\r\n        if (json._isActive !== undefined) this._isActive = json._isActive;\r\n        if (json._backgroundColor !== undefined) this._backgroundColor = json._backgroundColor;\r\n        if (json._renderTextureWidth !== undefined) this._renderTextureWidth = json._renderTextureWidth;\r\n        if (json._renderTextureHeight !== undefined) this._renderTextureHeight = json._renderTextureHeight;\r\n        if (json._renderTextureSmoothing !== undefined) this._renderTextureSmoothing = json._renderTextureSmoothing;\r\n        if (json.drawGizmoInRuntime !== undefined) this.drawGizmoInRuntime = json.drawGizmoInRuntime;\r\n        if (json._renderingMethod !== undefined) this._renderingMethod = json._renderingMethod;\r\n        if (json._enableBackfaceCulling !== undefined) this._enableBackfaceCulling = json._enableBackfaceCulling;\r\n        if (json._cullingFieldOfView !== undefined) this._cullingFieldOfView = json._cullingFieldOfView;\r\n        if (json._lightDirection) this._lightDirection = new Vector3(json._lightDirection.x, json._lightDirection.y, json._lightDirection.z);\r\n        if (json._lightColor !== undefined) this._lightColor = json._lightColor;\r\n        if (json._lightIntensity !== undefined) this._lightIntensity = json._lightIntensity;\r\n        if (json._ambientIntensity !== undefined) this._ambientIntensity = json._ambientIntensity;\r\n        if (json._depthOfFieldEnabled !== undefined) this._depthOfFieldEnabled = json._depthOfFieldEnabled;\r\n        if (json._focalDistance !== undefined) this._focalDistance = json._focalDistance;\r\n        if (json._aperture !== undefined) this._aperture = json._aperture;\r\n        if (json._maxBlurRadius !== undefined) this._maxBlurRadius = json._maxBlurRadius;\r\n        if (json._skyColor !== undefined) { this._skyColor = json._skyColor; } else { this._skyColor = \"#87CEEB\"; }\r\n        if (json._floorColor !== undefined) { this._floorColor = json._floorColor; } else { this._floorColor = \"#8B4513\"; }\r\n        if (json._backgroundType !== undefined) { this._backgroundType = json._backgroundType; } else { this._backgroundType = \"skyfloor\"; }\r\n        this.updateRenderTexture();\r\n    }\r\n\r\n    get renderTextureWidth() { return this._renderTextureWidth; }\r\n    set renderTextureWidth(value) { this._renderTextureWidth = Math.max(64, Math.min(2048, value)); this.updateRenderTexture(); }\r\n    get renderTextureHeight() { return this._renderTextureHeight; }\r\n    set renderTextureHeight(value) { this._renderTextureHeight = Math.max(64, Math.min(2048, value)); this.updateRenderTexture(); }\r\n    get renderTextureSmoothing() { return this._renderTextureSmoothing; }\r\n    set renderTextureSmoothing(value) { this._renderTextureSmoothing = value; }\r\n    get backgroundColor() { return this._backgroundColor; }\r\n    set backgroundColor(value) { this._backgroundColor = value; }\r\n    get position() { return this._position; }\r\n    set position(value) { this._position = value; }\r\n    get rotation() { return this._rotation; }\r\n    set rotation(value) { this._rotation = value; }\r\n    get fieldOfView() { return this._fieldOfView; }\r\n    set fieldOfView(value) { this._fieldOfView = Math.max(1, Math.min(179, value)); }\r\n    get nearPlane() { return this._nearPlane; }\r\n    set nearPlane(value) { this._nearPlane = Math.max(0.01, value); }\r\n    get farPlane() { return this._farPlane; }\r\n    set farPlane(value) { this._farPlane = Math.max(1, value); }\r\n    get isActive() { return this._isActive; }\r\n    set isActive(value) { this._isActive = value; }\r\n    get cullingFieldOfView() { return this._cullingFieldOfView; }\r\n    set cullingFieldOfView(value) { this._cullingFieldOfView = Math.max(1, Math.min(179, value)); }\r\n}\r\n\r\nwindow.Camera3D = Camera3D;\r\n",
      "type": "file",
      "name": "Camera3D.js",
      "parentPath": "/",
      "created": 1759457099334,
      "modified": 1759457099334
    },
    {
      "path": "/Camera3DBasic.js",
      "content": "/**\n * Camera3D - Module for 3D perspective cameras\n * \n * This module provides 3D camera functionality with multiple rendering methods.\n * Supports: Painter's Algorithm, Z-Buffer, Scanline, and Raytracing.\n */\nclass Camera3DBasic extends Module {\n    static namespace = \"WIP\";\n\n    constructor() {\n        super(\"Camera3DBasic\");\n\n        this._position = new Vector3(0, 0, 0);\n        this._rotation = new Vector3(0, 0, 0);\n        this._fieldOfView = 60;\n        this._nearPlane = 0.1;\n        this._farPlane = 5000;\n        this._isActive = false;\n        this._backgroundColor = \"#000000\";\n        this._renderTextureWidth = 320;\n        this._renderTextureHeight = 240;\n        this._renderTextureSmoothing = false;\n        this._renderTexture = null;\n        this._renderTextureCtx = null;\n        this.viewportWidth = 800;\n        this.viewportHeight = 600;\n        this.drawGizmoInRuntime = false;\n        this._renderingMethod = \"painter\";\n        this._enableBackfaceCulling = true;\n        this._zBuffer = null;\n        this._imageData = null;\n\n        this.exposeProperty(\"position\", \"vector3\", this._position, {\n            onChange: (val) => this._position = val\n        });\n        this.exposeProperty(\"rotation\", \"vector3\", this._rotation, {\n            onChange: (val) => this._rotation = val\n        });\n        this.exposeProperty(\"fieldOfView\", \"number\", 60, {\n            min: 1, max: 179, onChange: (val) => this._fieldOfView = val\n        });\n        this.exposeProperty(\"nearPlane\", \"number\", 0.1, {\n            min: 0.01, max: 10, step: 0.01, onChange: (val) => this._nearPlane = val\n        });\n        this.exposeProperty(\"farPlane\", \"number\", 1000, {\n            min: 10, max: 10000, step: 1, onChange: (val) => this._farPlane = val\n        });\n        this.exposeProperty(\"isActive\", \"boolean\", false, {\n            onChange: (val) => {\n                this._isActive = val;\n                if (val) this.setAsActiveCamera();\n            }\n        });\n        this.exposeProperty(\"backgroundColor\", \"color\", \"#000000\", {\n            onChange: (val) => this._backgroundColor = val\n        });\n        this.exposeProperty(\"drawGizmoInRuntime\", \"boolean\", false, {\n            onChange: (val) => this.drawGizmoInRuntime = val\n        });\n        this.exposeProperty(\"renderTextureWidth\", \"number\", 512, {\n            min: 64, max: 2048, step: 64,\n            onChange: (val) => {\n                this._renderTextureWidth = val;\n                this.updateRenderTexture();\n            }\n        });\n        this.exposeProperty(\"renderTextureHeight\", \"number\", 512, {\n            min: 64, max: 2048, step: 64,\n            onChange: (val) => {\n                this._renderTextureHeight = val;\n                this.updateRenderTexture();\n            }\n        });\n        this.exposeProperty(\"renderTextureSmoothing\", \"boolean\", false, {\n            onChange: (val) => this._renderTextureSmoothing = val\n        });\n        this.exposeProperty(\"renderingMethod\", \"dropdown\", \"painter\", {\n            options: [\"painter\", \"zbuffer\", \"scanline\", \"raytrace\"],\n            onChange: (val) => this._renderingMethod = val\n        });\n        this.exposeProperty(\"enableBackfaceCulling\", \"boolean\", true, {\n            onChange: (val) => this._enableBackfaceCulling = val\n        });\n\n        this.updateRenderTexture();\n    }\n\n    setAsActiveCamera() {\n        if (!this.gameObject) return;\n        const allObjects = this.getGameObjects();\n        allObjects.forEach(obj => {\n            const camera = obj.getModule(\"Camera3D\");\n            if (camera && camera !== this) camera._isActive = false;\n        });\n        this._isActive = true;\n    }\n\n    getGameObjects() {\n        if (!this.gameObject) return [];\n        return this.getAllGameObjects();\n    }\n\n    projectPoint(point) {\n        const cameraPoint = this.worldToCameraSpace(point);\n        const depth = cameraPoint.x;\n        if (depth <= this.nearPlane || depth >= this.farPlane) return null;\n        const aspect = this.viewportWidth / this.viewportHeight;\n        const fovRadians = this.fieldOfView * (Math.PI / 180);\n        const f = 1.0 / Math.tan(fovRadians * 0.5);\n        if (depth < 1e-6) return null;\n        const ndcX = (cameraPoint.y / depth) * (f / aspect);\n        const ndcY = (cameraPoint.z / depth) * f;\n        const screenX = (ndcX * 0.5 + 0.5) * this.viewportWidth;\n        const screenY = (0.5 - ndcY * 0.5) * this.viewportHeight;\n        return new Vector2(screenX, screenY);\n    }\n\n    worldToCameraSpace(point) {\n        const goPos = (this.gameObject && this.gameObject.getWorldPosition) ?\n            this.gameObject.getWorldPosition() : { x: 0, y: 0 };\n        let goDepth = 0;\n        if (this.gameObject) {\n            if (typeof this.gameObject.getWorldDepth === 'function') {\n                goDepth = this.gameObject.getWorldDepth();\n            } else if (typeof this.gameObject.depth === 'number') {\n                goDepth = this.gameObject.depth;\n            } else if (this.gameObject.position && this.gameObject.position.z) {\n                goDepth = this.gameObject.position.z;\n            }\n        }\n        const camWorldX = (goPos.x || 0) + (this._position.x || 0);\n        const camWorldY = (goPos.y || 0) + (this._position.y || 0);\n        const camWorldZ = goDepth + (this._position.z || 0);\n        const cameraPos = new Vector3(camWorldX, camWorldY, camWorldZ);\n        const parentAngleDeg = (this.gameObject && this.gameObject.getWorldRotation) ?\n            this.gameObject.getWorldRotation() : 0;\n        const yaw = (parentAngleDeg + (this._rotation.z || 0)) * (Math.PI / 180);\n        const pitch = (this._rotation.y || 0) * (Math.PI / 180);\n        const roll = (this._rotation.x || 0) * (Math.PI / 180);\n        let relativePos = this.subtractVector3(point, cameraPos);\n        relativePos = this.rotateVectorZ(relativePos, -yaw);\n        relativePos = this.rotateVectorY(relativePos, -pitch);\n        relativePos = this.rotateVectorX(relativePos, -roll);\n        return relativePos;\n    }\n\n    subtractVector3(a, b) {\n        return new Vector3(a.x - b.x, a.y - b.y, a.z - b.z);\n    }\n\n    rotateVectorX(v, angle) {\n        const cos = Math.cos(angle), sin = Math.sin(angle);\n        return new Vector3(v.x, v.y * cos - v.z * sin, v.y * sin + v.z * cos);\n    }\n\n    rotateVectorY(v, angle) {\n        const cos = Math.cos(angle), sin = Math.sin(angle);\n        return new Vector3(v.x * cos + v.z * sin, v.y, -v.x * sin + v.z * cos);\n    }\n\n    rotateVectorZ(v, angle) {\n        const cos = Math.cos(angle), sin = Math.sin(angle);\n        return new Vector3(v.x * cos - v.y * sin, v.x * sin + v.y * cos, v.z);\n    }\n\n    clipPolygonAgainstNearPlane(vertices, nearPlane) {\n        if (!vertices || vertices.length === 0) return [];\n        const out = [];\n        const epsilon = 0.0001;\n        for (let i = 0; i < vertices.length; i++) {\n            const a = vertices[i];\n            const b = vertices[(i + 1) % vertices.length];\n            const aIn = a.x >= nearPlane - epsilon;\n            const bIn = b.x >= nearPlane - epsilon;\n            if (aIn && bIn) {\n                out.push(b);\n            } else if (aIn && !bIn) {\n                const t = Math.max(0, Math.min(1, (nearPlane - a.x) / (b.x - a.x)));\n                out.push(new Vector3(nearPlane, a.y + t * (b.y - a.y), a.z + t * (b.z - a.z)));\n            } else if (!aIn && bIn) {\n                const t = Math.max(0, Math.min(1, (nearPlane - a.x) / (b.x - a.x)));\n                out.push(new Vector3(nearPlane, a.y + t * (b.y - a.y), a.z + t * (b.z - a.z)));\n                out.push(b);\n            }\n        }\n        return out;\n    }\n\n    projectCameraPoint(cameraPoint) {\n        const depth = cameraPoint.x;\n        if (depth <= 1e-6) return null;\n        const aspect = this.viewportWidth / this.viewportHeight;\n        const fovRadians = this.fieldOfView * (Math.PI / 180);\n        const f = 1.0 / Math.tan(fovRadians * 0.5);\n        const ndcX = (cameraPoint.y / depth) * (f / aspect);\n        const ndcY = (cameraPoint.z / depth) * f;\n        const screenX = (ndcX * 0.5 + 0.5) * this.viewportWidth;\n        const screenY = (0.5 - ndcY * 0.5) * this.viewportHeight;\n        return new Vector2(screenX, screenY);\n    }\n\n    isPointVisible(point) {\n        const cameraPoint = this.worldToCameraSpace(point);\n        return cameraPoint.x >= this.nearPlane && cameraPoint.x <= this.farPlane;\n    }\n\n    updateRenderTexture() {\n        if (!this._renderTexture || this._renderTexture.width !== this._renderTextureWidth ||\n            this._renderTexture.height !== this._renderTextureHeight) {\n            this._renderTexture = document.createElement('canvas');\n            this._renderTexture.width = this._renderTextureWidth;\n            this._renderTexture.height = this._renderTextureHeight;\n            this._renderTextureCtx = this._renderTexture.getContext('2d');\n            this.viewportWidth = this._renderTextureWidth;\n            this.viewportHeight = this._renderTextureHeight;\n            this._zBuffer = new Float32Array(this._renderTextureWidth * this._renderTextureHeight);\n            this._imageData = this._renderTextureCtx.createImageData(this._renderTextureWidth, this._renderTextureHeight);\n        }\n    }\n\n    getRenderTexture() { return this._renderTexture; }\n    getRenderTextureContext() { return this._renderTextureCtx; }\n\n    clearRenderTexture() {\n        if (!this._renderTextureCtx) return;\n        this._renderTextureCtx.imageSmoothingEnabled = this._renderTextureSmoothing;\n        this._renderTextureCtx.fillStyle = this._backgroundColor;\n        this._renderTextureCtx.fillRect(0, 0, this._renderTextureWidth, this._renderTextureHeight);\n        if (this._zBuffer) this._zBuffer.fill(Infinity);\n    }\n\n    updateViewport() {\n        this.viewportWidth = this._renderTextureWidth;\n        this.viewportHeight = this._renderTextureHeight;\n    }\n\n    calculateScreenNormal(vertices) {\n        if (vertices.length < 3) return 0;\n        const v0 = vertices[0], v1 = vertices[1], v2 = vertices[2];\n        const edge1 = { x: v1.x - v0.x, y: v1.y - v0.y };\n        const edge2 = { x: v2.x - v0.x, y: v2.y - v0.y };\n        return edge1.x * edge2.y - edge1.y * edge2.x;\n    }\n\n    drawTexturedTriangle(ctx, vertices, uvs, texture) {\n        if (!texture || vertices.length !== 3 || uvs.length !== 3) return;\n        ctx.save();\n        ctx.beginPath();\n        ctx.moveTo(vertices[0].x, vertices[0].y);\n        ctx.lineTo(vertices[1].x, vertices[1].y);\n        ctx.lineTo(vertices[2].x, vertices[2].y);\n        ctx.closePath();\n        ctx.clip();\n        const x0 = vertices[0].x, y0 = vertices[0].y;\n        const x1 = vertices[1].x, y1 = vertices[1].y;\n        const x2 = vertices[2].x, y2 = vertices[2].y;\n        const u0 = uvs[0].x * texture.width, v0 = uvs[0].y * texture.height;\n        const u1 = uvs[1].x * texture.width, v1 = uvs[1].y * texture.height;\n        const u2 = uvs[2].x * texture.width, v2 = uvs[2].y * texture.height;\n        const det = u0 * (v1 - v2) - u1 * (v0 - v2) + u2 * (v0 - v1);\n        if (Math.abs(det) > 0.0001) {\n            const a = (x0 * (v1 - v2) - x1 * (v0 - v2) + x2 * (v0 - v1)) / det;\n            const b = (x0 * (u2 - u1) - x1 * (u2 - u0) + x2 * (u1 - u0)) / det;\n            const c = (x0 * (u1 * v2 - u2 * v1) - x1 * (u0 * v2 - u2 * v0) + x2 * (u0 * v1 - u1 * v0)) / det;\n            const d = (y0 * (v1 - v2) - y1 * (v0 - v2) + y2 * (v0 - v1)) / det;\n            const e = (y0 * (u2 - u1) - y1 * (u2 - u0) + y2 * (u1 - u0)) / det;\n            const f = (y0 * (u1 * v2 - u2 * v1) - y1 * (u0 * v2 - u2 * v0) + y2 * (u0 * v1 - u1 * v0)) / det;\n            ctx.transform(a, d, b, e, c, f);\n            ctx.drawImage(texture, 0, 0);\n        }\n        ctx.restore();\n    }\n\n    renderPainter() {\n        const allObjects = this.getGameObjects();\n        const allFaces = [];\n        allObjects.forEach(obj => {\n            if (!obj.active) return;\n            const mesh = obj.getModule(\"Mesh3D\") || obj.getModule(\"CubeMesh3D\");\n            if (!mesh) return;\n            const transformedVertices = mesh.transformVertices();\n            if (!transformedVertices || !mesh.faces) return;\n            let texture = null, uvCoords = null;\n            if (mesh.texture && (mesh.texture instanceof Image || mesh.texture instanceof HTMLCanvasElement)) {\n                texture = mesh.texture;\n                uvCoords = mesh.uvCoords || mesh.generateDefaultUVs();\n            }\n            mesh.faces.forEach((face, faceIndex) => {\n                const cameraSpaceVertices = face.map(idx => \n                    idx < transformedVertices.length ? this.worldToCameraSpace(transformedVertices[idx]) : null\n                ).filter(v => v);\n                if (cameraSpaceVertices.length > 0) {\n                    const visibleVerts = cameraSpaceVertices.filter(v => v.x > this._nearPlane);\n                    const centerDepth = visibleVerts.length > 0 ?\n                        visibleVerts.reduce((sum, v) => sum + v.x, 0) / visibleVerts.length :\n                        this._farPlane + 1;\n                    allFaces.push({\n                        face, depth: centerDepth, mesh, transformedVertices,\n                        cameraSpaceVertices, texture,\n                        faceUVs: texture && uvCoords && uvCoords[faceIndex] ? uvCoords[faceIndex] : null\n                    });\n                }\n            });\n        });\n        allFaces.sort((a, b) => b.depth - a.depth);\n        const ctx = this._renderTextureCtx;\n        allFaces.forEach(({ cameraSpaceVertices, mesh, texture, faceUVs }) => {\n            const clippedVerts = this.clipPolygonAgainstNearPlane(cameraSpaceVertices, this._nearPlane);\n            if (clippedVerts.length < 3) return;\n            const screenVerts = clippedVerts.map(cv => \n                cv.x < this._farPlane ? this.projectCameraPoint(cv) : null\n            ).filter(v => v);\n            if (screenVerts.length < 3) return;\n            if (this._enableBackfaceCulling && this.calculateScreenNormal(screenVerts) < 0) return;\n            ctx.save();\n            ctx.beginPath();\n            ctx.rect(0, 0, this.viewportWidth, this.viewportHeight);\n            ctx.clip();\n            if (texture && faceUVs && faceUVs.length >= 3) {\n                for (let i = 1; i < screenVerts.length - 1; i++) {\n                    this.drawTexturedTriangle(ctx, \n                        [screenVerts[0], screenVerts[i], screenVerts[i + 1]],\n                        [faceUVs[0], faceUVs[i] || faceUVs[1], faceUVs[i + 1] || faceUVs[2]],\n                        texture);\n                }\n            } else {\n                if (mesh.renderMode === \"solid\" || mesh.renderMode === \"both\") {\n                    ctx.fillStyle = mesh.faceColor || mesh._faceColor;\n                    ctx.beginPath();\n                    ctx.moveTo(screenVerts[0].x, screenVerts[0].y);\n                    for (let i = 1; i < screenVerts.length; i++) ctx.lineTo(screenVerts[i].x, screenVerts[i].y);\n                    ctx.closePath();\n                    ctx.fill();\n                }\n            }\n            if (mesh.renderMode === \"wireframe\" || mesh.renderMode === \"both\") {\n                ctx.strokeStyle = mesh.wireframeColor || mesh._wireframeColor;\n                ctx.lineWidth = 1;\n                ctx.beginPath();\n                ctx.moveTo(screenVerts[0].x, screenVerts[0].y);\n                for (let i = 1; i < screenVerts.length; i++) ctx.lineTo(screenVerts[i].x, screenVerts[i].y);\n                ctx.closePath();\n                ctx.stroke();\n            }\n            ctx.restore();\n        });\n    }\n\n    renderZBuffer() {\n        const allObjects = this.getGameObjects();\n        const ctx = this._renderTextureCtx;\n        const imgData = this._imageData;\n        const data = imgData.data;\n        const w = this._renderTextureWidth, h = this._renderTextureHeight;\n        const bgColor = this.hexToRgb(this._backgroundColor);\n        for (let i = 0; i < data.length; i += 4) {\n            data[i] = bgColor.r; data[i + 1] = bgColor.g; data[i + 2] = bgColor.b; data[i + 3] = 255;\n        }\n        allObjects.forEach(obj => {\n            if (!obj.active) return;\n            const mesh = obj.getModule(\"Mesh3D\") || obj.getModule(\"CubeMesh3D\");\n            if (!mesh) return;\n            const transformedVertices = mesh.transformVertices();\n            if (!transformedVertices || !mesh.faces) return;\n            const faceColor = mesh.faceColor || mesh._faceColor || \"#888888\";\n            const rgb = this.hexToRgb(faceColor);\n            mesh.faces.forEach(face => {\n                const cameraVerts = face.map(idx => \n                    idx < transformedVertices.length ? this.worldToCameraSpace(transformedVertices[idx]) : null\n                ).filter(v => v);\n                const clippedVerts = this.clipPolygonAgainstNearPlane(cameraVerts, this._nearPlane);\n                if (clippedVerts.length < 3) return;\n                const screenVerts = clippedVerts.map(cv => {\n                    const proj = this.projectCameraPoint(cv);\n                    return proj ? { screen: proj, depth: cv.x } : null;\n                }).filter(v => v);\n                if (screenVerts.length < 3) return;\n                if (this._enableBackfaceCulling) {\n                    const sVerts = screenVerts.map(v => v.screen);\n                    if (this.calculateScreenNormal(sVerts) < 0) return;\n                }\n                for (let i = 1; i < screenVerts.length - 1; i++) {\n                    this.rasterizeTriangle(screenVerts[0], screenVerts[i], screenVerts[i + 1], rgb, data, w, h);\n                }\n            });\n        });\n        ctx.putImageData(imgData, 0, 0);\n    }\n\n    rasterizeTriangle(v0, v1, v2, color, data, w, h) {\n        const p0 = { x: Math.round(v0.screen.x), y: Math.round(v0.screen.y), z: v0.depth };\n        const p1 = { x: Math.round(v1.screen.x), y: Math.round(v1.screen.y), z: v1.depth };\n        const p2 = { x: Math.round(v2.screen.x), y: Math.round(v2.screen.y), z: v2.depth };\n        const minX = Math.max(0, Math.min(p0.x, p1.x, p2.x));\n        const maxX = Math.min(w - 1, Math.max(p0.x, p1.x, p2.x));\n        const minY = Math.max(0, Math.min(p0.y, p1.y, p2.y));\n        const maxY = Math.min(h - 1, Math.max(p0.y, p1.y, p2.y));\n        for (let y = minY; y <= maxY; y++) {\n            for (let x = minX; x <= maxX; x++) {\n                const bary = this.barycentric(p0, p1, p2, x, y);\n                if (bary.u >= 0 && bary.v >= 0 && bary.w >= 0) {\n                    const depth = bary.u * p0.z + bary.v * p1.z + bary.w * p2.z;\n                    const idx = y * w + x;\n                    if (depth < this._zBuffer[idx]) {\n                        this._zBuffer[idx] = depth;\n                        const pixelIdx = idx * 4;\n                        data[pixelIdx] = color.r; data[pixelIdx + 1] = color.g;\n                        data[pixelIdx + 2] = color.b; data[pixelIdx + 3] = 255;\n                    }\n                }\n            }\n        }\n    }\n\n    barycentric(p0, p1, p2, x, y) {\n        const denom = (p1.y - p2.y) * (p0.x - p2.x) + (p2.x - p1.x) * (p0.y - p2.y);\n        if (Math.abs(denom) < 0.001) return { u: -1, v: -1, w: -1 };\n        const u = ((p1.y - p2.y) * (x - p2.x) + (p2.x - p1.x) * (y - p2.y)) / denom;\n        const v = ((p2.y - p0.y) * (x - p2.x) + (p0.x - p2.x) * (y - p2.y)) / denom;\n        return { u, v, w: 1 - u - v };\n    }\n\n    hexToRgb(hex) {\n        const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n        return result ? {\n            r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16)\n        } : { r: 0, g: 0, b: 0 };\n    }\n\n    calculateTriangleColor(material, faceUVs, vertexIndices) {\n        if (!material) {\n            // No material, use default color\n            return this.hexToRgb(\"#888888\");\n        }\n\n        // If we have UV coordinates, sample texture at triangle center\n        if (faceUVs && faceUVs.length >= 3 && vertexIndices.length >= 3) {\n            // Calculate centroid UV coordinates\n            const u = (faceUVs[vertexIndices[0]].x + faceUVs[vertexIndices[1]].x + faceUVs[vertexIndices[2]].x) / 3;\n            const v = (faceUVs[vertexIndices[0]].y + faceUVs[vertexIndices[1]].y + faceUVs[vertexIndices[2]].y) / 3;\n\n            // Use material's texture sampling\n            if (typeof material.sampleTexture === 'function') {\n                const colorStr = material.sampleTexture(u, v);\n                return this.parseColorString(colorStr);\n            }\n        }\n\n        // No texture or no UVs, return diffuse color\n        const diffuseColor = material.diffuseColor || \"#FFFFFF\";\n        return this.hexToRgb(diffuseColor);\n    }\n\n    parseColorString(colorStr) {\n        // Parse rgba(r, g, b, a) format\n        const match = colorStr.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*([\\d.]+))?\\)/);\n        if (match) {\n            return {\n                r: parseInt(match[1]),\n                g: parseInt(match[2]),\n                b: parseInt(match[3]),\n                a: Math.floor((match[4] !== undefined ? parseFloat(match[4]) : 1.0) * 255)\n            };\n        }\n        return this.hexToRgb(\"#FFFFFF\");\n    }\n\n    renderScanline() {\n        const allObjects = this.getGameObjects();\n        const ctx = this._renderTextureCtx;\n        const w = this._renderTextureWidth, h = this._renderTextureHeight;\n        const scanlines = Array.from({ length: h }, () => []);\n        allObjects.forEach(obj => {\n            if (!obj.active) return;\n            const mesh = obj.getModule(\"Mesh3D\") || obj.getModule(\"CubeMesh3D\");\n            if (!mesh) return;\n            const transformedVertices = mesh.transformVertices();\n            if (!transformedVertices || !mesh.faces) return;\n            const faceColor = mesh.faceColor || mesh._faceColor || \"#888888\";\n            mesh.faces.forEach(face => {\n                const cameraVerts = face.map(idx => \n                    idx < transformedVertices.length ? this.worldToCameraSpace(transformedVertices[idx]) : null\n                ).filter(v => v);\n                const clippedVerts = this.clipPolygonAgainstNearPlane(cameraVerts, this._nearPlane);\n                if (clippedVerts.length < 3) return;\n                const screenVerts = clippedVerts.map(cv => {\n                    const proj = this.projectCameraPoint(cv);\n                    return proj ? { screen: proj, depth: cv.x } : null;\n                }).filter(v => v);\n                if (screenVerts.length < 3) return;\n                for (let i = 1; i < screenVerts.length - 1; i++) {\n                    const tri = [screenVerts[0], screenVerts[i], screenVerts[i + 1]];\n                    this.addTriangleToScanlines(tri, faceColor, scanlines, w, h);\n                }\n            });\n        });\n        for (let y = 0; y < h; y++) {\n            const edges = scanlines[y];\n            if (edges.length === 0) continue;\n            edges.sort((a, b) => a.x - b.x);\n            for (let i = 0; i < edges.length - 1; i += 2) {\n                const x1 = Math.max(0, Math.ceil(edges[i].x));\n                const x2 = Math.min(w - 1, Math.floor(edges[i + 1].x));\n                const z1 = edges[i].z, z2 = edges[i + 1].z;\n                ctx.fillStyle = edges[i].color;\n                for (let x = x1; x <= x2; x++) {\n                    const t = (x2 - x1) > 0 ? (x - x1) / (x2 - x1) : 0;\n                    const z = z1 + t * (z2 - z1);\n                    const idx = y * w + x;\n                    if (z < this._zBuffer[idx]) {\n                        this._zBuffer[idx] = z;\n                        ctx.fillRect(x, y, 1, 1);\n                    }\n                }\n            }\n        }\n    }\n\n    addTriangleToScanlines(tri, color, scanlines, w, h) {\n        for (let i = 0; i < 3; i++) {\n            const v0 = tri[i], v1 = tri[(i + 1) % 3];\n            let y0 = Math.round(v0.screen.y), y1 = Math.round(v1.screen.y);\n            let x0 = v0.screen.x, x1 = v1.screen.x, z0 = v0.depth, z1 = v1.depth;\n            if (y0 > y1) {\n                [y0, y1] = [y1, y0]; [x0, x1] = [x1, x0]; [z0, z1] = [z1, z0];\n            }\n            if (y0 === y1) continue;\n            for (let y = Math.max(0, y0); y <= Math.min(h - 1, y1); y++) {\n                const t = (y - y0) / (y1 - y0);\n                scanlines[y].push({ x: x0 + t * (x1 - x0), z: z0 + t * (z1 - z0), color });\n            }\n        }\n    }\n\n    renderRaytrace() {\n        const allObjects = this.getGameObjects();\n        const ctx = this._renderTextureCtx;\n        const imgData = this._imageData;\n        const data = imgData.data;\n        const w = this._renderTextureWidth, h = this._renderTextureHeight;\n        const bgColor = this.hexToRgb(this._backgroundColor);\n        const aspect = w / h;\n        const fovRadians = this.fieldOfView * (Math.PI / 180);\n        const tanHalfFov = Math.tan(fovRadians * 0.5);\n        const allTriangles = [];\n        allObjects.forEach(obj => {\n            if (!obj.active) return;\n            const mesh = obj.getModule(\"Mesh3D\") || obj.getModule(\"CubeMesh3D\");\n            if (!mesh) return;\n            const material = obj.getModule(\"Material\");\n            const transformedVertices = mesh.transformVertices();\n            if (!transformedVertices || !mesh.faces) return;\n\n            // Get UV coordinates for texture mapping\n            const uvCoords = mesh.uvCoords || mesh.generateDefaultUVs();\n\n            mesh.faces.forEach((face, faceIndex) => {\n                const cameraVerts = face.map(idx =>\n                    idx < transformedVertices.length ? this.worldToCameraSpace(transformedVertices[idx]) : null\n                ).filter(v => v);\n                if (cameraVerts.length < 3) return;\n\n                // Get UV coordinates for this face\n                const faceUVs = uvCoords && uvCoords[faceIndex] ? uvCoords[faceIndex] : null;\n\n                for (let i = 1; i < cameraVerts.length - 1; i++) {\n                    // Calculate average color for this triangle using material system\n                    const color = this.calculateTriangleColor(material, faceUVs, [0, i, i + 1]);\n\n                    allTriangles.push({\n                        v0: cameraVerts[0], v1: cameraVerts[i], v2: cameraVerts[i + 1],\n                        color: color\n                    });\n                }\n            });\n        });\n        for (let y = 0; y < h; y++) {\n            for (let x = 0; x < w; x++) {\n                const pixelIdx = (y * w + x) * 4;\n                const u = (x / w) * 2 - 1;\n                const v = 1 - (y / h) * 2;\n                const rayDirX = 1;\n                const rayDirY = u * tanHalfFov * aspect;\n                const rayDirZ = v * tanHalfFov;\n                const rayLen = Math.sqrt(rayDirX * rayDirX + rayDirY * rayDirY + rayDirZ * rayDirZ);\n                const rayDir = { x: rayDirX / rayLen, y: rayDirY / rayLen, z: rayDirZ / rayLen };\n                const rayOrigin = { x: 0, y: 0, z: 0 };\n                let closestT = Infinity;\n                let hitColor = null;\n                allTriangles.forEach(tri => {\n                    const t = this.rayTriangleIntersect(rayOrigin, rayDir, tri.v0, tri.v1, tri.v2);\n                    if (t !== null && t < closestT && t >= this._nearPlane && t <= this._farPlane) {\n                        closestT = t;\n                        hitColor = tri.color;\n                    }\n                });\n                if (hitColor) {\n                    data[pixelIdx] = hitColor.r;\n                    data[pixelIdx + 1] = hitColor.g;\n                    data[pixelIdx + 2] = hitColor.b;\n                    data[pixelIdx + 3] = 255;\n                } else {\n                    data[pixelIdx] = bgColor.r;\n                    data[pixelIdx + 1] = bgColor.g;\n                    data[pixelIdx + 2] = bgColor.b;\n                    data[pixelIdx + 3] = 255;\n                }\n            }\n        }\n        ctx.putImageData(imgData, 0, 0);\n    }\n\n    rayTriangleIntersect(origin, dir, v0, v1, v2) {\n        const edge1 = { x: v1.x - v0.x, y: v1.y - v0.y, z: v1.z - v0.z };\n        const edge2 = { x: v2.x - v0.x, y: v2.y - v0.y, z: v2.z - v0.z };\n        const h = {\n            x: dir.y * edge2.z - dir.z * edge2.y,\n            y: dir.z * edge2.x - dir.x * edge2.z,\n            z: dir.x * edge2.y - dir.y * edge2.x\n        };\n        const a = edge1.x * h.x + edge1.y * h.y + edge1.z * h.z;\n        if (Math.abs(a) < 0.0001) return null;\n        const f = 1 / a;\n        const s = { x: origin.x - v0.x, y: origin.y - v0.y, z: origin.z - v0.z };\n        const u = f * (s.x * h.x + s.y * h.y + s.z * h.z);\n        if (u < 0 || u > 1) return null;\n        const q = {\n            x: s.y * edge1.z - s.z * edge1.y,\n            y: s.z * edge1.x - s.x * edge1.z,\n            z: s.x * edge1.y - s.y * edge1.x\n        };\n        const v = f * (dir.x * q.x + dir.y * q.y + dir.z * q.z);\n        if (v < 0 || u + v > 1) return null;\n        const t = f * (edge2.x * q.x + edge2.y * q.y + edge2.z * q.z);\n        return t > 0.0001 ? t : null;\n    }\n\n    render3D() {\n        if (!this._renderTextureCtx || !this._isActive) return;\n        this.clearRenderTexture();\n        switch (this._renderingMethod) {\n            case \"painter\": this.renderPainter(); break;\n            case \"zbuffer\": this.renderZBuffer(); break;\n            case \"scanline\": this.renderScanline(); break;\n            case \"raytrace\": this.renderRaytrace(); break;\n            default: this.renderPainter();\n        }\n    }\n\n    getRenderedTexture() {\n        if (!this._isActive) return null;\n        this.render3D();\n        return this._renderTexture;\n    }\n\n    drawRenderedTexture(ctx, x = 0, y = 0, width = null, height = null) {\n        if (!this._renderTexture || !this._isActive) return;\n        ctx.imageSmoothingEnabled = this._renderTextureSmoothing;\n        const drawWidth = width || this._renderTextureWidth;\n        const drawHeight = height || this._renderTextureHeight;\n        ctx.drawImage(this._renderTexture, x, y, drawWidth, drawHeight);\n    }\n\n    start() {\n        this.updateViewport();\n        this.updateRenderTexture();\n        const cameras = this.getGameObjects()\n            .map(obj => obj.getModule(\"Camera3D\"))\n            .filter(cam => cam !== null);\n        if (cameras.length === 1 && cameras[0] === this) this._isActive = true;\n    }\n\n    beginLoop() { this.updateViewport(); }\n    draw(ctx) {}\n    drawGizmos(ctx) {} // Implement if needed\n\n    toJSON() {\n        return {\n            _type: \"Camera3D\", _position: { x: this._position.x, y: this._position.y, z: this._position.z },\n            _rotation: { x: this._rotation.x, y: this._rotation.y, z: this._rotation.z },\n            _fieldOfView: this._fieldOfView, _nearPlane: this._nearPlane, _farPlane: this._farPlane,\n            _isActive: this._isActive, _backgroundColor: this._backgroundColor,\n            _renderTextureWidth: this._renderTextureWidth, _renderTextureHeight: this._renderTextureHeight,\n            _renderTextureSmoothing: this._renderTextureSmoothing, drawGizmoInRuntime: this.drawGizmoInRuntime,\n            _renderingMethod: this._renderingMethod, _enableBackfaceCulling: this._enableBackfaceCulling\n        };\n    }\n\n    fromJSON(json) {\n        if (json._position) this._position = new Vector3(json._position.x, json._position.y, json._position.z);\n        if (json._rotation) this._rotation = new Vector3(json._rotation.x, json._rotation.y, json._rotation.z);\n        if (json._fieldOfView !== undefined) this._fieldOfView = json._fieldOfView;\n        if (json._nearPlane !== undefined) this._nearPlane = json._nearPlane;\n        if (json._farPlane !== undefined) this._farPlane = json._farPlane;\n        if (json._isActive !== undefined) this._isActive = json._isActive;\n        if (json._backgroundColor !== undefined) this._backgroundColor = json._backgroundColor;\n        if (json._renderTextureWidth !== undefined) this._renderTextureWidth = json._renderTextureWidth;\n        if (json._renderTextureHeight !== undefined) this._renderTextureHeight = json._renderTextureHeight;\n        if (json._renderTextureSmoothing !== undefined) this._renderTextureSmoothing = json._renderTextureSmoothing;\n        if (json.drawGizmoInRuntime !== undefined) this.drawGizmoInRuntime = json.drawGizmoInRuntime;\n        if (json._renderingMethod !== undefined) this._renderingMethod = json._renderingMethod;\n        if (json._enableBackfaceCulling !== undefined) this._enableBackfaceCulling = json._enableBackfaceCulling;\n        this.updateRenderTexture();\n    }\n\n    get renderTextureWidth() { return this._renderTextureWidth; }\n    set renderTextureWidth(value) { this._renderTextureWidth = Math.max(64, Math.min(2048, value)); this.updateRenderTexture(); }\n    get renderTextureHeight() { return this._renderTextureHeight; }\n    set renderTextureHeight(value) { this._renderTextureHeight = Math.max(64, Math.min(2048, value)); this.updateRenderTexture(); }\n    get renderTextureSmoothing() { return this._renderTextureSmoothing; }\n    set renderTextureSmoothing(value) { this._renderTextureSmoothing = value; }\n    get backgroundColor() { return this._backgroundColor; }\n    set backgroundColor(value) { this._backgroundColor = value; }\n    get position() { return this._position; }\n    set position(value) { this._position = value; }\n    get rotation() { return this._rotation; }\n    set rotation(value) { this._rotation = value; }\n    get fieldOfView() { return this._fieldOfView; }\n    set fieldOfView(value) { this._fieldOfView = Math.max(1, Math.min(179, value)); }\n    get nearPlane() { return this._nearPlane; }\n    set nearPlane(value) { this._nearPlane = Math.max(0.01, value); }\n    get farPlane() { return this._farPlane; }\n    set farPlane(value) { this._farPlane = Math.max(1, value); }\n    get isActive() { return this._isActive; }\n    set isActive(value) { this._isActive = value; }\n}\n\nwindow.Camera3DBasic = Camera3DBasic;",
      "type": "file",
      "name": "Camera3DBasic.js",
      "parentPath": "/",
      "created": 1759457134199,
      "modified": 1759457134199
    },
    {
      "path": "/CubeMesh3D.js",
      "content": "/**\r\n * CubeMesh3D - A specialized 3D mesh module for cubes with customizable properties\r\n * \r\n * This module creates and renders a 3D cube mesh with configurable dimensions,\r\n * colors, and rendering options.\r\n */\r\nclass CubeMesh3D extends Module {\r\n    static namespace = \"3D\";\r\n\r\n    /**\r\n     * Create a new CubeMesh3D\r\n     */\r\n    constructor() {\r\n        super(\"CubeMesh3D\");\r\n\r\n        // Cube properties\r\n        this._size = 100;\r\n        this._position = new Vector3(0, 0, 0);\r\n        this._rotation = new Vector3(0, 0, 0);\r\n        this._scale = new Vector3(1, 1, 1);\r\n\r\n        // Appearance\r\n        this._wireframeColor = \"#FFFFFF\";\r\n        this._faceColor = \"#3F51B5\";\r\n        this._renderMode = \"wireframe\"; // \"wireframe\", \"solid\", or \"both\"\r\n\r\n        // Axis visualization\r\n        this._showAxisLines = false;\r\n        this._axisLength = 150;\r\n\r\n        this._subdivisions = 1; // Number of subdivisions per face\r\n\r\n        // Mesh data\r\n        this.vertices = [];\r\n        this.edges = [];\r\n        this.faces = [];\r\n\r\n        // Material system\r\n        this.material = null; // Material instance for advanced texturing\r\n\r\n        // UV coordinates for texture mapping\r\n        this.uvCoordinates = [];\r\n\r\n        // Expose properties to the inspector\r\n        this.exposeProperty(\"size\", \"number\", 100, {\r\n            min: 1,\r\n            max: 500,\r\n            onChange: (val) => {\r\n                this._size = val;\r\n                this.updateCube();\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"position\", \"vector3\", this._position, {\r\n            onChange: (val) => this._position = val\r\n        });\r\n\r\n        this.exposeProperty(\"rotation\", \"vector3\", this._rotation, {\r\n            onChange: (val) => this._rotation = val\r\n        });\r\n\r\n        this.exposeProperty(\"scale\", \"vector3\", this._scale, {\r\n            onChange: (val) => this._scale = val\r\n        });\r\n\r\n        this.exposeProperty(\"subdivisions\", \"number\", 1, {\r\n            min: 1,\r\n            max: 10,\r\n            step: 1,\r\n            onChange: (val) => {\r\n                this._subdivisions = Math.floor(val);\r\n                this.updateCube();\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"wireframeColor\", \"color\", \"#FFFFFF\", {\r\n            onChange: (val) => this._wireframeColor = val\r\n        });\r\n        this.exposeProperty(\"faceColor\", \"color\", \"#3F51B5\", {\r\n            onChange: (val) => this._faceColor = val\r\n        });\r\n        this.exposeProperty(\"renderMode\", \"enum\", \"wireframe\", {\r\n            options: [\"wireframe\", \"solid\", \"both\"],\r\n            onChange: (val) => this._renderMode = val\r\n        });\r\n\r\n        this.exposeProperty(\"showAxisLines\", \"boolean\", false, {\r\n            onChange: (val) => this._showAxisLines = val\r\n        });\r\n\r\n        this.exposeProperty(\"axisLength\", \"number\", 150, {\r\n            min: 50,\r\n            max: 500,\r\n            onChange: (val) => this._axisLength = val\r\n        });\r\n\r\n        this.exposeProperty(\"material\", \"module\", null, {\r\n            moduleType: \"Material\",\r\n            onChange: (val) => this.material = val\r\n        });\r\n\r\n        // Initialize cube geometry\r\n        this.updateCube();\r\n\r\n        // Ensure material module exists on the game object\r\n        this.ensureMaterialModule();\r\n    }\r\n\r\n    start() {\r\n        // Ensure material module exists on start\r\n        this.ensureMaterialModule();\r\n    }\r\n\r\n    /**\r\n     * Ensure the game object has a Material module\r\n     */\r\n    ensureMaterialModule() {\r\n        if (!this.gameObject) return;\r\n\r\n        // Check if material module already exists\r\n        let materialModule = this.gameObject.getModule ? this.gameObject.getModule('Material') : null;\r\n        if (!materialModule) {\r\n            // Create and add a new material module\r\n            materialModule = new Material();\r\n            if (this.gameObject.addModule) {\r\n                this.gameObject.addModule(materialModule);\r\n            }\r\n        }\r\n\r\n        // Set the material reference\r\n        this.material = materialModule;\r\n    }\r\n\r\n    /**\r\n     * Generate UV coordinates for texture mapping\r\n     */\r\n    generateUVCoordinates() {\r\n        this.uvCoordinates = [];\r\n\r\n        for (let i = 0; i < this.vertices.length; i++) {\r\n            const vertex = this.vertices[i];\r\n\r\n            // Simple planar projection for UV mapping\r\n            let u, v;\r\n\r\n            if (Math.abs(vertex.x) > Math.abs(vertex.y) && Math.abs(vertex.x) > Math.abs(vertex.z)) {\r\n                // X-dominant face\r\n                u = (vertex.y + 1) / 2;\r\n                v = (vertex.z + 1) / 2;\r\n            } else if (Math.abs(vertex.y) > Math.abs(vertex.x) && Math.abs(vertex.y) > Math.abs(vertex.z)) {\r\n                // Y-dominant face\r\n                u = (vertex.x + 1) / 2;\r\n                v = (vertex.z + 1) / 2;\r\n            } else {\r\n                // Z-dominant face\r\n                u = (vertex.x + 1) / 2;\r\n                v = (vertex.y + 1) / 2;\r\n            }\r\n\r\n            this.uvCoordinates.push(new Vector2(u, v));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get material color for a face, considering texture if available\r\n     */\r\n    getMaterialColor(faceIndex) {\r\n        if (!this.material) {\r\n            return this._faceColor;\r\n        }\r\n\r\n        // For now, use the diffuse color\r\n        // In a full implementation, this would sample the texture based on face UVs\r\n        return this.material.diffuseColor;\r\n    }\r\n\r\n    /**\r\n       * Update the cube geometry based on current size\r\n       */\r\n     updateCube() {\r\n         const s = this.size / 2;\r\n         const divs = this._subdivisions;\r\n\r\n         this.vertices = [];\r\n         this.edges = [];\r\n         this.faces = [];\r\n\r\n         // Generate all vertices first (shared vertices for proper mesh connectivity)\r\n         const vertexMap = new Map();\r\n\r\n         // Helper function to get or create vertex index\r\n         const getVertexIndex = (x, y, z) => {\r\n             const key = `${x.toFixed(6)},${y.toFixed(6)},${z.toFixed(6)}`;\r\n             if (vertexMap.has(key)) {\r\n                 return vertexMap.get(key);\r\n             }\r\n             const index = this.vertices.length;\r\n             this.vertices.push(new Vector3(x, y, z));\r\n             vertexMap.set(key, index);\r\n             return index;\r\n         };\r\n\r\n         // Generate vertices for all 6 faces\r\n         // Bottom face (Z = -s)\r\n         for (let i = 0; i <= divs; i++) {\r\n             for (let j = 0; j <= divs; j++) {\r\n                 const x = -s + (2 * s * j) / divs;\r\n                 const y = -s + (2 * s * i) / divs;\r\n                 getVertexIndex(x, y, -s);\r\n             }\r\n         }\r\n\r\n         // Top face (Z = s)\r\n         for (let i = 0; i <= divs; i++) {\r\n             for (let j = 0; j <= divs; j++) {\r\n                 const x = -s + (2 * s * j) / divs;\r\n                 const y = s - (2 * s * i) / divs; // Flip Y for correct winding\r\n                 getVertexIndex(x, y, s);\r\n             }\r\n         }\r\n\r\n         // Front face (Y = s)\r\n         for (let i = 0; i <= divs; i++) {\r\n             for (let j = 0; j <= divs; j++) {\r\n                 const x = -s + (2 * s * j) / divs;\r\n                 const z = -s + (2 * s * i) / divs;\r\n                 getVertexIndex(x, s, z);\r\n             }\r\n         }\r\n\r\n         // Back face (Y = -s)\r\n         for (let i = 0; i <= divs; i++) {\r\n             for (let j = 0; j <= divs; j++) {\r\n                 const x = -s + (2 * s * j) / divs;\r\n                 const z = s - (2 * s * i) / divs; // Flip Z for correct winding\r\n                 getVertexIndex(x, -s, z);\r\n             }\r\n         }\r\n\r\n         // Right face (X = s)\r\n         for (let i = 0; i <= divs; i++) {\r\n             for (let j = 0; j <= divs; j++) {\r\n                 const y = -s + (2 * s * j) / divs;\r\n                 const z = s - (2 * s * i) / divs; // Flip Z for correct winding\r\n                 getVertexIndex(s, y, z);\r\n             }\r\n         }\r\n\r\n         // Left face (X = -s)\r\n         for (let i = 0; i <= divs; i++) {\r\n             for (let j = 0; j <= divs; j++) {\r\n                 const y = -s + (2 * s * j) / divs;\r\n                 const z = -s + (2 * s * i) / divs;\r\n                 getVertexIndex(-s, y, z);\r\n             }\r\n         }\r\n\r\n         // Create faces using shared vertices\r\n         // Bottom face (Z = -s)\r\n         this.createSubdividedFace(-s, 'z', divs, (i, j) => {\r\n             const x = -s + (2 * s * j) / divs;\r\n             const y = -s + (2 * s * i) / divs;\r\n             return getVertexIndex(x, y, -s);\r\n         });\r\n\r\n         // Top face (Z = s)\r\n         this.createSubdividedFace(s, 'z', divs, (i, j) => {\r\n             const x = -s + (2 * s * j) / divs;\r\n             const y = s - (2 * s * i) / divs; // Flip Y for correct winding\r\n             return getVertexIndex(x, y, s);\r\n         });\r\n\r\n         // Front face (Y = s)\r\n         this.createSubdividedFace(s, 'y', divs, (i, j) => {\r\n             const x = -s + (2 * s * j) / divs;\r\n             const z = -s + (2 * s * i) / divs;\r\n             return getVertexIndex(x, s, z);\r\n         });\r\n\r\n         // Back face (Y = -s)\r\n         this.createSubdividedFace(-s, 'y', divs, (i, j) => {\r\n             const x = -s + (2 * s * j) / divs;\r\n             const z = s - (2 * s * i) / divs; // Flip Z for correct winding\r\n             return getVertexIndex(x, -s, z);\r\n         });\r\n\r\n         // Right face (X = s)\r\n         this.createSubdividedFace(s, 'x', divs, (i, j) => {\r\n             const y = -s + (2 * s * j) / divs;\r\n             const z = s - (2 * s * i) / divs; // Flip Z for correct winding\r\n             return getVertexIndex(s, y, z);\r\n         });\r\n\r\n         // Left face (X = -s)\r\n         this.createSubdividedFace(-s, 'x', divs, (i, j) => {\r\n             const y = -s + (2 * s * j) / divs;\r\n             const z = -s + (2 * s * i) / divs;\r\n             return getVertexIndex(-s, y, z);\r\n         });\r\n\r\n         // Generate edges from faces (unique edges only)\r\n         const edgeSet = new Set();\r\n         for (const face of this.faces) {\r\n             for (let i = 0; i < face.length; i++) {\r\n                 const v1 = face[i];\r\n                 const v2 = face[(i + 1) % face.length];\r\n                 const edgeKey = v1 < v2 ? `${v1},${v2}` : `${v2},${v1}`;\r\n                 edgeSet.add(edgeKey);\r\n             }\r\n         }\r\n\r\n         this.edges = Array.from(edgeSet).map(key => key.split(',').map(Number));\r\n     }\r\n\r\n     /**\r\n      * Create a subdivided face using shared vertices\r\n      * @param {number} fixedCoord - The fixed coordinate value (e.g., Z = -s for bottom face)\r\n      * @param {string} axis - The axis being fixed ('x', 'y', or 'z')\r\n      * @param {number} divs - Number of subdivisions\r\n      * @param {function} getVertexIndex - Function to get vertex index for i,j coordinates\r\n      */\r\n     createSubdividedFace(fixedCoord, axis, divs, getVertexIndex) {\r\n         // Create triangular faces from grid (2 triangles per quad) - Counter-clockwise winding for outward-facing normals\r\n         for (let i = 0; i < divs; i++) {\r\n             for (let j = 0; j < divs; j++) {\r\n                 const v1 = getVertexIndex(i, j);\r\n                 const v2 = getVertexIndex(i + 1, j);\r\n                 const v3 = getVertexIndex(i + 1, j + 1);\r\n                 const v4 = getVertexIndex(i, j + 1);\r\n\r\n                 // First triangle - Counter-clockwise winding (v1 -> v2 -> v3)\r\n                 this.faces.push([v1, v2, v3]);\r\n                 // Second triangle - Counter-clockwise winding (v1 -> v3 -> v4)\r\n                 this.faces.push([v1, v3, v4]);\r\n             }\r\n         }\r\n     }\r\n\r\n    /**\r\n     * Update transform values when properties change\r\n     */\r\n    updateTransform() {\r\n        // This method can be used to perform additional actions when transform changes\r\n        // For now, it's just a placeholder for future enhancements\r\n    }\r\n\r\n    /**\r\n     * Draw the cube to the canvas\r\n     * @param {CanvasRenderingContext2D} ctx - The canvas context to draw on\r\n     */\r\n    draw(ctx) {\r\n        try {\r\n            // Find an active camera\r\n            const camera = this.findActiveCamera();\r\n            //if (!camera) {\r\n            // Draw a placeholder if no camera is available\r\n            this.drawPlaceholder(ctx);\r\n            //return;\r\n            // }\r\n\r\n            // Use render texture method if camera supports it\r\n            //if (camera.getRenderTextureContext && camera.render3D) {\r\n                //this.drawToRenderTexture(camera.getRenderTextureContext(), camera);\r\n            //} else {\r\n                // Fallback to direct drawing\r\n                //this.drawDirect(ctx, camera);\r\n            //}\r\n        } catch (e) {\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draw directly to a canvas context (fallback method)\r\n     * @param {CanvasRenderingContext2D} ctx - The canvas context to draw on\r\n     * @param {Camera3D} camera - The camera to use for projection\r\n     */\r\n    drawDirect(ctx, camera) {\r\n        // Transform vertices based on mesh position/rotation/scale and game object transform\r\n        const transformedVertices = this.transformVertices();\r\n\r\n        // Project the 3D vertices to 2D screen space\r\n        const projectedVertices = transformedVertices.map(vertex =>\r\n            camera.projectPoint(vertex)\r\n        );\r\n\r\n        // Sort faces by depth for basic depth sorting (painter's algorithm)\r\n        const sortedFaces = [...this.faces]\r\n            .map((face, index) => {\r\n                // Calculate maximum depth for accurate sorting of subdivided faces\r\n                let maxDepth = -Infinity;\r\n                let centroidY = 0, centroidZ = 0;\r\n\r\n                for (const vertexIndex of face) {\r\n                    if (vertexIndex < transformedVertices.length) {\r\n                        const vertex = transformedVertices[vertexIndex];\r\n                        maxDepth = Math.max(maxDepth, vertex.x); // Use X as depth (camera looks along +X)\r\n                        centroidY += vertex.y;\r\n                        centroidZ += vertex.z;\r\n                    }\r\n                }\r\n\r\n                centroidY /= face.length;\r\n                centroidZ /= face.length;\r\n\r\n                // Use maximum depth as primary sorting criteria for subdivided faces\r\n                // Add small offset based on face center to handle coplanar faces\r\n                const sortDepth = maxDepth + (centroidY + centroidZ) * 0.001;\r\n\r\n                return { face, sortDepth };\r\n            })\r\n            .sort((a, b) => b.sortDepth - a.sortDepth) // Sort back-to-front (lower depth values first = closer to camera)\r\n            .map(item => item.face);\r\n\r\n        // Draw faces in sorted order\r\n        if (this.renderMode === \"solid\" || this.renderMode === \"both\") {\r\n            for (const face of sortedFaces) {\r\n                // Use material color if available, otherwise fall back to faceColor\r\n                const faceColor = this.material ? this.getMaterialColor(face) : this._faceColor;\r\n                ctx.fillStyle = faceColor;\r\n                if (face.length < 3) continue; // Need at least 3 points to draw a face\r\n\r\n                // Check if all vertices are visible\r\n                const isVisible = face.every(vertexIndex =>\r\n                    projectedVertices[vertexIndex] !== null &&\r\n                    vertexIndex < projectedVertices.length\r\n                );\r\n                if (!isVisible) continue;\r\n\r\n                const faceVertices = face.map(idx => projectedVertices[idx]).filter(v => v !== null);\r\n                if (faceVertices.length < 3) continue;\r\n\r\n                // Triangulate faces with more than 3 vertices for proper rendering\r\n                if (faceVertices.length === 3) {\r\n                    // Triangle face - draw directly\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(faceVertices[0].x, faceVertices[0].y);\r\n                    ctx.lineTo(faceVertices[1].x, faceVertices[1].y);\r\n                    ctx.lineTo(faceVertices[2].x, faceVertices[2].y);\r\n                    ctx.closePath();\r\n                    ctx.fill();\r\n                } else if (faceVertices.length === 4) {\r\n                    // Quad face - triangulate into two triangles\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(faceVertices[0].x, faceVertices[0].y);\r\n                    ctx.lineTo(faceVertices[1].x, faceVertices[1].y);\r\n                    ctx.lineTo(faceVertices[2].x, faceVertices[2].y);\r\n                    ctx.closePath();\r\n                    ctx.fill();\r\n\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(faceVertices[0].x, faceVertices[0].y);\r\n                    ctx.lineTo(faceVertices[2].x, faceVertices[2].y);\r\n                    ctx.lineTo(faceVertices[3].x, faceVertices[3].y);\r\n                    ctx.closePath();\r\n                    ctx.fill();\r\n                } else {\r\n                    // Polygon with more vertices - triangulate using fan method\r\n                    for (let i = 1; i < faceVertices.length - 1; i++) {\r\n                        ctx.beginPath();\r\n                        ctx.moveTo(faceVertices[0].x, faceVertices[0].y);\r\n                        ctx.lineTo(faceVertices[i].x, faceVertices[i].y);\r\n                        ctx.lineTo(faceVertices[i + 1].x, faceVertices[i + 1].y);\r\n                        ctx.closePath();\r\n                        ctx.fill();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Draw edges\r\n        if (this.renderMode === \"wireframe\" || this.renderMode === \"both\") {\r\n            ctx.strokeStyle = this.wireframeColor;\r\n            ctx.lineWidth = 1;\r\n\r\n            for (const [from, to] of this.edges) {\r\n                // Check if both vertices are valid and visible\r\n                if (from >= projectedVertices.length ||\r\n                    to >= projectedVertices.length ||\r\n                    projectedVertices[from] === null ||\r\n                    projectedVertices[to] === null) {\r\n                    continue;\r\n                }\r\n\r\n                ctx.beginPath();\r\n                ctx.moveTo(projectedVertices[from].x, projectedVertices[from].y);\r\n                ctx.lineTo(projectedVertices[to].x, projectedVertices[to].y);\r\n                ctx.stroke();\r\n            }\r\n        }\r\n\r\n        // Draw axis lines if enabled\r\n        if (this.showAxisLines && projectedVertices.length > 0) {\r\n            // Use the center of the cube as origin (average of all vertices)\r\n            let centerX = 0, centerY = 0;\r\n            let validVertices = 0;\r\n\r\n            for (const vertex of projectedVertices) {\r\n                if (vertex !== null) {\r\n                    centerX += vertex.x;\r\n                    centerY += vertex.y;\r\n                    validVertices++;\r\n                }\r\n            }\r\n\r\n            if (validVertices > 0) {\r\n                centerX /= validVertices;\r\n                centerY /= validVertices;\r\n                this.drawAxisLines(ctx, new Vector2(centerX, centerY));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draw the cube to a render texture\r\n     * @param {CanvasRenderingContext2D} ctx - The render texture context\r\n     * @param {Camera3D} camera - The camera to use for projection\r\n     */\r\n    drawToRenderTexture(ctx, camera) {\r\n        // Transform vertices based on mesh position/rotation/scale and game object transform\r\n        const transformedVertices = this.transformVertices();\r\n\r\n        // Project the 3D vertices to 2D screen space\r\n        const projectedVertices = transformedVertices.map(vertex =>\r\n            camera.projectPoint(vertex)\r\n        );\r\n\r\n        // Filter out invalid projected vertices\r\n        const validProjectedVertices = projectedVertices.map((vertex, index) => {\r\n            if (vertex === null) {\r\n                // Return a point outside the viewport for invalid vertices\r\n                return new Vector2(-1000, -1000);\r\n            }\r\n            return vertex;\r\n        });\r\n\r\n        // Sort faces by depth for basic depth sorting (painter's algorithm)\r\n        const sortedFaces = [...this.faces]\r\n            .map((face, index) => {\r\n                // Calculate maximum depth for accurate sorting of subdivided faces\r\n                let maxDepth = -Infinity;\r\n                let centroidY = 0, centroidZ = 0;\r\n\r\n                for (const vertexIndex of face) {\r\n                    if (vertexIndex < transformedVertices.length) {\r\n                        const vertex = transformedVertices[vertexIndex];\r\n                        maxDepth = Math.max(maxDepth, vertex.x); // Use X as depth (camera looks along +X)\r\n                        centroidY += vertex.y;\r\n                        centroidZ += vertex.z;\r\n                    }\r\n                }\r\n\r\n                centroidY /= face.length;\r\n                centroidZ /= face.length;\r\n\r\n                // Use maximum depth as primary sorting criteria for subdivided faces\r\n                // Add small offset based on face center to handle coplanar faces\r\n                const sortDepth = maxDepth + (centroidY + centroidZ) * 0.001;\r\n\r\n                return { face, sortDepth };\r\n            })\r\n            .sort((a, b) => b.sortDepth - a.sortDepth) // Sort back-to-front (lower depth values first = closer to camera)\r\n            .map(item => item.face);\r\n\r\n        // Draw faces in sorted order\r\n        if (this.renderMode === \"solid\" || this.renderMode === \"both\") {\r\n            for (const face of sortedFaces) {\r\n                // Use material color if available, otherwise fall back to faceColor\r\n                const faceColor = this.material ? this.getMaterialColor(face) : this._faceColor;\r\n                ctx.fillStyle = faceColor;\r\n                // Check if vertices are valid and get projected vertices\r\n                const validVertices = [];\r\n                for (const vertexIndex of face) {\r\n                    if (vertexIndex < validProjectedVertices.length &&\r\n                        validProjectedVertices[vertexIndex].x > -999) {\r\n                        validVertices.push(validProjectedVertices[vertexIndex]);\r\n                    }\r\n                }\r\n\r\n                if (validVertices.length < 3) continue;\r\n\r\n                // Triangulate faces with more than 3 vertices for proper rendering\r\n                if (validVertices.length === 3) {\r\n                    // Triangle face - draw directly\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(validVertices[0].x, validVertices[0].y);\r\n                    ctx.lineTo(validVertices[1].x, validVertices[1].y);\r\n                    ctx.lineTo(validVertices[2].x, validVertices[2].y);\r\n                    ctx.closePath();\r\n                    ctx.fill();\r\n                } else if (validVertices.length === 4) {\r\n                    // Quad face - triangulate into two triangles\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(validVertices[0].x, validVertices[0].y);\r\n                    ctx.lineTo(validVertices[1].x, validVertices[1].y);\r\n                    ctx.lineTo(validVertices[2].x, validVertices[2].y);\r\n                    ctx.closePath();\r\n                    ctx.fill();\r\n\r\n                    ctx.beginPath();\r\n                    ctx.moveTo(validVertices[0].x, validVertices[0].y);\r\n                    ctx.lineTo(validVertices[2].x, validVertices[2].y);\r\n                    ctx.lineTo(validVertices[3].x, validVertices[3].y);\r\n                    ctx.closePath();\r\n                    ctx.fill();\r\n                } else {\r\n                    // Polygon with more vertices - triangulate using fan method\r\n                    for (let i = 1; i < validVertices.length - 1; i++) {\r\n                        ctx.beginPath();\r\n                        ctx.moveTo(validVertices[0].x, validVertices[0].y);\r\n                        ctx.lineTo(validVertices[i].x, validVertices[i].y);\r\n                        ctx.lineTo(validVertices[i + 1].x, validVertices[i + 1].y);\r\n                        ctx.closePath();\r\n                        ctx.fill();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Draw edges\r\n        if (this.renderMode === \"wireframe\" || this.renderMode === \"both\") {\r\n            ctx.strokeStyle = this.wireframeColor;\r\n            ctx.lineWidth = 1; // Decreased line width for better visibility\r\n\r\n            for (const [from, to] of this.edges) {\r\n                // Check if both vertices are valid and visible\r\n                if (from >= validProjectedVertices.length ||\r\n                    to >= validProjectedVertices.length ||\r\n                    validProjectedVertices[from].x < -999 ||\r\n                    validProjectedVertices[to].x < -999) {\r\n                    continue;\r\n                }\r\n\r\n                const fromVertex = validProjectedVertices[from];\r\n                const toVertex = validProjectedVertices[to];\r\n\r\n                ctx.beginPath();\r\n                ctx.moveTo(fromVertex.x, fromVertex.y);\r\n                ctx.lineTo(toVertex.x, toVertex.y);\r\n                ctx.stroke();\r\n            }\r\n        }\r\n\r\n        // Draw axis lines if enabled\r\n        if (this.showAxisLines && validProjectedVertices.length > 0) {\r\n            // Use the center of the cube as origin for axis lines\r\n            let centerX = 0, centerY = 0;\r\n            let validVertices = 0;\r\n\r\n            for (const vertex of validProjectedVertices) {\r\n                if (vertex && vertex.x > -999) {\r\n                    centerX += vertex.x;\r\n                    centerY += vertex.y;\r\n                    validVertices++;\r\n                }\r\n            }\r\n\r\n            if (validVertices > 0) {\r\n                centerX /= validVertices;\r\n                centerY /= validVertices;\r\n                this.drawAxisLines(ctx, new Vector2(centerX, centerY));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n      * Draw colored axis lines for visualization\r\n      * @param {CanvasRenderingContext2D} ctx - The render texture context\r\n      * @param {Vector2} origin - The origin point to draw axes from\r\n      */\r\n    drawAxisLines(ctx, origin) {\r\n        if (!origin) return;\r\n\r\n        const axisLength = this.axisLength;\r\n        const centerX = origin.x;\r\n        const centerY = origin.y;\r\n\r\n        // Define axis endpoints in 3D space (relative to origin) - Standard right-handed system\r\n        const axes = {\r\n            x: new Vector3(axisLength, 0, 0),    // Red - X axis (right/left)\r\n            y: new Vector3(0, axisLength, 0),    // Green - Y axis (up/down)\r\n            z: new Vector3(0, 0, axisLength)     // Blue - Z axis (forward/back)\r\n        };\r\n\r\n        // Project axis endpoints to screen space\r\n        const projectedAxes = {};\r\n        for (const [axis, endpoint] of Object.entries(axes)) {\r\n            const worldPoint = new Vector3(\r\n                endpoint.x + this.position.x,\r\n                endpoint.y + this.position.y,\r\n                endpoint.z + this.position.z\r\n            );\r\n            projectedAxes[axis] = this.projectPointRelative(worldPoint, origin);\r\n        }\r\n\r\n        // Draw axis lines with colors (standard right-handed system)\r\n        const axisColors = {\r\n            x: '#ff0000', // Red - X axis (right/left)\r\n            y: '#00ff00', // Green - Y axis (up/down)\r\n            z: '#0000ff'  // Blue - Z axis (forward/back)\r\n        };\r\n\r\n        const axisLabels = {\r\n            x: 'X',\r\n            y: 'Y',\r\n            z: 'Z'\r\n        };\r\n\r\n        ctx.font = '12px Arial';\r\n        ctx.textAlign = 'center';\r\n        ctx.textBaseline = 'middle';\r\n\r\n        for (const [axis, color] of Object.entries(axisColors)) {\r\n            const endPoint = projectedAxes[axis];\r\n            if (!endPoint) continue;\r\n\r\n            // Draw axis line\r\n            ctx.strokeStyle = color;\r\n            ctx.lineWidth = 3;\r\n            ctx.beginPath();\r\n            ctx.moveTo(centerX, centerY);\r\n            ctx.lineTo(endPoint.x, endPoint.y);\r\n            ctx.stroke();\r\n\r\n            // Draw axis label at the end\r\n            ctx.fillStyle = color;\r\n            ctx.fillText(axisLabels[axis], endPoint.x, endPoint.y);\r\n\r\n            // Draw arrowhead (small triangle)\r\n            this.drawArrowhead(ctx, centerX, centerY, endPoint.x, endPoint.y, color);\r\n        }\r\n\r\n        // Draw axis legend (standard right-handed system)\r\n        ctx.fillStyle = '#ffffff';\r\n        ctx.font = '10px Arial';\r\n        ctx.textAlign = 'left';\r\n        ctx.fillText('X: Right/Left (Red)', centerX + 10, centerY - 30);\r\n        ctx.fillText('Y: Up/Down (Green)', centerX + 10, centerY - 18);\r\n        ctx.fillText('Z: Forward/Back (Blue)', centerX + 10, centerY - 6);\r\n    }\r\n\r\n    /**\r\n      * Project a point relative to an origin for axis drawing\r\n      * @param {Vector3} worldPoint - The world point to project\r\n      * @param {Vector2} origin - The origin point\r\n      * @returns {Vector2|null} The projected point\r\n      */\r\n    projectPointRelative(worldPoint, origin) {\r\n        // Find active camera\r\n        const camera = this.findActiveCamera();\r\n        if (!camera) return null;\r\n\r\n        // Project the point\r\n        const projected = camera.projectPoint(worldPoint);\r\n        return projected;\r\n    }\r\n\r\n    /**\r\n      * Draw an arrowhead at the end of an axis line\r\n      * @param {CanvasRenderingContext2D} ctx - The canvas context\r\n      * @param {number} fromX - Start X coordinate\r\n      * @param {number} fromY - Start Y coordinate\r\n      * @param {number} toX - End X coordinate\r\n      * @param {number} toY - End Y coordinate\r\n      * @param {string} color - The color of the arrowhead\r\n      */\r\n    drawArrowhead(ctx, fromX, fromY, toX, toY, color) {\r\n        const headLength = 8;\r\n        const headAngle = Math.PI / 6; // 30 degrees\r\n\r\n        // Calculate direction vector\r\n        const dx = toX - fromX;\r\n        const dy = toY - fromY;\r\n        const length = Math.sqrt(dx * dx + dy * dy);\r\n\r\n        if (length === 0) return;\r\n\r\n        // Calculate unit vector\r\n        const unitX = dx / length;\r\n        const unitY = dy / length;\r\n\r\n        // Calculate perpendicular vector for arrowhead\r\n        const perpX = -unitY;\r\n        const perpY = unitX;\r\n\r\n        // Calculate arrowhead points\r\n        const arrowX1 = toX - headLength * (unitX * Math.cos(headAngle) - perpX * Math.sin(headAngle));\r\n        const arrowY1 = toY - headLength * (unitY * Math.cos(headAngle) - perpY * Math.sin(headAngle));\r\n        const arrowX2 = toX - headLength * (unitX * Math.cos(headAngle) + perpX * Math.sin(headAngle));\r\n        const arrowY2 = toY - headLength * (unitY * Math.cos(headAngle) + perpY * Math.sin(headAngle));\r\n\r\n        // Draw arrowhead\r\n        ctx.strokeStyle = color;\r\n        ctx.lineWidth = 2;\r\n        ctx.beginPath();\r\n        ctx.moveTo(toX, toY);\r\n        ctx.lineTo(arrowX1, arrowY1);\r\n        ctx.moveTo(toX, toY);\r\n        ctx.lineTo(arrowX2, arrowY2);\r\n        ctx.stroke();\r\n    }\r\n\r\n    /**\r\n      * Draw a placeholder shape when no camera is available\r\n      * @param {CanvasRenderingContext2D} ctx - The canvas context\r\n      */\r\n    drawPlaceholder(ctx) {\r\n        // Draw a simple cube wireframe\r\n        ctx.strokeStyle = this.wireframeColor;\r\n        ctx.lineWidth = 1;\r\n\r\n        // Size based on scale\r\n        const size = this.size * Math.max(this.scale.x, this.scale.y) / 2;\r\n\r\n        // Draw front face\r\n        ctx.beginPath();\r\n        ctx.rect(-size, -size, size * 2, size * 2);\r\n        ctx.stroke();\r\n\r\n        // Draw back face (offset for perspective effect)\r\n        ctx.beginPath();\r\n        ctx.rect(-size * 0.7, -size * 0.7, size * 1.4, size * 1.4);\r\n        ctx.stroke();\r\n\r\n        // Draw connecting lines\r\n        ctx.beginPath();\r\n        ctx.moveTo(-size, -size);\r\n        ctx.lineTo(-size * 0.7, -size * 0.7);\r\n        ctx.moveTo(size, -size);\r\n        ctx.lineTo(size * 0.7, -size * 0.7);\r\n        ctx.moveTo(size, size);\r\n        ctx.lineTo(size * 0.7, size * 0.7);\r\n        ctx.moveTo(-size, size);\r\n        ctx.lineTo(-size * 0.7, size * 0.7);\r\n        ctx.stroke();\r\n\r\n        // Draw \"Cube3D\" text\r\n        ctx.fillStyle = this.wireframeColor;\r\n        ctx.font = '12px Arial';\r\n        ctx.textAlign = 'center';\r\n        ctx.textBaseline = 'middle';\r\n        ctx.fillText('Cube3D', 0, 0);\r\n    }\r\n\r\n    /**\r\n     * Find the active camera in the scene\r\n     * @returns {Camera3D|null} The active camera or null\r\n     */\r\n    findActiveCamera() {\r\n        const allObjects = this.getGameObjects();\r\n\r\n        for (const obj of allObjects) {\r\n            const camera = obj.getModule(\"Camera3D\");\r\n            if (camera && camera.isActive) {\r\n                return camera;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get all game objects in the scene\r\n     * @returns {Array<GameObject>} All game objects\r\n     */\r\n    getGameObjects() {\r\n        if (!this.gameObject) return [];\r\n\r\n\r\n        return this.getAllGameObjects();\r\n\r\n        // Fallback to recursively finding game objects\r\n        const allObjects = [];\r\n\r\n        const scene = window.editor ? window.editor.activeScene :\r\n            (window.engine ? window.engine.scene : null);\r\n\r\n        if (scene && scene.gameObjects) {\r\n            const findObjects = (objects) => {\r\n                objects.forEach(obj => {\r\n                    allObjects.push(obj);\r\n                    if (obj.children && obj.children.length > 0) {\r\n                        findObjects(obj.children);\r\n                    }\r\n                });\r\n            };\r\n\r\n            findObjects(scene.gameObjects);\r\n        }\r\n\r\n        return allObjects;\r\n    }\r\n\r\n    /**\r\n      * Transform vertices based on mesh and game object transforms\r\n      * @returns {Array<Vector3>} Transformed vertices\r\n      */\r\n    transformVertices() {\r\n        // Get game object transforms if available\r\n        let objPos = { x: 0, y: 0 };\r\n        let objRot = 0;\r\n        let objScale = { x: 1, y: 1 };\r\n\r\n        if (this.gameObject) {\r\n            objPos = this.gameObject.getWorldPosition ? this.gameObject.getWorldPosition() : { x: 0, y: 0 };\r\n            objRot = this.gameObject.getWorldRotation ? this.gameObject.getWorldRotation() : 0;\r\n            objScale = this.gameObject.getWorldScale ? this.gameObject.getWorldScale() : { x: 1, y: 1 };\r\n        }\r\n\r\n        // Determine game object world depth (Z). Prefer getWorldDepth(), then depth, then position.z, else 0.\r\n        let objDepth = 0;\r\n        if (this.gameObject) {\r\n            if (typeof this.gameObject.getWorldDepth === 'function') {\r\n                objDepth = this.gameObject.getWorldDepth();\r\n            } else if (typeof this.gameObject.depth === 'number') {\r\n                objDepth = this.gameObject.depth;\r\n            } else if (this.gameObject.position && typeof this.gameObject.position.z === 'number') {\r\n                objDepth = this.gameObject.position.z;\r\n            }\r\n        }\r\n\r\n        // Convert to 3D (use game object depth for Z)\r\n        const objPos3D = new Vector3(objPos.x, objPos.y, objDepth);\r\n        const objScale3D = new Vector3(objScale.x, objScale.y, 1);\r\n\r\n        return this.vertices.map(vertex => {\r\n            // Start with the base vertex\r\n            let v = vertex.clone ? vertex.clone() : new Vector3(vertex.x, vertex.y, vertex.z);\r\n\r\n            // Step 1: Apply mesh scale\r\n            v.x *= this.scale.x;\r\n            v.y *= this.scale.y;\r\n            v.z *= this.scale.z;\r\n\r\n            // Step 2: Apply game object rotation first (convert degrees to radians)\r\n            // In 2D-to-3D system, game object rotation is applied around Z-axis\r\n            if (objRot !== 0) {\r\n                const rotRad = objRot * (Math.PI / 180);\r\n                v = this.rotateZ(v, rotRad);\r\n            }\r\n\r\n            // Step 3: Apply mesh rotation (convert degrees to radians)\r\n            // X-axis: roll, Y-axis: yaw, Z-axis: pitch\r\n            if (this.rotation.x !== 0) v = this.rotateX(v, this.rotation.x * (Math.PI / 180)); // Roll\r\n            if (this.rotation.y !== 0) v = this.rotateY(v, this.rotation.y * (Math.PI / 180)); // Yaw\r\n            if (this.rotation.z !== 0) v = this.rotateZ(v, this.rotation.z * (Math.PI / 180)); // Pitch\r\n\r\n            // Step 4: Apply mesh position (translate)\r\n            v.x += this.position.x;\r\n            v.y += this.position.y;\r\n            v.z += this.position.z;\r\n\r\n            // Step 5: Apply game object scale\r\n            v.x *= objScale3D.x;\r\n            v.y *= objScale3D.y;\r\n            v.z *= objScale3D.z;\r\n\r\n            // Step 6: Apply game object position (translate) including depth\r\n            v.x += objPos3D.x;\r\n            v.y += objPos3D.y;\r\n            v.z += objPos3D.z;\r\n\r\n            return v;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Rotate a vector around the X axis\r\n     * @param {Vector3} v - Vector to rotate\r\n     * @param {number} angle - Angle in radians\r\n     * @returns {Vector3} Rotated vector\r\n     */\r\n    rotateX(v, angle) {\r\n        const cos = Math.cos(angle);\r\n        const sin = Math.sin(angle);\r\n        return new Vector3(\r\n            v.x,\r\n            v.y * cos - v.z * sin,\r\n            v.y * sin + v.z * cos\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Rotate a vector around the Y axis\r\n     * @param {Vector3} v - Vector to rotate\r\n     * @param {number} angle - Angle in radians\r\n     * @returns {Vector3} Rotated vector\r\n     */\r\n    rotateY(v, angle) {\r\n        const cos = Math.cos(angle);\r\n        const sin = Math.sin(angle);\r\n        return new Vector3(\r\n            v.x * cos + v.z * sin,\r\n            v.y,\r\n            -v.x * sin + v.z * cos\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Rotate a vector around the Z axis\r\n     * @param {Vector3} v - Vector to rotate\r\n     * @param {number} angle - Angle in radians\r\n     * @returns {Vector3} Rotated vector\r\n     */\r\n    rotateZ(v, angle) {\r\n        const cos = Math.cos(angle);\r\n        const sin = Math.sin(angle);\r\n        return new Vector3(\r\n            v.x * cos - v.y * sin,\r\n            v.x * sin + v.y * cos,\r\n            v.z\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Draw in the editor\r\n     * @param {CanvasRenderingContext2D} ctx - The canvas context\r\n     */\r\n    drawInEditor(ctx) {\r\n        // Use the same draw method for both runtime and editor\r\n        this.draw(ctx);\r\n    }\r\n\r\n    /**\r\n      * Serialize the cube mesh to JSON\r\n      * @returns {Object} JSON representation of the cube mesh\r\n      */\r\n    toJSON() {\r\n        return {\r\n            _type: \"CubeMesh3D\",\r\n            _size: this._size,\r\n            _position: { x: this._position.x, y: this._position.y, z: this._position.z },\r\n            _rotation: { x: this._rotation.x, y: this._rotation.y, z: this._rotation.z },\r\n            _scale: { x: this._scale.x, y: this._scale.y, z: this._scale.z },\r\n            _wireframeColor: this._wireframeColor,\r\n            _faceColor: this._faceColor,\r\n            _renderMode: this._renderMode,\r\n            _showAxisLines: this._showAxisLines,\r\n            _axisLength: this._axisLength,\r\n            _subdivisions: this._subdivisions\r\n        };\r\n    }\r\n\r\n    /**\r\n      * Deserialize the cube mesh from JSON\r\n      * @param {Object} json - JSON representation of the cube mesh\r\n      */\r\n    fromJSON(json) {\r\n        if (json._size !== undefined) {\r\n            this._size = json._size;\r\n            this.updateCube();\r\n        }\r\n        if (json._position) this._position = new Vector3(json._position.x, json._position.y, json._position.z);\r\n        if (json._rotation) this._rotation = new Vector3(json._rotation.x, json._rotation.y, json._rotation.z);\r\n        if (json._scale) this._scale = new Vector3(json._scale.x, json._scale.y, json._scale.z);\r\n        if (json._wireframeColor !== undefined) this._wireframeColor = json._wireframeColor;\r\n        if (json._faceColor !== undefined) this._faceColor = json._faceColor;\r\n        if (json._renderMode !== undefined) this._renderMode = json._renderMode;\r\n        if (json._showAxisLines !== undefined) this._showAxisLines = json._showAxisLines;\r\n        if (json._axisLength !== undefined) this._axisLength = json._axisLength;\r\n        //if (json._subdivisions !== undefined) this._subdivisions = json._subdivisions;\r\n        this._subdivisions = 12;\r\n    }\r\n\r\n    // Getters and setters for properties\r\n    get size() { return this._size; }\r\n    set size(value) {\r\n        this._size = value;\r\n        this.updateCube();\r\n    }\r\n\r\n    get subdivisions() { return this._subdivisions; }\r\n    set subdivisions(value) {\r\n        this._subdivisions = Math.floor(Math.max(1, Math.min(10, value)));\r\n        this.updateCube();\r\n    }\r\n\r\n    get position() { return this._position; }\r\n    set position(value) { this._position = value; }\r\n\r\n    get rotation() { return this._rotation; }\r\n    set rotation(value) { this._rotation = value; }\r\n\r\n    get scale() { return this._scale; }\r\n    set scale(value) { this._scale = value; }\r\n\r\n    get wireframeColor() { return this._wireframeColor; }\r\n    set wireframeColor(value) { this._wireframeColor = value; }\r\n\r\n    get faceColor() { return this._faceColor; }\r\n    set faceColor(value) { this._faceColor = value; }\r\n\r\n    get renderMode() { return this._renderMode; }\r\n    set renderMode(value) { this._renderMode = value; }\r\n\r\n    get showAxisLines() { return this._showAxisLines; }\r\n    set showAxisLines(value) { this._showAxisLines = value; }\r\n\r\n    get axisLength() { return this._axisLength; }\r\n    set axisLength(value) { this._axisLength = Math.max(50, Math.min(500, value)); }\r\n}\r\n\r\n// Register the CubeMesh3D module\r\nwindow.CubeMesh3D = CubeMesh3D;",
      "type": "file",
      "name": "CubeMesh3D.js",
      "parentPath": "/",
      "created": 1759457099330,
      "modified": 1759457099330
    },
    {
      "path": "/FlyCamera.js",
      "content": "/**\r\n * FlyCamera - Module for camera movement with WASD controls\r\n * \r\n * This module allows for flying camera controls using WASD keys and QE for up/down.\r\n * It needs to be attached to a GameObject with a Camera3D module.\r\n * \r\n * COORDINATE SYSTEM:\r\n * - X axis: forward/back (W/S)\r\n * - Y axis: left/right (A/D)\r\n * - Z axis: up/down (E/Q)\r\n * \r\n * MOVEMENT:    \r\n * - W: Move forward\r\n * - S: Move backward\r\n * - A: Strafe left\r\n * - D: Strafe right\r\n * - E: Move up\r\n * - Q: Move down\r\n * - Shift: Sprint (increases movement speed)\r\n */\r\nclass FlyCamera extends Module {\r\n    static namespace = \"3D\";\r\n    \r\n    /**\r\n     * Create a new FlyCamera\r\n     */\r\n    constructor() {\r\n        super(\"FlyCamera\");\r\n        \r\n        // Setup requirements\r\n        this.requires(\"Camera3D\");\r\n        \r\n        // Movement settings\r\n        this._moveSpeed = 200; // Units per second\r\n        this._sprintMultiplier = 2.5;\r\n        this._verticalSpeed = 150; // Units per second for up/down movement\r\n        \r\n        // Smoothing settings\r\n        this._smoothing = 0.2; // Lower = more responsive, higher = smoother\r\n        this._currentVelocity = new Vector3(0, 0, 0);\r\n\r\n        // Z Axis Movement\r\n        this._useZAxis = true; // Enable vertical movement by default\r\n        this._lockZAxisPosition = false; // Lock camera at current Z position\r\n        \r\n        // Key mapping (can be customized)\r\n        this._keyMapping = {\r\n            forward: \"w\",\r\n            backward: \"s\",\r\n            left: \"a\",\r\n            right: \"d\",\r\n            up: \"e\",\r\n            down: \"q\",\r\n            sprint: \"shift\"\r\n        };\r\n        \r\n        // Camera reference (will be set in start())\r\n        this.camera = null;\r\n        \r\n        // Expose properties to the inspector\r\n        this.exposeProperty(\"moveSpeed\", \"number\", 200, {\r\n            min: 1,\r\n            max: 1000,\r\n            onChange: (val) => this._moveSpeed = val\r\n        });\r\n\r\n        this.exposeProperty(\"sprintMultiplier\", \"number\", 2.5, {\r\n            min: 1,\r\n            max: 10,\r\n            onChange: (val) => this._sprintMultiplier = val\r\n        });\r\n\r\n        this.exposeProperty(\"verticalSpeed\", \"number\", 150, {\r\n            min: 1,\r\n            max: 500,\r\n            onChange: (val) => this._verticalSpeed = val\r\n        });\r\n\r\n        this.exposeProperty(\"smoothing\", \"number\", 0.2, {\r\n            min: 0,\r\n            max: 0.99,\r\n            step: 0.01,\r\n            onChange: (val) => this._smoothing = val\r\n        });\r\n\r\n        this.exposeProperty(\"keyMapping\", \"object\", this._keyMapping, {\r\n            onChange: (val) => this._keyMapping = val\r\n        });\r\n\r\n        this.exposeProperty(\"useZAxis\", \"boolean\", true, {\r\n            onChange: (val) => this._useZAxis = val\r\n        });\r\n\r\n        this.exposeProperty(\"lockZAxisPosition\", \"boolean\", false, {\r\n            onChange: (val) => this._lockZAxisPosition = val\r\n        });\r\n\r\n        // Collision detection settings\r\n        this._collisionRadius = 50; // Radius to search for collidable objects\r\n        this._collisionEnabled = true; // Enable collision detection\r\n        this._slideAlongWalls = true; // Enable wall sliding instead of just stopping\r\n\r\n        this.exposeProperty(\"collisionRadius\", \"number\", 50, {\r\n            min: 1,\r\n            max: 1000,\r\n            onChange: (val) => this._collisionRadius = val\r\n        });\r\n\r\n        this.exposeProperty(\"collisionEnabled\", \"boolean\", true, {\r\n            onChange: (val) => this._collisionEnabled = val\r\n        });\r\n\r\n        this.exposeProperty(\"slideAlongWalls\", \"boolean\", true, {\r\n            onChange: (val) => this._slideAlongWalls = val\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Called when the module starts\r\n     */\r\n    start() {\r\n        // Get camera reference\r\n        this.camera = this.gameObject.getModule(\"Camera3D\");\r\n        \r\n        if (!this.camera) {\r\n            console.error(\"FlyCamera requires a Camera3D module on the same GameObject\");\r\n        }\r\n        \r\n        // Make sure input manager is available\r\n        if (!window.input) {\r\n            console.error(\"FlyCamera requires InputManager to be initialized\");\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Handle camera movement each frame\r\n     * @param {number} deltaTime - Time since last frame in seconds\r\n     */\r\n    loop(deltaTime) {\r\n        if (!this.camera || !window.input) return;\r\n        \r\n        // Calculate target velocity based on key presses\r\n        const targetVelocity = this.calculateTargetVelocity();\r\n        \r\n        // Apply smoothing\r\n        this._currentVelocity.x += (targetVelocity.x - this._currentVelocity.x) * (1 - this.smoothing);\r\n        this._currentVelocity.y += (targetVelocity.y - this._currentVelocity.y) * (1 - this.smoothing);\r\n        this._currentVelocity.z += (targetVelocity.z - this._currentVelocity.z) * (1 - this.smoothing);\r\n        \r\n        // Move the camera\r\n        if (this._currentVelocity.magnitude() > 0.01) {\r\n            this.moveCamera(deltaTime);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Calculate target velocity based on key presses\r\n     * @returns {Vector3} Target velocity\r\n     */\r\n    calculateTargetVelocity() {\r\n        // Start with zero velocity\r\n        const targetVelocity = new Vector3(0, 0, 0);\r\n        \r\n        // Check if input manager is available\r\n        if (!window.input) return targetVelocity;\r\n        \r\n        // Check sprint key\r\n        const sprinting = window.input.keyDown(this.keyMapping.sprint);\r\n        const speedMultiplier = sprinting ? this.sprintMultiplier : 1;\r\n        \r\n        // Calculate movement direction in camera space\r\n        // NOTE: X = forward/back, Y = left/right, Z = up/down\r\n        if (window.input.keyDown(this.keyMapping.forward)) {\r\n            targetVelocity.x += this.moveSpeed * speedMultiplier;   // forward -> +X\r\n        }\r\n        if (window.input.keyDown(this.keyMapping.backward)) {\r\n            targetVelocity.x -= this.moveSpeed * speedMultiplier;   // backward -> -X\r\n        }\r\n        if (window.input.keyDown(this.keyMapping.left)) {\r\n            targetVelocity.y -= this.moveSpeed * speedMultiplier;   // left -> -Y\r\n        }\r\n        if (window.input.keyDown(this.keyMapping.right)) {\r\n            targetVelocity.y += this.moveSpeed * speedMultiplier;   // right -> +Y\r\n        }\r\n        if (this._useZAxis) {\r\n            if (window.input.keyDown(this.keyMapping.up)) {\r\n                targetVelocity.z += this.verticalSpeed * speedMultiplier; // up -> +Z\r\n            }\r\n            if (window.input.keyDown(this.keyMapping.down)) {\r\n                targetVelocity.z -= this.verticalSpeed * speedMultiplier; // down -> -Z\r\n            }\r\n        }\r\n        \r\n        return targetVelocity;\r\n    }\r\n    \r\n    /**\r\n     * Find collidable game objects within a radius of the camera\r\n     * @param {number} radius - Search radius\r\n     * @returns {Array} Array of game objects with colliders\r\n     */\r\n    findCollidableObjects(radius) {\r\n        if (!window.engine || !window.engine.gameObjects) return [];\r\n\r\n        const collidableObjects = [];\r\n        const cameraPos = this.getCameraWorldPosition();\r\n\r\n        for (const gameObj of window.engine.gameObjects) {\r\n            if (!gameObj.active || gameObj === this.gameObject) continue;\r\n\r\n            // Check if object has collision capabilities\r\n            const hasCollider = gameObj.getModule && (\r\n                gameObj.getModule('Collider') ||\r\n                gameObj.getModule('RigidBody') ||\r\n                gameObj.getModule('BoundingBoxCollider')\r\n            );\r\n\r\n            if (hasCollider) {\r\n                const objPos = gameObj.getWorldPosition();\r\n                const distance = Math.sqrt(\r\n                    Math.pow(cameraPos.x - objPos.x, 2) +\r\n                    Math.pow(cameraPos.y - objPos.y, 2)\r\n                );\r\n\r\n                if (distance <= radius) {\r\n                    collidableObjects.push(gameObj);\r\n                }\r\n            }\r\n        }\r\n\r\n        return collidableObjects;\r\n    }\r\n\r\n    /**\r\n     * Get the camera's world position as a Vector2\r\n     * @returns {Object} Position object with x, y properties\r\n     */\r\n    getCameraWorldPosition() {\r\n        if (this.gameObject && this.gameObject.position) {\r\n            return {\r\n                x: this.gameObject.position.x || 0,\r\n                y: this.gameObject.position.y || 0\r\n            };\r\n        }\r\n        return { x: 0, y: 0 };\r\n    }\r\n\r\n    /**\r\n     * Check for collision along a movement vector\r\n     * @param {Vector3} movement - Movement vector\r\n     * @param {Array} collidableObjects - Objects to check collision against\r\n     * @returns {Object} Collision information or null\r\n     */\r\n    checkMovementCollision(movement, collidableObjects) {\r\n        if (!movement || movement.magnitude() < 0.01) return null;\r\n\r\n        const startPos = this.getCameraWorldPosition();\r\n\r\n        for (const obj of collidableObjects) {\r\n            const boundingBox = obj.getBoundingBox();\r\n            if (!boundingBox) continue;\r\n\r\n            // Create ray from current position in movement direction\r\n            const ray = {\r\n                origin: new Vector2(startPos.x, startPos.y),\r\n                direction: new Vector2(movement.x, movement.y).normalize()\r\n            };\r\n\r\n            const hit = window.collisionSystem.raycast(ray, boundingBox);\r\n            if (hit && hit.distance <= movement.magnitude()) {\r\n                return {\r\n                    object: obj,\r\n                    hit: hit,\r\n                    distance: hit.distance\r\n                };\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Apply collision response to movement\r\n     * @param {Vector3} originalMovement - Original movement vector\r\n     * @param {Object} collision - Collision information\r\n     * @returns {Vector3} Modified movement vector\r\n     */\r\n    applyCollisionResponse(originalMovement, collision) {\r\n        if (!this._slideAlongWalls) {\r\n            // Just stop movement in collision direction\r\n            return new Vector3(0, 0, originalMovement.z);\r\n        }\r\n\r\n        // Calculate slide direction\r\n        const hitNormal = collision.hit.normal;\r\n        const movementDir = new Vector2(originalMovement.x, originalMovement.y);\r\n\r\n        // Project movement onto the wall normal to get the component to remove\r\n        const dotProduct = movementDir.dot(hitNormal);\r\n        if (dotProduct >= 0) return originalMovement; // Moving away from wall\r\n\r\n        // Remove the component that's penetrating the wall\r\n        const slideMovement = movementDir.subtract(hitNormal.multiply(dotProduct));\r\n\r\n        return new Vector3(slideMovement.x, slideMovement.y, originalMovement.z);\r\n    }\r\n\r\n    /**\r\n     * Move the camera based on current velocity\r\n     * @param {number} deltaTime - Time since last frame in seconds\r\n     */\r\n    moveCamera(deltaTime) {\r\n        // Use parent's world rotation if available, fallback to local rotation or 0\r\n        const parentRotDeg = (this.gameObject && typeof this.gameObject.getWorldRotation === 'function')\r\n            ? this.gameObject.getWorldRotation()\r\n            : (typeof this.gameObject.rotation === 'number' ? this.gameObject.rotation : 0);\r\n\r\n        // Camera Euler (degrees)\r\n        const cameraYawDeg = (this.camera && this.camera.rotation && typeof this.camera.rotation.z === 'number') ? (this.camera.rotation.z || 0) : 0;\r\n        const cameraPitchDeg = (this.camera && this.camera.rotation && typeof this.camera.rotation.y === 'number') ? (this.camera.rotation.y || 0) : 0;\r\n        const cameraRollDeg = (this.camera && this.camera.rotation && typeof this.camera.rotation.x === 'number') ? (this.camera.rotation.x || 0) : 0;\r\n\r\n        // Combined yaw = parent yaw + camera local yaw\r\n        const combinedYawDeg = parentRotDeg + cameraYawDeg;\r\n\r\n        // Ensure gameObject.position exists and has numeric x/y (engine uses Vector2 by default)\r\n        if (!this.gameObject.position || typeof this.gameObject.position.x !== 'number' || typeof this.gameObject.position.y !== 'number') {\r\n            this.gameObject.position = { x: 0, y: 0 };\r\n        }\r\n\r\n        // Build forward and right vectors in world space using Vector3 helpers.\r\n        // Forward ignores pitch for forward/back movement (moves along x/y plane).\r\n        const forwardVec = Vector3.rotateByEulerDeg(Vector3.forward(), combinedYawDeg, 0, 0).normalize();\r\n        // Right vector only uses yaw for horizontal strafing (ignores pitch/roll)\r\n        const rightVec = Vector3.rotateByEulerDeg(Vector3.right(), combinedYawDeg, 0, 0).normalize();\r\n\r\n        // Compose horizontal movement vector in world space (velocity components are in camera local axes)\r\n        const horizontalMove = forwardVec.multiply(this._currentVelocity.x)\r\n            .add(rightVec.multiply(this._currentVelocity.y));\r\n\r\n        // Guard against invalid numbers and apply deltaTime\r\n        const dx = Number.isFinite(horizontalMove.x) ? horizontalMove.x * deltaTime : 0;\r\n        const dy = Number.isFinite(horizontalMove.y) ? horizontalMove.y * deltaTime : 0;\r\n        // Up/down movement is purely along world Z axis, ignoring rotation\r\n        const dz = Number.isFinite(this._currentVelocity.z) ? this._currentVelocity.z * deltaTime : 0;\r\n\r\n        // Apply collision detection if enabled\r\n        let finalDx = dx;\r\n        let finalDy = dy;\r\n        let finalDz = dz;\r\n\r\n        if (this._collisionEnabled && (Math.abs(dx) > 0.01 || Math.abs(dy) > 0.01)) {\r\n            // Find collidable objects within radius\r\n            const collidableObjects = this.findCollidableObjects(this._collisionRadius);\r\n\r\n            if (collidableObjects.length > 0) {\r\n                // Create movement vector for collision checking\r\n                const movementVector = new Vector3(dx, dy, 0);\r\n\r\n                // Check for collisions\r\n                const collision = this.checkMovementCollision(movementVector, collidableObjects);\r\n\r\n                if (collision) {\r\n                    // Apply collision response\r\n                    const collisionMovement = this.applyCollisionResponse(movementVector, collision);\r\n\r\n                    // Check if we still collide after applying slide\r\n                    if (collisionMovement.magnitude() > 0.01) {\r\n                        const slideCollision = this.checkMovementCollision(collisionMovement, collidableObjects);\r\n                        if (slideCollision) {\r\n                            // If still colliding after slide, stop movement\r\n                            finalDx = 0;\r\n                            finalDy = 0;\r\n                        } else {\r\n                            finalDx = collisionMovement.x;\r\n                            finalDy = collisionMovement.y;\r\n                        }\r\n                    } else {\r\n                        finalDx = 0;\r\n                        finalDy = 0;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Apply movement to GameObject's 2D position\r\n        this.gameObject.position.x += finalDx;\r\n        this.gameObject.position.y += finalDy;\r\n\r\n        // Apply vertical movement to the Camera3D's position.z (avoid adding z to parent Vector2)\r\n        if (this.camera && !this._lockZAxisPosition) {\r\n            if (!this.camera.position || typeof this.camera.position.z !== 'number') {\r\n                // ensure camera.position is a Vector3-like object\r\n                this.camera.position = new Vector3(\r\n                    (this.camera.position && this.camera.position.x) || 0,\r\n                    (this.camera.position && this.camera.position.y) || 0,\r\n                    (this.camera.position && this.camera.position.z) || 0\r\n                );\r\n            }\r\n\r\n            // Prefer updating gameObject.depth so Z maps to GameObject depth (negative=up, positive=down).\r\n            if (this.gameObject) {\r\n                if (typeof this.gameObject.depth === 'number') {\r\n                    this.gameObject.depth = (this.gameObject.depth || 0) + dz;\r\n                } else if (this.gameObject.position && typeof this.gameObject.position.z === 'number') {\r\n                    this.gameObject.position.z += dz;\r\n                } else {\r\n                    // Fallback: update camera local Z\r\n                    this.camera.position.z = (this.camera.position.z || 0) + dz;\r\n                }\r\n            } else {\r\n                // Fallback: update camera local Z\r\n                this.camera.position.z = (this.camera.position.z || 0) + dz;\r\n            }\r\n        } else {\r\n            // Fallback: only modify gameObject.position.z if it already exists as a number\r\n            if (this.gameObject && !this._lockZAxisPosition) {\r\n                if (typeof this.gameObject.depth === 'number') {\r\n                    this.gameObject.depth = (this.gameObject.depth || 0) + dz;\r\n                } else if (typeof this.gameObject.position.z === 'number') {\r\n                    this.gameObject.position.z += dz;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Serialize the fly camera to JSON\r\n     * @returns {Object} JSON representation of the fly camera\r\n     */\r\n    toJSON() {\r\n        return {\r\n            _type: \"FlyCamera\",\r\n            _moveSpeed: this._moveSpeed,\r\n            _sprintMultiplier: this._sprintMultiplier,\r\n            _verticalSpeed: this._verticalSpeed,\r\n            _smoothing: this._smoothing,\r\n            _keyMapping: { ...this._keyMapping },\r\n            _useZAxis: this._useZAxis,\r\n            _lockZAxisPosition: this._lockZAxisPosition,\r\n            _collisionRadius: this._collisionRadius,\r\n            _collisionEnabled: this._collisionEnabled,\r\n            _slideAlongWalls: this._slideAlongWalls\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Deserialize the fly camera from JSON\r\n     * @param {Object} json - JSON representation of the fly camera\r\n     */\r\n    fromJSON(json) {\r\n        if (json._moveSpeed !== undefined) this._moveSpeed = json._moveSpeed;\r\n        if (json._sprintMultiplier !== undefined) this._sprintMultiplier = json._sprintMultiplier;\r\n        if (json._verticalSpeed !== undefined) this._verticalSpeed = json._verticalSpeed;\r\n        if (json._smoothing !== undefined) this._smoothing = json._smoothing;\r\n        if (json._keyMapping) this._keyMapping = { ...json._keyMapping };\r\n        if (json._useZAxis !== undefined) this._useZAxis = json._useZAxis;\r\n        if (json._lockZAxisPosition !== undefined) this._lockZAxisPosition = json._lockZAxisPosition;\r\n        if (json._collisionRadius !== undefined) this._collisionRadius = json._collisionRadius;\r\n        if (json._collisionEnabled !== undefined) this._collisionEnabled = json._collisionEnabled;\r\n        if (json._slideAlongWalls !== undefined) this._slideAlongWalls = json._slideAlongWalls;\r\n    }\r\n\r\n    // Getters and setters for properties\r\n    get moveSpeed() { return this._moveSpeed; }\r\n    set moveSpeed(value) { this._moveSpeed = value; }\r\n\r\n    get sprintMultiplier() { return this._sprintMultiplier; }\r\n    set sprintMultiplier(value) { this._sprintMultiplier = value; }\r\n\r\n    get verticalSpeed() { return this._verticalSpeed; }\r\n    set verticalSpeed(value) { this._verticalSpeed = value; }\r\n\r\n    get smoothing() { return this._smoothing; }\r\n    set smoothing(value) { this._smoothing = Math.max(0, Math.min(0.99, value)); }\r\n\r\n    get keyMapping() { return this._keyMapping; }\r\n    set keyMapping(value) { this._keyMapping = value; }\r\n\r\n    get useZAxis() { return this._useZAxis; }\r\n    set useZAxis(value) { this._useZAxis = value; }\r\n\r\n    get lockZAxisPosition() { return this._lockZAxisPosition; }\r\n    set lockZAxisPosition(value) { this._lockZAxisPosition = value; }\r\n\r\n    get collisionRadius() { return this._collisionRadius; }\r\n    set collisionRadius(value) { this._collisionRadius = Math.max(1, value); }\r\n\r\n    get collisionEnabled() { return this._collisionEnabled; }\r\n    set collisionEnabled(value) { this._collisionEnabled = value; }\r\n\r\n    get slideAlongWalls() { return this._slideAlongWalls; }\r\n    set slideAlongWalls(value) { this._slideAlongWalls = value; }\r\n}\r\n\r\n// Register the FlyCamera module\r\nwindow.FlyCamera = FlyCamera;",
      "type": "file",
      "name": "FlyCamera.js",
      "parentPath": "/",
      "created": 1759457099330,
      "modified": 1759457099330
    },
    {
      "path": "/Material.js",
      "content": "/**\r\n * Material - A comprehensive material system for 3D meshes\r\n * \r\n * Supports textures, procedural generation, colors, and UV mapping\r\n * for the Dark Matter JS 3D engine.\r\n */\r\nclass Material extends Module {\r\n    static namespace = \"3D\";\r\n\r\n    /**\r\n     * Create a new Material\r\n     */\r\n    constructor() {\r\n        super(\"Material\");\r\n\r\n        // Material properties\r\n        this._diffuseColor = \"#FFFFFF\";\r\n        this._specularColor = \"#FFFFFF\";\r\n        this._emissiveColor = \"#000000\";\r\n        this._shininess = 32;\r\n        this._opacity = 1.0;\r\n\r\n        // Texture properties\r\n        this._diffuseTexture = null; // Image URL or canvas\r\n        this._normalTexture = null;\r\n        this._specularTexture = null;\r\n        this._emissiveTexture = null;\r\n\r\n        // Procedural texture generation\r\n        this._useProceduralTexture = false;\r\n        this._proceduralType = \"noise\"; // \"noise\", \"checker\", \"gradient\", \"cellular\"\r\n        this._proceduralSeed = 12345;\r\n        this._proceduralScale = 1.0;\r\n        this._proceduralColor1 = \"#4CAF50\";\r\n        this._proceduralColor2 = \"#2196F3\";\r\n        this._proceduralOctaves = 4;\r\n        this._proceduralPersistence = 0.5;\r\n        this._proceduralLacunarity = 2.0;\r\n\r\n        // UV mapping properties\r\n        this._uvScale = new Vector2(1, 1);\r\n        this._uvOffset = new Vector2(0, 0);\r\n        this._uvRotation = 0;\r\n\r\n        // Material flags\r\n        this._transparent = false;\r\n        this._doubleSided = false;\r\n        this._wireframe = false;\r\n\r\n        // Generated texture cache\r\n        this._generatedTexture = null;\r\n        this._textureSize = 512;\r\n\r\n        // Enhanced texture management\r\n        this._loadedTextures = new Map(); // Cache for loaded textures\r\n        this._texturePromises = new Map(); // Track loading promises\r\n        this._textureLoadQueue = []; // Queue for background loading\r\n\r\n        // Expose properties to inspector\r\n        this.exposeProperty(\"diffuseColor\", \"color\", this._diffuseColor, {\r\n            onChange: (val) => this._diffuseColor = val\r\n        });\r\n\r\n        this.exposeProperty(\"specularColor\", \"color\", this._specularColor, {\r\n            onChange: (val) => this._specularColor = val\r\n        });\r\n\r\n        this.exposeProperty(\"emissiveColor\", \"color\", this._emissiveColor, {\r\n            onChange: (val) => this._emissiveColor = val\r\n        });\r\n\r\n        this.exposeProperty(\"shininess\", \"number\", this._shininess, {\r\n            min: 1,\r\n            max: 128,\r\n            onChange: (val) => this._shininess = val\r\n        });\r\n\r\n        this.exposeProperty(\"opacity\", \"number\", this._opacity, {\r\n            min: 0,\r\n            max: 1,\r\n            step: 0.01,\r\n            onChange: (val) => {\r\n                this._opacity = val;\r\n                this._transparent = val < 1.0;\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"diffuseTexture\", \"asset\", this._diffuseTexture, {\r\n            assetType: \"image\",\r\n            fileTypes: ['png', 'jpg', 'jpeg', 'gif', 'webp', 'svg', 'bmp'],\r\n            onChange: (val) => {\r\n                this._diffuseTexture = val;\r\n                this._useProceduralTexture = false;\r\n                this._generatedTexture = null;\r\n\r\n                // Preload texture if it's a path\r\n                if (typeof val === 'string') {\r\n                    this.preloadTexture(val);\r\n                }\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"useProceduralTexture\", \"boolean\", this._useProceduralTexture, {\r\n            onChange: (val) => {\r\n                this._useProceduralTexture = val;\r\n                if (val) {\r\n                    this._diffuseTexture = null;\r\n                    this.generateProceduralTexture();\r\n                }\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"proceduralType\", \"enum\", this._proceduralType, {\r\n            options: [\"noise\", \"checker\", \"gradient\", \"cellular\"],\r\n            onChange: (val) => {\r\n                this._proceduralType = val;\r\n                if (this._useProceduralTexture) {\r\n                    this.generateProceduralTexture();\r\n                }\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"proceduralSeed\", \"number\", this._proceduralSeed, {\r\n            onChange: (val) => {\r\n                this._proceduralSeed = val;\r\n                if (this._useProceduralTexture) {\r\n                    this.generateProceduralTexture();\r\n                }\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"proceduralScale\", \"number\", this._proceduralScale, {\r\n            min: 0.1,\r\n            max: 10,\r\n            step: 0.1,\r\n            onChange: (val) => {\r\n                this._proceduralScale = val;\r\n                if (this._useProceduralTexture) {\r\n                    this.generateProceduralTexture();\r\n                }\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"proceduralColor1\", \"color\", this._proceduralColor1, {\r\n            onChange: (val) => {\r\n                this._proceduralColor1 = val;\r\n                if (this._useProceduralTexture) {\r\n                    this.generateProceduralTexture();\r\n                }\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"proceduralColor2\", \"color\", this._proceduralColor2, {\r\n            onChange: (val) => {\r\n                this._proceduralColor2 = val;\r\n                if (this._useProceduralTexture) {\r\n                    this.generateProceduralTexture();\r\n                }\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"proceduralOctaves\", \"number\", this._proceduralOctaves, {\r\n            min: 1,\r\n            max: 8,\r\n            onChange: (val) => {\r\n                this._proceduralOctaves = val;\r\n                if (this._useProceduralTexture) {\r\n                    this.generateProceduralTexture();\r\n                }\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"proceduralPersistence\", \"number\", this._proceduralPersistence, {\r\n            min: 0.1,\r\n            max: 1,\r\n            step: 0.01,\r\n            onChange: (val) => {\r\n                this._proceduralPersistence = val;\r\n                if (this._useProceduralTexture) {\r\n                    this.generateProceduralTexture();\r\n                }\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"proceduralLacunarity\", \"number\", this._proceduralLacunarity, {\r\n            min: 1,\r\n            max: 4,\r\n            step: 0.1,\r\n            onChange: (val) => {\r\n                this._proceduralLacunarity = val;\r\n                if (this._useProceduralTexture) {\r\n                    this.generateProceduralTexture();\r\n                }\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"uvScale\", \"vector2\", this._uvScale, {\r\n            onChange: (val) => this._uvScale = val\r\n        });\r\n\r\n        this.exposeProperty(\"uvOffset\", \"vector2\", this._uvOffset, {\r\n            onChange: (val) => this._uvOffset = val\r\n        });\r\n\r\n        this.exposeProperty(\"uvRotation\", \"number\", this._uvRotation, {\r\n            min: 0,\r\n            max: 360,\r\n            onChange: (val) => this._uvRotation = val\r\n        });\r\n\r\n        this.exposeProperty(\"transparent\", \"boolean\", this._transparent, {\r\n            onChange: (val) => this._transparent = val\r\n        });\r\n\r\n        this.exposeProperty(\"doubleSided\", \"boolean\", this._doubleSided, {\r\n            onChange: (val) => this._doubleSided = val\r\n        });\r\n\r\n        this.exposeProperty(\"wireframe\", \"boolean\", this._wireframe, {\r\n            onChange: (val) => this._wireframe = val\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Generate a procedural texture based on current settings\r\n     */\r\n    generateProceduralTexture() {\r\n        const size = this._textureSize;\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = size;\r\n        canvas.height = size;\r\n        const ctx = canvas.getContext('2d');\r\n        const imageData = ctx.createImageData(size, size);\r\n        const data = imageData.data;\r\n\r\n        const color1 = this._parseColor(this._proceduralColor1);\r\n        const color2 = this._parseColor(this._proceduralColor2);\r\n\r\n        for (let y = 0; y < size; y++) {\r\n            for (let x = 0; x < size; x++) {\r\n                const u = x / size;\r\n                const v = y / size;\r\n\r\n                let value = 0;\r\n\r\n                switch (this._proceduralType) {\r\n                    case \"noise\":\r\n                        value = this._generateNoise(u * this._proceduralScale, v * this._proceduralScale);\r\n                        break;\r\n                    case \"checker\":\r\n                        value = this._generateChecker(u * this._proceduralScale, v * this._proceduralScale);\r\n                        break;\r\n                    case \"gradient\":\r\n                        value = this._generateGradient(u, v);\r\n                        break;\r\n                    case \"cellular\":\r\n                        value = this._generateCellular(u * this._proceduralScale, v * this._proceduralScale);\r\n                        break;\r\n                }\r\n\r\n                // Normalize value to 0-1 range\r\n                value = Math.max(0, Math.min(1, (value + 1) / 2));\r\n\r\n                // Interpolate between colors\r\n                const color = this._lerpColor(color1, color2, value);\r\n\r\n                const index = (y * size + x) * 4;\r\n                data[index] = color.r;     // Red\r\n                data[index + 1] = color.g; // Green\r\n                data[index + 2] = color.b; // Blue\r\n                data[index + 3] = 255;     // Alpha\r\n            }\r\n        }\r\n\r\n        ctx.putImageData(imageData, 0, 0);\r\n        this._generatedTexture = canvas;\r\n\r\n        return canvas;\r\n    }\r\n\r\n    /**\r\n     * Generate noise value at given coordinates\r\n     */\r\n    _generateNoise(x, y) {\r\n        // Simple pseudo-random noise using the seed\r\n        const n = Math.sin(x * 12.9898 + y * 78.233 + this._proceduralSeed) * 43758.5453;\r\n        return (n - Math.floor(n)) * 2 - 1; // Normalize to -1 to 1\r\n    }\r\n\r\n    /**\r\n     * Generate checker pattern\r\n     */\r\n    _generateChecker(u, v) {\r\n        const x = Math.floor(u * 8); // 8x8 checker pattern\r\n        const y = Math.floor(v * 8);\r\n        return (x + y) % 2 === 0 ? 1 : -1;\r\n    }\r\n\r\n    /**\r\n     * Generate radial gradient\r\n     */\r\n    _generateGradient(u, v) {\r\n        const centerU = 0.5;\r\n        const centerV = 0.5;\r\n        const distance = Math.sqrt((u - centerU) ** 2 + (v - centerV) ** 2);\r\n        return Math.max(-1, Math.min(1, 1 - distance * 2));\r\n    }\r\n\r\n    /**\r\n     * Generate cellular/Worley noise\r\n     */\r\n    _generateCellular(u, v) {\r\n        let minDistance = Infinity;\r\n\r\n        // Sample a few random points\r\n        for (let i = 0; i < 8; i++) {\r\n            const px = this._hash(i * 2) + Math.sin(i + this._proceduralSeed) * 0.5;\r\n            const py = this._hash(i * 2 + 1) + Math.cos(i + this._proceduralSeed) * 0.5;\r\n\r\n            const distance = Math.sqrt((u - px) ** 2 + (v - py) ** 2);\r\n            minDistance = Math.min(minDistance, distance);\r\n        }\r\n\r\n        // Normalize distance (this is a simple approximation)\r\n        return Math.max(-1, Math.min(1, 1 - minDistance * 4));\r\n    }\r\n\r\n    /**\r\n     * Simple hash function for pseudo-random values\r\n     */\r\n    _hash(value) {\r\n        const hash = ((value * 73856093) ^ (value * 19349663)) >>> 0;\r\n        return (hash / 4294967295) * 2 - 1; // Normalize to -1 to 1\r\n    }\r\n\r\n    /**\r\n     * Parse color string to RGB object\r\n     */\r\n    _parseColor(color) {\r\n        if (!color) return { r: 255, g: 255, b: 255 };\r\n\r\n        // Handle hex colors\r\n        if (typeof color === 'string' && color.startsWith('#')) {\r\n            const hex = color.slice(1);\r\n            if (hex.length === 3) {\r\n                return {\r\n                    r: parseInt(hex[0] + hex[0], 16),\r\n                    g: parseInt(hex[1] + hex[1], 16),\r\n                    b: parseInt(hex[2] + hex[2], 16)\r\n                };\r\n            } else if (hex.length === 6) {\r\n                return {\r\n                    r: parseInt(hex.slice(0, 2), 16),\r\n                    g: parseInt(hex.slice(2, 4), 16),\r\n                    b: parseInt(hex.slice(4, 6), 16)\r\n                };\r\n            }\r\n        }\r\n\r\n        // Handle rgb() format\r\n        if (typeof color === 'string' && color.startsWith('rgb')) {\r\n            const match = color.match(/rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)/);\r\n            if (match) {\r\n                return {\r\n                    r: parseInt(match[1]),\r\n                    g: parseInt(match[2]),\r\n                    b: parseInt(match[3])\r\n                };\r\n            }\r\n        }\r\n\r\n        return { r: 255, g: 255, b: 255 };\r\n    }\r\n\r\n    /**\r\n     * Linear interpolation between two colors\r\n     */\r\n    _lerpColor(color1, color2, t) {\r\n        return {\r\n            r: Math.round(color1.r + (color2.r - color1.r) * t),\r\n            g: Math.round(color1.g + (color2.g - color1.g) * t),\r\n            b: Math.round(color1.b + (color2.b - color1.b) * t)\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get the diffuse texture (either loaded or generated)\r\n     */\r\n    getDiffuseTexture() {\r\n        if (this._useProceduralTexture) {\r\n            return this._generatedTexture;\r\n        }\r\n\r\n        // If texture is already loaded, return it\r\n        if (this._diffuseTexture && (this._diffuseTexture instanceof HTMLImageElement ||\r\n            this._diffuseTexture instanceof HTMLCanvasElement ||\r\n            this._diffuseTexture instanceof ImageData)) {\r\n            return this._diffuseTexture;\r\n        }\r\n\r\n        // If texture is a string path, try to load it\r\n        if (typeof this._diffuseTexture === 'string') {\r\n            return this.loadTextureFromPath(this._diffuseTexture);\r\n        }\r\n\r\n        return this._diffuseTexture;\r\n    }\r\n\r\n    /**\r\n     * Enhanced texture loading with caching and multiple fallback methods\r\n     * @param {string} path - Path to the texture\r\n     * @returns {Promise<HTMLImageElement|HTMLCanvasElement|null>} - Loaded texture\r\n     */\r\n    async loadTextureFromPath(path) {\r\n        if (!path) return null;\r\n\r\n        // Check cache first\r\n        if (this._loadedTextures.has(path)) {\r\n            return this._loadedTextures.get(path);\r\n        }\r\n\r\n        // Check if already loading\r\n        if (this._texturePromises.has(path)) {\r\n            return this._texturePromises.get(path);\r\n        }\r\n\r\n        // Create loading promise\r\n        const loadPromise = this._loadTextureWithFallbacks(path);\r\n        this._texturePromises.set(path, loadPromise);\r\n\r\n        try {\r\n            const texture = await loadPromise;\r\n            this._loadedTextures.set(path, texture);\r\n            return texture;\r\n        } catch (error) {\r\n            console.error('Failed to load texture:', path, error);\r\n            this._texturePromises.delete(path);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load texture with multiple fallback methods (similar to SpriteRenderer)\r\n     * @param {string} path - Path to the texture\r\n     * @returns {Promise<HTMLImageElement|HTMLCanvasElement|null>} - Loaded texture\r\n     */\r\n    async _loadTextureWithFallbacks(path) {\r\n        try {\r\n            // PRIORITY 1: Load from AssetManager\r\n            if (window.assetManager) {\r\n                const asset = await window.assetManager.getAssetByPath(path);\r\n                if (asset && (asset instanceof HTMLImageElement || asset instanceof HTMLCanvasElement)) {\r\n                    console.log('Texture loaded from AssetManager:', path);\r\n                    return asset;\r\n                }\r\n            }\r\n\r\n            // PRIORITY 2: Load from FileBrowser (editor mode)\r\n            if (window.editor && window.editor.fileBrowser) {\r\n                try {\r\n                    const texture = await this._loadTextureFromFileBrowser(path);\r\n                    if (texture) {\r\n                        console.log('Texture loaded via FileBrowser:', path);\r\n                        return texture;\r\n                    }\r\n                } catch (error) {\r\n                    console.warn('FileBrowser loading failed:', error);\r\n                }\r\n            }\r\n\r\n            // PRIORITY 3: Direct URL loading (fallback)\r\n            return await this._loadTextureDirect(path);\r\n\r\n        } catch (error) {\r\n            console.error('Error in texture loading pipeline:', error);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Load texture from FileBrowser (editor mode)\r\n     * @param {string} path - Path to the texture\r\n     * @returns {Promise<HTMLImageElement|HTMLCanvasElement|null>} - Loaded texture\r\n     */\r\n    async _loadTextureFromFileBrowser(path) {\r\n        const fileBrowser = window.editor.fileBrowser;\r\n\r\n        // Try to read file content\r\n        const content = await fileBrowser.readFile(path);\r\n        if (!content) {\r\n            throw new Error(`Could not read texture file: ${path}`);\r\n        }\r\n\r\n        // Handle data URL\r\n        if (typeof content === 'string' && content.startsWith('data:image')) {\r\n            return this._loadTextureFromDataURL(content);\r\n        }\r\n\r\n        // Handle base64 or raw content\r\n        if (typeof content === 'string' && !content.startsWith('data:')) {\r\n            const extension = path.split('.').pop().toLowerCase();\r\n            const mimeType = this._getMimeType(extension);\r\n\r\n            let dataUrl;\r\n            if (content.startsWith('data:')) {\r\n                dataUrl = content;\r\n            } else {\r\n                dataUrl = `data:${mimeType};base64,${content}`;\r\n            }\r\n\r\n            return this._loadTextureFromDataURL(dataUrl);\r\n        }\r\n\r\n        // Handle binary content\r\n        if (content instanceof Blob || content instanceof ArrayBuffer) {\r\n            let blob = content;\r\n            if (content instanceof ArrayBuffer) {\r\n                const extension = path.split('.').pop().toLowerCase();\r\n                blob = new Blob([content], { type: `image/${extension}` });\r\n            }\r\n\r\n            const dataUrl = await this._blobToDataURL(blob);\r\n            return this._loadTextureFromDataURL(dataUrl);\r\n        }\r\n\r\n        throw new Error(`Unsupported texture content type: ${typeof content}`);\r\n    }\r\n\r\n    /**\r\n     * Load texture directly from URL/path\r\n     * @param {string} path - Path to the texture\r\n     * @returns {Promise<HTMLImageElement>} - Loaded texture\r\n     */\r\n    async _loadTextureDirect(path) {\r\n        return new Promise((resolve, reject) => {\r\n            const img = new Image();\r\n\r\n            img.onload = () => {\r\n                console.log('Texture loaded successfully:', path);\r\n                resolve(img);\r\n            };\r\n\r\n            img.onerror = () => {\r\n                reject(new Error(`Failed to load texture: ${path}`));\r\n            };\r\n\r\n            // Handle cross-origin if needed\r\n            if (path.startsWith('http') && !path.includes(window.location.hostname)) {\r\n                img.crossOrigin = 'anonymous';\r\n            }\r\n\r\n            img.src = path;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Load texture from data URL\r\n     * @param {string} dataUrl - Data URL of the texture\r\n     * @returns {Promise<HTMLImageElement>} - Loaded texture\r\n     */\r\n    async _loadTextureFromDataURL(dataUrl) {\r\n        return new Promise((resolve, reject) => {\r\n            const img = new Image();\r\n\r\n            img.onload = () => resolve(img);\r\n            img.onerror = () => reject(new Error('Failed to load texture from data URL'));\r\n\r\n            img.src = dataUrl;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Convert blob to data URL\r\n     * @param {Blob} blob - Blob to convert\r\n     * @returns {Promise<string>} - Data URL\r\n     */\r\n    async _blobToDataURL(blob) {\r\n        return new Promise((resolve, reject) => {\r\n            const reader = new FileReader();\r\n            reader.onload = () => resolve(reader.result);\r\n            reader.onerror = reject;\r\n            reader.readAsDataURL(blob);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get MIME type from file extension\r\n     * @param {string} extension - File extension\r\n     * @returns {string} - MIME type\r\n     */\r\n    _getMimeType(extension) {\r\n        const mimeTypes = {\r\n            'png': 'image/png',\r\n            'jpg': 'image/jpeg',\r\n            'jpeg': 'image/jpeg',\r\n            'gif': 'image/gif',\r\n            'webp': 'image/webp',\r\n            'svg': 'image/svg+xml',\r\n            'bmp': 'image/bmp'\r\n        };\r\n\r\n        return mimeTypes[extension] || 'image/png';\r\n    }\r\n\r\n    /**\r\n     * Preload a texture for better performance\r\n     * @param {string} path - Path to the texture to preload\r\n     */\r\n    preloadTexture(path) {\r\n        if (!path || this._loadedTextures.has(path) || this._texturePromises.has(path)) {\r\n            return;\r\n        }\r\n\r\n        // Add to loading queue\r\n        this._textureLoadQueue.push(path);\r\n\r\n        // Process queue if not already processing\r\n        if (this._textureLoadQueue.length === 1) {\r\n            this._processTextureQueue();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Process the texture loading queue\r\n     */\r\n    async _processTextureQueue() {\r\n        while (this._textureLoadQueue.length > 0) {\r\n            const path = this._textureLoadQueue.shift();\r\n            try {\r\n                await this.loadTextureFromPath(path);\r\n            } catch (error) {\r\n                console.warn('Failed to preload texture:', path, error);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clear texture cache\r\n     * @param {string} path - Specific path to clear, or null to clear all\r\n     */\r\n    clearTextureCache(path = null) {\r\n        if (path) {\r\n            this._loadedTextures.delete(path);\r\n            this._texturePromises.delete(path);\r\n        } else {\r\n            this._loadedTextures.clear();\r\n            this._texturePromises.clear();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get texture loading progress\r\n     * @returns {Object} - Loading statistics\r\n     */\r\n    getTextureLoadingStats() {\r\n        return {\r\n            cached: this._loadedTextures.size,\r\n            loading: this._texturePromises.size,\r\n            queued: this._textureLoadQueue.length\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Calculate lighting for a point on a surface\r\n     * @param {Vector3} point - World position of the point\r\n     * @param {Vector3} normal - Surface normal at the point\r\n     * @param {Vector3} viewDir - Direction from point to camera\r\n     * @param {Array} lights - Array of light objects with position, color, intensity\r\n     * @returns {Object} - Lighting result with diffuse, specular, ambient components\r\n     */\r\n    calculateLighting(point, normal, viewDir, lights = []) {\r\n        const result = {\r\n            diffuse: { r: 0, g: 0, b: 0 },\r\n            specular: { r: 0, g: 0, b: 0 },\r\n            ambient: this._parseColor(this._emissiveColor)\r\n        };\r\n\r\n        // Normalize vectors\r\n        const n = normal.clone().normalize();\r\n        const v = viewDir.clone().normalize();\r\n\r\n        for (const light of lights) {\r\n            const lightDir = light.position.clone().sub(point).normalize();\r\n            const lightColor = this._parseColor(light.color || \"#FFFFFF\");\r\n            const intensity = light.intensity || 1.0;\r\n\r\n            // Diffuse lighting (Lambert's cosine law)\r\n            const diffuseFactor = Math.max(0, n.dot(lightDir));\r\n            result.diffuse.r += lightColor.r * diffuseFactor * intensity;\r\n            result.diffuse.g += lightColor.g * diffuseFactor * intensity;\r\n            result.diffuse.b += lightColor.b * diffuseFactor * intensity;\r\n\r\n            // Specular lighting (Phong reflection model)\r\n            if (diffuseFactor > 0) {\r\n                const reflectDir = n.clone().multiplyScalar(2 * n.dot(lightDir)).sub(lightDir);\r\n                const specularFactor = Math.pow(Math.max(0, reflectDir.dot(v)), this._shininess);\r\n                const specularIntensity = intensity * specularFactor;\r\n\r\n                const specularColor = this._parseColor(this._specularColor);\r\n                result.specular.r += specularColor.r * specularIntensity;\r\n                result.specular.g += specularColor.g * specularIntensity;\r\n                result.specular.b += specularColor.b * specularIntensity;\r\n            }\r\n        }\r\n\r\n        // Clamp values to 0-255 range\r\n        const clampColor = (color) => ({\r\n            r: Math.max(0, Math.min(255, color.r)),\r\n            g: Math.max(0, Math.min(255, color.g)),\r\n            b: Math.max(0, Math.min(255, color.b))\r\n        });\r\n\r\n        result.diffuse = clampColor(result.diffuse);\r\n        result.specular = clampColor(result.specular);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Get lit color for a surface point considering material properties\r\n     * @param {Vector3} point - World position of the point\r\n     * @param {Vector3} normal - Surface normal at the point\r\n     * @param {Vector3} viewDir - Direction from point to camera\r\n     * @param {Array} lights - Array of light objects\r\n     * @param {Vector2} uv - UV coordinates for texture sampling\r\n     * @returns {Object} - Final color with RGBA values\r\n     */\r\n    getLitSurfaceColor(point, normal, viewDir, lights = [], uv = new Vector2(0, 0)) {\r\n        // Get base material color from texture or diffuse color\r\n        let baseColor;\r\n        if (this._diffuseTexture) {\r\n            const textureColor = this.sampleTexture(uv.x, uv.y);\r\n            if (textureColor) {\r\n                // Parse RGBA from texture sample\r\n                const match = textureColor.match(/rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*([\\d.]+))?\\)/);\r\n                if (match) {\r\n                    baseColor = {\r\n                        r: parseInt(match[1]),\r\n                        g: parseInt(match[2]),\r\n                        b: parseInt(match[3]),\r\n                        a: match[4] ? parseFloat(match[4]) : 1.0\r\n                    };\r\n                } else {\r\n                    baseColor = this._parseColor(this._diffuseColor);\r\n                }\r\n            } else {\r\n                baseColor = this._parseColor(this._diffuseColor);\r\n            }\r\n        } else {\r\n            baseColor = this._parseColor(this._diffuseColor);\r\n        }\r\n\r\n        // Calculate lighting\r\n        const lighting = this.calculateLighting(point, normal, viewDir, lights);\r\n\r\n        // Combine base color with lighting\r\n        const finalColor = {\r\n            r: Math.round((baseColor.r * (lighting.ambient.r / 255 + lighting.diffuse.r / 255)) + lighting.specular.r),\r\n            g: Math.round((baseColor.g * (lighting.ambient.g / 255 + lighting.diffuse.g / 255)) + lighting.specular.g),\r\n            b: Math.round((baseColor.b * (lighting.ambient.b / 255 + lighting.diffuse.b / 255)) + lighting.specular.b),\r\n            a: baseColor.a * this._opacity\r\n        };\r\n\r\n        // Clamp final values\r\n        finalColor.r = Math.max(0, Math.min(255, finalColor.r));\r\n        finalColor.g = Math.max(0, Math.min(255, finalColor.g));\r\n        finalColor.b = Math.max(0, Math.min(255, finalColor.b));\r\n\r\n        return finalColor;\r\n    }\r\n\r\n    /**\r\n     * Simple lighting setup for scenes without explicit lights\r\n     * @param {Vector3} point - World position of the point\r\n     * @param {Vector3} normal - Surface normal at the point\r\n     * @param {Vector3} viewDir - Direction from point to camera\r\n     * @returns {Object} - Final color with RGBA values\r\n     */\r\n    getSimpleLitColor(point, normal, viewDir, uv = new Vector2(0, 0)) {\r\n        // Default lighting setup\r\n        const defaultLights = [\r\n            {\r\n                position: new Vector3(100, 100, 100),\r\n                color: \"#FFFFFF\",\r\n                intensity: 1.0\r\n            },\r\n            {\r\n                position: new Vector3(-50, -50, 50),\r\n                color: \"#8888FF\",\r\n                intensity: 0.3\r\n            }\r\n        ];\r\n\r\n        return this.getLitSurfaceColor(point, normal, viewDir, defaultLights, uv);\r\n    }\r\n\r\n    /**\r\n     * Sample texture color at UV coordinates\r\n     */\r\n    sampleTexture(u, v, texture = null) {\r\n        const tex = texture || this.getDiffuseTexture();\r\n        if (!tex) {\r\n            // Return diffuse color if no texture\r\n            const color = this._parseColor(this._diffuseColor);\r\n            return `rgba(${color.r}, ${color.g}, ${color.b}, ${this._opacity})`;\r\n        }\r\n\r\n        // Apply UV transformations\r\n        let transformedU = u * this._uvScale.x + this._uvOffset.x;\r\n        let transformedV = v * this._uvScale.y + this._uvOffset.y;\r\n\r\n        // Apply rotation\r\n        if (this._uvRotation !== 0) {\r\n            const rad = this._uvRotation * Math.PI / 180;\r\n            const cos = Math.cos(rad);\r\n            const sin = Math.sin(rad);\r\n            const centerU = 0.5;\r\n            const centerV = 0.5;\r\n\r\n            transformedU -= centerU;\r\n            transformedV -= centerV;\r\n\r\n            const rotatedU = transformedU * cos - transformedV * sin;\r\n            const rotatedV = transformedU * sin + transformedV * cos;\r\n\r\n            transformedU = rotatedU + centerU;\r\n            transformedV = rotatedV + centerV;\r\n        }\r\n\r\n        // Wrap UV coordinates\r\n        transformedU = ((transformedU % 1) + 1) % 1;\r\n        transformedV = ((transformedV % 1) + 1) % 1;\r\n\r\n        // Sample the texture\r\n        const x = Math.floor(transformedU * tex.width);\r\n        const y = Math.floor(transformedV * tex.height);\r\n\r\n        if (x >= 0 && x < tex.width && y >= 0 && y < tex.height) {\r\n            const canvas = tex;\r\n            const ctx = canvas.getContext('2d');\r\n            const imageData = ctx.getImageData(x, y, 1, 1);\r\n            const data = imageData.data;\r\n\r\n            return `rgba(${data[0]}, ${data[1]}, ${data[2]}, ${data[3] * this._opacity / 255})`;\r\n        }\r\n\r\n        // Fallback to diffuse color\r\n        const color = this._parseColor(this._diffuseColor);\r\n        return `rgba(${color.r}, ${color.g}, ${color.b}, ${this._opacity})`;\r\n    }\r\n\r\n    /**\r\n     * Create a simple test texture for debugging\r\n     */\r\n    createTestTexture() {\r\n        const size = 256;\r\n        const canvas = document.createElement('canvas');\r\n        canvas.width = size;\r\n        canvas.height = size;\r\n        const ctx = canvas.getContext('2d');\r\n\r\n        // Create a colorful test pattern\r\n        for (let y = 0; y < size; y++) {\r\n            for (let x = 0; x < size; x++) {\r\n                const u = x / size;\r\n                const v = y / size;\r\n\r\n                const r = Math.floor(u * 255);\r\n                const g = Math.floor(v * 255);\r\n                const b = Math.floor((u + v) / 2 * 255);\r\n\r\n                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;\r\n                ctx.fillRect(x, y, 1, 1);\r\n            }\r\n        }\r\n\r\n        this._diffuseTexture = canvas;\r\n        this._useProceduralTexture = false;\r\n        this._generatedTexture = null;\r\n\r\n        return canvas;\r\n    }\r\n\r\n    /**\r\n     * Clone this material\r\n     */\r\n    clone() {\r\n        const cloned = new Material();\r\n        cloned._diffuseColor = this._diffuseColor;\r\n        cloned._specularColor = this._specularColor;\r\n        cloned._emissiveColor = this._emissiveColor;\r\n        cloned._shininess = this._shininess;\r\n        cloned._opacity = this._opacity;\r\n        cloned._diffuseTexture = this._diffuseTexture;\r\n        cloned._normalTexture = this._normalTexture;\r\n        cloned._specularTexture = this._specularTexture;\r\n        cloned._emissiveTexture = this._emissiveTexture;\r\n        cloned._useProceduralTexture = this._useProceduralTexture;\r\n        cloned._proceduralType = this._proceduralType;\r\n        cloned._proceduralSeed = this._proceduralSeed;\r\n        cloned._proceduralScale = this._proceduralScale;\r\n        cloned._proceduralColor1 = this._proceduralColor1;\r\n        cloned._proceduralColor2 = this._proceduralColor2;\r\n        cloned._proceduralOctaves = this._proceduralOctaves;\r\n        cloned._proceduralPersistence = this._proceduralPersistence;\r\n        cloned._proceduralLacunarity = this._proceduralLacunarity;\r\n        cloned._uvScale = this._uvScale.clone();\r\n        cloned._uvOffset = this._uvOffset.clone();\r\n        cloned._uvRotation = this._uvRotation;\r\n        cloned._transparent = this._transparent;\r\n        cloned._doubleSided = this._doubleSided;\r\n        cloned._wireframe = this._wireframe;\r\n\r\n        return cloned;\r\n    }\r\n\r\n    /**\r\n     * Serialize material to JSON\r\n     */\r\n    toJSON() {\r\n        return {\r\n            _type: \"Material\",\r\n            _diffuseColor: this._diffuseColor,\r\n            _specularColor: this._specularColor,\r\n            _emissiveColor: this._emissiveColor,\r\n            _shininess: this._shininess,\r\n            _opacity: this._opacity,\r\n            _diffuseTexture: this._diffuseTexture,\r\n            _normalTexture: this._normalTexture,\r\n            _specularTexture: this._specularTexture,\r\n            _emissiveTexture: this._emissiveTexture,\r\n            _useProceduralTexture: this._useProceduralTexture,\r\n            _proceduralType: this._proceduralType,\r\n            _proceduralSeed: this._proceduralSeed,\r\n            _proceduralScale: this._proceduralScale,\r\n            _proceduralColor1: this._proceduralColor1,\r\n            _proceduralColor2: this._proceduralColor2,\r\n            _proceduralOctaves: this._proceduralOctaves,\r\n            _proceduralPersistence: this._proceduralPersistence,\r\n            _proceduralLacunarity: this._proceduralLacunarity,\r\n            _uvScale: { x: this._uvScale.x, y: this._uvScale.y },\r\n            _uvOffset: { x: this._uvOffset.x, y: this._uvOffset.y },\r\n            _uvRotation: this._uvRotation,\r\n            _transparent: this._transparent,\r\n            _doubleSided: this._doubleSided,\r\n            _wireframe: this._wireframe\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Deserialize material from JSON\r\n     */\r\n    fromJSON(json) {\r\n        if (json._diffuseColor !== undefined) this._diffuseColor = json._diffuseColor;\r\n        if (json._specularColor !== undefined) this._specularColor = json._specularColor;\r\n        if (json._emissiveColor !== undefined) this._emissiveColor = json._emissiveColor;\r\n        if (json._shininess !== undefined) this._shininess = json._shininess;\r\n        if (json._opacity !== undefined) {\r\n            this._opacity = json._opacity;\r\n            this._transparent = json._opacity < 1.0;\r\n        }\r\n        if (json._diffuseTexture !== undefined) this._diffuseTexture = json._diffuseTexture;\r\n        if (json._normalTexture !== undefined) this._normalTexture = json._normalTexture;\r\n        if (json._specularTexture !== undefined) this._specularTexture = json._specularTexture;\r\n        if (json._emissiveTexture !== undefined) this._emissiveTexture = json._emissiveTexture;\r\n        if (json._useProceduralTexture !== undefined) this._useProceduralTexture = json._useProceduralTexture;\r\n        if (json._proceduralType !== undefined) this._proceduralType = json._proceduralType;\r\n        if (json._proceduralSeed !== undefined) this._proceduralSeed = json._proceduralSeed;\r\n        if (json._proceduralScale !== undefined) this._proceduralScale = json._proceduralScale;\r\n        if (json._proceduralColor1 !== undefined) this._proceduralColor1 = json._proceduralColor1;\r\n        if (json._proceduralColor2 !== undefined) this._proceduralColor2 = json._proceduralColor2;\r\n        if (json._proceduralOctaves !== undefined) this._proceduralOctaves = json._proceduralOctaves;\r\n        if (json._proceduralPersistence !== undefined) this._proceduralPersistence = json._proceduralPersistence;\r\n        if (json._proceduralLacunarity !== undefined) this._proceduralLacunarity = json._proceduralLacunarity;\r\n        if (json._uvScale) this._uvScale = new Vector2(json._uvScale.x, json._uvScale.y);\r\n        if (json._uvOffset) this._uvOffset = new Vector2(json._uvOffset.x, json._uvOffset.y);\r\n        if (json._uvRotation !== undefined) this._uvRotation = json._uvRotation;\r\n        if (json._transparent !== undefined) this._transparent = json._transparent;\r\n        if (json._doubleSided !== undefined) this._doubleSided = json._doubleSided;\r\n        if (json._wireframe !== undefined) this._wireframe = json._wireframe;\r\n\r\n        // Regenerate procedural texture if needed\r\n        if (this._useProceduralTexture) {\r\n            this.generateProceduralTexture();\r\n        }\r\n    }\r\n\r\n    // Getters and setters\r\n    get diffuseColor() { return this._diffuseColor; }\r\n    set diffuseColor(value) { this._diffuseColor = value; }\r\n\r\n    get specularColor() { return this._specularColor; }\r\n    set specularColor(value) { this._specularColor = value; }\r\n\r\n    get emissiveColor() { return this._emissiveColor; }\r\n    set emissiveColor(value) { this._emissiveColor = value; }\r\n\r\n    get shininess() { return this._shininess; }\r\n    set shininess(value) { this._shininess = Math.max(1, Math.min(128, value)); }\r\n\r\n    get opacity() { return this._opacity; }\r\n    set opacity(value) {\r\n        this._opacity = Math.max(0, Math.min(1, value));\r\n        this._transparent = this._opacity < 1.0;\r\n    }\r\n\r\n    get diffuseTexture() { return this._diffuseTexture; }\r\n    set diffuseTexture(value) {\r\n        this._diffuseTexture = value;\r\n        this._useProceduralTexture = false;\r\n        this._generatedTexture = null;\r\n\r\n        // Preload texture if it's a path\r\n        if (typeof value === 'string') {\r\n            this.preloadTexture(value);\r\n        }\r\n    }\r\n\r\n    get useProceduralTexture() { return this._useProceduralTexture; }\r\n    set useProceduralTexture(value) {\r\n        this._useProceduralTexture = value;\r\n        if (value) {\r\n            this._diffuseTexture = null;\r\n            this.generateProceduralTexture();\r\n        }\r\n    }\r\n\r\n    get proceduralType() { return this._proceduralType; }\r\n    set proceduralType(value) { this._proceduralType = value; }\r\n\r\n    get proceduralSeed() { return this._proceduralSeed; }\r\n    set proceduralSeed(value) { this._proceduralSeed = value; }\r\n\r\n    get proceduralScale() { return this._proceduralScale; }\r\n    set proceduralScale(value) { this._proceduralScale = value; }\r\n\r\n    get proceduralColor1() { return this._proceduralColor1; }\r\n    set proceduralColor1(value) { this._proceduralColor1 = value; }\r\n\r\n    get proceduralColor2() { return this._proceduralColor2; }\r\n    set proceduralColor2(value) { this._proceduralColor2 = value; }\r\n\r\n    get uvScale() { return this._uvScale; }\r\n    set uvScale(value) { this._uvScale = value; }\r\n\r\n    get uvOffset() { return this._uvOffset; }\r\n    set uvOffset(value) { this._uvOffset = value; }\r\n\r\n    get uvRotation() { return this._uvRotation; }\r\n    set uvRotation(value) { this._uvRotation = value; }\r\n\r\n    get transparent() { return this._transparent; }\r\n    set transparent(value) { this._transparent = value; }\r\n\r\n    get doubleSided() { return this._doubleSided; }\r\n    set doubleSided(value) { this._doubleSided = value; }\r\n\r\n    get wireframe() { return this._wireframe; }\r\n    set wireframe(value) { this._wireframe = value; }\r\n}\r\n\r\n// Register the Material module\r\nwindow.Material = Material;",
      "type": "file",
      "name": "Material.js",
      "parentPath": "/",
      "created": 1759457099332,
      "modified": 1759457099332
    },
    {
      "path": "/Mesh3D.js",
      "content": "/**\r\n * Mesh3D - A 3D mesh renderer for the Dark Matter JS engine\r\n * \r\n * This module renders 3D meshes using the 2D canvas API.\r\n */\r\nclass Mesh3D extends Module {\r\n    static namespace = \"3D\";\r\n\r\n    /**\r\n     * Create a new Mesh3D\r\n     */\r\n    constructor() {\r\n        super(\"Mesh3D\");\r\n\r\n        // Mesh data\r\n        this.vertices = []; // Array of Vector3 objects\r\n        this.edges = [];    // Array of pairs of vertex indices\r\n        this.faces = [];    // Array of arrays of vertex indices\r\n\r\n        // Mesh properties\r\n        this.position = new Vector3(0, 0, 0);\r\n        this.rotation = new Vector3(0, 0, 0);\r\n        this.scale = new Vector3(1, 1, 1);\r\n\r\n        // Appearance\r\n        this.wireframeColor = \"#FFFFFF\";\r\n        this.faceColor = \"#3F51B5\";\r\n        this.renderMode = \"solid\"; // \"wireframe\", \"solid\", or \"both\"\r\n\r\n        // Material system\r\n        this.material = null; // Material instance for advanced texturing\r\n\r\n        // Axis visualization\r\n        this._showAxisLines = false;\r\n        this._axisLength = 150;\r\n\r\n        // Expose properties to the inspector\r\n        this.exposeProperty(\"position\", \"vector3\", this.position, {\r\n            onChange: (val) => this.position = val\r\n        });\r\n        this.exposeProperty(\"rotation\", \"vector3\", this.rotation, {\r\n            onChange: (val) => this.rotation = val\r\n        });\r\n        this.exposeProperty(\"scale\", \"vector3\", this.scale, {\r\n            onChange: (val) => this.scale = val\r\n        });\r\n        this.exposeProperty(\"wireframeColor\", \"color\", \"#FFFFFF\", {\r\n            onChange: (val) => this.wireframeColor = val\r\n        });\r\n        this.exposeProperty(\"faceColor\", \"color\", \"#3F51B5\", {\r\n            onChange: (val) => this.faceColor = val\r\n        });\r\n        this.exposeProperty(\"renderMode\", \"enum\", \"wireframe\", {\r\n            options: [\"wireframe\", \"solid\", \"both\"],\r\n            onChange: (val) => this.renderMode = val\r\n        });\r\n\r\n        this.exposeProperty(\"material\", \"module\", null, {\r\n            moduleType: \"Material\",\r\n            onChange: (val) => this.material = val\r\n        });\r\n\r\n        this.exposeProperty(\"showAxisLines\", \"boolean\", false, {\r\n            onChange: (val) => this._showAxisLines = val\r\n        });\r\n\r\n        this.exposeProperty(\"axisLength\", \"number\", 150, {\r\n            min: 50,\r\n            max: 500,\r\n            onChange: (val) => this._axisLength = val\r\n        });\r\n\r\n        // Initialize with a default cube\r\n        this.createCube(100);\r\n\r\n        // Generate UV coordinates for texture mapping\r\n        this.generateUVCoordinates();\r\n\r\n        // Ensure material module exists on the game object\r\n        this.ensureMaterialModule();\r\n    }\r\n\r\n    /**\r\n     * Ensure the game object has a Material module\r\n     */\r\n    ensureMaterialModule() {\r\n        if (!this.gameObject) return;\r\n\r\n        // Check if material module already exists\r\n        let materialModule = this.gameObject.getModule ? this.gameObject.getModule('Material') : null;\r\n        if (!materialModule) {\r\n            // Create and add a new material module\r\n            materialModule = new Material();\r\n            if (this.gameObject.addModule) {\r\n                this.gameObject.addModule(materialModule);\r\n            }\r\n        }\r\n\r\n        // Set the material reference\r\n        this.material = materialModule;\r\n    }\r\n\r\n    /**\r\n     * Generate UV coordinates for texture mapping\r\n     */\r\n    generateUVCoordinates() {\r\n        this.uvCoordinates = [];\r\n\r\n        for (let i = 0; i < this.vertices.length; i++) {\r\n            const vertex = this.vertices[i];\r\n\r\n            // Simple planar projection for UV mapping\r\n            // This is a basic implementation - can be improved for different mesh types\r\n            let u, v;\r\n\r\n            if (Math.abs(vertex.x) > Math.abs(vertex.y) && Math.abs(vertex.x) > Math.abs(vertex.z)) {\r\n                // X-dominant face\r\n                u = (vertex.y + 1) / 2;\r\n                v = (vertex.z + 1) / 2;\r\n            } else if (Math.abs(vertex.y) > Math.abs(vertex.x) && Math.abs(vertex.y) > Math.abs(vertex.z)) {\r\n                // Y-dominant face\r\n                u = (vertex.x + 1) / 2;\r\n                v = (vertex.z + 1) / 2;\r\n            } else {\r\n                // Z-dominant face\r\n                u = (vertex.x + 1) / 2;\r\n                v = (vertex.y + 1) / 2;\r\n            }\r\n\r\n            this.uvCoordinates.push(new Vector2(u, v));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get material color for a face, considering texture if available\r\n     * @param {Array<number>} face - Array of vertex indices\r\n     * @param {Array<Vector3>} worldVertices - World-space vertex positions\r\n     * @param {Camera3D} camera - Camera for view direction calculation\r\n     * @param {Array<Vector3>} normals - Face normals (optional)\r\n     * @returns {string} - CSS color string\r\n     */\r\n    getMaterialColor(face, worldVertices, camera, normals = null) {\r\n        if (!this.material) {\r\n            return this.faceColor;\r\n        }\r\n\r\n        // For simple flat shading, use face center\r\n        const faceCenter = this.getFaceCenter(face, worldVertices);\r\n        const normal = normals ? normals[0] : this.calculateFaceNormal(face, worldVertices);\r\n\r\n        if (camera && camera.position) {\r\n            const viewDir = camera.position.clone().sub(faceCenter).normalize();\r\n\r\n            // Calculate UV coordinates for face center (simple average)\r\n            const uvs = face.map(vertexIndex => this.uvCoordinates[vertexIndex] || new Vector2(0, 0));\r\n            const avgU = uvs.reduce((sum, uv) => sum + uv.x, 0) / uvs.length;\r\n            const avgV = uvs.reduce((sum, uv) => sum + uv.y, 0) / uvs.length;\r\n\r\n            // Get lit color from material\r\n            const litColor = this.material.getSimpleLitColor(faceCenter, normal, viewDir, new Vector2(avgU, avgV));\r\n\r\n            return `rgba(${Math.round(litColor.r)}, ${Math.round(litColor.g)}, ${Math.round(litColor.b)}, ${litColor.a})`;\r\n        }\r\n\r\n        // Fallback to diffuse color if no camera\r\n        return this.material.diffuseColor;\r\n    }\r\n\r\n    /**\r\n     * Calculate face center from vertex indices\r\n     * @param {Array<number>} face - Array of vertex indices\r\n     * @param {Array<Vector3>} vertices - Array of vertex positions\r\n     * @returns {Vector3} - Face center position\r\n     */\r\n    getFaceCenter(face, vertices) {\r\n        const center = new Vector3(0, 0, 0);\r\n        for (const vertexIndex of face) {\r\n            if (vertexIndex < vertices.length) {\r\n                center.add(vertices[vertexIndex]);\r\n            }\r\n        }\r\n        center.divideScalar(face.length);\r\n        return center;\r\n    }\r\n\r\n    /**\r\n     * Calculate face normal from vertex positions\r\n     * @param {Array<number>} face - Array of vertex indices\r\n     * @param {Array<Vector3>} vertices - Array of vertex positions\r\n     * @returns {Vector3} - Face normal vector\r\n     */\r\n    calculateFaceNormal(face, vertices) {\r\n        if (face.length < 3) {\r\n            return new Vector3(0, 0, 1);\r\n        }\r\n\r\n        // Use first three vertices to calculate normal\r\n        const v1 = vertices[face[0]];\r\n        const v2 = vertices[face[1]];\r\n        const v3 = vertices[face[2]];\r\n\r\n        if (!v1 || !v2 || !v3) {\r\n            return new Vector3(0, 0, 1);\r\n        }\r\n\r\n        // Calculate two edges\r\n        const edge1 = v2.clone().sub(v1);\r\n        const edge2 = v3.clone().sub(v1);\r\n\r\n        // Calculate cross product for normal\r\n        const normal = edge1.clone().cross(edge2).normalize();\r\n\r\n        return normal;\r\n    }\r\n\r\n    /**\r\n     * Create a cube mesh\r\n     * @param {number} size - Size of the cube\r\n     */\r\n    createCube(size = 100) {\r\n        const s = size / 2;\r\n\r\n        this.vertices = [\r\n            new Vector3(-s, -s, -s), // 0: back-bottom-left\r\n            new Vector3(-s, s, -s),  // 1: back-bottom-right\r\n            new Vector3(s, s, -s),   // 2: back-top-right\r\n            new Vector3(s, -s, -s),  // 3: back-top-left\r\n            new Vector3(-s, -s, s),  // 4: front-bottom-left\r\n            new Vector3(-s, s, s),   // 5: front-bottom-right\r\n            new Vector3(s, s, s),    // 6: front-top-right\r\n            new Vector3(s, -s, s)    // 7: front-top-left\r\n        ];\r\n\r\n        this.edges = [\r\n            [0, 1], [1, 2], [2, 3], [3, 0], // back face\r\n            [4, 5], [5, 6], [6, 7], [7, 4], // front face\r\n            [0, 4], [1, 5], [2, 6], [3, 7]  // connecting edges\r\n        ];\r\n\r\n        this.faces = [\r\n            [0, 1, 2, 3], // back face\r\n            [4, 5, 6, 7], // front face\r\n            [0, 4, 7, 3], // left face\r\n            [1, 5, 6, 2], // right face\r\n            [3, 2, 6, 7], // top face\r\n            [0, 1, 5, 4]  // bottom face\r\n        ];\r\n\r\n        // Regenerate UV coordinates after changing mesh data\r\n        this.generateUVCoordinates();\r\n    }\r\n\r\n    /**\r\n     * Create a pyramid mesh\r\n     * @param {number} baseSize - Size of the base\r\n     * @param {number} height - Height of the pyramid\r\n     */\r\n    createPyramid(baseSize = 100, height = 150) {\r\n        const s = baseSize / 2;\r\n        const h = height / 2;\r\n\r\n        this.vertices = [\r\n            new Vector3(-s, -h, -s), // 0: base back-left\r\n            new Vector3(s, -h, -s),  // 1: base back-right\r\n            new Vector3(s, -h, s),   // 2: base front-right\r\n            new Vector3(-s, -h, s),  // 3: base front-left\r\n            new Vector3(0, h, 0)     // 4: apex\r\n        ];\r\n\r\n        this.edges = [\r\n            [0, 1], [1, 2], [2, 3], [3, 0], // base\r\n            [0, 4], [1, 4], [2, 4], [3, 4]  // edges to apex\r\n        ];\r\n\r\n        this.faces = [\r\n            [0, 1, 2, 3], // base\r\n            [0, 1, 4],    // back face\r\n            [1, 2, 4],    // right face\r\n            [2, 3, 4],    // front face\r\n            [3, 0, 4]     // left face\r\n        ];\r\n\r\n        // Regenerate UV coordinates after changing mesh data\r\n        this.generateUVCoordinates();\r\n    }\r\n\r\n    /**\r\n     * Create a sphere mesh (approximation using triangles)\r\n     * @param {number} radius - Radius of the sphere\r\n     * @param {number} detail - Level of detail (segments)\r\n     */\r\n    createSphere(radius = 100, detail = 12) {\r\n        // Reset mesh data\r\n        this.vertices = [];\r\n        this.edges = [];\r\n        this.faces = [];\r\n\r\n        // Create vertices using spherical coordinates\r\n        for (let lat = 0; lat <= detail; lat++) {\r\n            const theta = lat * Math.PI / detail;\r\n            const sinTheta = Math.sin(theta);\r\n            const cosTheta = Math.cos(theta);\r\n\r\n            for (let lon = 0; lon <= detail; lon++) {\r\n                const phi = lon * 2 * Math.PI / detail;\r\n                const sinPhi = Math.sin(phi);\r\n                const cosPhi = Math.cos(phi);\r\n\r\n                const x = radius * sinTheta * cosPhi;\r\n                const y = radius * cosTheta;\r\n                const z = radius * sinTheta * sinPhi;\r\n\r\n                this.vertices.push(new Vector3(x, y, z));\r\n            }\r\n        }\r\n\r\n        // Create faces and edges\r\n        for (let lat = 0; lat < detail; lat++) {\r\n            for (let lon = 0; lon < detail; lon++) {\r\n                const first = lat * (detail + 1) + lon;\r\n                const second = first + detail + 1;\r\n\r\n                // Create two triangular faces\r\n                this.faces.push([first, first + 1, second + 1]);\r\n                this.faces.push([first, second + 1, second]);\r\n\r\n                // Add edges\r\n                this.edges.push([first, first + 1]);\r\n                this.edges.push([first, second]);\r\n\r\n                if (lat === detail - 1) {\r\n                    this.edges.push([second, second + 1]);\r\n                }\r\n\r\n                if (lon === detail - 1) {\r\n                    this.edges.push([first + 1, second + 1]);\r\n                }\r\n            }\r\n        }\r\n\r\n        // Regenerate UV coordinates after changing mesh data\r\n        this.generateUVCoordinates();\r\n    }\r\n\r\n    /**\r\n     * Create a custom mesh from vertices, edges, and faces\r\n     * @param {Array<Vector3>} vertices - Array of 3D points\r\n     * @param {Array<Array<number>>} edges - Array of vertex index pairs\r\n     * @param {Array<Array<number>>} faces - Array of vertex index arrays\r\n     */\r\n    setMeshData(vertices, edges, faces) {\r\n        this.vertices = vertices;\r\n        this.edges = edges || [];\r\n        this.faces = faces || [];\r\n\r\n        // Regenerate UV coordinates after changing mesh data\r\n        this.generateUVCoordinates();\r\n    }\r\n\r\n    /**\r\n     * Draw the mesh to the canvas\r\n     * @param {CanvasRenderingContext2D} ctx - The canvas context to draw on\r\n     */\r\n    draw(ctx) {\r\n        // Find an active camera\r\n        const camera = this.findActiveCamera();\r\n        if (!camera) {\r\n            // Draw a placeholder if no camera is available\r\n            this.drawPlaceholder(ctx);\r\n            return;\r\n        }\r\n\r\n        // Use render texture method if camera supports it\r\n        if (camera.getRenderTextureContext && camera.render3D) {\r\n            this.drawToRenderTexture(camera.getRenderTextureContext(), camera);\r\n        } else {\r\n            // Fallback to direct drawing\r\n            this.drawDirect(ctx, camera);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draw directly to a canvas context (fallback method)\r\n     * @param {CanvasRenderingContext2D} ctx - The canvas context to draw on\r\n     * @param {Camera3D} camera - The camera to use for projection\r\n     */\r\n    drawDirect(ctx, camera) {\r\n        // Transform vertices based on mesh position/rotation/scale and game object transform\r\n        const transformedVertices = this.transformVertices();\r\n\r\n        // Project the 3D vertices to 2D screen space\r\n        const projectedVertices = transformedVertices.map(vertex =>\r\n            camera.projectPoint(vertex)\r\n        );\r\n\r\n        // Sort faces by depth for basic depth sorting (painter's algorithm)\r\n        const sortedFaces = [...this.faces]\r\n            .map((face, index) => {\r\n                // Calculate centroid depth for more stable sorting\r\n                const centroidX = face.reduce((sum, vertexIndex) => sum + transformedVertices[vertexIndex].x, 0) / face.length;\r\n                const centroidY = face.reduce((sum, vertexIndex) => sum + transformedVertices[vertexIndex].y, 0) / face.length;\r\n                const centroidZ = face.reduce((sum, vertexIndex) => sum + transformedVertices[vertexIndex].z, 0) / face.length;\r\n\r\n                // Use centroid X as primary depth (camera looks along +X)\r\n                // Add small offset based on face center to handle coplanar faces\r\n                const sortDepth = centroidX + (centroidY + centroidZ) * 0.001;\r\n\r\n                return { face, sortDepth };\r\n            })\r\n            .sort((a, b) => b.sortDepth - a.sortDepth) // Sort back-to-front (lower depth values first = closer to camera)\r\n            .map(item => item.face);\r\n\r\n        // Draw faces in sorted order\r\n        if (this.renderMode === \"solid\" || this.renderMode === \"both\") {\r\n            for (const face of sortedFaces) {\r\n                if (face.length < 3) continue; // Need at least 3 points to draw a face\r\n\r\n                // Check if all vertices are visible\r\n                const isVisible = face.every(vertexIndex =>\r\n                    projectedVertices[vertexIndex] !== null &&\r\n                    vertexIndex < projectedVertices.length\r\n                );\r\n                if (!isVisible) continue;\r\n\r\n                // Get lit material color for this face\r\n                const faceColor = this.getMaterialColor(face, transformedVertices, camera);\r\n\r\n                // Draw the face\r\n                ctx.fillStyle = faceColor;\r\n                ctx.beginPath();\r\n                ctx.moveTo(projectedVertices[face[0]].x, projectedVertices[face[0]].y);\r\n\r\n                for (let i = 1; i < face.length; i++) {\r\n                    ctx.lineTo(projectedVertices[face[i]].x, projectedVertices[face[i]].y);\r\n                }\r\n\r\n                ctx.closePath();\r\n                ctx.fill();\r\n            }\r\n        }\r\n\r\n        // Draw edges\r\n        if (this.renderMode === \"wireframe\" || this.renderMode === \"both\") {\r\n            ctx.strokeStyle = this.wireframeColor;\r\n            ctx.lineWidth = 1;\r\n\r\n            for (const [from, to] of this.edges) {\r\n                // Check if both vertices are valid and visible\r\n                if (from >= projectedVertices.length ||\r\n                    to >= projectedVertices.length ||\r\n                    projectedVertices[from] === null ||\r\n                    projectedVertices[to] === null) {\r\n                    continue;\r\n                }\r\n\r\n                ctx.beginPath();\r\n                ctx.moveTo(projectedVertices[from].x, projectedVertices[from].y);\r\n                ctx.lineTo(projectedVertices[to].x, projectedVertices[to].y);\r\n                ctx.stroke();\r\n            }\r\n        }\r\n\r\n        // Draw axis lines if enabled\r\n        if (this.showAxisLines) {\r\n            this.drawAxisLines(ctx, projectedVertices);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draw the mesh to a render texture\r\n     * @param {CanvasRenderingContext2D} ctx - The render texture context\r\n     * @param {Camera3D} camera - The camera to use for projection\r\n     */\r\n    drawToRenderTexture(ctx, camera) {\r\n        // Transform vertices based on mesh position/rotation/scale and game object transform\r\n        const transformedVertices = this.transformVertices();\r\n\r\n        // Project the 3D vertices to 2D screen space\r\n        const projectedVertices = transformedVertices.map(vertex =>\r\n            camera.projectPoint(vertex)\r\n        );\r\n\r\n        // Sort faces by depth for basic depth sorting (painter's algorithm)\r\n        const sortedFaces = [...this.faces]\r\n            .map((face, index) => {\r\n                // Calculate centroid depth for more stable sorting\r\n                const centroidX = face.reduce((sum, vertexIndex) => sum + transformedVertices[vertexIndex].x, 0) / face.length;\r\n                const centroidY = face.reduce((sum, vertexIndex) => sum + transformedVertices[vertexIndex].y, 0) / face.length;\r\n                const centroidZ = face.reduce((sum, vertexIndex) => sum + transformedVertices[vertexIndex].z, 0) / face.length;\r\n\r\n                // Use centroid X as primary depth (camera looks along +X)\r\n                // Add small offset based on face center to handle coplanar faces\r\n                const sortDepth = centroidX + (centroidY + centroidZ) * 0.001;\r\n\r\n                return { face, sortDepth };\r\n            })\r\n            .sort((a, b) => b.sortDepth - a.sortDepth) // Sort back-to-front (lower depth values first = closer to camera)\r\n            .map(item => item.face);\r\n\r\n        // Draw faces in sorted order\r\n        if (this.renderMode === \"solid\" || this.renderMode === \"both\") {\r\n            for (const face of sortedFaces) {\r\n                if (face.length < 3) continue; // Need at least 3 points to draw a face\r\n\r\n                // Check if vertices are valid and get projected vertices\r\n                const validVertices = [];\r\n                for (const vertexIndex of face) {\r\n                    if (vertexIndex < projectedVertices.length &&\r\n                        projectedVertices[vertexIndex] !== null) {\r\n                        validVertices.push(projectedVertices[vertexIndex]);\r\n                    }\r\n                }\r\n\r\n                if (validVertices.length < 3) continue;\r\n\r\n                // Get lit material color for this face\r\n                const faceColor = this.getMaterialColor(face, transformedVertices, camera);\r\n\r\n                // Draw the face using valid vertices\r\n                ctx.fillStyle = faceColor;\r\n                ctx.beginPath();\r\n                ctx.moveTo(validVertices[0].x, validVertices[0].y);\r\n\r\n                for (let i = 1; i < validVertices.length; i++) {\r\n                    ctx.lineTo(validVertices[i].x, validVertices[i].y);\r\n                }\r\n\r\n                ctx.closePath();\r\n                ctx.fill();\r\n            }\r\n        }\r\n\r\n        // Draw edges\r\n        if (this.renderMode === \"wireframe\" || this.renderMode === \"both\") {\r\n            ctx.strokeStyle = this.wireframeColor;\r\n            ctx.lineWidth = 2;\r\n\r\n            for (const [from, to] of this.edges) {\r\n                // Check if both vertices are valid and visible\r\n                if (from >= projectedVertices.length ||\r\n                    to >= projectedVertices.length ||\r\n                    projectedVertices[from] === null ||\r\n                    projectedVertices[to] === null) {\r\n                    continue;\r\n                }\r\n\r\n                const fromVertex = projectedVertices[from];\r\n                const toVertex = projectedVertices[to];\r\n\r\n                ctx.beginPath();\r\n                ctx.moveTo(fromVertex.x, fromVertex.y);\r\n                ctx.lineTo(toVertex.x, toVertex.y);\r\n                ctx.stroke();\r\n            }\r\n        }\r\n\r\n        // Draw axis lines if enabled\r\n        if (this.showAxisLines) {\r\n            this.drawAxisLines(ctx, projectedVertices);\r\n        }\r\n    }\r\n\r\n    /**\r\n      * Draw colored axis lines for visualization\r\n      * @param {CanvasRenderingContext2D} ctx - The render texture context\r\n      * @param {Array<Vector2>} vertices - The projected vertices array\r\n      */\r\n    drawAxisLines(ctx, vertices) {\r\n        if (vertices.length === 0) return;\r\n\r\n        // Calculate center point from valid vertices\r\n        let centerX = 0, centerY = 0;\r\n        let validVertices = 0;\r\n\r\n        for (const vertex of vertices) {\r\n            if (vertex !== null) {\r\n                centerX += vertex.x;\r\n                centerY += vertex.y;\r\n                validVertices++;\r\n            }\r\n        }\r\n\r\n        if (validVertices === 0) return;\r\n\r\n        centerX /= validVertices;\r\n        centerY /= validVertices;\r\n\r\n        const axisLength = this.axisLength;\r\n        const centerPoint = new Vector2(centerX, centerY);\r\n\r\n        // Define axis endpoints in 3D space (relative to mesh position) - Z-up coordinate system\r\n        const axes = {\r\n            x: new Vector3(axisLength, 0, 0),    // Red - X axis (forward/back)\r\n            y: new Vector3(0, axisLength, 0),    // Blue - Y axis (left/right)\r\n            z: new Vector3(0, 0, axisLength)     // Green - Z axis (up/down)\r\n        };\r\n\r\n        // Project axis endpoints to screen space\r\n        const projectedAxes = {};\r\n        for (const [axis, endpoint] of Object.entries(axes)) {\r\n            const worldPoint = new Vector3(\r\n                endpoint.x + this.position.x,\r\n                endpoint.y + this.position.y,\r\n                endpoint.z + this.position.z\r\n            );\r\n            projectedAxes[axis] = this.projectPointRelative(worldPoint, centerPoint);\r\n        }\r\n\r\n        // Draw axis lines with colors\r\n        const axisColors = {\r\n            x: '#ff0000', // Red - X axis (forward/back)\r\n            y: '#0000ff', // Blue - Y axis (left/right)\r\n            z: '#00ff00'  // Green - Z axis (up/down)\r\n        };\r\n\r\n        const axisLabels = {\r\n            x: 'X',\r\n            y: 'Y',\r\n            z: 'Z'\r\n        };\r\n\r\n        ctx.font = '12px Arial';\r\n        ctx.textAlign = 'center';\r\n        ctx.textBaseline = 'middle';\r\n\r\n        for (const [axis, color] of Object.entries(axisColors)) {\r\n            const endPoint = projectedAxes[axis];\r\n            if (!endPoint) continue;\r\n\r\n            // Draw axis line\r\n            ctx.strokeStyle = color;\r\n            ctx.lineWidth = 3;\r\n            ctx.beginPath();\r\n            ctx.moveTo(centerX, centerY);\r\n            ctx.lineTo(endPoint.x, endPoint.y);\r\n            ctx.stroke();\r\n\r\n            // Draw axis label at the end\r\n            ctx.fillStyle = color;\r\n            ctx.fillText(axisLabels[axis], endPoint.x, endPoint.y);\r\n\r\n            // Draw arrowhead (small triangle)\r\n            this.drawArrowhead(ctx, centerX, centerY, endPoint.x, endPoint.y, color);\r\n        }\r\n\r\n        // Draw axis legend\r\n        ctx.fillStyle = '#ffffff';\r\n        ctx.font = '10px Arial';\r\n        ctx.textAlign = 'left';\r\n        ctx.fillText('X: Forward/Back (Red)', centerX + 10, centerY - 30);\r\n        ctx.fillText('Y: Left/Right (Blue)', centerX + 10, centerY - 18);\r\n        ctx.fillText('Z: Up/Down (Green)', centerX + 10, centerY - 6);\r\n    }\r\n\r\n    /**\r\n      * Project a point relative to an origin for axis drawing\r\n      * @param {Vector3} worldPoint - The world point to project\r\n      * @param {Vector2} origin - The origin point\r\n      * @returns {Vector2|null} The projected point\r\n      */\r\n    projectPointRelative(worldPoint, origin) {\r\n        // Find active camera\r\n        const camera = this.findActiveCamera();\r\n        if (!camera) return null;\r\n\r\n        // Project the point\r\n        const projected = camera.projectPoint(worldPoint);\r\n        return projected;\r\n    }\r\n\r\n    /**\r\n      * Draw an arrowhead at the end of an axis line\r\n      * @param {CanvasRenderingContext2D} ctx - The canvas context\r\n      * @param {number} fromX - Start X coordinate\r\n      * @param {number} fromY - Start Y coordinate\r\n      * @param {number} toX - End X coordinate\r\n      * @param {number} toY - End Y coordinate\r\n      * @param {string} color - The color of the arrowhead\r\n      */\r\n    drawArrowhead(ctx, fromX, fromY, toX, toY, color) {\r\n        const headLength = 8;\r\n        const headAngle = Math.PI / 6; // 30 degrees\r\n\r\n        // Calculate direction vector\r\n        const dx = toX - fromX;\r\n        const dy = toY - fromY;\r\n        const length = Math.sqrt(dx * dx + dy * dy);\r\n\r\n        if (length === 0) return;\r\n\r\n        // Calculate unit vector\r\n        const unitX = dx / length;\r\n        const unitY = dy / length;\r\n\r\n        // Calculate perpendicular vector for arrowhead\r\n        const perpX = -unitY;\r\n        const perpY = unitX;\r\n\r\n        // Calculate arrowhead points\r\n        const arrowX1 = toX - headLength * (unitX * Math.cos(headAngle) - perpX * Math.sin(headAngle));\r\n        const arrowY1 = toY - headLength * (unitY * Math.cos(headAngle) - perpY * Math.sin(headAngle));\r\n        const arrowX2 = toX - headLength * (unitX * Math.cos(headAngle) + perpX * Math.sin(headAngle));\r\n        const arrowY2 = toY - headLength * (unitY * Math.cos(headAngle) + perpY * Math.sin(headAngle));\r\n\r\n        // Draw arrowhead\r\n        ctx.strokeStyle = color;\r\n        ctx.lineWidth = 2;\r\n        ctx.beginPath();\r\n        ctx.moveTo(toX, toY);\r\n        ctx.lineTo(arrowX1, arrowY1);\r\n        ctx.moveTo(toX, toY);\r\n        ctx.lineTo(arrowX2, arrowY2);\r\n        ctx.stroke();\r\n    }\r\n\r\n    /**\r\n      * Draw a placeholder shape when no camera is available\r\n      * @param {CanvasRenderingContext2D} ctx - The canvas context\r\n      */\r\n    drawPlaceholder(ctx) {\r\n        // Draw a simple cube wireframe\r\n        ctx.strokeStyle = this.wireframeColor;\r\n        ctx.lineWidth = 1;\r\n\r\n        // Size based on scale\r\n        const size = 25;\r\n\r\n        // Draw front face\r\n        ctx.beginPath();\r\n        ctx.rect(-size, -size, size * 2, size * 2);\r\n        ctx.stroke();\r\n\r\n        // Draw back face (offset for perspective effect)\r\n        ctx.beginPath();\r\n        ctx.rect(-size * 0.7, -size * 0.7, size * 1.4, size * 1.4);\r\n        ctx.stroke();\r\n\r\n        // Draw connecting lines\r\n        ctx.beginPath();\r\n        ctx.moveTo(-size, -size);\r\n        ctx.lineTo(-size * 0.7, -size * 0.7);\r\n        ctx.moveTo(size, -size);\r\n        ctx.lineTo(size * 0.7, -size * 0.7);\r\n        ctx.moveTo(size, size);\r\n        ctx.lineTo(size * 0.7, size * 0.7);\r\n        ctx.moveTo(-size, size);\r\n        ctx.lineTo(-size * 0.7, size * 0.7);\r\n        ctx.stroke();\r\n\r\n        // Draw \"Mesh3D\" text\r\n        ctx.fillStyle = this.wireframeColor;\r\n        ctx.font = '12px Arial';\r\n        ctx.textAlign = 'center';\r\n        ctx.textBaseline = 'middle';\r\n        ctx.fillText('Mesh3D', 0, 0);\r\n    }\r\n\r\n    /**\r\n     * Find the active camera in the scene\r\n     * @returns {Camera3D|null} The active camera or null\r\n     */\r\n    findActiveCamera() {\r\n        const allObjects = this.getAllGameObjects();\r\n\r\n        for (const obj of allObjects) {\r\n            const camera = obj.getModule(\"Camera3D\");\r\n            if (camera && camera.isActive) {\r\n                return camera;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get all game objects in the scene\r\n     * @returns {Array<GameObject>} All game objects\r\n     */\r\n    getAllGameObjects() {\r\n        if (!this.gameObject) return [];\r\n\r\n        // Use the editor's method to get all game objects if available\r\n        if (window.editor && window.editor.getAllGameObjects) {\r\n            return window.editor.getAllGameObjects();\r\n        }\r\n\r\n        // Fallback to recursively finding game objects\r\n        const allObjects = [];\r\n\r\n        const scene = window.editor ? window.editor.activeScene :\r\n            (window.engine ? window.engine.scene : null);\r\n\r\n        if (scene && scene.gameObjects) {\r\n            const findObjects = (objects) => {\r\n                objects.forEach(obj => {\r\n                    allObjects.push(obj);\r\n                    if (obj.children && obj.children.length > 0) {\r\n                        findObjects(obj.children);\r\n                    }\r\n                });\r\n            };\r\n\r\n            findObjects(scene.gameObjects);\r\n        }\r\n\r\n        return allObjects;\r\n    }\r\n\r\n    /**\r\n      * Transform vertices based on mesh and game object transforms\r\n      * @returns {Array<Vector3>} Transformed vertices\r\n      */\r\n    transformVertices() {\r\n        // Get game object transforms if available\r\n        let objPos = { x: 0, y: 0 };\r\n        let objRot = 0;\r\n        let objScale = { x: 1, y: 1 };\r\n\r\n        if (this.gameObject) {\r\n            objPos = this.gameObject.getWorldPosition ? this.gameObject.getWorldPosition() : { x: 0, y: 0 };\r\n            objRot = this.gameObject.getWorldRotation ? this.gameObject.getWorldRotation() : 0;\r\n            objScale = this.gameObject.getWorldScale ? this.gameObject.getWorldScale() : { x: 1, y: 1 };\r\n        }\r\n\r\n        // Determine game object world depth (Z). Prefer getWorldDepth(), then depth, then position.z, else 0.\r\n        let objDepth = 0;\r\n        if (this.gameObject) {\r\n            if (typeof this.gameObject.getWorldDepth === 'function') {\r\n                objDepth = this.gameObject.getWorldDepth();\r\n            } else if (typeof this.gameObject.depth === 'number') {\r\n                objDepth = this.gameObject.depth;\r\n            } else if (this.gameObject.position && typeof this.gameObject.position.z === 'number') {\r\n                objDepth = this.gameObject.position.z;\r\n            }\r\n        }\r\n\r\n        // Convert to 3D (use game object depth for Z)\r\n        const objPos3D = new Vector3(objPos.x, objPos.y, objDepth);\r\n        const objScale3D = new Vector3(objScale.x, objScale.y, 1);\r\n\r\n        return this.vertices.map(vertex => {\r\n            // Start with the base vertex\r\n            let v = vertex.clone ? vertex.clone() : new Vector3(vertex.x, vertex.y, vertex.z);\r\n\r\n            // Step 1: Apply mesh scale\r\n            v.x *= this.scale.x;\r\n            v.y *= this.scale.y;\r\n            v.z *= this.scale.z;\r\n\r\n            // Step 2: Apply game object rotation first (convert degrees to radians)\r\n            // In 2D-to-3D system, game object rotation is applied around Z-axis\r\n            if (objRot !== 0) {\r\n                const rotRad = objRot * (Math.PI / 180);\r\n                v = this.rotateZ(v, rotRad);\r\n            }\r\n\r\n            // Step 3: Apply mesh rotation (convert degrees to radians)\r\n            // X-axis: roll, Y-axis: yaw, Z-axis: pitch\r\n            if (this.rotation.x !== 0) v = this.rotateX(v, this.rotation.x * (Math.PI / 180)); // Roll\r\n            if (this.rotation.y !== 0) v = this.rotateY(v, this.rotation.y * (Math.PI / 180)); // Yaw\r\n            if (this.rotation.z !== 0) v = this.rotateZ(v, this.rotation.z * (Math.PI / 180)); // Pitch\r\n\r\n            // Step 4: Apply mesh position (translate)\r\n            v.x += this.position.x;\r\n            v.y += this.position.y;\r\n            v.z += this.position.z;\r\n\r\n            // Step 5: Apply game object scale\r\n            v.x *= objScale3D.x;\r\n            v.y *= objScale3D.y;\r\n            v.z *= objScale3D.z;\r\n\r\n            // Step 6: Apply game object position (translate) including depth\r\n            v.x += objPos3D.x;\r\n            v.y += objPos3D.y;\r\n            v.z += objPos3D.z;\r\n\r\n            return v;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Rotate a vector around the X axis\r\n     * @param {Vector3} v - Vector to rotate\r\n     * @param {number} angle - Angle in radians\r\n     * @returns {Vector3} Rotated vector\r\n     */\r\n    rotateX(v, angle) {\r\n        const cos = Math.cos(angle);\r\n        const sin = Math.sin(angle);\r\n        return new Vector3(\r\n            v.x,\r\n            v.y * cos - v.z * sin,\r\n            v.y * sin + v.z * cos\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Rotate a vector around the Y axis\r\n     * @param {Vector3} v - Vector to rotate\r\n     * @param {number} angle - Angle in radians\r\n     * @returns {Vector3} Rotated vector\r\n     */\r\n    rotateY(v, angle) {\r\n        const cos = Math.cos(angle);\r\n        const sin = Math.sin(angle);\r\n        return new Vector3(\r\n            v.x * cos + v.z * sin,\r\n            v.y,\r\n            -v.x * sin + v.z * cos\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Rotate a vector around the Z axis\r\n     * @param {Vector3} v - Vector to rotate\r\n     * @param {number} angle - Angle in radians\r\n     * @returns {Vector3} Rotated vector\r\n     */\r\n    rotateZ(v, angle) {\r\n        const cos = Math.cos(angle);\r\n        const sin = Math.sin(angle);\r\n        return new Vector3(\r\n            v.x * cos - v.y * sin,\r\n            v.x * sin + v.y * cos,\r\n            v.z\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Draw in the editor\r\n     * @param {CanvasRenderingContext2D} ctx - The canvas context\r\n     */\r\n    drawInEditor(ctx) {\r\n        // Use the same draw method for both runtime and editor\r\n        this.draw(ctx);\r\n    }\r\n\r\n    /**\r\n       * Serialize the mesh to JSON\r\n       * @returns {Object} JSON representation of the mesh\r\n       */\r\n     toJSON() {\r\n         return {\r\n             _type: \"Mesh3D\",\r\n             vertices: this.vertices.map(v => ({ x: v.x, y: v.y, z: v.z })),\r\n             edges: this.edges.map(edge => [...edge]),\r\n             faces: this.faces.map(face => [...face]),\r\n             uvCoordinates: this.uvCoordinates.map(uv => ({ x: uv.x, y: uv.y })),\r\n             position: { x: this.position.x, y: this.position.y, z: this.position.z },\r\n             rotation: { x: this.rotation.x, y: this.rotation.y, z: this.rotation.z },\r\n             scale: { x: this.scale.x, y: this.scale.y, z: this.scale.z },\r\n             wireframeColor: this.wireframeColor,\r\n             faceColor: this.faceColor,\r\n             renderMode: this.renderMode,\r\n             _showAxisLines: this._showAxisLines,\r\n             _axisLength: this._axisLength,\r\n             material: this.material ? this.material.toJSON() : null\r\n         };\r\n     }\r\n\r\n    /**\r\n       * Deserialize the mesh from JSON\r\n       * @param {Object} json - JSON representation of the mesh\r\n       */\r\n     fromJSON(json) {\r\n         if (json.vertices) {\r\n             this.vertices = json.vertices.map(v => new Vector3(v.x, v.y, v.z));\r\n         }\r\n         if (json.edges) this.edges = json.edges;\r\n         if (json.faces) this.faces = json.faces;\r\n         if (json.uvCoordinates) {\r\n             this.uvCoordinates = json.uvCoordinates.map(uv => new Vector2(uv.x, uv.y));\r\n         } else {\r\n             // Regenerate UV coordinates if not present\r\n             this.generateUVCoordinates();\r\n         }\r\n         if (json.position) this.position = new Vector3(json.position.x, json.position.y, json.position.z);\r\n         if (json.rotation) this.rotation = new Vector3(json.rotation.x, json.rotation.y, json.rotation.z);\r\n         if (json.scale) this.scale = new Vector3(json.scale.x, json.scale.y, json.scale.z);\r\n         if (json.wireframeColor !== undefined) this.wireframeColor = json.wireframeColor;\r\n         if (json.faceColor !== undefined) this.faceColor = json.faceColor;\r\n         if (json.renderMode !== undefined) this.renderMode = json.renderMode;\r\n         if (json._showAxisLines !== undefined) this._showAxisLines = json._showAxisLines;\r\n         if (json._axisLength !== undefined) this._axisLength = json._axisLength;\r\n\r\n         // Deserialize material if present\r\n         if (json.material) {\r\n             if (!this.material) {\r\n                 this.ensureMaterialModule();\r\n             }\r\n             if (this.material && this.material.fromJSON) {\r\n                 this.material.fromJSON(json.material);\r\n             }\r\n         }\r\n     }\r\n\r\n    // Getters and setters for properties\r\n    get showAxisLines() { return this._showAxisLines; }\r\n    set showAxisLines(value) { this._showAxisLines = value; }\r\n\r\n    get axisLength() { return this._axisLength; }\r\n    set axisLength(value) { this._axisLength = Math.max(50, Math.min(500, value)); }\r\n}\r\n\r\n// Register the Mesh3D module\r\nwindow.Mesh3D = Mesh3D;",
      "type": "file",
      "name": "Mesh3D.js",
      "parentPath": "/",
      "created": 1759457099332,
      "modified": 1759457099332
    },
    {
      "path": "/MouseLook.js",
      "content": "/**\r\n * MouseLook - Module for controlling camera rotation with the mouse\r\n * \r\n * This module allows for camera rotation using mouse movement.\r\n * It needs to be attached to a GameObject with a Camera3D module.\r\n */\r\nclass MouseLook extends Module {\r\n    static namespace = \"3D\";\r\n    static description = \"Controls camera rotation with mouse movement\";\r\n    static allowMultiple = false;\r\n    static icon = \"fa-mouse\";\r\n    \r\n    /**\r\n     * Create a new MouseLook\r\n     */\r\n    constructor() {\r\n        super(\"MouseLook\");\r\n        \r\n        // Setup requirements\r\n        this.requires(\"Camera3D\");\r\n        \r\n        // Look settings\r\n        this._sensitivity = 0.2; // Lower = less sensitive\r\n        this._invertX = false;\r\n        this._invertY = false;\r\n        this._smoothing = 0.1; // Lower = more responsive, higher = smoother\r\n        this._lockX = false; // Lock horizontal rotation\r\n        this._lockY = false; // Lock vertical rotation\r\n        \r\n        // Range limits\r\n        this._minPitch = -89.9; // Minimum vertical angle (looking down)\r\n        this._maxPitch = 89.9;  // Maximum vertical angle (looking up)\r\n        \r\n        // Mouse state\r\n        this._isLooking = false;\r\n        this._lastMouseX = 0;\r\n        this._lastMouseY = 0;\r\n        \r\n        // Smoothing\r\n        this._targetRotation = new Vector3(0, 0, 0);\r\n        \r\n        // Camera reference (will be set in start())\r\n        this.camera = null;\r\n        \r\n        // Activate mode\r\n        this._activateMode = \"rightButton\"; // Options: \"always\", \"rightButton\", \"middleButton\", \"leftButton\", \"freeLook\"\r\n        \r\n        // Pointer lock settings\r\n        this._lockCursor = false;\r\n        this._isPointerLocked = false;\r\n\r\n        // Screen wrap settings\r\n        this._screenWrap = true; // Enable mouse wrap around screen edges\r\n        this._wrapSensitivity = 1.0; // Sensitivity multiplier when wrapping\r\n        \r\n        // Expose properties to the inspector\r\n        this.exposeProperty(\"sensitivity\", \"number\", 0.2, {\r\n            min: 0.01,\r\n            max: 2,\r\n            step: 0.01,\r\n            onChange: (val) => this._sensitivity = val\r\n        });\r\n\r\n        this.exposeProperty(\"invertX\", \"boolean\", false, {\r\n            onChange: (val) => this._invertX = val\r\n        });\r\n        this.exposeProperty(\"invertY\", \"boolean\", false, {\r\n            onChange: (val) => this._invertY = val\r\n        });\r\n\r\n        this.exposeProperty(\"lockX\", \"boolean\", false, {\r\n            onChange: (val) => this._lockX = val\r\n        });\r\n\r\n        this.exposeProperty(\"lockY\", \"boolean\", false, {\r\n            onChange: (val) => this._lockY = val\r\n        });\r\n\r\n        this.exposeProperty(\"smoothing\", \"number\", 0.1, {\r\n            min: 0,\r\n            max: 0.99,\r\n            step: 0.01,\r\n            onChange: (val) => this._smoothing = val\r\n        });\r\n\r\n        this.exposeProperty(\"minPitch\", \"number\", -89.9, {\r\n            min: -89.9,\r\n            max: 89.9,\r\n            onChange: (val) => this._minPitch = val\r\n        });\r\n\r\n        this.exposeProperty(\"maxPitch\", \"number\", 89.9, {\r\n            min: -89.9,\r\n            max: 89.9,\r\n            onChange: (val) => this._maxPitch = val\r\n        });\r\n\r\n        this.exposeProperty(\"activateMode\", \"enum\", \"rightButton\", {\r\n            options: [\"always\", \"rightButton\", \"middleButton\", \"leftButton\", \"freeLook\"],\r\n            onChange: (val) => this._activateMode = val\r\n        });\r\n\r\n        this.exposeProperty(\"lockCursor\", \"boolean\", false, {\r\n            onChange: (val) => this._lockCursor = val\r\n        });\r\n\r\n        this.exposeProperty(\"screenWrap\", \"boolean\", true, {\r\n            onChange: (val) => this._screenWrap = val\r\n        });\r\n\r\n        this.exposeProperty(\"wrapSensitivity\", \"number\", 1.0, {\r\n            min: 0.1,\r\n            max: 5.0,\r\n            step: 0.1,\r\n            onChange: (val) => this._wrapSensitivity = val\r\n        });\r\n        \r\n        // Bind methods to maintain 'this' context\r\n        this.handleMouseDown = this.handleMouseDown.bind(this);\r\n        this.handleMouseMove = this.handleMouseMove.bind(this);\r\n        this.handleMouseUp = this.handleMouseUp.bind(this);\r\n        this.handleMouseLeave = this.handleMouseLeave.bind(this);\r\n        this.handleMouseEnter = this.handleMouseEnter.bind(this);\r\n        this.handlePointerLockChange = this.handlePointerLockChange.bind(this);\r\n        this.handleKeyDown = this.handleKeyDown.bind(this);\r\n        this.handleCanvasFocus = this.handleCanvasFocus.bind(this);\r\n        this.handleCanvasBlur = this.handleCanvasBlur.bind(this);\r\n    }\r\n    \r\n    /**\r\n     * Called when the module starts\r\n     */\r\n    start() {\r\n        // Get camera reference\r\n        this.camera = this.gameObject.getModule(\"Camera3D\");\r\n        \r\n        if (!this.camera) {\r\n            console.error(\"MouseLook requires a Camera3D module on the same GameObject\");\r\n            return;\r\n        }\r\n        \r\n        // Initialize target rotation to camera's current rotation\r\n        this._targetRotation = new Vector3(\r\n            this.camera.rotation.x,\r\n            this.camera.rotation.y,\r\n            this.camera.rotation.z\r\n        );\r\n        \r\n        // Wait a short time to ensure engine is initialized\r\n        setTimeout(() => {\r\n            this.setupEventListeners();\r\n        }, 100);\r\n    }\r\n\r\n    /**\r\n     * Set up event listeners for mouse control\r\n     */\r\n    setupEventListeners() {\r\n        // Set up event listeners\r\n        if (window.engine && window.engine.canvas) {\r\n            const canvas = window.engine.canvas;\r\n            canvas.addEventListener('mousedown', this.handleMouseDown);\r\n            document.addEventListener('mousemove', this.handleMouseMove);\r\n            document.addEventListener('mouseup', this.handleMouseUp);\r\n            canvas.addEventListener('mouseleave', this.handleMouseLeave);\r\n            canvas.addEventListener('mouseenter', this.handleMouseEnter);\r\n            document.addEventListener('pointerlockchange', this.handlePointerLockChange);\r\n            document.addEventListener('keydown', this.handleKeyDown);\r\n            canvas.addEventListener('focus', this.handleCanvasFocus);\r\n            canvas.addEventListener('blur', this.handleCanvasBlur);\r\n            \r\n            // Make canvas focusable if it isn't already\r\n            if (!canvas.hasAttribute('tabindex')) {\r\n                canvas.setAttribute('tabindex', '0');\r\n            }\r\n        } else if (document.querySelector('canvas')) {\r\n            // Fallback to any canvas in the document\r\n            const canvas = document.querySelector('canvas');\r\n            canvas.addEventListener('mousedown', this.handleMouseDown);\r\n            document.addEventListener('mousemove', this.handleMouseMove);\r\n            document.addEventListener('mouseup', this.handleMouseUp);\r\n            canvas.addEventListener('mouseleave', this.handleMouseLeave);\r\n            canvas.addEventListener('mouseenter', this.handleMouseEnter);\r\n            document.addEventListener('pointerlockchange', this.handlePointerLockChange);\r\n            document.addEventListener('keydown', this.handleKeyDown);\r\n            canvas.addEventListener('focus', this.handleCanvasFocus);\r\n            canvas.addEventListener('blur', this.handleCanvasBlur);\r\n            \r\n            // Make canvas focusable if it isn't already\r\n            if (!canvas.hasAttribute('tabindex')) {\r\n                canvas.setAttribute('tabindex', '0');\r\n            }\r\n            console.log(\"MouseLook: Using fallback canvas\");\r\n        } else {\r\n            console.warn(\"MouseLook: No canvas found for mouse events\");\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Called when the module is destroyed\r\n     */\r\n    onDestroy() {\r\n        // Clean up event listeners\r\n        const canvas = window.engine?.canvas || document.querySelector('canvas');\r\n        if (canvas) {\r\n            canvas.removeEventListener('mousedown', this.handleMouseDown);\r\n            document.removeEventListener('mousemove', this.handleMouseMove);\r\n            document.removeEventListener('mouseup', this.handleMouseUp);\r\n            canvas.removeEventListener('mouseleave', this.handleMouseLeave);\r\n            canvas.removeEventListener('mouseenter', this.handleMouseEnter);\r\n            document.removeEventListener('pointerlockchange', this.handlePointerLockChange);\r\n            document.removeEventListener('keydown', this.handleKeyDown);\r\n            canvas.removeEventListener('focus', this.handleCanvasFocus);\r\n            canvas.removeEventListener('blur', this.handleCanvasBlur);\r\n        }\r\n        \r\n        // Release pointer lock if active\r\n        if (this._isPointerLocked) {\r\n            document.exitPointerLock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle canvas focus event\r\n     */\r\n    handleCanvasFocus() {\r\n        if (this._lockCursor && this._activateMode === \"freeLook\") {\r\n            this.requestPointerLock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle canvas blur event\r\n     */\r\n    handleCanvasBlur() {\r\n        if (this._isPointerLocked) {\r\n            document.exitPointerLock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle mouse leave event\r\n     * @param {MouseEvent} event - The mouse event\r\n     */\r\n    handleMouseLeave(event) {\r\n        if (!this._screenWrap || this._isPointerLocked) return;\r\n\r\n        // Store that we're wrapping so we don't process this as normal mouse movement\r\n        this._isWrapping = true;\r\n        this._wrapStartTime = Date.now();\r\n    }\r\n\r\n    /**\r\n     * Handle mouse enter event\r\n     * @param {MouseEvent} event - The mouse event\r\n     */\r\n    handleMouseEnter(event) {\r\n        if (!this._screenWrap || this._isPointerLocked) return;\r\n\r\n        // If we were wrapping, simulate the mouse movement that got cut off\r\n        if (this._isWrapping && this._lastMouseX !== undefined && this._lastMouseY !== undefined) {\r\n            // Calculate how much mouse movement we might have missed\r\n            const timeSinceLeave = Date.now() - this._wrapStartTime;\r\n            if (timeSinceLeave < 100) { // Only if it was a quick leave/re-enter\r\n                // Apply wrap movement based on the edge we left from\r\n                this.simulateWrapMovement(event);\r\n            }\r\n        }\r\n\r\n        this._isWrapping = false;\r\n    }\r\n\r\n    /**\r\n     * Simulate mouse movement when wrapping around screen edges\r\n     * @param {MouseEvent} event - The mouse enter event\r\n     */\r\n    simulateWrapMovement(event) {\r\n        if (!this._isLooking) return;\r\n\r\n        // Determine which edge we likely came from based on enter position\r\n        const canvas = window.engine?.canvas || document.querySelector('canvas');\r\n        if (!canvas) return;\r\n\r\n        const rect = canvas.getBoundingClientRect();\r\n        let simulatedDeltaX = 0;\r\n        let simulatedDeltaY = 0;\r\n\r\n        // If mouse entered from left edge, simulate rightward movement\r\n        if (event.clientX <= rect.left + 10) {\r\n            simulatedDeltaX = 50 * this._wrapSensitivity;\r\n        }\r\n        // If mouse entered from right edge, simulate leftward movement\r\n        else if (event.clientX >= rect.right - 10) {\r\n            simulatedDeltaX = -50 * this._wrapSensitivity;\r\n        }\r\n        // If mouse entered from top edge, simulate downward movement\r\n        else if (event.clientY <= rect.top + 10) {\r\n            simulatedDeltaY = 50 * this._wrapSensitivity;\r\n        }\r\n        // If mouse entered from bottom edge, simulate upward movement\r\n        else if (event.clientY >= rect.bottom - 10) {\r\n            simulatedDeltaY = -50 * this._wrapSensitivity;\r\n        }\r\n\r\n        if (simulatedDeltaX !== 0 || simulatedDeltaY !== 0) {\r\n            // Apply the simulated rotation\r\n            const yawDelta = this._lockX ? 0 : simulatedDeltaX * this.sensitivity * (this.invertX ? -1 : 1);\r\n            const pitchDelta = this._lockY ? 0 : simulatedDeltaY * this.sensitivity * (this.invertY ? -1 : 1);\r\n\r\n            this._targetRotation.z = (this._targetRotation.z + yawDelta) % 360;\r\n            this._targetRotation.y = this._targetRotation.y - pitchDelta;\r\n            this._targetRotation.y = Math.max(this.minPitch, Math.min(this.maxPitch, this._targetRotation.y));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle key down event\r\n     * @param {KeyboardEvent} event - The keyboard event\r\n     */\r\n    handleKeyDown(event) {\r\n        if (event.key === 'Escape' && this._isPointerLocked) {\r\n            document.exitPointerLock();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle pointer lock change event\r\n     */\r\n    handlePointerLockChange() {\r\n        const canvas = window.engine?.canvas || document.querySelector('canvas');\r\n        this._isPointerLocked = document.pointerLockElement === canvas;\r\n        \r\n        if (this._isPointerLocked) {\r\n            this._isLooking = true;\r\n        } else if (this._activateMode === \"freeLook\") {\r\n            this._isLooking = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Request pointer lock on the canvas\r\n     */\r\n    requestPointerLock() {\r\n        const canvas = window.engine?.canvas || document.querySelector('canvas');\r\n        if (canvas && !this._isPointerLocked) {\r\n            canvas.requestPointerLock();\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Handle mouse down event\r\n     * @param {MouseEvent} event - The mouse event\r\n     */\r\n    handleMouseDown(event) {\r\n        if (!this.camera) return;\r\n        \r\n        // Handle freeLook mode with pointer lock\r\n        if (this._activateMode === \"freeLook\") {\r\n            if (this._lockCursor && !this._isPointerLocked) {\r\n                this.requestPointerLock();\r\n            } else if (!this._lockCursor) {\r\n                this._isLooking = true;\r\n                this._lastMouseX = event.clientX;\r\n                this._lastMouseY = event.clientY;\r\n            }\r\n            return;\r\n        }\r\n        \r\n        // Check if the correct mouse button was pressed\r\n        if (this._activateMode === \"always\" ||\r\n           (this._activateMode === \"rightButton\" && event.button === 2) ||\r\n           (this._activateMode === \"middleButton\" && event.button === 1) ||\r\n           (this._activateMode === \"leftButton\" && event.button === 0)) {\r\n            \r\n            this._isLooking = true;\r\n            this._lastMouseX = event.clientX;\r\n            this._lastMouseY = event.clientY;\r\n            \r\n            // Prevent default context menu if right click is used\r\n            if (event.button === 2) {\r\n                event.preventDefault();\r\n                \r\n                // Add a one-time event listener for context menu\r\n                const contextMenuHandler = (e) => {\r\n                    e.preventDefault();\r\n                    document.removeEventListener('contextmenu', contextMenuHandler);\r\n                };\r\n                \r\n                document.addEventListener('contextmenu', contextMenuHandler);\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Handle mouse move event\r\n     * @param {MouseEvent} event - The mouse event\r\n     */\r\n    handleMouseMove(event) {\r\n        if (!this.camera || !this._isLooking) return;\r\n        \r\n        let deltaX, deltaY;\r\n        \r\n        // Use movementX/Y for pointer lock, otherwise calculate delta\r\n        if (this._isPointerLocked) {\r\n            deltaX = event.movementX || 0;\r\n            deltaY = event.movementY || 0;\r\n        } else {\r\n            // Calculate mouse movement\r\n            deltaX = event.clientX - this._lastMouseX;\r\n            deltaY = event.clientY - this._lastMouseY;\r\n            \r\n            // Update last mouse position\r\n            this._lastMouseX = event.clientX;\r\n            this._lastMouseY = event.clientY;\r\n        }\r\n        \r\n        // Apply sensitivity and inversion, respecting axis locks\r\n        const yawDelta = this._lockX ? 0 : deltaX * this.sensitivity * (this.invertX ? -1 : 1);\r\n        const pitchDelta = this._lockY ? 0 : deltaY * this.sensitivity * (this.invertY ? -1 : 1);\r\n        \r\n        // Update target rotation using Z-up convention where:\r\n        // - Z = yaw (turn left/right)\r\n        // - Y = pitch (tilt up/down around right axis)\r\n        // - X = roll (unused by mouse look unless explicitly set)\r\n        this._targetRotation.z = (this._targetRotation.z + yawDelta) % 360;\r\n        this._targetRotation.y = this._targetRotation.y - pitchDelta;\r\n\r\n        // Clamp pitch (rotation.y) to prevent flipping\r\n        this._targetRotation.y = Math.max(this.minPitch, Math.min(this.maxPitch, this._targetRotation.y));\r\n    }\r\n    \r\n    /**\r\n     * Handle mouse up event\r\n     * @param {MouseEvent} event - The mouse event\r\n     */\r\n    handleMouseUp(event) {\r\n        if (!this.camera) return;\r\n        \r\n        // Don't stop looking in freeLook mode without cursor lock or if pointer is locked\r\n        if (this._activateMode === \"freeLook\" && (this._isPointerLocked || !this._lockCursor)) {\r\n            if (!this._lockCursor) {\r\n                this._isLooking = false;\r\n            }\r\n            return;\r\n        }\r\n        \r\n        // Check if the correct mouse button was released\r\n        if ((this._activateMode === \"rightButton\" && event.button === 2) ||\r\n            (this._activateMode === \"middleButton\" && event.button === 1) ||\r\n            (this._activateMode === \"leftButton\" && event.button === 0)) {\r\n            \r\n            this._isLooking = false;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Handle camera rotation each frame\r\n     * @param {number} deltaTime - Time since last frame in seconds\r\n     */\r\n    loop(deltaTime) {\r\n        if (!this.camera) return;\r\n        \r\n        // For \"always\" mode, automatically enable looking\r\n        if (this._activateMode === \"always\") {\r\n            this._isLooking = true;\r\n        }\r\n        \r\n        // For \"freeLook\" mode without cursor lock, enable looking\r\n        if (this._activateMode === \"freeLook\" && !this._lockCursor) {\r\n            this._isLooking = true;\r\n        }\r\n        \r\n        // Apply rotation with smoothing (Z-up: pitch = rotation.y, yaw = rotation.z, roll = rotation.x)\r\n        if (this.smoothing > 0) {\r\n            // Pitch -> rotation.y\r\n            this.camera.rotation.y += (this._targetRotation.y - this.camera.rotation.y) * (1 - this.smoothing);\r\n            // Roll -> rotation.x\r\n            this.camera.rotation.x += (this._targetRotation.x - this.camera.rotation.x) * (1 - this.smoothing);\r\n            // Yaw -> rotation.z\r\n            this.camera.rotation.z += (this._targetRotation.z - this.camera.rotation.z) * (1 - this.smoothing);\r\n        } else {\r\n            // Direct rotation without smoothing\r\n            this.camera.rotation.y = this._targetRotation.y; // Pitch (Y-axis)\r\n            this.camera.rotation.x = this._targetRotation.x; // Roll (X-axis)\r\n            this.camera.rotation.z = this._targetRotation.z; // Yaw (Z-axis)\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Serialize the mouse look to JSON\r\n     * @returns {Object} JSON representation of the mouse look\r\n     */\r\n    toJSON() {\r\n        return {\r\n            _type: \"MouseLook\",\r\n            _sensitivity: this._sensitivity,\r\n            _invertX: this._invertX,\r\n            _invertY: this._invertY,\r\n            _smoothing: this._smoothing,\r\n            _lockX: this._lockX,\r\n            _lockY: this._lockY,\r\n            _minPitch: this._minPitch,\r\n            _maxPitch: this._maxPitch,\r\n            _activateMode: this._activateMode,\r\n            _lockCursor: this._lockCursor,\r\n            _screenWrap: this._screenWrap,\r\n            _wrapSensitivity: this._wrapSensitivity\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Deserialize the mouse look from JSON\r\n     * @param {Object} json - JSON representation of the mouse look\r\n     */\r\n    fromJSON(json) {\r\n        if (json._sensitivity !== undefined) this._sensitivity = json._sensitivity;\r\n        if (json._invertX !== undefined) this._invertX = json._invertX;\r\n        if (json._invertY !== undefined) this._invertY = json._invertY;\r\n        if (json._smoothing !== undefined) this._smoothing = json._smoothing;\r\n        if (json._lockX !== undefined) this._lockX = json._lockX;\r\n        if (json._lockY !== undefined) this._lockY = json._lockY;\r\n        if (json._minPitch !== undefined) this._minPitch = json._minPitch;\r\n        if (json._maxPitch !== undefined) this._maxPitch = json._maxPitch;\r\n        if (json._activateMode !== undefined) this._activateMode = json._activateMode;\r\n        if (json._lockCursor !== undefined) this._lockCursor = json._lockCursor;\r\n        if (json._screenWrap !== undefined) this._screenWrap = json._screenWrap;\r\n        if (json._wrapSensitivity !== undefined) this._wrapSensitivity = json._wrapSensitivity;\r\n    }\r\n\r\n    // Getters and setters for properties\r\n    get sensitivity() { return this._sensitivity; }\r\n    set sensitivity(value) { this._sensitivity = value; }\r\n\r\n    get invertX() { return this._invertX; }\r\n    set invertX(value) { this._invertX = value; }\r\n\r\n    get invertY() { return this._invertY; }\r\n    set invertY(value) { this._invertY = value; }\r\n\r\n    get lockX() { return this._lockX; }\r\n    set lockX(value) { this._lockX = value; }\r\n\r\n    get lockY() { return this._lockY; }\r\n    set lockY(value) { this._lockY = value; }\r\n\r\n    get smoothing() { return this._smoothing; }\r\n    set smoothing(value) { this._smoothing = Math.max(0, Math.min(0.99, value)); }\r\n\r\n    get minPitch() { return this._minPitch; }\r\n    set minPitch(value) { this._minPitch = Math.max(-89.9, Math.min(this.maxPitch, value)); }\r\n\r\n    get maxPitch() { return this._maxPitch; }\r\n    set maxPitch(value) { this._maxPitch = Math.min(89.9, Math.max(this.minPitch, value)); }\r\n\r\n    get activateMode() { return this._activateMode; }\r\n    set activateMode(value) { this._activateMode = value; }\r\n\r\n    get lockCursor() { return this._lockCursor; }\r\n    set lockCursor(value) { this._lockCursor = value; }\r\n\r\n    get screenWrap() { return this._screenWrap; }\r\n    set screenWrap(value) { this._screenWrap = value; }\r\n\r\n    get wrapSensitivity() { return this._wrapSensitivity; }\r\n    set wrapSensitivity(value) { this._wrapSensitivity = Math.max(0.1, Math.min(5.0, value)); }\r\n}\r\n\r\n// Register the MouseLook module\r\nwindow.MouseLook = MouseLook;",
      "type": "file",
      "name": "MouseLook.js",
      "parentPath": "/",
      "created": 1759457099332,
      "modified": 1759457099332
    },
    {
      "path": "/SphereMesh3D.js",
      "content": "/**\r\n * SphereMesh3D - A specialized 3D mesh module for spheres with customizable properties\r\n * \r\n * This module creates and renders a 3D sphere mesh with configurable radius,\r\n * colors, and rendering options using UV sphere topology.\r\n */\r\nclass SphereMesh3D extends Module {\r\n    static namespace = \"3D\";\r\n\r\n    /**\r\n     * Create a new SphereMesh3D\r\n     */\r\n    constructor() {\r\n        super(\"SphereMesh3D\");\r\n\r\n        // Sphere properties\r\n        this._radius = 50;\r\n        this._position = new Vector3(0, 0, 0);\r\n        this._rotation = new Vector3(0, 0, 0);\r\n        this._scale = new Vector3(1, 1, 1);\r\n\r\n        // Appearance\r\n        this._wireframeColor = \"#FFFFFF\";\r\n        this._faceColor = \"#3F51B5\";\r\n        this._renderMode = \"wireframe\"; // \"wireframe\", \"solid\", or \"both\"\r\n\r\n        // Axis visualization\r\n        this._showAxisLines = false;\r\n        this._axisLength = 150;\r\n\r\n        // Sphere resolution\r\n        this._segments = 16; // Horizontal segments (longitude)\r\n        this._rings = 12;    // Vertical rings (latitude)\r\n\r\n        // Mesh data\r\n        this.vertices = [];\r\n        this.edges = [];\r\n        this.faces = [];\r\n\r\n        // Material system\r\n        this.material = null; // Material instance for advanced texturing\r\n\r\n        // UV coordinates for texture mapping\r\n        this.uvCoordinates = [];\r\n\r\n        // Expose properties to the inspector\r\n        this.exposeProperty(\"radius\", \"number\", 50, {\r\n            min: 1,\r\n            max: 500,\r\n            onChange: (val) => {\r\n                this._radius = val;\r\n                this.updateSphere();\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"position\", \"vector3\", this._position, {\r\n            onChange: (val) => this._position = val\r\n        });\r\n\r\n        this.exposeProperty(\"rotation\", \"vector3\", this._rotation, {\r\n            onChange: (val) => this._rotation = val\r\n        });\r\n\r\n        this.exposeProperty(\"scale\", \"vector3\", this._scale, {\r\n            onChange: (val) => this._scale = val\r\n        });\r\n\r\n        this.exposeProperty(\"segments\", \"number\", 16, {\r\n            min: 3,\r\n            max: 64,\r\n            step: 1,\r\n            onChange: (val) => {\r\n                this._segments = Math.floor(val);\r\n                this.updateSphere();\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"rings\", \"number\", 12, {\r\n            min: 2,\r\n            max: 64,\r\n            step: 1,\r\n            onChange: (val) => {\r\n                this._rings = Math.floor(val);\r\n                this.updateSphere();\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"wireframeColor\", \"color\", \"#FFFFFF\", {\r\n            onChange: (val) => this._wireframeColor = val\r\n        });\r\n\r\n        this.exposeProperty(\"faceColor\", \"color\", \"#3F51B5\", {\r\n            onChange: (val) => this._faceColor = val\r\n        });\r\n\r\n        this.exposeProperty(\"renderMode\", \"enum\", \"wireframe\", {\r\n            options: [\"wireframe\", \"solid\", \"both\"],\r\n            onChange: (val) => this._renderMode = val\r\n        });\r\n\r\n        this.exposeProperty(\"showAxisLines\", \"boolean\", false, {\r\n            onChange: (val) => this._showAxisLines = val\r\n        });\r\n\r\n        this.exposeProperty(\"axisLength\", \"number\", 150, {\r\n            min: 50,\r\n            max: 500,\r\n            onChange: (val) => this._axisLength = val\r\n        });\r\n\r\n        this.exposeProperty(\"material\", \"module\", null, {\r\n            moduleType: \"Material\",\r\n            onChange: (val) => this.material = val\r\n        });\r\n\r\n        // Initialize sphere geometry\r\n        this.updateSphere();\r\n\r\n        // Ensure material module exists on the game object\r\n        this.ensureMaterialModule();\r\n    }\r\n\r\n    start() {\r\n        // Ensure material module exists on start\r\n        this.ensureMaterialModule();\r\n    }\r\n\r\n    /**\r\n     * Ensure the game object has a Material module\r\n     */\r\n    ensureMaterialModule() {\r\n        if (!this.gameObject) return;\r\n\r\n        // Check if material module already exists\r\n        let materialModule = this.gameObject.getModule ? this.gameObject.getModule('Material') : null;\r\n        if (!materialModule) {\r\n            // Create and add a new material module\r\n            materialModule = new Material();\r\n            if (this.gameObject.addModule) {\r\n                this.gameObject.addModule(materialModule);\r\n            }\r\n        }\r\n\r\n        // Set the material reference\r\n        this.material = materialModule;\r\n    }\r\n\r\n    /**\r\n     * Update the sphere geometry based on current radius and resolution\r\n     */\r\n    updateSphere() {\r\n        const r = this.radius;\r\n        const segments = this._segments;\r\n        const rings = this._rings;\r\n\r\n        this.vertices = [];\r\n        this.edges = [];\r\n        this.faces = [];\r\n\r\n        // Generate vertices using UV sphere topology\r\n        // Top pole\r\n        this.vertices.push(new Vector3(0, 0, r));\r\n\r\n        // Generate vertices for each ring (excluding poles)\r\n        for (let ring = 1; ring < rings; ring++) {\r\n            const phi = Math.PI * ring / rings; // Latitude angle (0 to PI)\r\n            const z = r * Math.cos(phi);\r\n            const ringRadius = r * Math.sin(phi);\r\n\r\n            for (let seg = 0; seg < segments; seg++) {\r\n                const theta = 2 * Math.PI * seg / segments; // Longitude angle (0 to 2PI)\r\n                const x = ringRadius * Math.cos(theta);\r\n                const y = ringRadius * Math.sin(theta);\r\n                this.vertices.push(new Vector3(x, y, z));\r\n            }\r\n        }\r\n\r\n        // Bottom pole\r\n        this.vertices.push(new Vector3(0, 0, -r));\r\n\r\n        // Generate faces\r\n        // Top cap (connecting to top pole) - Counter-clockwise winding\r\n        for (let seg = 0; seg < segments; seg++) {\r\n            const nextSeg = (seg + 1) % segments;\r\n            this.faces.push([\r\n                0, // Top pole\r\n                1 + seg,\r\n                1 + nextSeg\r\n            ]);\r\n        }\r\n\r\n        // Middle quads\r\n        for (let ring = 0; ring < rings - 2; ring++) {\r\n            const currentRingStart = 1 + ring * segments;\r\n            const nextRingStart = 1 + (ring + 1) * segments;\r\n\r\n            for (let seg = 0; seg < segments; seg++) {\r\n                const nextSeg = (seg + 1) % segments;\r\n\r\n                // Create quad face (split into two triangles for better rendering) - Counter-clockwise winding\r\n                this.faces.push([\r\n                    currentRingStart + seg,\r\n                    nextRingStart + seg,\r\n                    nextRingStart + nextSeg,\r\n                    currentRingStart + nextSeg\r\n                ]);\r\n            }\r\n        }\r\n\r\n        // Bottom cap (connecting to bottom pole) - Counter-clockwise winding\r\n        const lastRingStart = 1 + (rings - 2) * segments;\r\n        const bottomPoleIndex = this.vertices.length - 1;\r\n\r\n        for (let seg = 0; seg < segments; seg++) {\r\n            const nextSeg = (seg + 1) % segments;\r\n            this.faces.push([\r\n                bottomPoleIndex, // Bottom pole\r\n                lastRingStart + nextSeg,\r\n                lastRingStart + seg\r\n            ]);\r\n        }\r\n\r\n        // Generate edges from faces (unique edges only)\r\n        const edgeSet = new Set();\r\n        for (const face of this.faces) {\r\n            for (let i = 0; i < face.length; i++) {\r\n                const v1 = face[i];\r\n                const v2 = face[(i + 1) % face.length];\r\n                const edgeKey = v1 < v2 ? `${v1},${v2}` : `${v2},${v1}`;\r\n                edgeSet.add(edgeKey);\r\n            }\r\n        }\r\n\r\n        this.edges = Array.from(edgeSet).map(key => key.split(',').map(Number));\r\n\r\n        // Generate UV coordinates for texture mapping\r\n        this.generateUVCoordinates();\r\n    }\r\n\r\n    /**\r\n     * Generate UV coordinates for texture mapping\r\n     */\r\n    generateUVCoordinates() {\r\n        this.uvCoordinates = [];\r\n\r\n        for (let i = 0; i < this.vertices.length; i++) {\r\n            const vertex = this.vertices[i];\r\n\r\n            // Convert 3D spherical coordinates to 2D UV coordinates\r\n            // Normalize the vertex position to get spherical coordinates\r\n            const normalized = vertex.clone();\r\n            const length = Math.sqrt(vertex.x * vertex.x + vertex.y * vertex.y + vertex.z * vertex.z);\r\n\r\n            if (length > 0) {\r\n                normalized.x /= length;\r\n                normalized.y /= length;\r\n                normalized.z /= length;\r\n            }\r\n\r\n            // Calculate UV coordinates using spherical mapping\r\n            // U: longitude (0 to 1) - wraps around the sphere horizontally\r\n            // V: latitude (0 to 1) - from bottom to top pole\r\n            const u = 0.5 + (Math.atan2(normalized.x, normalized.z) / (2 * Math.PI));\r\n            const v = 0.5 - (Math.asin(normalized.y) / Math.PI);\r\n\r\n            this.uvCoordinates.push(new Vector2(u, v));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get material color for a face, considering texture if available\r\n     */\r\n    getMaterialColor(faceIndex) {\r\n        if (!this.material) {\r\n            return this._faceColor;\r\n        }\r\n\r\n        // For now, use the diffuse color\r\n        // In a full implementation, this would sample the texture based on face UVs\r\n        return this.material.diffuseColor;\r\n    }\r\n\r\n    /**\r\n     * Draw the sphere to the canvas\r\n     * @param {CanvasRenderingContext2D} ctx - The canvas context to draw on\r\n     */\r\n    draw(ctx) {\r\n        try {\r\n            // Find an active camera\r\n            const camera = this.findActiveCamera();\r\n\r\n            // Use render texture method if camera supports it\r\n            if (camera && camera.getRenderTextureContext && camera.render3D) {\r\n                this.drawToRenderTexture(camera.getRenderTextureContext(), camera);\r\n            } else if (camera) {\r\n                // Fallback to direct drawing\r\n                this.drawDirect(ctx, camera);\r\n            }\r\n        } catch (e) {\r\n            // Silently fail\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draw directly to a canvas context (fallback method)\r\n     * @param {CanvasRenderingContext2D} ctx - The canvas context to draw on\r\n     * @param {Camera3D} camera - The camera to use for projection\r\n     */\r\n    drawDirect(ctx, camera) {\r\n        // Transform vertices based on mesh position/rotation/scale and game object transform\r\n        const transformedVertices = this.transformVertices();\r\n\r\n        // Project the 3D vertices to 2D screen space\r\n        const projectedVertices = transformedVertices.map(vertex =>\r\n            camera.projectPoint(vertex)\r\n        );\r\n\r\n        // Sort faces by depth for basic depth sorting (painter's algorithm)\r\n        const sortedFaces = [...this.faces]\r\n            .map((face, index) => {\r\n                // Calculate centroid depth for more stable sorting\r\n                const centroidX = face.reduce((sum, vertexIndex) => sum + transformedVertices[vertexIndex].x, 0) / face.length;\r\n                const centroidY = face.reduce((sum, vertexIndex) => sum + transformedVertices[vertexIndex].y, 0) / face.length;\r\n                const centroidZ = face.reduce((sum, vertexIndex) => sum + transformedVertices[vertexIndex].z, 0) / face.length;\r\n\r\n                // Use centroid X as primary depth (camera looks along +X)\r\n                // Add small offset based on face center to handle coplanar faces\r\n                const sortDepth = centroidX + (centroidY + centroidZ) * 0.001;\r\n\r\n                return { face, sortDepth };\r\n            })\r\n            .sort((a, b) => b.sortDepth - a.sortDepth) // Sort back-to-front (lower depth values first = closer to camera)\r\n            .map(item => item.face);\r\n\r\n        // Draw faces in sorted order\r\n        if (this.renderMode === \"solid\" || this.renderMode === \"both\") {\r\n            for (const face of sortedFaces) {\r\n                // Use material color if available, otherwise fall back to faceColor\r\n                const faceColor = this.material ? this.getMaterialColor(face) : this._faceColor;\r\n                ctx.fillStyle = faceColor;\r\n                if (face.length < 3) continue;\r\n\r\n                const isVisible = face.every(vertexIndex =>\r\n                    projectedVertices[vertexIndex] !== null &&\r\n                    vertexIndex < projectedVertices.length\r\n                );\r\n                if (!isVisible) continue;\r\n\r\n                ctx.beginPath();\r\n                ctx.moveTo(projectedVertices[face[0]].x, projectedVertices[face[0]].y);\r\n\r\n                for (let i = 1; i < face.length; i++) {\r\n                    ctx.lineTo(projectedVertices[face[i]].x, projectedVertices[face[i]].y);\r\n                }\r\n\r\n                ctx.closePath();\r\n                ctx.fill();\r\n            }\r\n        }\r\n\r\n        // Draw edges\r\n        if (this.renderMode === \"wireframe\" || this.renderMode === \"both\") {\r\n            ctx.strokeStyle = this.wireframeColor;\r\n            ctx.lineWidth = 1;\r\n\r\n            for (const [from, to] of this.edges) {\r\n                if (from >= projectedVertices.length ||\r\n                    to >= projectedVertices.length ||\r\n                    projectedVertices[from] === null ||\r\n                    projectedVertices[to] === null) {\r\n                    continue;\r\n                }\r\n\r\n                ctx.beginPath();\r\n                ctx.moveTo(projectedVertices[from].x, projectedVertices[from].y);\r\n                ctx.lineTo(projectedVertices[to].x, projectedVertices[to].y);\r\n                ctx.stroke();\r\n            }\r\n        }\r\n\r\n        // Draw axis lines if enabled\r\n        if (this.showAxisLines && projectedVertices.length > 0) {\r\n            let centerX = 0, centerY = 0;\r\n            let validVertices = 0;\r\n\r\n            for (const vertex of projectedVertices) {\r\n                if (vertex !== null) {\r\n                    centerX += vertex.x;\r\n                    centerY += vertex.y;\r\n                    validVertices++;\r\n                }\r\n            }\r\n\r\n            if (validVertices > 0) {\r\n                centerX /= validVertices;\r\n                centerY /= validVertices;\r\n                this.drawAxisLines(ctx, new Vector2(centerX, centerY));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draw the sphere to a render texture\r\n     * @param {CanvasRenderingContext2D} ctx - The render texture context\r\n     * @param {Camera3D} camera - The camera to use for projection\r\n     */\r\n    drawToRenderTexture(ctx, camera) {\r\n        const transformedVertices = this.transformVertices();\r\n        const projectedVertices = transformedVertices.map(vertex =>\r\n            camera.projectPoint(vertex)\r\n        );\r\n\r\n        const validProjectedVertices = projectedVertices.map((vertex, index) => {\r\n            if (vertex === null) {\r\n                return new Vector2(-1000, -1000);\r\n            }\r\n            return vertex;\r\n        });\r\n\r\n        // Sort faces by depth\r\n        const sortedFaces = [...this.faces]\r\n            .map((face, index) => {\r\n                // Calculate centroid depth for more stable sorting\r\n                const centroidX = face.reduce((sum, vertexIndex) => sum + transformedVertices[vertexIndex].x, 0) / face.length;\r\n                const centroidY = face.reduce((sum, vertexIndex) => sum + transformedVertices[vertexIndex].y, 0) / face.length;\r\n                const centroidZ = face.reduce((sum, vertexIndex) => sum + transformedVertices[vertexIndex].z, 0) / face.length;\r\n\r\n                // Use centroid X as primary depth (camera looks along +X)\r\n                // Add small offset based on face center to handle coplanar faces\r\n                const sortDepth = centroidX + (centroidY + centroidZ) * 0.001;\r\n\r\n                return { face, sortDepth };\r\n            })\r\n            .sort((a, b) => b.sortDepth - a.sortDepth) // Sort back-to-front (lower depth values first = closer to camera)\r\n            .map(item => item.face);\r\n\r\n        // Draw faces\r\n        if (this.renderMode === \"solid\" || this.renderMode === \"both\") {\r\n            for (const face of sortedFaces) {\r\n                // Use material color if available, otherwise fall back to faceColor\r\n                const faceColor = this.material ? this.getMaterialColor(face) : this._faceColor;\r\n                ctx.fillStyle = faceColor;\r\n                const validVertices = [];\r\n                for (const vertexIndex of face) {\r\n                    if (vertexIndex < validProjectedVertices.length &&\r\n                        validProjectedVertices[vertexIndex].x > -999) {\r\n                        validVertices.push(validProjectedVertices[vertexIndex]);\r\n                    }\r\n                }\r\n\r\n                if (validVertices.length < 3) continue;\r\n\r\n                ctx.beginPath();\r\n                ctx.moveTo(validVertices[0].x, validVertices[0].y);\r\n\r\n                for (let i = 1; i < validVertices.length; i++) {\r\n                    ctx.lineTo(validVertices[i].x, validVertices[i].y);\r\n                }\r\n\r\n                ctx.closePath();\r\n                ctx.fill();\r\n            }\r\n        }\r\n\r\n        // Draw edges\r\n        if (this.renderMode === \"wireframe\" || this.renderMode === \"both\") {\r\n            ctx.strokeStyle = this.wireframeColor;\r\n            ctx.lineWidth = 1;\r\n\r\n            for (const [from, to] of this.edges) {\r\n                if (from >= validProjectedVertices.length ||\r\n                    to >= validProjectedVertices.length ||\r\n                    validProjectedVertices[from].x < -999 ||\r\n                    validProjectedVertices[to].x < -999) {\r\n                    continue;\r\n                }\r\n\r\n                const fromVertex = validProjectedVertices[from];\r\n                const toVertex = validProjectedVertices[to];\r\n\r\n                ctx.beginPath();\r\n                ctx.moveTo(fromVertex.x, fromVertex.y);\r\n                ctx.lineTo(toVertex.x, toVertex.y);\r\n                ctx.stroke();\r\n            }\r\n        }\r\n\r\n        // Draw axis lines if enabled\r\n        if (this.showAxisLines) {\r\n            this.drawAxisLines(ctx, validProjectedVertices[0]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Draw colored axis lines for visualization\r\n     * @param {CanvasRenderingContext2D} ctx - The render texture context\r\n     * @param {Vector2} origin - The origin point to draw axes from\r\n     */\r\n    drawAxisLines(ctx, origin) {\r\n        if (!origin) return;\r\n\r\n        const axisLength = this.axisLength;\r\n        const centerX = origin.x;\r\n        const centerY = origin.y;\r\n\r\n        const axes = {\r\n            x: new Vector3(axisLength, 0, 0),\r\n            y: new Vector3(0, axisLength, 0),\r\n            z: new Vector3(0, 0, axisLength)\r\n        };\r\n\r\n        const projectedAxes = {};\r\n        for (const [axis, endpoint] of Object.entries(axes)) {\r\n            const worldPoint = new Vector3(\r\n                endpoint.x + this.position.x,\r\n                endpoint.y + this.position.y,\r\n                endpoint.z + this.position.z\r\n            );\r\n            projectedAxes[axis] = this.projectPointRelative(worldPoint, origin);\r\n        }\r\n\r\n        const axisColors = {\r\n            x: '#ff0000',\r\n            y: '#0000ff',\r\n            z: '#00ff00'\r\n        };\r\n\r\n        const axisLabels = {\r\n            x: 'X',\r\n            y: 'Y',\r\n            z: 'Z'\r\n        };\r\n\r\n        ctx.font = '12px Arial';\r\n        ctx.textAlign = 'center';\r\n        ctx.textBaseline = 'middle';\r\n\r\n        for (const [axis, color] of Object.entries(axisColors)) {\r\n            const endPoint = projectedAxes[axis];\r\n            if (!endPoint) continue;\r\n\r\n            ctx.strokeStyle = color;\r\n            ctx.lineWidth = 3;\r\n            ctx.beginPath();\r\n            ctx.moveTo(centerX, centerY);\r\n            ctx.lineTo(endPoint.x, endPoint.y);\r\n            ctx.stroke();\r\n\r\n            ctx.fillStyle = color;\r\n            ctx.fillText(axisLabels[axis], endPoint.x, endPoint.y);\r\n\r\n            this.drawArrowhead(ctx, centerX, centerY, endPoint.x, endPoint.y, color);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Project a point relative to an origin for axis drawing\r\n     * @param {Vector3} worldPoint - The world point to project\r\n     * @param {Vector2} origin - The origin point\r\n     * @returns {Vector2|null} The projected point\r\n     */\r\n    projectPointRelative(worldPoint, origin) {\r\n        const camera = this.findActiveCamera();\r\n        if (!camera) return null;\r\n        return camera.projectPoint(worldPoint);\r\n    }\r\n\r\n    /**\r\n     * Draw an arrowhead at the end of an axis line\r\n     * @param {CanvasRenderingContext2D} ctx - The canvas context\r\n     * @param {number} fromX - Start X coordinate\r\n     * @param {number} fromY - Start Y coordinate\r\n     * @param {number} toX - End X coordinate\r\n     * @param {number} toY - End Y coordinate\r\n     * @param {string} color - The color of the arrowhead\r\n     */\r\n    drawArrowhead(ctx, fromX, fromY, toX, toY, color) {\r\n        const headLength = 8;\r\n        const headAngle = Math.PI / 6;\r\n\r\n        const dx = toX - fromX;\r\n        const dy = toY - fromY;\r\n        const length = Math.sqrt(dx * dx + dy * dy);\r\n\r\n        if (length === 0) return;\r\n\r\n        const unitX = dx / length;\r\n        const unitY = dy / length;\r\n        const perpX = -unitY;\r\n        const perpY = unitX;\r\n\r\n        const arrowX1 = toX - headLength * (unitX * Math.cos(headAngle) - perpX * Math.sin(headAngle));\r\n        const arrowY1 = toY - headLength * (unitY * Math.cos(headAngle) - perpY * Math.sin(headAngle));\r\n        const arrowX2 = toX - headLength * (unitX * Math.cos(headAngle) + perpX * Math.sin(headAngle));\r\n        const arrowY2 = toY - headLength * (unitY * Math.cos(headAngle) + perpY * Math.sin(headAngle));\r\n\r\n        ctx.strokeStyle = color;\r\n        ctx.lineWidth = 2;\r\n        ctx.beginPath();\r\n        ctx.moveTo(toX, toY);\r\n        ctx.lineTo(arrowX1, arrowY1);\r\n        ctx.moveTo(toX, toY);\r\n        ctx.lineTo(arrowX2, arrowY2);\r\n        ctx.stroke();\r\n    }\r\n\r\n    /**\r\n     * Find the active camera in the scene\r\n     * @returns {Camera3D|null} The active camera or null\r\n     */\r\n    findActiveCamera() {\r\n        const allObjects = this.getGameObjects();\r\n\r\n        for (const obj of allObjects) {\r\n            const camera = obj.getModule(\"Camera3D\");\r\n            if (camera && camera.isActive) {\r\n                return camera;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Get all game objects in the scene\r\n     * @returns {Array<GameObject>} All game objects\r\n     */\r\n    getGameObjects() {\r\n        if (!this.gameObject) return [];\r\n\r\n        return this.getAllGameObjects();\r\n    }\r\n\r\n    /**\r\n     * Transform vertices based on mesh and game object transforms\r\n     * @returns {Array<Vector3>} Transformed vertices\r\n     */\r\n    transformVertices() {\r\n        let objPos = { x: 0, y: 0 };\r\n        let objRot = 0;\r\n        let objScale = { x: 1, y: 1 };\r\n\r\n        if (this.gameObject) {\r\n            objPos = this.gameObject.getWorldPosition ? this.gameObject.getWorldPosition() : { x: 0, y: 0 };\r\n            objRot = this.gameObject.getWorldRotation ? this.gameObject.getWorldRotation() : 0;\r\n            objScale = this.gameObject.getWorldScale ? this.gameObject.getWorldScale() : { x: 1, y: 1 };\r\n        }\r\n\r\n        let objDepth = 0;\r\n        if (this.gameObject) {\r\n            if (typeof this.gameObject.getWorldDepth === 'function') {\r\n                objDepth = this.gameObject.getWorldDepth();\r\n            } else if (typeof this.gameObject.depth === 'number') {\r\n                objDepth = this.gameObject.depth;\r\n            } else if (this.gameObject.position && typeof this.gameObject.position.z === 'number') {\r\n                objDepth = this.gameObject.position.z;\r\n            }\r\n        }\r\n\r\n        const objPos3D = new Vector3(objPos.x, objPos.y, objDepth);\r\n        const objScale3D = new Vector3(objScale.x, objScale.y, 1);\r\n\r\n        return this.vertices.map(vertex => {\r\n            let v = vertex.clone ? vertex.clone() : new Vector3(vertex.x, vertex.y, vertex.z);\r\n\r\n            // Apply mesh scale\r\n            v.x *= this.scale.x;\r\n            v.y *= this.scale.y;\r\n            v.z *= this.scale.z;\r\n\r\n            // Apply game object rotation\r\n            if (objRot !== 0) {\r\n                const rotRad = objRot * (Math.PI / 180);\r\n                v = this.rotateZ(v, rotRad);\r\n            }\r\n\r\n            // Apply mesh rotation\r\n            if (this.rotation.x !== 0) v = this.rotateX(v, this.rotation.x * (Math.PI / 180));\r\n            if (this.rotation.y !== 0) v = this.rotateY(v, this.rotation.y * (Math.PI / 180));\r\n            if (this.rotation.z !== 0) v = this.rotateZ(v, this.rotation.z * (Math.PI / 180));\r\n\r\n            // Apply mesh position\r\n            v.x += this.position.x;\r\n            v.y += this.position.y;\r\n            v.z += this.position.z;\r\n\r\n            // Apply game object scale\r\n            v.x *= objScale3D.x;\r\n            v.y *= objScale3D.y;\r\n            v.z *= objScale3D.z;\r\n\r\n            // Apply game object position\r\n            v.x += objPos3D.x;\r\n            v.y += objPos3D.y;\r\n            v.z += objPos3D.z;\r\n\r\n            return v;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Rotate a vector around the X axis\r\n     * @param {Vector3} v - Vector to rotate\r\n     * @param {number} angle - Angle in radians\r\n     * @returns {Vector3} Rotated vector\r\n     */\r\n    rotateX(v, angle) {\r\n        const cos = Math.cos(angle);\r\n        const sin = Math.sin(angle);\r\n        return new Vector3(\r\n            v.x,\r\n            v.y * cos - v.z * sin,\r\n            v.y * sin + v.z * cos\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Rotate a vector around the Y axis\r\n     * @param {Vector3} v - Vector to rotate\r\n     * @param {number} angle - Angle in radians\r\n     * @returns {Vector3} Rotated vector\r\n     */\r\n    rotateY(v, angle) {\r\n        const cos = Math.cos(angle);\r\n        const sin = Math.sin(angle);\r\n        return new Vector3(\r\n            v.x * cos + v.z * sin,\r\n            v.y,\r\n            -v.x * sin + v.z * cos\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Rotate a vector around the Z axis\r\n     * @param {Vector3} v - Vector to rotate\r\n     * @param {number} angle - Angle in radians\r\n     * @returns {Vector3} Rotated vector\r\n     */\r\n    rotateZ(v, angle) {\r\n        const cos = Math.cos(angle);\r\n        const sin = Math.sin(angle);\r\n        return new Vector3(\r\n            v.x * cos - v.y * sin,\r\n            v.x * sin + v.y * cos,\r\n            v.z\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Draw in the editor\r\n     * @param {CanvasRenderingContext2D} ctx - The canvas context\r\n     */\r\n    drawInEditor(ctx) {\r\n        this.draw(ctx);\r\n    }\r\n\r\n    /**\r\n     * Serialize the sphere mesh to JSON\r\n     * @returns {Object} JSON representation of the sphere mesh\r\n     */\r\n    toJSON() {\r\n        return {\r\n            _type: \"SphereMesh3D\",\r\n            _radius: this._radius,\r\n            _position: { x: this._position.x, y: this._position.y, z: this._position.z },\r\n            _rotation: { x: this._rotation.x, y: this._rotation.y, z: this._rotation.z },\r\n            _scale: { x: this._scale.x, y: this._scale.y, z: this._scale.z },\r\n            _wireframeColor: this._wireframeColor,\r\n            _faceColor: this._faceColor,\r\n            _renderMode: this._renderMode,\r\n            _showAxisLines: this._showAxisLines,\r\n            _axisLength: this._axisLength,\r\n            _segments: this._segments,\r\n            _rings: this._rings,\r\n            material: this.material ? this.material.toJSON() : null\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Deserialize the sphere mesh from JSON\r\n     * @param {Object} json - JSON representation of the sphere mesh\r\n     */\r\n    fromJSON(json) {\r\n        if (json._radius !== undefined) {\r\n            this._radius = json._radius;\r\n            this.updateSphere();\r\n        }\r\n        if (json._position) this._position = new Vector3(json._position.x, json._position.y, json._position.z);\r\n        if (json._rotation) this._rotation = new Vector3(json._rotation.x, json._rotation.y, json._rotation.z);\r\n        if (json._scale) this._scale = new Vector3(json._scale.x, json._scale.y, json._scale.z);\r\n        if (json._wireframeColor !== undefined) this._wireframeColor = json._wireframeColor;\r\n        if (json._faceColor !== undefined) this._faceColor = json._faceColor;\r\n        if (json._renderMode !== undefined) this._renderMode = json._renderMode;\r\n        if (json._showAxisLines !== undefined) this._showAxisLines = json._showAxisLines;\r\n        if (json._axisLength !== undefined) this._axisLength = json._axisLength;\r\n        if (json._segments !== undefined) this._segments = json._segments;\r\n        if (json._rings !== undefined) this._rings = json._rings;\r\n        if (json.material !== undefined) {\r\n            if (this.material && json.material) {\r\n                this.material.fromJSON(json.material);\r\n            } else if (json.material) {\r\n                // Create new material if one doesn't exist\r\n                this.material = new Material();\r\n                this.material.fromJSON(json.material);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Getters and setters\r\n    get radius() { return this._radius; }\r\n    set radius(value) {\r\n        this._radius = value;\r\n        this.updateSphere();\r\n    }\r\n\r\n    get segments() { return this._segments; }\r\n    set segments(value) {\r\n        this._segments = Math.floor(Math.max(3, Math.min(64, value)));\r\n        this.updateSphere();\r\n    }\r\n\r\n    get rings() { return this._rings; }\r\n    set rings(value) {\r\n        this._rings = Math.floor(Math.max(2, Math.min(64, value)));\r\n        this.updateSphere();\r\n    }\r\n\r\n    get position() { return this._position; }\r\n    set position(value) { this._position = value; }\r\n\r\n    get rotation() { return this._rotation; }\r\n    set rotation(value) { this._rotation = value; }\r\n\r\n    get scale() { return this._scale; }\r\n    set scale(value) { this._scale = value; }\r\n\r\n    get wireframeColor() { return this._wireframeColor; }\r\n    set wireframeColor(value) { this._wireframeColor = value; }\r\n\r\n    get faceColor() { return this._faceColor; }\r\n    set faceColor(value) { this._faceColor = value; }\r\n\r\n    get renderMode() { return this._renderMode; }\r\n    set renderMode(value) { this._renderMode = value; }\r\n\r\n    get showAxisLines() { return this._showAxisLines; }\r\n    set showAxisLines(value) { this._showAxisLines = value; }\r\n\r\n    get axisLength() { return this._axisLength; }\r\n    set axisLength(value) { this._axisLength = Math.max(50, Math.min(500, value)); }\r\n}\r\n\r\n// Register the SphereMesh3D module\r\nwindow.SphereMesh3D = SphereMesh3D;",
      "type": "file",
      "name": "SphereMesh3D.js",
      "parentPath": "/",
      "created": 1759457099332,
      "modified": 1759457099332
    },
    {
      "path": "/TopDownCamera.js",
      "content": "/**\r\n  * TopDownCamera - Module for top-down camera movement (Z-up coordinate system)\r\n  *\r\n  * This module provides top-down camera controls that lock the camera\r\n  * at a top-down angle while allowing movement in the X/Y plane.\r\n  * Coordinate system: Z = up/down, Y = left/right, X = forward/back\r\n  * It needs to be attached to a GameObject with a Camera3D module.\r\n  */\r\nclass TopDownCamera extends Module {\r\n    static namespace = \"3D\";\r\n    static description = \"Top-down camera controller with Z-up coordinate system (Z=up/down, Y=left/right, X=forward/back)\";\r\n    static iconClass = \"fas fa-camera\";\r\n\r\n    /**\r\n     * Create a new TopDownCamera\r\n     */\r\n    constructor() {\r\n        super(\"TopDownCamera\");\r\n\r\n        // Setup requirements\r\n        this.requires(\"Camera3D\");\r\n\r\n        // Camera settings\r\n        this._cameraDistance = 500; // Distance from target (Z-axis)\r\n        this._moveSpeed = 200; // Units per second\r\n        this._sprintMultiplier = 2.5;\r\n        this._smoothing = 0.2; // Lower = more responsive, higher = smoother\r\n        this._currentVelocity = new Vector3(0, 0, 0);\r\n\r\n        // Top-down angle settings (in degrees) - Z-up coordinate system\r\n        this._topDownAngleX = 90; // Pitch around Y axis (90 degrees = looking straight down)\r\n        this._topDownAngleY = 0;  // Yaw around Z axis (0 = no rotation)\r\n        this._topDownAngleZ = 0;  // Roll around X axis (0 = no roll)\r\n\r\n        // Key mapping (can be customized)\r\n        this._keyMapping = {\r\n            forward: \"w\",\r\n            backward: \"s\",\r\n            left: \"a\",\r\n            right: \"d\",\r\n            up: \"e\",        // Move up in Z (increase distance)\r\n            down: \"q\",      // Move down in Z (decrease distance)\r\n            sprint: \"shift\"\r\n        };\r\n\r\n        // Camera reference (will be set in start())\r\n        this.camera = null;\r\n\r\n        // Expose properties to the inspector\r\n        this.exposeProperty(\"cameraDistance\", \"number\", 500, {\r\n            min: 10,\r\n            max: 2000,\r\n            step: 10,\r\n            description: \"Distance from camera to target\",\r\n            onChange: (val) => this._cameraDistance = val\r\n        });\r\n\r\n        this.exposeProperty(\"moveSpeed\", \"number\", 200, {\r\n            min: 1,\r\n            max: 1000,\r\n            description: \"Movement speed in units per second\",\r\n            onChange: (val) => this._moveSpeed = val\r\n        });\r\n\r\n        this.exposeProperty(\"sprintMultiplier\", \"number\", 2.5, {\r\n            min: 1,\r\n            max: 10,\r\n            description: \"Speed multiplier when sprinting\",\r\n            onChange: (val) => this._sprintMultiplier = val\r\n        });\r\n\r\n        this.exposeProperty(\"smoothing\", \"number\", 0.2, {\r\n            min: 0,\r\n            max: 0.99,\r\n            step: 0.01,\r\n            description: \"Movement smoothing (0 = instant, 1 = very smooth)\",\r\n            onChange: (val) => this._smoothing = val\r\n        });\r\n\r\n        this.exposeProperty(\"topDownAngleX\", \"number\", 90, {\r\n            min: 45,\r\n            max: 90,\r\n            step: 1,\r\n            description: \"Camera pitch angle around Y axis (90 = straight down)\",\r\n            onChange: (val) => this._topDownAngleX = val\r\n        });\r\n\r\n        this.exposeProperty(\"topDownAngleY\", \"number\", 0, {\r\n            min: -180,\r\n            max: 180,\r\n            step: 1,\r\n            description: \"Camera yaw angle around Z axis (rotation around vertical axis)\",\r\n            onChange: (val) => this._topDownAngleY = val\r\n        });\r\n\r\n        this.exposeProperty(\"topDownAngleZ\", \"number\", 0, {\r\n            min: -180,\r\n            max: 180,\r\n            step: 1,\r\n            description: \"Camera roll angle around X axis (tilt)\",\r\n            onChange: (val) => this._topDownAngleZ = val\r\n        });\r\n\r\n        this.exposeProperty(\"keyMapping\", \"object\", this._keyMapping, {\r\n            description: \"Key mapping for camera controls\",\r\n            onChange: (val) => this._keyMapping = val\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Called when the module starts\r\n     */\r\n    start() {\r\n        // Get camera reference\r\n        this.camera = this.gameObject.getModule(\"Camera3D\");\r\n\r\n        if (!this.camera) {\r\n            console.error(\"TopDownCamera requires a Camera3D module on the same GameObject\");\r\n        }\r\n\r\n        // Make sure input manager is available\r\n        if (!window.input) {\r\n            console.error(\"TopDownCamera requires InputManager to be initialized\");\r\n        }\r\n\r\n        // Lock camera to top-down angle immediately\r\n        this.lockCameraAngle();\r\n    }\r\n\r\n    /**\r\n      * Lock the camera to the top-down angle\r\n      */\r\n     lockCameraAngle() {\r\n         if (!this.camera) return;\r\n \r\n         // Set camera rotation to top-down angles (Z-up coordinate system)\r\n         // rotation.x = roll (around X axis) = 0 for no roll\r\n         // rotation.y = pitch (around Y axis) = 90 degrees for straight down\r\n         // rotation.z = yaw (around Z axis) = rotation angle\r\n         if (this.camera.rotation) {\r\n             this.camera.rotation.x = this._topDownAngleZ; // Roll (around X axis)\r\n             this.camera.rotation.y = this._topDownAngleX; // Pitch (around Y axis) - 90 degrees = straight down\r\n             this.camera.rotation.z = this._topDownAngleY; // Yaw (around Z axis)\r\n         }\r\n \r\n         // Also set the gameObject's rotation to match\r\n         if (this.gameObject) {\r\n             this.gameObject.angle = this._topDownAngleY; // Use yaw angle directly\r\n         }\r\n     }\r\n\r\n    /**\r\n     * Handle camera movement each frame\r\n     * @param {number} deltaTime - Time since last frame in seconds\r\n     */\r\n    loop(deltaTime) {\r\n        if (!this.camera || !window.input) return;\r\n\r\n        // Lock camera angle every frame to prevent changes\r\n        this.lockCameraAngle();\r\n\r\n        // Calculate target velocity based on key presses\r\n        const targetVelocity = this.calculateTargetVelocity();\r\n\r\n        // Apply smoothing\r\n        this._currentVelocity.x += (targetVelocity.x - this._currentVelocity.x) * (1 - this._smoothing);\r\n        this._currentVelocity.y += (targetVelocity.y - this._currentVelocity.y) * (1 - this._smoothing);\r\n        this._currentVelocity.z += (targetVelocity.z - this._currentVelocity.z) * (1 - this._smoothing);\r\n\r\n        // Move the camera\r\n        if (this._currentVelocity.magnitude() > 0.01) {\r\n            this.moveCamera(deltaTime);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate target velocity based on key presses\r\n     * @returns {Vector3} Target velocity\r\n     */\r\n    calculateTargetVelocity() {\r\n        // Start with zero velocity\r\n        const targetVelocity = new Vector3(0, 0, 0);\r\n\r\n        // Check if input manager is available\r\n        if (!window.input) return targetVelocity;\r\n\r\n        // Check sprint key\r\n        const sprinting = window.input.keyDown(this.keyMapping.sprint);\r\n        const speedMultiplier = sprinting ? this.sprintMultiplier : 1;\r\n\r\n        // Calculate movement direction in world space\r\n        // For top-down camera, we move in X/Y plane and Z (distance)\r\n        if (window.input.keyDown(this.keyMapping.forward)) {\r\n            targetVelocity.x += this.moveSpeed * speedMultiplier;   // Forward (X axis)\r\n        }\r\n        if (window.input.keyDown(this.keyMapping.backward)) {\r\n            targetVelocity.x -= this.moveSpeed * speedMultiplier;   // Backward (-X axis)\r\n        }\r\n        if (window.input.keyDown(this.keyMapping.left)) {\r\n            targetVelocity.y -= this.moveSpeed * speedMultiplier;   // Left (-Y axis)\r\n        }\r\n        if (window.input.keyDown(this.keyMapping.right)) {\r\n            targetVelocity.y += this.moveSpeed * speedMultiplier;   // Right (Y axis)\r\n        }\r\n        if (window.input.keyDown(this.keyMapping.up)) {\r\n            targetVelocity.z += this.moveSpeed * speedMultiplier;   // Up (+Z, increase distance)\r\n        }\r\n        if (window.input.keyDown(this.keyMapping.down)) {\r\n            targetVelocity.z -= this.moveSpeed * speedMultiplier;   // Down (-Z, decrease distance)\r\n        }\r\n\r\n        return targetVelocity;\r\n    }\r\n\r\n    /**\r\n     * Move the camera based on current velocity\r\n     * @param {number} deltaTime - Time since last frame in seconds\r\n     */\r\n    moveCamera(deltaTime) {\r\n        // Ensure gameObject.position exists and has numeric x/y\r\n        if (!this.gameObject.position || typeof this.gameObject.position.x !== 'number' || typeof this.gameObject.position.y !== 'number') {\r\n            this.gameObject.position = { x: 0, y: 0 };\r\n        }\r\n\r\n        // Apply horizontal movement (X/Y plane)\r\n        const dx = Number.isFinite(this._currentVelocity.x) ? this._currentVelocity.x * deltaTime : 0;\r\n        const dy = Number.isFinite(this._currentVelocity.y) ? this._currentVelocity.y * deltaTime : 0;\r\n\r\n        this.gameObject.position.x += dx;\r\n        this.gameObject.position.y += dy;\r\n\r\n        // Apply vertical movement (Z distance)\r\n        const dz = Number.isFinite(this._currentVelocity.z) ? this._currentVelocity.z * deltaTime : 0;\r\n\r\n        if (this.camera && this.camera.position) {\r\n            // Update camera's Z position for distance\r\n            if (!this.camera.position.z || typeof this.camera.position.z !== 'number') {\r\n                this.camera.position.z = this._cameraDistance;\r\n            } else {\r\n                this.camera.position.z += dz;\r\n                // Clamp camera distance to reasonable bounds\r\n                this.camera.position.z = Math.max(50, Math.min(2000, this.camera.position.z));\r\n                // Update our distance property to match\r\n                this._cameraDistance = this.camera.position.z;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the camera distance immediately\r\n     * @param {number} distance - New camera distance\r\n     */\r\n    setCameraDistance(distance) {\r\n        this._cameraDistance = Math.max(50, Math.min(2000, distance));\r\n\r\n        if (this.camera && this.camera.position) {\r\n            this.camera.position.z = this._cameraDistance;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the current camera distance\r\n     * @returns {number} Current camera distance\r\n     */\r\n    getCameraDistance() {\r\n        if (this.camera && this.camera.position && typeof this.camera.position.z === 'number') {\r\n            return this.camera.position.z;\r\n        }\r\n        return this._cameraDistance;\r\n    }\r\n\r\n    /**\r\n      * Set the top-down angles (Z-up coordinate system)\r\n      * @param {number} pitch - Pitch angle around Y axis (90 = straight down)\r\n      * @param {number} yaw - Yaw angle around Z axis (rotation)\r\n      * @param {number} roll - Roll angle around X axis (tilt)\r\n      */\r\n     setTopDownAngles(pitch = 90, yaw = 0, roll = 0) {\r\n         this._topDownAngleX = Math.max(45, Math.min(90, pitch)); // Pitch (Y axis)\r\n         this._topDownAngleY = yaw; // Yaw (Z axis)\r\n         this._topDownAngleZ = roll; // Roll (X axis)\r\n\r\n         // Apply immediately\r\n         this.lockCameraAngle();\r\n     }\r\n\r\n    /**\r\n     * Serialize the top-down camera to JSON\r\n     * @returns {Object} JSON representation of the top-down camera\r\n     */\r\n    toJSON() {\r\n        return {\r\n            _type: \"TopDownCamera\",\r\n            _cameraDistance: this._cameraDistance,\r\n            _moveSpeed: this._moveSpeed,\r\n            _sprintMultiplier: this._sprintMultiplier,\r\n            _smoothing: this._smoothing,\r\n            _topDownAngleX: this._topDownAngleX,\r\n            _topDownAngleY: this._topDownAngleY,\r\n            _topDownAngleZ: this._topDownAngleZ,\r\n            _keyMapping: { ...this._keyMapping }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Deserialize the top-down camera from JSON\r\n     * @param {Object} json - JSON representation of the top-down camera\r\n     */\r\n    fromJSON(json) {\r\n        if (json._cameraDistance !== undefined) this._cameraDistance = json._cameraDistance;\r\n        if (json._moveSpeed !== undefined) this._moveSpeed = json._moveSpeed;\r\n        if (json._sprintMultiplier !== undefined) this._sprintMultiplier = json._sprintMultiplier;\r\n        if (json._smoothing !== undefined) this._smoothing = json._smoothing;\r\n        if (json._topDownAngleX !== undefined) this._topDownAngleX = json._topDownAngleX;\r\n        if (json._topDownAngleY !== undefined) this._topDownAngleY = json._topDownAngleY;\r\n        if (json._topDownAngleZ !== undefined) this._topDownAngleZ = json._topDownAngleZ;\r\n        if (json._keyMapping) this._keyMapping = { ...json._keyMapping };\r\n\r\n        // Apply the loaded settings\r\n        this.lockCameraAngle();\r\n    }\r\n\r\n    // Getters and setters for properties\r\n    get cameraDistance() { return this._cameraDistance; }\r\n    set cameraDistance(value) { this._cameraDistance = value; this.setCameraDistance(value); }\r\n\r\n    get moveSpeed() { return this._moveSpeed; }\r\n    set moveSpeed(value) { this._moveSpeed = value; }\r\n\r\n    get sprintMultiplier() { return this._sprintMultiplier; }\r\n    set sprintMultiplier(value) { this._sprintMultiplier = value; }\r\n\r\n    get smoothing() { return this._smoothing; }\r\n    set smoothing(value) { this._smoothing = Math.max(0, Math.min(0.99, value)); }\r\n\r\n    get topDownAngleX() { return this._topDownAngleX; }\r\n    set topDownAngleX(value) { this._topDownAngleX = value; this.lockCameraAngle(); }\r\n\r\n    get topDownAngleY() { return this._topDownAngleY; }\r\n    set topDownAngleY(value) { this._topDownAngleY = value; this.lockCameraAngle(); }\r\n\r\n    get topDownAngleZ() { return this._topDownAngleZ; }\r\n    set topDownAngleZ(value) { this._topDownAngleZ = value; this.lockCameraAngle(); }\r\n\r\n    get keyMapping() { return this._keyMapping; }\r\n    set keyMapping(value) { this._keyMapping = value; }\r\n}\r\n\r\n// Register the TopDownCamera module\r\nwindow.TopDownCamera = TopDownCamera;",
      "type": "file",
      "name": "TopDownCamera.js",
      "parentPath": "/",
      "created": 1759457099333,
      "modified": 1759457099333
    }
  ],
  "metadata": {
    "exportedBy": "Dark Matter JS Game Engine",
    "exportVersion": "1.0",
    "engineVersion": "1.0.0",
    "selectionMode": "explicit-directories-only"
  }
}