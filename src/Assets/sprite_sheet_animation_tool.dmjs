{
  "name": "Sprite-Sheet Animation Tool",
  "description": "An advanced keyframe animation tool that exports sprite-sheets. \n\nAllows for multiple animations organized by rows and columns",
  "version": "1.0.0",
  "author": "SynKrown",
  "timestamp": 1757910826619,
  "directories": [
    "/assets"
  ],
  "totalFiles": 1,
  "totalDirectories": 1,
  "files": [
    {
      "path": "/assets/AnimationToolWindow.js",
      "content": "/* AnimationToolWindow - Advanced animation and sprite editor\n * \n * Features:\n * - Drawing tools (brush, pen, pencil, shapes, fill bucket)\n * - Color picker and palette\n * - Animation timeline with onion skinning\n * - Layer management per frame\n * - Animation groups (idle, walking, etc.)\n * - Save/load to file browser\n * - Export as sprite sheet\n * - Professional layout with toolbar\n * \n * @extends EditorWindow\n */\nclass AnimationToolWindow extends EditorWindow {\n    static displayName = \"Animation Tool\";\n    static description = \"Advanced animation and sprite editor\";\n    static icon = \"fa-film\";\n    static color = \"#9afdff\";\n\n    constructor() {\n        super(\"Animation Tool\", {\n            width: 1400,\n            height: 900,\n            resizable: true,\n            className: 'animation-tool-window'\n        });\n\n        // Drawing state\n        this.isDrawing = false;\n        this.currentTool = 'brush';\n        this.currentColor = '#ffffff';\n        this.brushSize = 5;\n        this.opacity = 1.0;\n        this.activeLayerIndex = 0;\n\n        // Animation groups (idle, walking, etc.)\n        this.animationGroups = new Map();\n        this.currentGroupId = 'default';\n\n        // Initialize default group\n        this.animationGroups.set('default', {\n            id: 'default',\n            name: 'Default',\n            frames: [],\n            currentFrameIndex: 0\n        });\n\n        this.isPlaying = false;\n        this.frameRate = 12;\n        this.onionSkinEnabled = true;\n        this.onionSkinFrames = 3;\n        this.onionSkinOpacity = 0.3;\n\n        // Canvas properties\n        this.canvasWidth = 64;\n        this.canvasHeight = 64;\n        this.zoom = 8.0;\n        this.panX = 0;\n        this.panY = 0;\n        this.showGrid = true;\n        this.gridSize = 1;\n\n        // History for undo/redo\n        this.history = [];\n        this.historyIndex = -1;\n        this.maxHistorySteps = 50;\n\n        // File management\n        this.currentFilePath = null;\n        this.hasUnsavedChanges = false;\n        this.projectName = 'Untitled Animation';\n\n        this.setupUI();\n        this.initializeCanvas();\n        this.setupEventListeners();\n        this.addDefaultFrame();\n\n        // Ensure first frame is properly loaded\n        setTimeout(() => {\n            this.selectFrame(0);\n        }, 100);\n    }\n\n    setupUI() {\n        this.clearContent();\n\n        const mainContainer = document.createElement('div');\n        mainContainer.style.cssText = `\n            display: flex;\n            flex-direction: column;\n            height: 100%;\n            overflow: hidden;\n        `;\n\n        this.createToolbar();\n\n        const workspace = document.createElement('div');\n        workspace.style.cssText = `\n            display: flex;\n            flex: 1;\n            overflow: hidden;\n        `;\n\n        this.createLeftPanel();\n        this.createCanvasPanel();\n        this.createRightPanel();\n        this.createTimelinePanel();\n\n        workspace.appendChild(this.leftPanel);\n        workspace.appendChild(this.canvasPanel);\n        workspace.appendChild(this.rightPanel);\n\n        mainContainer.appendChild(this.toolbar);\n        mainContainer.appendChild(workspace);\n        mainContainer.appendChild(this.timelinePanel);\n\n        this.addContent(mainContainer);\n    }\n\n    createToolbar() {\n        this.toolbar = document.createElement('div');\n        this.toolbar.style.cssText = `\n            display: flex;\n            align-items: center;\n            padding: 8px;\n            background: #2a2a2a;\n            border-bottom: 1px solid #444;\n            gap: 8px;\n            flex-wrap: wrap;\n        `;\n\n        // File operations\n        this.addToolbarButton('new', 'ðŸ“„', 'New Animation', () => this.newAnimation());\n        this.addToolbarButton('open', 'ðŸ“', 'Open Animation', () => this.openAnimation());\n        this.addToolbarButton('save', 'ðŸ’¾', 'Save Animation', () => this.saveAnimation());\n        this.addToolbarButton('export-sheet', 'ðŸ—‚ï¸', 'Export Sprite Sheet', () => this.exportSpriteSheet());\n\n        this.addToolbarSeparator();\n\n        // Edit operations\n        this.addToolbarButton('undo', 'â†¶', 'Undo', () => this.undo());\n        this.addToolbarButton('redo', 'â†·', 'Redo', () => this.redo());\n        this.addToolbarButton('clear', 'ðŸ—‘ï¸', 'Clear Canvas', () => this.clearCanvas());\n\n        this.addToolbarSeparator();\n\n        // Zoom controls\n        this.addToolbarButton('zoom-out', 'ðŸ”-', 'Zoom Out', () => this.zoomOut());\n        this.addToolbarButton('zoom-reset', 'ðŸ”=', 'Reset Zoom', () => this.resetZoom());\n        this.addToolbarButton('zoom-in', 'ðŸ”+', 'Zoom In', () => this.zoomIn());\n\n        this.addToolbarSeparator();\n\n        // Animation controls\n        this.addToolbarButton('play', 'â–¶ï¸', 'Play Animation', () => this.togglePlayback());\n        this.addToolbarButton('onion-skin', 'ðŸ‘»', 'Toggle Onion Skin', () => this.toggleOnionSkin());\n    }\n\n    createLeftPanel() {\n        this.leftPanel = document.createElement('div');\n        this.leftPanel.style.cssText = `\n            width: 250px;\n            background: #252525;\n            border-right: 1px solid #444;\n            display: flex;\n            flex-direction: column;\n            overflow-y: auto;\n        `;\n\n        // Animation Groups section\n        const groupsSection = this.createSection('Animation Groups');\n        this.createAnimationGroupsPanel(groupsSection);\n\n        // Tools section\n        const toolsSection = this.createSection('Drawing Tools');\n        this.createToolGrid(toolsSection);\n\n        // Color section\n        const colorSection = this.createSection('Colors');\n        this.createColorPicker(colorSection);\n\n        // Brush settings section\n        const brushSection = this.createSection('Brush Settings');\n        this.createBrushSettings(brushSection);\n\n        this.leftPanel.appendChild(groupsSection);\n        this.leftPanel.appendChild(toolsSection);\n        this.leftPanel.appendChild(colorSection);\n        this.leftPanel.appendChild(brushSection);\n    }\n\n    createAnimationGroupsPanel(container) {\n        this.groupsContainer = document.createElement('div');\n        this.groupsContainer.style.cssText = `\n            padding: 8px;\n        `;\n\n        const addGroupBtn = document.createElement('button');\n        addGroupBtn.textContent = '+ Add Animation';\n        addGroupBtn.style.cssText = `\n            width: 100%;\n            padding: 8px;\n            background: #9C27B0;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            margin-bottom: 8px;\n            cursor: pointer;\n        `;\n\n        addGroupBtn.addEventListener('click', () => {\n            const name = prompt('Animation name:', `Animation ${this.animationGroups.size + 1}`);\n            if (name) this.addAnimationGroup(name);\n        });\n\n        container.appendChild(addGroupBtn);\n        container.appendChild(this.groupsContainer);\n        this.updateGroupsDisplay();\n    }\n\n    createCanvasPanel() {\n        this.canvasPanel = document.createElement('div');\n        this.canvasPanel.style.cssText = `\n            flex: 1;\n            display: flex;\n            flex-direction: column;\n            background: #1a1a1a;\n            overflow: hidden;\n            position: relative;\n        `;\n\n        this.canvasContainer = document.createElement('div');\n        this.canvasContainer.style.cssText = `\n            flex: 1;\n            overflow: auto;\n            display: flex;\n            align-items: flex-start;\n            justify-content: flex-start;\n            background: #1a1a1a;\n            padding: 20px;\n        `;\n\n        this.canvasWrapper = document.createElement('div');\n        this.canvasWrapper.style.cssText = `\n            position: relative;\n            background: #ffffff;\n            box-shadow: 0 0 20px rgba(0,0,0,0.5);\n            border: 2px solid #666;\n        `;\n\n        this.canvasContainer.appendChild(this.canvasWrapper);\n        this.canvasPanel.appendChild(this.canvasContainer);\n    }\n\n    createRightPanel() {\n        this.rightPanel = document.createElement('div');\n        this.rightPanel.style.cssText = `\n            width: 280px;\n            background: #252525;\n            border-left: 1px solid #444;\n            display: flex;\n            flex-direction: column;\n            overflow-y: auto;\n        `;\n\n        // Layers section\n        const layersSection = this.createSection('Layers');\n        this.createLayersPanel(layersSection);\n\n        // Properties section\n        const propsSection = this.createSection('Properties');\n        this.createPropertiesPanel(propsSection);\n\n        const previewSection = this.createSection('Animation Preview');\n        this.createAnimationPreview(previewSection);\n\n        this.rightPanel.appendChild(layersSection);\n        this.rightPanel.appendChild(previewSection);\n        this.rightPanel.appendChild(propsSection);\n    }\n\n    createTimelinePanel() {\n        this.timelinePanel = document.createElement('div');\n        this.timelinePanel.style.cssText = `\n            height: 160px;\n            background: #2a2a2a;\n            border-top: 1px solid #444;\n            display: flex;\n            flex-direction: column;\n        `;\n\n        // Timeline header with controls\n        const timelineHeader = document.createElement('div');\n        timelineHeader.style.cssText = `\n            padding: 8px;\n            background: #333;\n            border-bottom: 1px solid #444;\n            display: flex;\n            align-items: center;\n            gap: 8px;\n            flex-wrap: wrap;\n        `;\n\n        // Frame controls\n        const frameControls = document.createElement('div');\n        frameControls.style.cssText = `\n            display: flex;\n            gap: 4px;\n            align-items: center;\n        `;\n\n        // Frame control buttons\n        const frameButtons = [\n            { id: 'add-frame', icon: 'âž•', title: 'Add Frame', action: () => this.addFrame() },\n            { id: 'duplicate-frame', icon: 'ðŸ“‹', title: 'Duplicate Frame', action: () => this.duplicateFrame() },\n            { id: 'delete-frame', icon: 'ðŸ—‘ï¸', title: 'Delete Frame', action: () => this.deleteFrame() },\n            { id: 'move-left', icon: 'â—€ï¸', title: 'Move Frame Left', action: () => this.moveFrameLeft() },\n            { id: 'move-right', icon: 'â–¶ï¸', title: 'Move Frame Right', action: () => this.moveFrameRight() },\n        ];\n\n        frameButtons.forEach(btn => {\n            const button = document.createElement('button');\n            button.innerHTML = btn.icon;\n            button.title = btn.title;\n            button.style.cssText = `\n                padding: 6px 8px;\n                background: #3a3a3a;\n                border: 1px solid #555;\n                border-radius: 4px;\n                color: #fff;\n                cursor: pointer;\n                font-size: 12px;\n            `;\n            button.addEventListener('click', btn.action);\n            frameControls.appendChild(button);\n        });\n\n        timelineHeader.innerHTML = `\n            <span style=\"color: #fff; font-weight: bold;\">Timeline</span>\n            <span style=\"color: #aaa;\">Frame: <span id=\"current-frame\">1</span></span>\n            <span style=\"color: #aaa;\">FPS:</span>\n            <input type=\"number\" id=\"fps-input\" value=\"12\" min=\"1\" max=\"60\" \n                   style=\"width: 50px; background: #444; color: #fff; border: 1px solid #666; padding: 2px;\">\n        `;\n\n        timelineHeader.appendChild(frameControls);\n\n        // Timeline frames container\n        this.framesContainer = document.createElement('div');\n        this.framesContainer.style.cssText = `\n            flex: 1;\n            display: flex;\n            align-items: center;\n            overflow-x: auto;\n            padding: 8px;\n            gap: 4px;\n        `;\n\n        this.timelinePanel.appendChild(timelineHeader);\n        this.timelinePanel.appendChild(this.framesContainer);\n\n        // FPS input handler\n        setTimeout(() => {\n            const fpsInput = document.getElementById('fps-input');\n            if (fpsInput) {\n                fpsInput.addEventListener('change', (e) => {\n                    this.frameRate = parseInt(e.target.value);\n                });\n            }\n        }, 100);\n    }\n\n    createAnimationPreview(container) {\n        const previewContainer = document.createElement('div');\n        previewContainer.style.cssText = `\n        padding: 8px;\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n    `;\n\n        // Preview canvas\n        this.previewCanvas = document.createElement('canvas');\n        this.previewCanvas.width = 64;\n        this.previewCanvas.height = 64;\n        this.previewCanvas.style.cssText = `\n        width: 128px;\n        height: 128px;\n        border: 2px solid #666;\n        background: white;\n        image-rendering: pixelated;\n        margin-bottom: 8px;\n    `;\n        this.previewCtx = this.previewCanvas.getContext('2d');\n\n        // Preview controls\n        const previewControls = document.createElement('div');\n        previewControls.style.cssText = `\n        display: flex;\n        gap: 4px;\n    `;\n\n        const playPreviewBtn = document.createElement('button');\n        playPreviewBtn.innerHTML = 'â–¶ï¸';\n        playPreviewBtn.style.cssText = `\n        padding: 4px 8px;\n        background: #3a3a3a;\n        border: 1px solid #555;\n        color: white;\n        border-radius: 4px;\n        cursor: pointer;\n    `;\n\n        playPreviewBtn.addEventListener('click', () => this.togglePreviewPlayback());\n\n        previewControls.appendChild(playPreviewBtn);\n\n        previewContainer.appendChild(this.previewCanvas);\n        previewContainer.appendChild(previewControls);\n        container.appendChild(previewContainer);\n\n        this.isPreviewPlaying = false;\n        this.updatePreview();\n    }\n\n    initializeCanvas() {\n        // Create background canvas (checkered pattern for transparency)\n        this.backgroundCanvas = document.createElement('canvas');\n        this.backgroundCanvas.width = this.canvasWidth;\n        this.backgroundCanvas.height = this.canvasHeight;\n        this.backgroundCtx = this.backgroundCanvas.getContext('2d');\n\n        // Create grid canvas (bottom layer)\n        this.gridCanvas = document.createElement('canvas');\n        this.gridCanvas.width = this.canvasWidth;\n        this.gridCanvas.height = this.canvasHeight;\n        this.gridCtx = this.gridCanvas.getContext('2d');\n\n        // Create onion skin canvas\n        this.onionCanvas = document.createElement('canvas');\n        this.onionCanvas.width = this.canvasWidth;\n        this.onionCanvas.height = this.canvasHeight;\n        this.onionCtx = this.onionCanvas.getContext('2d');\n\n        // Create main drawing canvas\n        this.canvas = document.createElement('canvas');\n        this.canvas.width = this.canvasWidth;\n        this.canvas.height = this.canvasHeight;\n        this.ctx = this.canvas.getContext('2d');\n\n        // Stack canvases\n        [this.backgroundCanvas, this.gridCanvas, this.onionCanvas, this.canvas].forEach((canvas, index) => {\n            canvas.style.cssText = `\n                position: absolute;\n                top: 0;\n                left: 0;\n                cursor: crosshair;\n                z-index: ${index + 1};\n                background: transparent;\n                image-rendering: pixelated;\n                image-rendering: -moz-crisp-edges;\n                image-rendering: crisp-edges;\n            `;\n        });\n\n        this.canvasWrapper.appendChild(this.backgroundCanvas);\n        this.canvasWrapper.appendChild(this.gridCanvas);\n        this.canvasWrapper.appendChild(this.onionCanvas);\n        this.canvasWrapper.appendChild(this.canvas);\n\n        this.updateCanvasSize();\n        this.drawTransparencyBackground();\n        this.drawGrid();\n    }\n\n    drawTransparencyBackground() {\n        const checkerSize = Math.max(1, Math.floor(8 / this.zoom));\n        this.backgroundCtx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n\n        for (let x = 0; x < this.canvasWidth; x += checkerSize) {\n            for (let y = 0; y < this.canvasHeight; y += checkerSize) {\n                const isLight = ((Math.floor(x / checkerSize) + Math.floor(y / checkerSize)) % 2) === 0;\n                this.backgroundCtx.fillStyle = isLight ? '#ffffff' : '#cccccc';\n                this.backgroundCtx.fillRect(x, y, checkerSize, checkerSize);\n            }\n        }\n    }\n\n    createToolGrid(container) {\n        const tools = [\n            { id: 'brush', icon: 'ðŸ–Œï¸', name: 'Brush' },\n            { id: 'pen', icon: 'âœï¸', name: 'Pen' },\n            { id: 'pencil', icon: 'âœŽ', name: 'Pencil' },\n            { id: 'eraser', icon: 'ðŸ§½', name: 'Eraser' },\n            { id: 'fill', icon: 'ðŸª£', name: 'Fill Bucket' },\n            { id: 'line', icon: 'ðŸ“', name: 'Line' },\n            { id: 'rectangle', icon: 'â¬›', name: 'Rectangle' },\n            { id: 'circle', icon: 'â­•', name: 'Circle' },\n            { id: 'eyedropper', icon: 'ðŸ’‰', name: 'Eyedropper' }\n        ];\n\n        const toolGrid = document.createElement('div');\n        toolGrid.style.cssText = `\n            display: grid;\n            grid-template-columns: repeat(3, 1fr);\n            gap: 4px;\n            padding: 8px;\n        `;\n\n        tools.forEach(tool => {\n            const button = document.createElement('button');\n            button.style.cssText = `\n                padding: 8px;\n                background: ${this.currentTool === tool.id ? '#9C27B0' : '#3a3a3a'};\n                border: 1px solid #555;\n                border-radius: 4px;\n                color: #fff;\n                cursor: pointer;\n                font-size: 14px;\n                display: flex;\n                flex-direction: column;\n                align-items: center;\n                gap: 2px;\n            `;\n\n            button.innerHTML = `\n                <span>${tool.icon}</span>\n                <span style=\"font-size: 9px;\">${tool.name}</span>\n            `;\n\n            button.addEventListener('click', () => {\n                this.selectTool(tool.id);\n                this.updateToolButtons();\n            });\n\n            button.dataset.toolId = tool.id;\n            toolGrid.appendChild(button);\n        });\n\n        container.appendChild(toolGrid);\n    }\n\n    createColorPicker(container) {\n        // Current color display\n        const currentColorDiv = document.createElement('div');\n        currentColorDiv.style.cssText = `\n            margin: 8px;\n            padding: 16px;\n            background: ${this.currentColor};\n            border: 2px solid #666;\n            border-radius: 4px;\n            cursor: pointer;\n        `;\n\n        // Color input\n        const colorInput = document.createElement('input');\n        colorInput.type = 'color';\n        colorInput.value = this.currentColor;\n        colorInput.style.cssText = `\n            width: 100%;\n            height: 40px;\n            margin: 8px;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n        `;\n\n        colorInput.addEventListener('change', (e) => {\n            this.currentColor = e.target.value;\n            currentColorDiv.style.background = this.currentColor;\n        });\n\n        // Color palette\n        const palette = document.createElement('div');\n        palette.style.cssText = `\n            display: grid;\n            grid-template-columns: repeat(8, 1fr);\n            gap: 2px;\n            margin: 8px;\n        `;\n\n        const colors = [\n            '#000000', '#ffffff', '#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff',\n            '#800000', '#808080', '#800080', '#008000', '#000080', '#808000', '#008080', '#c0c0c0',\n            '#ff8080', '#80ff80', '#8080ff', '#ffff80', '#ff80ff', '#80ffff', '#ffc080', '#c080ff'\n        ];\n\n        colors.forEach(color => {\n            const colorSwatch = document.createElement('div');\n            colorSwatch.style.cssText = `\n                width: 20px;\n                height: 20px;\n                background: ${color};\n                border: 1px solid #666;\n                cursor: pointer;\n            `;\n\n            colorSwatch.addEventListener('click', () => {\n                this.currentColor = color;\n                currentColorDiv.style.background = color;\n                colorInput.value = color;\n            });\n\n            palette.appendChild(colorSwatch);\n        });\n\n        container.appendChild(currentColorDiv);\n        container.appendChild(colorInput);\n        container.appendChild(palette);\n    }\n\n    createBrushSettings(container) {\n        // Brush size\n        const sizeLabel = document.createElement('label');\n        sizeLabel.textContent = 'Brush Size:';\n        sizeLabel.style.cssText = `\n            display: block;\n            color: #fff;\n            margin: 8px;\n            font-size: 12px;\n        `;\n\n        const sizeSlider = document.createElement('input');\n        sizeSlider.type = 'range';\n        sizeSlider.min = '1';\n        sizeSlider.max = '50';\n        sizeSlider.value = this.brushSize;\n        sizeSlider.style.cssText = `\n            width: calc(100% - 16px);\n            margin: 0 8px 8px 8px;\n        `;\n\n        const sizeValue = document.createElement('span');\n        sizeValue.textContent = this.brushSize + 'px';\n        sizeValue.style.cssText = `\n            color: #aaa;\n            font-size: 12px;\n            margin: 0 8px;\n        `;\n\n        sizeSlider.addEventListener('input', (e) => {\n            this.brushSize = parseInt(e.target.value);\n            sizeValue.textContent = this.brushSize + 'px';\n        });\n\n        // Grid toggle\n        const gridLabel = document.createElement('label');\n        gridLabel.textContent = 'Show Grid:';\n        gridLabel.style.cssText = `\n            display: block;\n            color: #fff;\n            margin: 8px;\n            font-size: 12px;\n        `;\n\n        const gridCheckbox = document.createElement('input');\n        gridCheckbox.type = 'checkbox';\n        gridCheckbox.checked = this.showGrid;\n        gridCheckbox.style.cssText = `\n            margin: 0 8px;\n        `;\n\n        gridCheckbox.addEventListener('change', (e) => {\n            this.showGrid = e.target.checked;\n            this.drawGrid();\n        });\n\n        // Onion skin opacity\n        const onionLabel = document.createElement('label');\n        onionLabel.textContent = 'Onion Skin Opacity:';\n        onionLabel.style.cssText = `\n            display: block;\n            color: #fff;\n            margin: 8px;\n            font-size: 12px;\n        `;\n\n        const onionSlider = document.createElement('input');\n        onionSlider.type = 'range';\n        onionSlider.min = '0.1';\n        onionSlider.max = '0.8';\n        onionSlider.step = '0.1';\n        onionSlider.value = this.onionSkinOpacity;\n        onionSlider.style.cssText = `\n            width: calc(100% - 16px);\n            margin: 0 8px 8px 8px;\n        `;\n\n        const onionValue = document.createElement('span');\n        onionValue.textContent = Math.round(this.onionSkinOpacity * 100) + '%';\n        onionValue.style.cssText = `\n            color: #aaa;\n            font-size: 12px;\n            margin: 0 8px;\n        `;\n\n        onionSlider.addEventListener('input', (e) => {\n            this.onionSkinOpacity = parseFloat(e.target.value);\n            onionValue.textContent = Math.round(this.onionSkinOpacity * 100) + '%';\n            this.updateOnionSkin();\n        });\n\n        container.appendChild(sizeLabel);\n        container.appendChild(sizeSlider);\n        container.appendChild(sizeValue);\n        container.appendChild(gridLabel);\n        container.appendChild(gridCheckbox);\n        container.appendChild(onionLabel);\n        container.appendChild(onionSlider);\n        container.appendChild(onionValue);\n    }\n\n    createLayersPanel(container) {\n        this.layersContainer = document.createElement('div');\n        this.layersContainer.style.cssText = `\n            padding: 8px;\n            max-height: 300px;\n            overflow-y: auto;\n        `;\n\n        const addLayerBtn = document.createElement('button');\n        addLayerBtn.textContent = '+ Add Layer';\n        addLayerBtn.style.cssText = `\n            width: 100%;\n            padding: 8px;\n            background: #0078d4;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            margin-bottom: 8px;\n            cursor: pointer;\n        `;\n\n        addLayerBtn.addEventListener('click', () => {\n            const name = prompt('Layer name:', `Layer ${this.getCurrentFrame().layers.length + 1}`);\n            if (name) this.addLayer(name);\n        });\n\n        container.appendChild(addLayerBtn);\n        container.appendChild(this.layersContainer);\n    }\n\n    createPropertiesPanel(container) {\n        const props = document.createElement('div');\n        props.style.cssText = `\n            padding: 8px;\n            color: #fff;\n            font-size: 12px;\n        `;\n\n        props.innerHTML = `\n            <div style=\"margin-bottom: 8px;\">\n                <label style=\"display: block; margin-bottom: 4px;\">Canvas Size:</label>\n                <input type=\"number\" id=\"canvas-width\" value=\"${this.canvasWidth}\" min=\"8\" max=\"512\" \n                    style=\"width: 60px; background: #444; color: #fff; border: 1px solid #666; padding: 2px; margin-right: 4px;\">\n                Ã—\n                <input type=\"number\" id=\"canvas-height\" value=\"${this.canvasHeight}\" min=\"8\" max=\"512\" \n                    style=\"width: 60px; background: #444; color: #fff; border: 1px solid #666; padding: 2px; margin-left: 4px;\">\n                <button id=\"resize-canvas\" style=\"display: block; width: 100%; margin-top: 4px; padding: 4px; background: #0078d4; color: white; border: none; border-radius: 2px; cursor: pointer;\">Resize</button>\n            </div>\n            <div>Zoom: <span id=\"zoom-level\">${Math.round(this.zoom * 100)}%</span></div>\n            <div>Animation: <span id=\"current-animation\">Default</span></div>\n            <div>Frames: <span id=\"frame-count\">1</span></div>\n            <div>Layers: <span id=\"layer-count\">1</span></div>\n        `;\n\n        container.appendChild(props);\n\n        setTimeout(() => {\n            const resizeBtn = document.getElementById('resize-canvas');\n            if (resizeBtn) {\n                resizeBtn.addEventListener('click', () => this.resizeCanvas());\n            }\n        }, 100);\n    }\n\n    resizeCanvas() {\n        const widthInput = document.getElementById('canvas-width');\n        const heightInput = document.getElementById('canvas-height');\n\n        const newWidth = parseInt(widthInput.value);\n        const newHeight = parseInt(heightInput.value);\n\n        if (newWidth < 8 || newWidth > 512 || newHeight < 8 || newHeight > 512) {\n            alert('Canvas size must be between 8 and 512 pixels');\n            return;\n        }\n\n        if (confirm(`Resize canvas to ${newWidth}Ã—${newHeight}? This will clear all frames.`)) {\n            // Save current state\n            this.saveFrameData();\n\n            // Update canvas dimensions\n            this.canvasWidth = newWidth;\n            this.canvasHeight = newHeight;\n\n            // Resize all canvases\n            [this.canvas, this.onionCanvas, this.gridCanvas, this.backgroundCanvas].forEach(canvas => {\n                if (canvas) {\n                    canvas.width = this.canvasWidth;\n                    canvas.height = this.canvasHeight;\n                }\n            });\n\n            // Reset all frames with new dimensions\n            this.animationGroups.forEach(group => {\n                group.frames.forEach(frame => {\n                    // Recreate layers with new dimensions\n                    frame.layers = frame.layers.map(layer => ({\n                        ...layer,\n                        data: this.ctx.createImageData(this.canvasWidth, this.canvasHeight)\n                    }));\n\n                    // Clear frame image data\n                    frame.imageData = this.ctx.createImageData(this.canvasWidth, this.canvasHeight);\n                });\n            });\n\n            this.updateCanvasSize();\n            this.drawTransparencyBackground();\n            this.drawGrid();\n            this.redrawCanvas();\n            this.updateTimelineDisplay();\n            this.updateLayersDisplay();\n            this.hasUnsavedChanges = true;\n        }\n    }\n\n    // Helper methods\n    createSection(title) {\n        const section = document.createElement('div');\n        section.style.cssText = `\n            border-bottom: 1px solid #444;\n        `;\n\n        const header = document.createElement('div');\n        header.textContent = title;\n        header.style.cssText = `\n            padding: 8px;\n            background: #333;\n            color: #fff;\n            font-weight: bold;\n            font-size: 12px;\n            border-bottom: 1px solid #444;\n        `;\n\n        section.appendChild(header);\n        return section;\n    }\n\n    addToolbarButton(id, icon, title, onClick) {\n        const button = document.createElement('button');\n        button.id = id;\n        button.innerHTML = icon;\n        button.title = title;\n        button.style.cssText = `\n            padding: 8px;\n            background: #3a3a3a;\n            border: 1px solid #555;\n            border-radius: 4px;\n            color: #fff;\n            cursor: pointer;\n            min-width: 32px;\n            height: 32px;\n        `;\n\n        button.addEventListener('click', onClick);\n        this.toolbar.appendChild(button);\n    }\n\n    addToolbarSeparator() {\n        const separator = document.createElement('div');\n        separator.style.cssText = `\n            width: 1px;\n            height: 24px;\n            background: #555;\n            margin: 0 4px;\n        `;\n        this.toolbar.appendChild(separator);\n    }\n\n    setupEventListeners() {\n        if (this.canvas) {\n            this.canvas.addEventListener('mousedown', (e) => this.startDrawing(e));\n            this.canvas.addEventListener('mousemove', (e) => this.draw(e));\n            document.addEventListener('mouseup', () => this.stopDrawing());\n            //this.canvas.addEventListener('mouseout', () => this.stopDrawing());\n        }\n    }\n\n    // Animation Groups Methods\n    addAnimationGroup(name) {\n        const id = Date.now().toString();\n        const group = {\n            id,\n            name,\n            frames: [],\n            currentFrameIndex: 0\n        };\n\n        // Add default frame with default layer\n        group.frames.push({\n            id: Date.now(),\n            layers: [{\n                id: Date.now(),\n                name: 'Background',\n                visible: true,\n                opacity: 1.0,\n                data: this.ctx.createImageData(this.canvasWidth, this.canvasHeight)\n            }]\n        });\n\n        this.animationGroups.set(id, group);\n        this.currentGroupId = id;\n        this.updateGroupsDisplay();\n        this.updateTimelineDisplay();\n        this.updateLayersDisplay();\n        this.clearCanvas();\n        this.hasUnsavedChanges = true;\n    }\n\n    deleteAnimationGroup(groupId) {\n        if (this.animationGroups.size <= 1) {\n            alert('Cannot delete the last animation group');\n            return;\n        }\n\n        if (confirm('Delete this animation group?')) {\n            this.animationGroups.delete(groupId);\n\n            // Switch to first available group\n            this.currentGroupId = this.animationGroups.keys().next().value;\n\n            this.updateGroupsDisplay();\n            this.selectFrame(this.getCurrentGroup().currentFrameIndex);\n            this.hasUnsavedChanges = true;\n        }\n    }\n\n    switchToGroup(groupId) {\n        if (this.animationGroups.has(groupId)) {\n            // Save current frame data before switching\n            this.saveFrameData();\n\n            // Store the current group's frame index\n            const currentGroup = this.getCurrentGroup();\n            if (currentGroup) {\n                currentGroup.currentFrameIndex = Math.max(0, Math.min(currentGroup.currentFrameIndex, currentGroup.frames.length - 1));\n            }\n\n            this.currentGroupId = groupId;\n            this.updateGroupsDisplay();\n\n            // Load the selected frame of the new group\n            const newGroup = this.getCurrentGroup();\n            if (newGroup && newGroup.frames.length > 0) {\n                // Ensure frame index is valid\n                newGroup.currentFrameIndex = Math.max(0, Math.min(newGroup.currentFrameIndex, newGroup.frames.length - 1));\n                this.loadFrameData(newGroup.currentFrameIndex);\n            } else {\n                // No frames in new group, clear canvas\n                this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n                this.updateOnionSkin();\n            }\n\n            this.updateTimelineDisplay();\n            this.updateFrameCounter();\n            this.updateLayersDisplay();\n        }\n    }\n\n    getCurrentGroup() {\n        return this.animationGroups.get(this.currentGroupId);\n    }\n\n    getCurrentFrame() {\n        const group = this.getCurrentGroup();\n        return group.frames[group.currentFrameIndex] || null;\n    }\n\n    updateGroupsDisplay() {\n        this.groupsContainer.innerHTML = '';\n\n        this.animationGroups.forEach((group, groupId) => {\n            const groupDiv = document.createElement('div');\n            groupDiv.style.cssText = `\n                padding: 8px;\n                border: 1px solid ${groupId === this.currentGroupId ? '#9C27B0' : '#555'};\n                margin-bottom: 4px;\n                background: ${groupId === this.currentGroupId ? '#333' : '#2a2a2a'};\n                color: #fff;\n                cursor: pointer;\n                display: flex;\n                justify-content: space-between;\n                align-items: center;\n            `;\n\n            const nameSpan = document.createElement('span');\n            nameSpan.textContent = `${group.name} (${group.frames.length})`;\n\n            const deleteBtn = document.createElement('button');\n            deleteBtn.innerHTML = 'ðŸ—‘ï¸';\n            deleteBtn.style.cssText = `\n                background: none;\n                border: none;\n                color: #ff6b6b;\n                cursor: pointer;\n                padding: 2px;\n            `;\n            deleteBtn.onclick = (e) => {\n                e.stopPropagation();\n                this.deleteAnimationGroup(groupId);\n            };\n\n            groupDiv.appendChild(nameSpan);\n            groupDiv.appendChild(deleteBtn);\n\n            groupDiv.addEventListener('click', () => {\n                this.switchToGroup(groupId);\n            });\n\n            this.groupsContainer.appendChild(groupDiv);\n        });\n\n        // Update properties display\n        const currentAnimSpan = document.getElementById('current-animation');\n        if (currentAnimSpan) {\n            currentAnimSpan.textContent = this.getCurrentGroup().name;\n        }\n    }\n\n    validateFrameData(frame) {\n        if (!frame) return false;\n\n        try {\n            // Check if imageData is valid\n            if (frame.imageData) {\n                const data = frame.imageData.data;\n                if (!data || data.length !== this.canvasWidth * this.canvasHeight * 4) {\n                    console.warn('Invalid frame imageData detected');\n                    return false;\n                }\n            }\n\n            // Check layers\n            if (frame.layers) {\n                for (let layer of frame.layers) {\n                    if (layer.data) {\n                        const data = layer.data.data;\n                        if (!data || data.length !== this.canvasWidth * this.canvasHeight * 4) {\n                            console.warn('Invalid layer data detected');\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            return true;\n        } catch (error) {\n            console.warn('Frame validation error:', error);\n            return false;\n        }\n    }\n\n    // Drawing methods\n    startDrawing(e) {\n        this.isDrawing = true;\n        const rect = this.canvas.getBoundingClientRect();\n        const x = (e.clientX - rect.left) / this.zoom;\n        const y = (e.clientY - rect.top) / this.zoom;\n\n        this.lastX = x;\n        this.lastY = y;\n\n        this.saveState();\n\n        // Get the active layer for drawing\n        const currentFrame = this.getCurrentFrame();\n        if (!currentFrame || !currentFrame.layers[this.activeLayerIndex]) return;\n\n        // Create a temporary drawing canvas for the active layer\n        this.tempDrawingCanvas = document.createElement('canvas');\n        this.tempDrawingCanvas.width = this.canvasWidth;\n        this.tempDrawingCanvas.height = this.canvasHeight;\n        this.tempDrawingCtx = this.tempDrawingCanvas.getContext('2d');\n\n        // Load current layer data to temp canvas\n        const activeLayer = currentFrame.layers[this.activeLayerIndex];\n        if (activeLayer.data) {\n            this.tempDrawingCtx.putImageData(activeLayer.data, 0, 0);\n        }\n\n        // Set drawing properties\n        this.tempDrawingCtx.globalAlpha = this.opacity;\n        this.tempDrawingCtx.strokeStyle = this.currentColor;\n        this.tempDrawingCtx.fillStyle = this.currentColor;\n        this.tempDrawingCtx.lineWidth = this.brushSize;\n        this.tempDrawingCtx.lineCap = 'round';\n        this.tempDrawingCtx.lineJoin = 'round';\n\n        if (this.currentTool === 'brush' || this.currentTool === 'pen') {\n            this.tempDrawingCtx.beginPath();\n            this.tempDrawingCtx.moveTo(x, y);\n        } else if (this.currentTool === 'pencil') {\n            this.drawPixelToLayer(Math.floor(x), Math.floor(y));\n        }\n    }\n\n    draw(e) {\n        if (!this.isDrawing || !this.tempDrawingCtx) return;\n\n        const rect = this.canvas.getBoundingClientRect();\n        const x = (e.clientX - rect.left) / this.zoom;\n        const y = (e.clientY - rect.top) / this.zoom;\n\n        switch (this.currentTool) {\n            case 'brush':\n            case 'pen':\n                this.tempDrawingCtx.lineTo(x, y);\n                this.tempDrawingCtx.stroke();\n                break;\n            case 'pencil':\n                const pixelX = Math.floor(x);\n                const pixelY = Math.floor(y);\n                const lastPixelX = Math.floor(this.lastX);\n                const lastPixelY = Math.floor(this.lastY);\n\n                if (pixelX !== lastPixelX || pixelY !== lastPixelY) {\n                    this.drawPencilLineToLayer(this.lastX, this.lastY, x, y);\n                }\n                break;\n            case 'eraser':\n                this.tempDrawingCtx.globalCompositeOperation = 'destination-out';\n                this.tempDrawingCtx.beginPath();\n                this.tempDrawingCtx.arc(x, y, this.brushSize / 2, 0, Math.PI * 2);\n                this.tempDrawingCtx.fill();\n                this.tempDrawingCtx.globalCompositeOperation = 'source-over';\n                break;\n        }\n\n        this.lastX = x;\n        this.lastY = y;\n\n        // Immediately update the main canvas preview while drawing\n        this.updateCanvasPreview();\n        this.hasUnsavedChanges = true;\n    }\n\n    updateCanvasPreview() {\n        // Update main canvas with all layers including the current drawing\n        this.redrawCanvasWithTempLayer();\n    }\n\n    drawPencilLine(x1, y1, x2, y2) {\n        const startX = Math.floor(x1);\n        const startY = Math.floor(y1);\n        const endX = Math.floor(x2);\n        const endY = Math.floor(y2);\n\n        if (startX === endX && startY === endY) {\n            this.drawPixel(startX, startY);\n            return;\n        }\n\n        const dx = Math.abs(endX - startX);\n        const dy = Math.abs(endY - startY);\n        const sx = startX < endX ? 1 : -1;\n        const sy = startY < endY ? 1 : -1;\n        let err = dx - dy;\n\n        let currentX = startX;\n        let currentY = startY;\n\n        let maxIterations = Math.max(dx, dy) + 1;\n        let iterations = 0;\n\n        while (iterations < maxIterations) {\n            this.drawPixel(currentX, currentY);\n\n            if (currentX === endX && currentY === endY) break;\n\n            const e2 = 2 * err;\n            if (e2 > -dy) {\n                err -= dy;\n                currentX += sx;\n            }\n            if (e2 < dx) {\n                err += dx;\n                currentY += sy;\n            }\n\n            iterations++;\n        }\n    }\n\n    drawPixel(x, y) {\n        this.ctx.fillRect(x, y, 1, 1);\n    }\n\n    drawPencilLineToLayer(x1, y1, x2, y2) {\n        const startX = Math.floor(x1);\n        const startY = Math.floor(y1);\n        const endX = Math.floor(x2);\n        const endY = Math.floor(y2);\n\n        if (startX === endX && startY === endY) {\n            this.drawPixelToLayer(startX, startY);\n            return;\n        }\n\n        const dx = Math.abs(endX - startX);\n        const dy = Math.abs(endY - startY);\n        const sx = startX < endX ? 1 : -1;\n        const sy = startY < endY ? 1 : -1;\n        let err = dx - dy;\n\n        let currentX = startX;\n        let currentY = startY;\n\n        let maxIterations = Math.max(dx, dy) + 1;\n        let iterations = 0;\n\n        while (iterations < maxIterations) {\n            this.drawPixelToLayer(currentX, currentY);\n\n            if (currentX === endX && currentY === endY) break;\n\n            const e2 = 2 * err;\n            if (e2 > -dy) {\n                err -= dy;\n                currentX += sx;\n            }\n            if (e2 < dx) {\n                err += dx;\n                currentY += sy;\n            }\n\n            iterations++;\n        }\n    }\n\n    drawPixelToLayer(x, y) {\n        if (this.tempDrawingCtx) {\n            this.tempDrawingCtx.fillRect(x, y, 1, 1);\n        }\n    }\n\n    drawGrid() {\n        if (!this.showGrid || this.zoom < 4) {\n            this.gridCtx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n            return;\n        }\n\n        this.gridCtx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n        this.gridCtx.strokeStyle = 'rgba(128, 128, 128, 0.3)';\n        this.gridCtx.lineWidth = 1 / this.zoom;\n\n        // Draw vertical lines\n        for (let x = 0; x <= this.canvasWidth; x += this.gridSize) {\n            this.gridCtx.beginPath();\n            this.gridCtx.moveTo(x, 0);\n            this.gridCtx.lineTo(x, this.canvasHeight);\n            this.gridCtx.stroke();\n        }\n\n        // Draw horizontal lines\n        for (let y = 0; y <= this.canvasHeight; y += this.gridSize) {\n            this.gridCtx.beginPath();\n            this.gridCtx.moveTo(0, y);\n            this.gridCtx.lineTo(this.canvasWidth, y);\n            this.gridCtx.stroke();\n        }\n    }\n\n    stopDrawing() {\n        if (!this.isDrawing) return;\n        this.isDrawing = false;\n\n        // Save the drawing to the active layer\n        this.saveToActiveLayer();\n\n        // Clean up temp canvas\n        this.tempDrawingCanvas = null;\n        this.tempDrawingCtx = null;\n\n        // Redraw canvas with all layers\n        this.redrawCanvas();\n\n        // Save state for undo/redo AFTER the drawing is complete\n        this.saveState();\n    }\n\n    saveToActiveLayer() {\n        const currentFrame = this.getCurrentFrame();\n        if (!currentFrame || !currentFrame.layers[this.activeLayerIndex] || !this.tempDrawingCtx) return;\n\n        try {\n            // Save the temp canvas data to the active layer\n            const imageData = this.tempDrawingCtx.getImageData(0, 0, this.canvasWidth, this.canvasHeight);\n            currentFrame.layers[this.activeLayerIndex].data = new ImageData(\n                new Uint8ClampedArray(imageData.data),\n                imageData.width,\n                imageData.height\n            );\n        } catch (error) {\n            console.warn('Error saving to active layer:', error);\n        }\n    }\n\n    saveFrameData() {\n        const group = this.getCurrentGroup();\n        if (!group || group.frames.length === 0) return;\n\n        const currentFrame = group.frames[group.currentFrameIndex];\n        if (!currentFrame) return;\n\n        try {\n            // Save the composited canvas data to the current frame\n            const imageData = this.ctx.getImageData(0, 0, this.canvasWidth, this.canvasHeight);\n            currentFrame.imageData = new ImageData(\n                new Uint8ClampedArray(imageData.data),\n                imageData.width,\n                imageData.height\n            );\n        } catch (error) {\n            console.warn('Error saving frame data:', error);\n        }\n    }\n\n    redrawCanvasWithTempLayer() {\n        const currentFrame = this.getCurrentFrame();\n        if (!currentFrame) return;\n\n        // Clear main canvas\n        this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n\n        // Composite all layers\n        currentFrame.layers.forEach((layer, index) => {\n            if (!layer.visible) return;\n\n            try {\n                this.ctx.save();\n                this.ctx.globalAlpha = layer.opacity || 1.0;\n                this.ctx.globalCompositeOperation = layer.blendMode || 'source-over';\n\n                if (index === this.activeLayerIndex && this.tempDrawingCanvas) {\n                    // Use temp drawing canvas for active layer while drawing\n                    this.ctx.drawImage(this.tempDrawingCanvas, 0, 0);\n                } else if (layer.data) {\n                    // Create a temporary canvas for this layer\n                    const tempCanvas = document.createElement('canvas');\n                    tempCanvas.width = this.canvasWidth;\n                    tempCanvas.height = this.canvasHeight;\n                    const tempCtx = tempCanvas.getContext('2d');\n\n                    // Put the layer data on the temp canvas\n                    tempCtx.putImageData(layer.data, 0, 0);\n\n                    // Draw the temp canvas to the main canvas\n                    this.ctx.drawImage(tempCanvas, 0, 0);\n                }\n\n                this.ctx.restore();\n            } catch (error) {\n                console.warn('Error rendering layer:', error);\n            }\n        });\n    }\n\n    // Tool methods\n    selectTool(toolId) {\n        this.currentTool = toolId;\n        this.updateToolButtons();\n    }\n\n    updateToolButtons() {\n        const buttons = this.leftPanel.querySelectorAll('button[data-tool-id]');\n        buttons.forEach(button => {\n            const isActive = button.dataset.toolId === this.currentTool;\n            button.style.background = isActive ? '#9C27B0' : '#3a3a3a';\n        });\n    }\n\n    // Animation methods\n    addDefaultFrame() {\n        const group = this.getCurrentGroup();\n        if (group.frames.length === 0) {\n            this.addFrame();\n            // Initialize history with the first empty state\n            setTimeout(() => {\n                this.history = [];\n                this.historyIndex = -1;\n                this.saveState();\n            }, 100);\n        }\n    }\n\n    addFrame() {\n        const group = this.getCurrentGroup();\n\n        // Save current frame data before adding new frame\n        this.saveFrameData();\n\n        // Create empty image data\n        const emptyImageData = this.ctx.createImageData(this.canvasWidth, this.canvasHeight);\n\n        const newFrame = {\n            id: Date.now(),\n            layers: [{\n                id: Date.now(),\n                name: 'Background',\n                visible: true,\n                opacity: 1.0,\n                blendMode: 'source-over',\n                data: new ImageData(\n                    new Uint8ClampedArray(emptyImageData.data),\n                    this.canvasWidth,\n                    this.canvasHeight\n                )\n            }],\n            imageData: new ImageData(\n                new Uint8ClampedArray(emptyImageData.data),\n                this.canvasWidth,\n                this.canvasHeight\n            )\n        };\n\n        group.frames.push(newFrame);\n        group.currentFrameIndex = group.frames.length - 1;\n        this.activeLayerIndex = 0;\n\n        // Clear canvas and redraw\n        this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n        this.redrawCanvas();\n        this.updateTimelineDisplay();\n        this.updateFrameCounter();\n        this.updateLayersDisplay();\n\n        this.hasUnsavedChanges = true;\n    }\n\n    duplicateFrame() {\n        const group = this.getCurrentGroup();\n        if (group.frames.length === 0) return;\n\n        // Save current frame data before duplicating\n        this.saveFrameData();\n\n        const currentFrame = group.frames[group.currentFrameIndex];\n        const duplicatedFrame = {\n            id: Date.now(),\n            layers: currentFrame.layers.map(layer => ({\n                ...layer,\n                id: Date.now() + Math.random(),\n                data: new ImageData(\n                    new Uint8ClampedArray(layer.data.data),\n                    layer.data.width,\n                    layer.data.height\n                )\n            })),\n            imageData: new ImageData(\n                new Uint8ClampedArray(currentFrame.imageData.data),\n                currentFrame.imageData.width,\n                currentFrame.imageData.height\n            )\n        };\n\n        group.frames.splice(group.currentFrameIndex + 1, 0, duplicatedFrame);\n        group.currentFrameIndex++;\n\n        // Load the duplicated frame\n        this.loadFrameData(group.currentFrameIndex);\n\n        this.hasUnsavedChanges = true;\n    }\n\n    deleteFrame() {\n        const group = this.getCurrentGroup();\n        if (group.frames.length <= 1) return;\n\n        group.frames.splice(group.currentFrameIndex, 1);\n        group.currentFrameIndex = Math.min(group.currentFrameIndex, group.frames.length - 1);\n\n        // Load the new current frame\n        this.loadFrameData(group.currentFrameIndex);\n\n        this.hasUnsavedChanges = true;\n    }\n\n    moveFrameLeft() {\n        const group = this.getCurrentGroup();\n        if (group.currentFrameIndex <= 0) return;\n\n        // Save current frame data\n        this.saveFrameData();\n\n        const frame = group.frames.splice(group.currentFrameIndex, 1)[0];\n        group.frames.splice(group.currentFrameIndex - 1, 0, frame);\n        group.currentFrameIndex--;\n\n        // Reload the moved frame\n        this.loadFrameData(group.currentFrameIndex);\n\n        this.hasUnsavedChanges = true;\n    }\n\n    moveFrameRight() {\n        const group = this.getCurrentGroup();\n        if (group.currentFrameIndex >= group.frames.length - 1) return;\n\n        // Save current frame data\n        this.saveFrameData();\n\n        const frame = group.frames.splice(group.currentFrameIndex, 1)[0];\n        group.frames.splice(group.currentFrameIndex + 1, 0, frame);\n        group.currentFrameIndex++;\n\n        // Reload the moved frame\n        this.loadFrameData(group.currentFrameIndex);\n\n        this.hasUnsavedChanges = true;\n    }\n\n    selectFrame(index) {\n        const group = this.getCurrentGroup();\n        if (!group || index < 0 || index >= group.frames.length) return;\n\n        // Save current frame data before switching\n        //this.saveFrameData();\n\n        group.currentFrameIndex = index;\n        this.loadFrameData(index);\n    }\n\n    selectFrameManual(index) {\n        const group = this.getCurrentGroup();\n        if (!group || index < 0 || index >= group.frames.length) return;\n\n        // Only save when manually switching frames\n        this.saveFrameData();\n\n        group.currentFrameIndex = index;\n        this.loadFrameData(index);\n    }\n\n    loadFrameData(frameIndex) {\n        const group = this.getCurrentGroup();\n        if (!group || frameIndex < 0 || frameIndex >= group.frames.length) return;\n\n        const frame = group.frames[frameIndex];\n\n        // Clear canvas first\n        this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n\n        // Load frame data\n        if (frame && frame.imageData) {\n            try {\n                // Validate frame data before loading\n                if (this.validateFrameData(frame)) {\n                    this.ctx.putImageData(frame.imageData, 0, 0);\n                } else {\n                    // Try to reconstruct from layers\n                    this.reconstructFrameFromLayers(frame);\n                }\n            } catch (error) {\n                console.warn('Error loading frame data:', error);\n                // Try to reconstruct from layers as fallback\n                this.reconstructFrameFromLayers(frame);\n            }\n        }\n\n        // Update displays\n        setTimeout(() => {\n            this.updateOnionSkin();\n            this.updateTimelineDisplay();\n            this.updateFrameCounter();\n            this.updateLayersDisplay();\n            this.updatePreview();\n        }, 10);\n    }\n\n    reconstructFrameFromLayers(frame) {\n        if (!frame.layers || frame.layers.length === 0) return;\n\n        this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n\n        // Composite all visible layers\n        frame.layers.forEach(layer => {\n            if (layer.visible && layer.data) {\n                try {\n                    this.ctx.globalAlpha = layer.opacity || 1.0;\n                    this.ctx.putImageData(layer.data, 0, 0);\n                } catch (error) {\n                    console.warn('Error rendering layer:', error);\n                }\n            }\n        });\n\n        this.ctx.globalAlpha = 1.0;\n\n        // Save the composited result back to frame\n        frame.imageData = this.ctx.getImageData(0, 0, this.canvasWidth, this.canvasHeight);\n    }\n\n    togglePreviewPlayback() {\n        this.isPreviewPlaying = !this.isPreviewPlaying;\n        if (this.isPreviewPlaying) {\n            this.playPreview();\n        }\n    }\n\n    playPreview() {\n        if (!this.isPreviewPlaying) return;\n\n        const group = this.getCurrentGroup();\n        if (group.frames.length <= 1) return;\n\n        this.previewFrameIndex = (this.previewFrameIndex || 0) + 1;\n        if (this.previewFrameIndex >= group.frames.length) {\n            this.previewFrameIndex = 0;\n        }\n\n        this.updatePreview();\n\n        setTimeout(() => {\n            if (this.isPreviewPlaying) {\n                this.playPreview();\n            }\n        }, 1000 / this.frameRate);\n    }\n\n    updatePreview() {\n        const group = this.getCurrentGroup();\n        const frameIndex = this.previewFrameIndex || group.currentFrameIndex;\n        const frame = group.frames[frameIndex];\n\n        this.previewCtx.clearRect(0, 0, 64, 64);\n        if (frame && frame.imageData) {\n            this.previewCtx.putImageData(frame.imageData, 0, 0);\n        }\n    }\n\n    togglePlayback() {\n        this.isPlaying = !this.isPlaying;\n\n        if (this.isPlaying) {\n            this.playAnimation();\n        }\n\n        const playBtn = document.getElementById('play');\n        if (playBtn) {\n            playBtn.innerHTML = this.isPlaying ? 'â¸ï¸' : 'â–¶ï¸';\n        }\n    }\n\n    playAnimation() {\n        if (!this.isPlaying) return;\n\n        const group = this.getCurrentGroup();\n        if (group.frames.length <= 1) {\n            this.isPlaying = false;\n            return;\n        }\n\n        setTimeout(() => {\n            group.currentFrameIndex = (group.currentFrameIndex + 1) % group.frames.length;\n            this.selectFrame(group.currentFrameIndex);\n\n            if (this.isPlaying) {\n                this.playAnimation();\n            }\n        }, 1000 / this.frameRate);\n    }\n\n    toggleOnionSkin() {\n        this.onionSkinEnabled = !this.onionSkinEnabled;\n        this.updateOnionSkin();\n\n        const onionBtn = document.getElementById('onion-skin');\n        if (onionBtn) {\n            onionBtn.style.background = this.onionSkinEnabled ? '#9C27B0' : '#3a3a3a';\n        }\n    }\n\n    updateOnionSkin() {\n        // Clear the onion skin canvas\n        this.onionCtx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n\n        if (!this.onionSkinEnabled) return;\n\n        const group = this.getCurrentGroup();\n        if (!group || group.frames.length <= 1) return;\n\n        this.onionCtx.save();\n\n        // Draw previous frames (red tint)\n        for (let i = 1; i <= this.onionSkinFrames; i++) {\n            const frameIndex = group.currentFrameIndex - i;\n            if (frameIndex >= 0 && group.frames[frameIndex] && group.frames[frameIndex].imageData) {\n                const opacity = this.onionSkinOpacity / i;\n                this.onionCtx.globalAlpha = opacity;\n                this.onionCtx.globalCompositeOperation = 'source-over';\n\n                // Create temporary canvas for the frame\n                const tempCanvas = document.createElement('canvas');\n                tempCanvas.width = this.canvasWidth;\n                tempCanvas.height = this.canvasHeight;\n                const tempCtx = tempCanvas.getContext('2d');\n\n                // Draw the frame\n                tempCtx.putImageData(group.frames[frameIndex].imageData, 0, 0);\n\n                // Apply red tint\n                tempCtx.globalCompositeOperation = 'source-atop';\n                tempCtx.fillStyle = 'rgba(255, 100, 100, 0.8)';\n                tempCtx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);\n\n                // Draw to onion skin canvas\n                this.onionCtx.drawImage(tempCanvas, 0, 0);\n            }\n        }\n\n        // Draw next frames (blue tint)\n        for (let i = 1; i <= this.onionSkinFrames; i++) {\n            const frameIndex = group.currentFrameIndex + i;\n            if (frameIndex < group.frames.length && group.frames[frameIndex] && group.frames[frameIndex].imageData) {\n                const opacity = this.onionSkinOpacity / (i * 1.5);\n                this.onionCtx.globalAlpha = opacity;\n                this.onionCtx.globalCompositeOperation = 'source-over';\n\n                // Create temporary canvas for the frame\n                const tempCanvas = document.createElement('canvas');\n                tempCanvas.width = this.canvasWidth;\n                tempCanvas.height = this.canvasHeight;\n                const tempCtx = tempCanvas.getContext('2d');\n\n                // Draw the frame\n                tempCtx.putImageData(group.frames[frameIndex].imageData, 0, 0);\n\n                // Apply blue tint\n                tempCtx.globalCompositeOperation = 'source-atop';\n                tempCtx.fillStyle = 'rgba(100, 100, 255, 0.8)';\n                tempCtx.fillRect(0, 0, this.canvasWidth, this.canvasHeight);\n\n                // Draw to onion skin canvas\n                this.onionCtx.drawImage(tempCanvas, 0, 0);\n            }\n        }\n\n        this.onionCtx.restore();\n    }\n\n    // Layer methods\n    deleteLayer(index) {\n        const currentFrame = this.getCurrentFrame();\n        if (currentFrame && currentFrame.layers.length > 1 && currentFrame.layers[index]) {\n            currentFrame.layers.splice(index, 1);\n            if (this.activeLayerIndex >= currentFrame.layers.length) {\n                this.activeLayerIndex = currentFrame.layers.length - 1;\n            }\n            this.updateLayersDisplay();\n            this.redrawCanvas();\n            this.hasUnsavedChanges = true;\n        }\n    }\n\n    setLayerBlendMode(index, blendMode) {\n        const currentFrame = this.getCurrentFrame();\n        if (currentFrame && currentFrame.layers[index]) {\n            currentFrame.layers[index].blendMode = blendMode;\n            this.redrawCanvas();\n            this.hasUnsavedChanges = true;\n        }\n    }\n\n    setLayerOpacity(index, opacity) {\n        const currentFrame = this.getCurrentFrame();\n        if (currentFrame && currentFrame.layers[index]) {\n            currentFrame.layers[index].opacity = parseFloat(opacity);\n            this.redrawCanvas();\n            this.hasUnsavedChanges = true;\n        }\n    }\n\n    addLayer(name) {\n        const currentFrame = this.getCurrentFrame();\n        if (!currentFrame) return;\n\n        // Create empty image data for new layer\n        const emptyImageData = this.ctx.createImageData(this.canvasWidth, this.canvasHeight);\n\n        const layer = {\n            id: Date.now(),\n            name: name,\n            visible: true,\n            opacity: 1.0,\n            blendMode: 'source-over',\n            data: new ImageData(\n                new Uint8ClampedArray(emptyImageData.data),\n                this.canvasWidth,\n                this.canvasHeight\n            )\n        };\n\n        currentFrame.layers.push(layer);\n        this.activeLayerIndex = currentFrame.layers.length - 1;\n        this.updateLayersDisplay();\n        this.redrawCanvas();\n        this.hasUnsavedChanges = true;\n    }\n\n    updateLayersDisplay() {\n        // Clear but keep the add layer button\n        const addLayerBtn = this.layersContainer.querySelector('button');\n        this.layersContainer.innerHTML = '';\n\n        if (addLayerBtn) {\n            //this.layersContainer.appendChild(addLayerBtn);\n        } else {\n            const newAddLayerBtn = document.createElement('button');\n            newAddLayerBtn.textContent = '+ Add Layer';\n            newAddLayerBtn.style.cssText = `\n            width: 100%;\n            padding: 8px;\n            background: #0078d4;\n            color: white;\n            border: none;\n            border-radius: 4px;\n            margin-bottom: 8px;\n            cursor: pointer;\n        `;\n            newAddLayerBtn.addEventListener('click', () => {\n                const name = prompt('Layer name:', `Layer ${this.getCurrentFrame().layers.length + 1}`);\n                if (name) this.addLayer(name);\n            });\n            this.layersContainer.appendChild(newAddLayerBtn);\n        }\n\n        const currentFrame = this.getCurrentFrame();\n        if (!currentFrame) return;\n\n        // Display layers in reverse order (top layer first)\n        const layers = [...currentFrame.layers].reverse();\n\n        layers.forEach((layer, reverseIndex) => {\n            const index = currentFrame.layers.length - 1 - reverseIndex;\n            const layerDiv = document.createElement('div');\n            layerDiv.style.cssText = `\n            padding: 8px;\n            border: 1px solid ${index === this.activeLayerIndex ? '#9C27B0' : '#555'};\n            margin-bottom: 4px;\n            background: ${index === this.activeLayerIndex ? '#333' : '#2a2a2a'};\n            color: #fff;\n            cursor: pointer;\n            border-radius: 4px;\n        `;\n\n            // Create controls with proper event listeners\n            const visibilityBtn = document.createElement('button');\n            visibilityBtn.innerHTML = layer.visible ? 'ðŸ‘ï¸' : 'ðŸš«';\n            visibilityBtn.style.cssText = `\n            background: none;\n            border: none;\n            color: ${layer.visible ? '#00ff00' : '#666'};\n            cursor: pointer;\n            margin-right: 4px;\n            font-size: 12px;\n        `;\n            visibilityBtn.addEventListener('click', (e) => {\n                e.stopPropagation();\n                this.toggleLayerVisibility(index);\n            });\n\n            // Layer ordering buttons\n            const moveUpBtn = document.createElement('button');\n            moveUpBtn.innerHTML = 'â†‘';\n            moveUpBtn.title = 'Move Layer Up';\n            moveUpBtn.style.cssText = `\n            background: none;\n            border: none;\n            color: ${index < currentFrame.layers.length - 1 ? '#00aaff' : '#666'};\n            cursor: ${index < currentFrame.layers.length - 1 ? 'pointer' : 'not-allowed'};\n            margin-right: 2px;\n            font-size: 12px;\n            font-weight: bold;\n        `;\n            moveUpBtn.disabled = index >= currentFrame.layers.length - 1;\n            moveUpBtn.addEventListener('click', (e) => {\n                e.stopPropagation();\n                if (!moveUpBtn.disabled) {\n                    this.moveLayerUp(index);\n                }\n            });\n\n            const moveDownBtn = document.createElement('button');\n            moveDownBtn.innerHTML = 'â†“';\n            moveDownBtn.title = 'Move Layer Down';\n            moveDownBtn.style.cssText = `\n            background: none;\n            border: none;\n            color: ${index > 0 ? '#00aaff' : '#666'};\n            cursor: ${index > 0 ? 'pointer' : 'not-allowed'};\n            margin-right: 4px;\n            font-size: 12px;\n            font-weight: bold;\n        `;\n            moveDownBtn.disabled = index <= 0;\n            moveDownBtn.addEventListener('click', (e) => {\n                e.stopPropagation();\n                if (!moveDownBtn.disabled) {\n                    this.moveLayerDown(index);\n                }\n            });\n\n            const deleteBtn = document.createElement('button');\n            deleteBtn.innerHTML = 'ðŸ—‘ï¸';\n            deleteBtn.style.cssText = `\n            background: none;\n            border: none;\n            color: #ff6b6b;\n            cursor: pointer;\n            font-size: 12px;\n        `;\n            deleteBtn.addEventListener('click', (e) => {\n                e.stopPropagation();\n                this.deleteLayer(index);\n            });\n\n            const blendSelect = document.createElement('select');\n            blendSelect.style.cssText = `\n            background: #444;\n            color: #fff;\n            border: 1px solid #666;\n            padding: 2px;\n            font-size: 10px;\n        `;\n\n            const blendModes = [\n                { value: 'source-over', label: 'Normal' },\n                { value: 'multiply', label: 'Multiply' },\n                { value: 'screen', label: 'Screen' },\n                { value: 'overlay', label: 'Overlay' },\n                { value: 'darken', label: 'Darken' },\n                { value: 'lighten', label: 'Lighten' },\n                { value: 'color-dodge', label: 'Color Dodge' },\n                { value: 'color-burn', label: 'Color Burn' },\n                { value: 'hard-light', label: 'Hard Light' },\n                { value: 'soft-light', label: 'Soft Light' },\n                { value: 'difference', label: 'Difference' },\n                { value: 'exclusion', label: 'Exclusion' }\n            ];\n\n            blendModes.forEach(mode => {\n                const option = document.createElement('option');\n                option.value = mode.value;\n                option.textContent = mode.label;\n                option.selected = layer.blendMode === mode.value;\n                blendSelect.appendChild(option);\n            });\n\n            blendSelect.addEventListener('change', (e) => {\n                this.setLayerBlendMode(index, e.target.value);\n            });\n\n            const opacitySlider = document.createElement('input');\n            opacitySlider.type = 'range';\n            opacitySlider.min = '0';\n            opacitySlider.max = '1';\n            opacitySlider.step = '0.1';\n            opacitySlider.value = layer.opacity || 1;\n            opacitySlider.style.cssText = 'flex: 1;';\n            opacitySlider.addEventListener('change', (e) => {\n                this.setLayerOpacity(index, e.target.value);\n            });\n\n            const opacityLabel = document.createElement('span');\n            opacityLabel.textContent = `${Math.round((layer.opacity || 1) * 100)}%`;\n\n            // Update opacity label when slider changes\n            opacitySlider.addEventListener('input', (e) => {\n                opacityLabel.textContent = `${Math.round(e.target.value * 100)}%`;\n            });\n\n            const headerDiv = document.createElement('div');\n            headerDiv.style.cssText = `\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            margin-bottom: 4px;\n        `;\n\n            const nameSpan = document.createElement('span');\n            nameSpan.style.fontWeight = 'bold';\n            nameSpan.textContent = layer.name;\n\n            const buttonsDiv = document.createElement('div');\n            buttonsDiv.style.cssText = `\n            display: flex;\n            align-items: center;\n            gap: 2px;\n        `;\n            buttonsDiv.appendChild(visibilityBtn);\n            buttonsDiv.appendChild(moveUpBtn);\n            buttonsDiv.appendChild(moveDownBtn);\n            buttonsDiv.appendChild(deleteBtn);\n\n            headerDiv.appendChild(nameSpan);\n            headerDiv.appendChild(buttonsDiv);\n\n            const blendDiv = document.createElement('div');\n            blendDiv.style.cssText = `\n            display: flex;\n            align-items: center;\n            gap: 8px;\n            font-size: 11px;\n        `;\n\n            const blendLabel = document.createElement('label');\n            blendLabel.textContent = 'Blend:';\n            blendDiv.appendChild(blendLabel);\n            blendDiv.appendChild(blendSelect);\n\n            const opacityDiv = document.createElement('div');\n            opacityDiv.style.cssText = `\n            display: flex;\n            align-items: center;\n            gap: 8px;\n            font-size: 11px;\n            margin-top: 4px;\n        `;\n\n            const opacityLabelDiv = document.createElement('label');\n            opacityLabelDiv.textContent = 'Opacity:';\n            opacityDiv.appendChild(opacityLabelDiv);\n            opacityDiv.appendChild(opacitySlider);\n            opacityDiv.appendChild(opacityLabel);\n\n            layerDiv.appendChild(headerDiv);\n            layerDiv.appendChild(blendDiv);\n            layerDiv.appendChild(opacityDiv);\n\n            layerDiv.addEventListener('click', () => {\n                this.activeLayerIndex = index;\n                this.updateLayersDisplay();\n            });\n\n            this.layersContainer.appendChild(layerDiv);\n        });\n\n        // Update layer count\n        const layerCountSpan = document.getElementById('layer-count');\n        if (layerCountSpan) {\n            layerCountSpan.textContent = currentFrame.layers.length;\n        }\n    }\n\n    moveLayerUp(index) {\n        const currentFrame = this.getCurrentFrame();\n        if (!currentFrame || index >= currentFrame.layers.length - 1) return;\n\n        // Swap layers\n        const temp = currentFrame.layers[index];\n        currentFrame.layers[index] = currentFrame.layers[index + 1];\n        currentFrame.layers[index + 1] = temp;\n\n        // Update active layer index if it was one of the moved layers\n        if (this.activeLayerIndex === index) {\n            this.activeLayerIndex = index + 1;\n        } else if (this.activeLayerIndex === index + 1) {\n            this.activeLayerIndex = index;\n        }\n\n        // Redraw and update UI\n        this.redrawCanvas();\n        this.updateLayersDisplay();\n        this.hasUnsavedChanges = true;\n    }\n\n    moveLayerDown(index) {\n        const currentFrame = this.getCurrentFrame();\n        if (!currentFrame || index <= 0) return;\n\n        // Swap layers\n        const temp = currentFrame.layers[index];\n        currentFrame.layers[index] = currentFrame.layers[index - 1];\n        currentFrame.layers[index - 1] = temp;\n\n        // Update active layer index if it was one of the moved layers\n        if (this.activeLayerIndex === index) {\n            this.activeLayerIndex = index - 1;\n        } else if (this.activeLayerIndex === index - 1) {\n            this.activeLayerIndex = index;\n        }\n\n        // Redraw and update UI\n        this.redrawCanvas();\n        this.updateLayersDisplay();\n        this.hasUnsavedChanges = true;\n    }\n\n    toggleLayerVisibility(index) {\n        const currentFrame = this.getCurrentFrame();\n        if (currentFrame && currentFrame.layers[index]) {\n            currentFrame.layers[index].visible = !currentFrame.layers[index].visible;\n            this.updateLayersDisplay();\n            this.redrawCanvas();\n            this.hasUnsavedChanges = true;\n        }\n    }\n\n    redrawCanvas() {\n        const currentFrame = this.getCurrentFrame();\n        if (!currentFrame) return;\n\n        // Clear main canvas\n        this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n\n        // Composite all visible layers with proper blend modes and opacity\n        currentFrame.layers.forEach(layer => {\n            if (!layer.visible || !layer.data) return;\n\n            try {\n                this.ctx.save();\n\n                // Apply layer opacity and blend mode\n                this.ctx.globalAlpha = layer.opacity || 1.0;\n                this.ctx.globalCompositeOperation = layer.blendMode || 'source-over';\n\n                // Create a temporary canvas for this layer to properly composite it\n                const tempCanvas = document.createElement('canvas');\n                tempCanvas.width = this.canvasWidth;\n                tempCanvas.height = this.canvasHeight;\n                const tempCtx = tempCanvas.getContext('2d');\n\n                // Put the layer data on the temp canvas\n                tempCtx.putImageData(layer.data, 0, 0);\n\n                // Draw the temp canvas to the main canvas (this respects blend modes and alpha)\n                this.ctx.drawImage(tempCanvas, 0, 0);\n\n                this.ctx.restore();\n            } catch (error) {\n                console.warn('Error rendering layer:', error);\n            }\n        });\n\n        // Save the composited result back to frame\n        try {\n            currentFrame.imageData = this.ctx.getImageData(0, 0, this.canvasWidth, this.canvasHeight);\n        } catch (error) {\n            console.warn('Error saving composited frame:', error);\n        }\n\n        this.updateOnionSkin();\n    }\n\n    // File operations\n    async newAnimation() {\n        if (this.hasUnsavedChanges) {\n            if (!confirm('You have unsaved changes. Continue?')) return;\n        }\n\n        this.animationGroups.clear();\n        this.currentGroupId = 'default';\n\n        this.animationGroups.set('default', {\n            id: 'default',\n            name: 'Default',\n            frames: [],\n            currentFrameIndex: 0\n        });\n\n        this.currentFilePath = null;\n        this.hasUnsavedChanges = false;\n        this.projectName = 'Untitled Animation';\n\n        this.addDefaultFrame();\n        this.updateGroupsDisplay();\n        this.updateTimelineDisplay();\n        this.updateLayersDisplay();\n        this.clearCanvas();\n    }\n\n    async saveAnimation() {\n        try {\n            const data = {\n                projectName: this.projectName,\n                canvasWidth: this.canvasWidth,\n                canvasHeight: this.canvasHeight,\n                frameRate: this.frameRate,\n                animationGroups: Array.from(this.animationGroups.entries()).map(([id, group]) => ({\n                    id,\n                    name: group.name,\n                    currentFrameIndex: group.currentFrameIndex,\n                    frames: group.frames.map(frame => ({\n                        id: frame.id,\n                        layers: frame.layers.map(layer => ({\n                            ...layer,\n                            data: Array.from(layer.data.data)\n                        })),\n                        imageData: frame.imageData ? Array.from(frame.imageData.data) : null\n                    }))\n                })),\n                currentGroupId: this.currentGroupId\n            };\n\n            let filePath = this.currentFilePath;\n            \n            if (!filePath) {\n                const fileName = await this.showSaveFileDialog();\n                if (!fileName) return;\n                filePath = fileName;\n                this.currentFilePath = filePath;\n            }\n\n            // Ensure the Animations directory exists\n            const animationsDir = '/Animations';\n            if (window.fileBrowser) {\n                const dirExists = await window.fileBrowser.exists(animationsDir);\n                if (!dirExists) {\n                    await window.fileBrowser.createDirectory(animationsDir);\n                }\n                \n                const success = await window.fileBrowser.writeFile(filePath, JSON.stringify(data, null, 2));\n                if (success) {\n                    this.hasUnsavedChanges = false;\n                    this.showNotification('Animation saved successfully');\n                    // Refresh file browser to show the new file\n                    await window.fileBrowser.refreshFiles();\n                } else {\n                    this.showNotification('Failed to save animation', 'error');\n                }\n            }\n        } catch (error) {\n            console.error('Error saving animation:', error);\n            this.showNotification('Error saving animation', 'error');\n        }\n    }\n\n    async openAnimation() {\n        try {\n            if (this.hasUnsavedChanges) {\n                if (!confirm('You have unsaved changes. Continue?')) return;\n            }\n\n            const filePath = await this.showOpenFileDialog();\n            if (!filePath) return;\n\n            if (window.fileBrowser) {\n                const content = await window.fileBrowser.readFile(filePath);\n                if (content) {\n                    const data = JSON.parse(content);\n                    this.loadAnimationData(data);\n                    this.currentFilePath = filePath;\n                    this.hasUnsavedChanges = false;\n                    this.showNotification('Animation loaded successfully');\n                } else {\n                    this.showNotification('Failed to read animation file', 'error');\n                }\n            }\n        } catch (error) {\n            console.error('Error loading animation:', error);\n            this.showNotification('Error loading animation', 'error');\n        }\n    }\n\n    /**\n     * Show save file dialog\n     */\n    async showSaveFileDialog() {\n        return new Promise((resolve) => {\n            const modal = this.createFileDialog('Save Animation', 'save', resolve);\n            document.body.appendChild(modal);\n        });\n    }\n\n    /**\n     * Show open file dialog\n     */\n    async showOpenFileDialog() {\n        return new Promise((resolve) => {\n            const modal = this.createFileDialog('Open Animation', 'open', resolve);\n            document.body.appendChild(modal);\n        });\n    }\n\n    /**\n     * Create file dialog modal\n     */\n    createFileDialog(title, mode, callback) {\n        const modal = document.createElement('div');\n        modal.className = 'animation-file-dialog-overlay';\n        modal.style.cssText = `\n            position: fixed;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            background: rgba(0, 0, 0, 0.8);\n            z-index: 10000;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n        `;\n\n        const dialog = document.createElement('div');\n        dialog.className = 'animation-file-dialog';\n        dialog.style.cssText = `\n            background: #2a2a2a;\n            border: 1px solid #444;\n            border-radius: 8px;\n            width: 600px;\n            max-height: 700px;\n            display: flex;\n            flex-direction: column;\n            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);\n        `;\n\n        const header = document.createElement('div');\n        header.style.cssText = `\n            padding: 16px;\n            border-bottom: 1px solid #444;\n            display: flex;\n            justify-content: space-between;\n            align-items: center;\n            background: #333;\n            border-radius: 8px 8px 0 0;\n        `;\n\n        const titleEl = document.createElement('h3');\n        titleEl.textContent = title;\n        titleEl.style.cssText = `\n            margin: 0;\n            color: #fff;\n            font-size: 16px;\n        `;\n\n        const closeBtn = document.createElement('button');\n        closeBtn.innerHTML = 'Ã—';\n        closeBtn.style.cssText = `\n            background: none;\n            border: none;\n            color: #fff;\n            font-size: 24px;\n            cursor: pointer;\n            padding: 0;\n            width: 30px;\n            height: 30px;\n            display: flex;\n            align-items: center;\n            justify-content: center;\n        `;\n\n        header.appendChild(titleEl);\n        header.appendChild(closeBtn);\n\n        const content = document.createElement('div');\n        content.style.cssText = `\n            flex: 1;\n            overflow: hidden;\n            display: flex;\n            flex-direction: column;\n        `;\n\n        if (mode === 'save') {\n            this.createSaveDialogContent(content, callback, modal);\n        } else {\n            this.createOpenDialogContent(content, callback, modal);\n        }\n\n        dialog.appendChild(header);\n        dialog.appendChild(content);\n        modal.appendChild(dialog);\n\n        // Close handlers\n        closeBtn.addEventListener('click', () => {\n            modal.remove();\n            callback(null);\n        });\n\n        modal.addEventListener('click', (e) => {\n            if (e.target === modal) {\n                modal.remove();\n                callback(null);\n            }\n        });\n\n        return modal;\n    }\n\n    /**\n     * Create save dialog content\n     */\n    createSaveDialogContent(container, callback, modal) {\n        const form = document.createElement('div');\n        form.style.cssText = `\n            padding: 20px;\n            display: flex;\n            flex-direction: column;\n            gap: 16px;\n        `;\n\n        // File name input\n        const nameGroup = document.createElement('div');\n        nameGroup.innerHTML = `\n            <label style=\"display: block; color: #fff; margin-bottom: 8px;\">File Name:</label>\n            <input type=\"text\" id=\"fileName\" value=\"${this.projectName || 'Untitled'}\" \n                style=\"width: 100%; padding: 8px; background: #1a1a1a; color: #fff; border: 1px solid #555; border-radius: 4px;\">\n        `;\n\n        // Directory selection\n        const dirGroup = document.createElement('div');\n        dirGroup.innerHTML = `\n            <label style=\"display: block; color: #fff; margin-bottom: 8px;\">Save to Directory:</label>\n            <select id=\"directorySelect\" style=\"width: 100%; padding: 8px; background: #1a1a1a; color: #fff; border: 1px solid #555; border-radius: 4px;\">\n                <option value=\"/Animations\">Animations</option>\n                <option value=\"/Animations/Projects\">Animations/Projects</option>\n                <option value=\"/\">Root</option>\n            </select>\n        `;\n\n        const buttons = document.createElement('div');\n        buttons.style.cssText = `\n            display: flex;\n            gap: 8px;\n            justify-content: flex-end;\n            margin-top: 20px;\n        `;\n\n        const cancelBtn = document.createElement('button');\n        cancelBtn.textContent = 'Cancel';\n        cancelBtn.style.cssText = `\n            padding: 8px 16px;\n            background: #666;\n            color: #fff;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n        `;\n\n        const saveBtn = document.createElement('button');\n        saveBtn.textContent = 'Save';\n        saveBtn.style.cssText = `\n            padding: 8px 16px;\n            background: #0078d4;\n            color: #fff;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n        `;\n\n        buttons.appendChild(cancelBtn);\n        buttons.appendChild(saveBtn);\n\n        form.appendChild(nameGroup);\n        form.appendChild(dirGroup);\n        form.appendChild(buttons);\n        container.appendChild(form);\n\n        // Event handlers\n        cancelBtn.addEventListener('click', () => {\n            modal.remove();\n            callback(null);\n        });\n\n        saveBtn.addEventListener('click', () => {\n            const fileName = document.getElementById('fileName').value.trim();\n            const directory = document.getElementById('directorySelect').value;\n            \n            if (!fileName) {\n                alert('Please enter a file name');\n                return;\n            }\n\n            const finalFileName = fileName.endsWith('.anim') ? fileName : `${fileName}.anim`;\n            const fullPath = directory === '/' ? `/${finalFileName}` : `${directory}/${finalFileName}`;\n            \n            modal.remove();\n            callback(fullPath);\n        });\n\n        // Enter key handler\n        document.getElementById('fileName').addEventListener('keypress', (e) => {\n            if (e.key === 'Enter') {\n                saveBtn.click();\n            }\n        });\n\n        // Focus the input\n        setTimeout(() => {\n            document.getElementById('fileName').focus();\n            document.getElementById('fileName').select();\n        }, 100);\n    }\n\n    /**\n     * Create open dialog content\n     */\n    async createOpenDialogContent(container, callback, modal) {\n        const content = document.createElement('div');\n        content.style.cssText = `\n            display: flex;\n            flex-direction: column;\n            height: 500px;\n        `;\n\n        // Search input\n        const searchGroup = document.createElement('div');\n        searchGroup.style.cssText = `\n            padding: 16px;\n            border-bottom: 1px solid #444;\n        `;\n\n        const searchInput = document.createElement('input');\n        searchInput.type = 'text';\n        searchInput.placeholder = 'Search animation files...';\n        searchInput.style.cssText = `\n            width: 100%;\n            padding: 8px;\n            background: #1a1a1a;\n            color: #fff;\n            border: 1px solid #555;\n            border-radius: 4px;\n        `;\n\n        searchGroup.appendChild(searchInput);\n\n        // File list\n        const fileList = document.createElement('div');\n        fileList.style.cssText = `\n            flex: 1;\n            overflow-y: auto;\n            padding: 8px;\n        `;\n\n        // Buttons\n        const buttons = document.createElement('div');\n        buttons.style.cssText = `\n            display: flex;\n            gap: 8px;\n            justify-content: flex-end;\n            padding: 16px;\n            border-top: 1px solid #444;\n        `;\n\n        const cancelBtn = document.createElement('button');\n        cancelBtn.textContent = 'Cancel';\n        cancelBtn.style.cssText = `\n            padding: 8px 16px;\n            background: #666;\n            color: #fff;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n        `;\n\n        const openBtn = document.createElement('button');\n        openBtn.textContent = 'Open';\n        openBtn.disabled = true;\n        openBtn.style.cssText = `\n            padding: 8px 16px;\n            background: #0078d4;\n            color: #fff;\n            border: none;\n            border-radius: 4px;\n            cursor: pointer;\n            opacity: 0.5;\n        `;\n\n        buttons.appendChild(cancelBtn);\n        buttons.appendChild(openBtn);\n\n        content.appendChild(searchGroup);\n        content.appendChild(fileList);\n        content.appendChild(buttons);\n        container.appendChild(content);\n\n        // Load animation files\n        let animationFiles = [];\n        let selectedFile = null;\n\n        if (window.fileBrowser && window.fileBrowser.db) {\n            try {\n                const transaction = window.fileBrowser.db.transaction(['files'], 'readonly');\n                const store = transaction.objectStore('files');\n                const allFiles = await new Promise(resolve => {\n                    store.getAll().onsuccess = e => resolve(e.target.result);\n                });\n\n                animationFiles = allFiles.filter(file => \n                    file.type === 'file' && file.name.endsWith('.anim')\n                ).sort((a, b) => b.modified - a.modified); // Sort by most recent first\n\n            } catch (error) {\n                console.error('Error loading animation files:', error);\n            }\n        }\n\n        const renderFileList = (filteredFiles = animationFiles) => {\n            fileList.innerHTML = '';\n\n            if (filteredFiles.length === 0) {\n                fileList.innerHTML = `\n                    <div style=\"text-align: center; color: #888; padding: 40px;\">\n                        No animation files found\n                    </div>\n                `;\n                return;\n            }\n\n            filteredFiles.forEach(file => {\n                const item = document.createElement('div');\n                item.className = 'animation-file-item';\n                item.dataset.path = file.path;\n                item.style.cssText = `\n                    padding: 12px;\n                    border: 1px solid #444;\n                    border-radius: 4px;\n                    margin-bottom: 8px;\n                    cursor: pointer;\n                    background: #333;\n                    transition: all 0.2s ease;\n                `;\n\n                const fileName = file.name.replace('.anim', '');\n                const modifiedDate = new Date(file.modified).toLocaleDateString();\n                const filePath = file.path.substring(0, file.path.lastIndexOf('/')) || '/';\n\n                item.innerHTML = `\n                    <div style=\"display: flex; justify-content: space-between; align-items: center;\">\n                        <div>\n                            <div style=\"color: #fff; font-weight: bold; margin-bottom: 4px;\">\n                                <i class=\"fas fa-film\" style=\"margin-right: 8px; color: #769afd;\"></i>\n                                ${fileName}\n                            </div>\n                            <div style=\"color: #aaa; font-size: 12px;\">\n                                ${filePath} â€¢ Modified: ${modifiedDate}\n                            </div>\n                        </div>\n                    </div>\n                `;\n\n                item.addEventListener('click', () => {\n                    // Remove selection from other items\n                    fileList.querySelectorAll('.animation-file-item').forEach(el => {\n                        el.style.background = '#333';\n                        el.style.borderColor = '#444';\n                    });\n\n                    // Select this item\n                    item.style.background = '#0078d4';\n                    item.style.borderColor = '#0078d4';\n                    selectedFile = file.path;\n                    openBtn.disabled = false;\n                    openBtn.style.opacity = '1';\n                });\n\n                item.addEventListener('dblclick', () => {\n                    selectedFile = file.path;\n                    modal.remove();\n                    callback(selectedFile);\n                });\n\n                fileList.appendChild(item);\n            });\n        };\n\n        // Search functionality\n        searchInput.addEventListener('input', (e) => {\n            const searchTerm = e.target.value.toLowerCase();\n            const filtered = animationFiles.filter(file => \n                file.name.toLowerCase().includes(searchTerm) ||\n                file.path.toLowerCase().includes(searchTerm)\n            );\n            renderFileList(filtered);\n        });\n\n        // Event handlers\n        cancelBtn.addEventListener('click', () => {\n            modal.remove();\n            callback(null);\n        });\n\n        openBtn.addEventListener('click', () => {\n            if (selectedFile) {\n                modal.remove();\n                callback(selectedFile);\n            }\n        });\n\n        // Initial render\n        renderFileList();\n    }\n\n    loadAnimationData(data) {\n        this.projectName = data.projectName || 'Loaded Animation';\n        this.canvasWidth = data.canvasWidth || 64;\n        this.canvasHeight = data.canvasHeight || 64;\n        this.frameRate = data.frameRate || 12;\n        this.currentGroupId = data.currentGroupId || 'default';\n\n        // Restore animation groups\n        this.animationGroups.clear();\n        data.animationGroups.forEach(groupData => {\n            const group = {\n                id: groupData.id,\n                name: groupData.name,\n                currentFrameIndex: groupData.currentFrameIndex,\n                frames: groupData.frames.map(frameData => ({\n                    id: frameData.id,\n                    layers: frameData.layers.map(layerData => ({\n                        ...layerData,\n                        data: new ImageData(\n                            new Uint8ClampedArray(layerData.data),\n                            this.canvasWidth,\n                            this.canvasHeight\n                        )\n                    })),\n                    imageData: frameData.imageData ? new ImageData(\n                        new Uint8ClampedArray(frameData.imageData),\n                        this.canvasWidth,\n                        this.canvasHeight\n                    ) : null\n                }))\n            };\n            this.animationGroups.set(group.id, group);\n        });\n\n        // Reset active layer\n        this.activeLayerIndex = 0;\n\n        // Update canvas size and UI\n        this.updateCanvasSize();\n        this.updateGroupsDisplay();\n        this.selectFrame(this.getCurrentGroup().currentFrameIndex);\n    }\n\n    async exportSpriteSheet() {\n        try {\n            // Prompt for filename\n            const fileName = prompt('Export filename (without extension):', this.projectName + '_spritesheet');\n            if (!fileName) return;\n\n            // Calculate sprite sheet dimensions\n            const animGroups = Array.from(this.animationGroups.values());\n            const maxFrames = Math.max(...animGroups.map(g => g.frames.length));\n            const animCount = animGroups.length;\n\n            const sheetWidth = maxFrames * this.canvasWidth;\n            const sheetHeight = animCount * this.canvasHeight;\n\n            // Create sprite sheet canvas\n            const sheetCanvas = document.createElement('canvas');\n            sheetCanvas.width = sheetWidth;\n            sheetCanvas.height = sheetHeight;\n            const sheetCtx = sheetCanvas.getContext('2d');\n\n            // Keep transparent background\n            sheetCtx.clearRect(0, 0, sheetWidth, sheetHeight);\n\n            // Draw each animation group as a row\n            animGroups.forEach((group, groupIndex) => {\n                group.frames.forEach((frame, frameIndex) => {\n                    if (frame.imageData) {\n                        const x = frameIndex * this.canvasWidth;\n                        const y = groupIndex * this.canvasHeight;\n\n                        // Create temporary canvas for this frame\n                        const tempCanvas = document.createElement('canvas');\n                        tempCanvas.width = this.canvasWidth;\n                        tempCanvas.height = this.canvasHeight;\n                        const tempCtx = tempCanvas.getContext('2d');\n                        tempCtx.putImageData(frame.imageData, 0, 0);\n\n                        // Draw to sprite sheet\n                        sheetCtx.drawImage(tempCanvas, x, y);\n                    }\n                });\n            });\n\n            // Ensure SpriteSheets directory exists\n            const spriteSheetsDir = '/SpriteSheets';\n            if (window.fileBrowser) {\n                const dirExists = await window.fileBrowser.exists(spriteSheetsDir);\n                if (!dirExists) {\n                    await window.fileBrowser.createDirectory(spriteSheetsDir);\n                }\n\n                // Export as PNG\n                sheetCanvas.toBlob(async (blob) => {\n                    const reader = new FileReader();\n                    reader.onload = async () => {\n                        const dataUrl = reader.result;\n                        const success = await window.fileBrowser.writeFile(`${spriteSheetsDir}/${fileName}.png`, dataUrl);\n                        if (success) {\n                            this.showNotification(`Sprite sheet exported as ${fileName}.png`);\n                            // Refresh file browser\n                            await window.fileBrowser.refreshFiles();\n                        }\n                    };\n                    reader.readAsDataURL(blob);\n                });\n\n                // Also create metadata file\n                const metadata = {\n                    spriteWidth: this.canvasWidth,\n                    spriteHeight: this.canvasHeight,\n                    animations: animGroups.map((group, index) => ({\n                        name: group.name,\n                        row: index,\n                        frameCount: group.frames.length,\n                        frameRate: this.frameRate\n                    }))\n                };\n\n                const success = await window.fileBrowser.writeFile(`${spriteSheetsDir}/${fileName}.json`, JSON.stringify(metadata, null, 2));\n                if (success) {\n                    await window.fileBrowser.refreshFiles();\n                }\n            }\n\n        } catch (error) {\n            console.error('Error exporting sprite sheet:', error);\n            this.showNotification('Error exporting sprite sheet', 'error');\n        }\n    }\n\n    // Utility methods\n    updateCanvasSize() {\n        const canvases = [this.canvas, this.onionCanvas, this.gridCanvas, this.backgroundCanvas].filter(c => c);\n\n        canvases.forEach(canvas => {\n            if (canvas.width !== this.canvasWidth || canvas.height !== this.canvasHeight) {\n                canvas.width = this.canvasWidth;\n                canvas.height = this.canvasHeight;\n            }\n            canvas.style.width = `${this.canvasWidth * this.zoom}px`;\n            canvas.style.height = `${this.canvasHeight * this.zoom}px`;\n        });\n\n        if (this.canvasWrapper) {\n            this.canvasWrapper.style.width = `${this.canvasWidth * this.zoom}px`;\n            this.canvasWrapper.style.height = `${this.canvasHeight * this.zoom}px`;\n        }\n\n        this.drawTransparencyBackground();\n        this.drawGrid();\n    }\n\n    updateTimelineDisplay() {\n        this.framesContainer.innerHTML = '';\n\n        const group = this.getCurrentGroup();\n        if (!group) return;\n\n        group.frames.forEach((frame, index) => {\n            const frameDiv = document.createElement('div');\n            frameDiv.style.cssText = `\n                width: 60px;\n                height: 40px;\n                border: 2px solid ${index === group.currentFrameIndex ? '#9C27B0' : '#666'};\n                background: #444;\n                cursor: pointer;\n                display: flex;\n                align-items: center;\n                justify-content: center;\n                color: #fff;\n                font-size: 12px;\n                position: relative;\n                border-radius: 4px;\n                margin-right: 4px;\n\n                .animation-file-dialog-overlay {\n                    backdrop-filter: blur(4px);\n                }\n\n                .animation-file-dialog {\n                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\n                }\n\n                .animation-file-item:hover {\n                    background: #404040 !important;\n                    border-color: #666 !important;\n                }\n\n                .animation-file-item.selected {\n                    background: #0078d4 !important;\n                    border-color: #0078d4 !important;\n                }\n\n                /* Scrollbar styling for file list */\n                .animation-file-dialog div::-webkit-scrollbar {\n                    width: 8px;\n                }\n\n                .animation-file-dialog div::-webkit-scrollbar-track {\n                    background: #1a1a1a;\n                }\n\n                .animation-file-dialog div::-webkit-scrollbar-thumb {\n                    background: #555;\n                    border-radius: 4px;\n                }\n\n                .animation-file-dialog div::-webkit-scrollbar-thumb:hover {\n                    background: #777;\n                }\n            `;\n\n            frameDiv.innerHTML = `\n                <span>${index + 1}</span>\n                ${index === group.currentFrameIndex ? '<div style=\"position: absolute; top: 2px; right: 2px; width: 6px; height: 6px; background: #9C27B0; border-radius: 50%;\"></div>' : ''}\n            `;\n\n            frameDiv.addEventListener('click', () => this.selectFrameManual(index));\n            this.framesContainer.appendChild(frameDiv);\n        });\n\n        // Update frame count\n        const frameCountSpan = document.getElementById('frame-count');\n        if (frameCountSpan) {\n            frameCountSpan.textContent = group.frames.length;\n        }\n    }\n\n    updateFrameCounter() {\n        const frameSpan = document.getElementById('current-frame');\n        if (frameSpan) {\n            frameSpan.textContent = this.getCurrentGroup().currentFrameIndex + 1;\n        }\n    }\n\n    clearCanvas() {\n        this.ctx.clearRect(0, 0, this.canvasWidth, this.canvasHeight);\n        this.saveFrameData();\n        this.hasUnsavedChanges = true;\n    }\n\n    zoomIn() {\n        this.zoom = Math.min(this.zoom * 1.2, 20);\n        this.updateCanvasSize();\n        this.updateZoomDisplay();\n    }\n\n    zoomOut() {\n        this.zoom = Math.max(this.zoom / 1.2, 0.1);\n        this.updateCanvasSize();\n        this.updateZoomDisplay();\n    }\n\n    resetZoom() {\n        this.zoom = this.canvasWidth <= 64 ? 8.0 : 1.0;\n        this.updateCanvasSize();\n        this.updateZoomDisplay();\n    }\n\n    updateZoomDisplay() {\n        const zoomSpan = document.getElementById('zoom-level');\n        if (zoomSpan) {\n            zoomSpan.textContent = Math.round(this.zoom * 100) + '%';\n        }\n    }\n\n    // History methods\n    saveState() {\n        // Save the current state of all layers in the current frame\n        const currentFrame = this.getCurrentFrame();\n        if (!currentFrame) return;\n\n        if (this.historyIndex < this.maxHistorySteps - 1) {\n            this.historyIndex++;\n\n            // Save a deep copy of all layer data\n            const frameState = {\n                layers: currentFrame.layers.map(layer => ({\n                    ...layer,\n                    data: new ImageData(\n                        new Uint8ClampedArray(layer.data.data),\n                        layer.data.width,\n                        layer.data.height\n                    )\n                })),\n                imageData: this.ctx.getImageData(0, 0, this.canvasWidth, this.canvasHeight)\n            };\n\n            this.history[this.historyIndex] = frameState;\n            this.history.length = this.historyIndex + 1;\n        }\n    }\n\n    undo() {\n        if (this.historyIndex > 0) {\n            this.historyIndex--;\n            const state = this.history[this.historyIndex];\n\n            if (state) {\n                const currentFrame = this.getCurrentFrame();\n                if (currentFrame) {\n                    // Restore layer data\n                    currentFrame.layers = state.layers.map(layer => ({\n                        ...layer,\n                        data: new ImageData(\n                            new Uint8ClampedArray(layer.data.data),\n                            layer.data.width,\n                            layer.data.height\n                        )\n                    }));\n\n                    // Restore canvas\n                    this.ctx.putImageData(state.imageData, 0, 0);\n\n                    // Update frame image data\n                    currentFrame.imageData = new ImageData(\n                        new Uint8ClampedArray(state.imageData.data),\n                        state.imageData.width,\n                        state.imageData.height\n                    );\n\n                    // Update displays\n                    this.updateLayersDisplay();\n                    this.hasUnsavedChanges = true;\n                }\n            }\n        }\n    }\n\n    redo() {\n        if (this.historyIndex < this.history.length - 1) {\n            this.historyIndex++;\n            const state = this.history[this.historyIndex];\n\n            if (state) {\n                const currentFrame = this.getCurrentFrame();\n                if (currentFrame) {\n                    // Restore layer data\n                    currentFrame.layers = state.layers.map(layer => ({\n                        ...layer,\n                        data: new ImageData(\n                            new Uint8ClampedArray(layer.data.data),\n                            layer.data.width,\n                            layer.data.height\n                        )\n                    }));\n\n                    // Restore canvas\n                    this.ctx.putImageData(state.imageData, 0, 0);\n\n                    // Update frame image data\n                    currentFrame.imageData = new ImageData(\n                        new Uint8ClampedArray(state.imageData.data),\n                        state.imageData.width,\n                        state.imageData.height\n                    );\n\n                    // Update displays\n                    this.updateLayersDisplay();\n                    this.hasUnsavedChanges = true;\n                }\n            }\n        }\n    }\n\n    showNotification(message, type = 'info') {\n        console.log(`${type.toUpperCase()}: ${message}`);\n\n        // Create notification element\n        const notification = document.createElement('div');\n        notification.style.cssText = `\n            position: fixed;\n            top: 20px;\n            right: 20px;\n            padding: 12px 20px;\n            background: ${type === 'error' ? '#ff4444' : type === 'success' ? '#44ff44' : '#4444ff'};\n            color: white;\n            border-radius: 4px;\n            z-index: 10000;\n            font-size: 14px;\n            box-shadow: 0 2px 10px rgba(0,0,0,0.3);\n        `;\n        notification.textContent = message;\n\n        document.body.appendChild(notification);\n\n        setTimeout(() => {\n            if (notification.parentNode) {\n                notification.parentNode.removeChild(notification);\n            }\n        }, 3000);\n    }\n\n    onBeforeClose() {\n        if (this.hasUnsavedChanges) {\n            return confirm('You have unsaved changes. Close anyway?');\n        }\n        return true;\n    }\n}\n\n// Export to global scope\nwindow.AnimationToolWindow = AnimationToolWindow;",
      "type": "file",
      "name": "AnimationToolWindow.js",
      "parentPath": "/assets",
      "created": 1757910689047,
      "modified": 1757910718708
    }
  ],
  "metadata": {
    "exportedBy": "Dark Matter JS Game Engine",
    "exportVersion": "1.0",
    "engineVersion": "1.0.0"
  }
}