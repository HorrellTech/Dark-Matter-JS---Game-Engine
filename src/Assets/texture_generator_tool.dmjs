{
  "name": "Texture Generator Tool",
  "description": "A noise based texture generator tool",
  "version": "1.0.0",
  "author": "SynKrown",
  "timestamp": 1757910672348,
  "directories": [
    "/Assets",
    "/Assets/assets"
  ],
  "totalFiles": 1,
  "totalDirectories": 2,
  "files": [
    {
      "path": "/Assets/assets/TextureGeneratorWindow.js",
      "content": "/**\n * TextureGeneratorWindow - A procedural texture generator editor\n * \n * Features:\n * - Multiple noise types (Perlin, Simplex, Fractal, etc.)\n * - Two-color gradient system with randomness\n * - Adjustable dimensions and parameters\n * - Real-time preview\n * - Save to file functionality\n * - Seamless/tileable texture generation\n * - Pixel scaling and filtering options\n */\nclass TextureGeneratorWindow extends EditorWindow {\n    static icon = \"fa-image\";\n    static color = \"#9C27B0\";\n    static description = \"Generate procedural textures with various noise algorithms\";\n\n    constructor() {\n        super(\"Texture Generator\", { \n            width: 900, \n            height: 650,\n            resizable: true \n        });\n\n        // Texture properties\n        this.textureWidth = 64;\n        this.textureHeight = 64;\n        this.noiseType = 'perlin';\n        this.color1 = '#000000';\n        this.color2 = '#ffffff';\n        this.colorRandomness = 0.2;\n        this.scale = 50;\n        this.octaves = 4;\n        this.persistence = 0.5;\n        this.lacunarity = 2.0;\n        this.seed = Math.random() * 1000;\n        \n        // New properties\n        this.seamless = true; // Make textures tileable by default\n        this.pixelScale = 1; // Scale factor for each pixel\n        this.filterType = 'smooth'; // 'smooth' or 'pixelated'\n\n        // Canvas for preview\n        this.previewCanvas = null;\n        this.previewCtx = null;\n\n        this.setupUI();\n        this.exposeProperties();\n    }\n\n    setupUI() {\n        // Create main layout\n        const mainContainer = document.createElement('div');\n        mainContainer.style.cssText = `\n            display: flex;\n            gap: 16px;\n            height: 100%;\n        `;\n\n        // Left panel - controls\n        const controlsPanel = document.createElement('div');\n        controlsPanel.style.cssText = `\n            width: 320px;\n            background: #252525;\n            padding: 16px;\n            border-radius: 8px;\n            overflow-y: auto;\n        `;\n\n        // Right panel - preview\n        const previewPanel = document.createElement('div');\n        previewPanel.style.cssText = `\n            flex: 1;\n            background: #252525;\n            padding: 16px;\n            border-radius: 8px;\n            display: flex;\n            flex-direction: column;\n            align-items: center;\n        `;\n\n        // Create controls\n        this.createControls(controlsPanel);\n        this.createPreview(previewPanel);\n\n        mainContainer.appendChild(controlsPanel);\n        mainContainer.appendChild(previewPanel);\n        this.addContent(mainContainer);\n    }\n\n    createControls(container) {\n        // Dimensions section\n        const dimensionsSection = this.createSection('Dimensions');\n        \n        const widthInput = this.addInput('width', 'Width', {\n            type: 'number',\n            value: this.textureWidth,\n            onChange: (value) => {\n                this.textureWidth = parseInt(value);\n                this.generateTexture();\n            }\n        });\n        \n        const heightInput = this.addInput('height', 'Height', {\n            type: 'number',\n            value: this.textureHeight,\n            onChange: (value) => {\n                this.textureHeight = parseInt(value);\n                this.generateTexture();\n            }\n        });\n\n        dimensionsSection.appendChild(widthInput.parentNode);\n        dimensionsSection.appendChild(heightInput.parentNode);\n\n        // Quality & Rendering section\n        const qualitySection = this.createSection('Quality & Rendering');\n        \n        const seamlessCheckbox = this.addCheckbox('seamless', 'Seamless/Tileable', {\n            checked: this.seamless,\n            onChange: (checked) => {\n                this.seamless = checked;\n                this.generateTexture();\n            }\n        });\n\n        const pixelScaleInput = this.addInput('pixelScale', 'Pixel Scale', {\n            type: 'range',\n            value: this.pixelScale,\n            onChange: (value) => {\n                this.pixelScale = parseFloat(value);\n                this.generateTexture();\n            }\n        });\n        pixelScaleInput.min = 0.1;\n        pixelScaleInput.max = 1;\n        pixelScaleInput.step = 0.1;\n\n        const filterSelect = this.addSelect('filterType', 'Image Filtering', [\n            { value: 'smooth', text: 'Smooth/Blurred' },\n            { value: 'pixelated', text: 'Pixelated/Clean' }\n        ], {\n            value: this.filterType,\n            onChange: (value) => {\n                this.filterType = value;\n                this.updateCanvasFiltering();\n                this.generateTexture();\n            }\n        });\n\n        qualitySection.appendChild(seamlessCheckbox.parentNode);\n        qualitySection.appendChild(pixelScaleInput.parentNode);\n        qualitySection.appendChild(filterSelect.parentNode);\n\n        // Noise type section\n        const noiseSection = this.createSection('Noise Type');\n        \n        const noiseSelect = this.addSelect('noiseType', 'Noise Algorithm', [\n            { value: 'perlin', text: 'Perlin Noise' },\n            { value: 'simplex', text: 'Simplex Noise' },\n            { value: 'fractal', text: 'Fractal Noise' },\n            { value: 'ridged', text: 'Ridged Noise' },\n            { value: 'cellular', text: 'Cellular/Voronoi' },\n            { value: 'random', text: 'Random' }\n        ], {\n            value: this.noiseType,\n            onChange: (value) => {\n                this.noiseType = value;\n                this.generateTexture();\n            }\n        });\n\n        noiseSection.appendChild(noiseSelect.parentNode);\n\n        // Color section\n        const colorSection = this.createSection('Colors');\n        \n        const color1Input = this.addColorPicker('color1', 'Color 1', this.color1, (value) => {\n            this.color1 = value;\n            this.generateTexture();\n        });\n        \n        const color2Input = this.addColorPicker('color2', 'Color 2', this.color2, (value) => {\n            this.color2 = value;\n            this.generateTexture();\n        });\n\n        const randomnessInput = this.addInput('randomness', 'Color Randomness', {\n            type: 'range',\n            value: this.colorRandomness,\n            onChange: (value) => {\n                this.colorRandomness = parseFloat(value);\n                this.generateTexture();\n            }\n        });\n        randomnessInput.min = 0;\n        randomnessInput.max = 1;\n        randomnessInput.step = 0.01;\n\n        colorSection.appendChild(color1Input.parentNode);\n        colorSection.appendChild(color2Input.parentNode);\n        colorSection.appendChild(randomnessInput.parentNode);\n\n        // Parameters section\n        const paramsSection = this.createSection('Parameters');\n        \n        const scaleInput = this.addInput('scale', 'Scale', {\n            type: 'range',\n            value: this.scale,\n            onChange: (value) => {\n                this.scale = parseFloat(value);\n                this.generateTexture();\n            }\n        });\n        scaleInput.min = 1;\n        scaleInput.max = 200;\n        scaleInput.step = 1;\n\n        const octavesInput = this.addInput('octaves', 'Octaves', {\n            type: 'range',\n            value: this.octaves,\n            onChange: (value) => {\n                this.octaves = parseInt(value);\n                this.generateTexture();\n            }\n        });\n        octavesInput.min = 1;\n        octavesInput.max = 8;\n        octavesInput.step = 1;\n\n        const persistenceInput = this.addInput('persistence', 'Persistence', {\n            type: 'range',\n            value: this.persistence,\n            onChange: (value) => {\n                this.persistence = parseFloat(value);\n                this.generateTexture();\n            }\n        });\n        persistenceInput.min = 0.1;\n        persistenceInput.max = 1;\n        persistenceInput.step = 0.01;\n\n        const seedInput = this.addInput('seed', 'Seed', {\n            type: 'number',\n            value: this.seed.toFixed(0),\n            onChange: (value) => {\n                this.seed = parseFloat(value);\n                this.generateTexture();\n            }\n        });\n\n        paramsSection.appendChild(scaleInput.parentNode);\n        paramsSection.appendChild(octavesInput.parentNode);\n        paramsSection.appendChild(persistenceInput.parentNode);\n        paramsSection.appendChild(seedInput.parentNode);\n\n        // Action buttons\n        const actionsSection = this.createSection('Actions');\n        \n        const randomizeBtn = this.addButton('randomize', 'Randomize Seed', {\n            onClick: () => {\n                this.seed = Math.random() * 1000;\n                this.getComponent('seed').value = this.seed.toFixed(0);\n                this.generateTexture();\n            }\n        });\n\n        const generateBtn = this.addButton('generate', 'Generate', {\n            onClick: () => this.generateTexture(),\n            style: 'background: #28a745;'\n        });\n\n        const saveBtn = this.addButton('save', 'Save to Downloads', {\n            onClick: () => this.saveTexture(),\n            style: 'background: #17a2b8;'\n        });\n\n        const saveToFileBtn = this.addButton('saveToFile', 'Save to File Browser', {\n            onClick: () => this.saveToFileBrowser(),\n            style: 'background: #6f42c1;'\n        });\n\n        actionsSection.appendChild(randomizeBtn);\n        actionsSection.appendChild(generateBtn);\n        actionsSection.appendChild(saveBtn);\n        actionsSection.appendChild(saveToFileBtn);\n\n        // Add all sections to container\n        container.appendChild(dimensionsSection);\n        container.appendChild(qualitySection);\n        container.appendChild(noiseSection);\n        container.appendChild(colorSection);\n        container.appendChild(paramsSection);\n        container.appendChild(actionsSection);\n    }\n\n    createSection(title) {\n        const section = document.createElement('div');\n        section.style.cssText = `\n            margin-bottom: 24px;\n            padding-bottom: 16px;\n            border-bottom: 1px solid #444;\n        `;\n\n        const header = document.createElement('h4');\n        header.textContent = title;\n        header.style.cssText = `\n            margin: 0 0 12px 0;\n            color: #ffffff;\n            font-size: 16px;\n            font-weight: 600;\n        `;\n\n        section.appendChild(header);\n        return section;\n    }\n\n    addColorPicker(id, label, value, onChange) {\n        const container = document.createElement('div');\n        container.className = 'editor-window-color-group';\n        container.style.cssText = `\n            margin: 8px 0;\n            display: flex;\n            flex-direction: column;\n        `;\n\n        const labelElement = document.createElement('label');\n        labelElement.textContent = label;\n        labelElement.style.cssText = `\n            color: #ffffff;\n            font-size: 12px;\n            margin-bottom: 4px;\n            font-weight: 500;\n        `;\n\n        const colorInput = document.createElement('input');\n        colorInput.type = 'color';\n        colorInput.id = id;\n        colorInput.value = value;\n        colorInput.style.cssText = `\n            width: 100%;\n            height: 40px;\n            border: 1px solid #555;\n            border-radius: 4px;\n            cursor: pointer;\n            background: none;\n        `;\n\n        colorInput.addEventListener('change', (e) => onChange(e.target.value));\n\n        container.appendChild(labelElement);\n        container.appendChild(colorInput);\n        this.components.set(id, colorInput);\n        return colorInput;\n    }\n\n    createPreview(container) {\n        const title = document.createElement('h3');\n        title.textContent = 'Preview';\n        title.style.cssText = `\n            margin: 0 0 16px 0;\n            color: #ffffff;\n            font-size: 18px;\n        `;\n\n        this.previewCanvas = document.createElement('canvas');\n        this.previewCanvas.width = 400;\n        this.previewCanvas.height = 400;\n        this.previewCanvas.style.cssText = `\n            border: 1px solid #555;\n            border-radius: 4px;\n            background: #1a1a1a;\n            max-width: 100%;\n            max-height: 400px;\n        `;\n\n        this.previewCtx = this.previewCanvas.getContext('2d');\n        this.updateCanvasFiltering();\n\n        container.appendChild(title);\n        container.appendChild(this.previewCanvas);\n\n        // Generate initial texture\n        this.generateTexture();\n    }\n\n    updateCanvasFiltering() {\n        if (!this.previewCanvas) return;\n        \n        if (this.filterType === 'pixelated') {\n            this.previewCanvas.style.imageRendering = 'pixelated';\n            this.previewCanvas.style.imageRendering = '-moz-crisp-edges';\n            this.previewCanvas.style.imageRendering = 'crisp-edges';\n            this.previewCtx.imageSmoothingEnabled = false;\n        } else {\n            this.previewCanvas.style.imageRendering = 'auto';\n            this.previewCtx.imageSmoothingEnabled = true;\n        }\n    }\n\n    generateTexture() {\n        if (!this.previewCtx) return;\n\n        const canvas = this.previewCanvas;\n        const ctx = this.previewCtx;\n        \n        // Apply pixel scaling to the actual canvas size\n        const scaledWidth = Math.floor(canvas.width * this.pixelScale);\n        const scaledHeight = Math.floor(canvas.height * this.pixelScale);\n        \n        const imageData = ctx.createImageData(scaledWidth, scaledHeight);\n        const data = imageData.data;\n\n        // Parse colors\n        const color1RGB = this.hexToRgb(this.color1);\n        const color2RGB = this.hexToRgb(this.color2);\n\n        for (let y = 0; y < scaledHeight; y++) {\n            for (let x = 0; x < scaledWidth; x++) {\n                // Normalize coordinates\n                let nx = x / scaledWidth;\n                let ny = y / scaledHeight;\n\n                let noiseValue = nx;\n\n                // For seamless textures, wrap coordinates for noise sampling\n                if (this.seamless) {\n                    // Use domain warping for true seamless textures\n                    const s = nx * this.textureWidth / this.scale;\n                    const t = ny * this.textureHeight / this.scale;\n\n                    // Sample noise in a way that wraps seamlessly\n                    noiseValue = this.generateSeamlessNoise(s, t);\n                } else {\n                    noiseValue = this.generateNoise(nx, ny);\n                }\n                \n                // Apply color randomness\n                if (this.colorRandomness > 0) {\n                    const randomOffset = (Math.random() - 0.5) * this.colorRandomness * 2;\n                    noiseValue = Math.max(0, Math.min(1, noiseValue + randomOffset));\n                }\n\n                // Interpolate between colors\n                const r = Math.floor(color1RGB.r + (color2RGB.r - color1RGB.r) * noiseValue);\n                const g = Math.floor(color1RGB.g + (color2RGB.g - color1RGB.g) * noiseValue);\n                const b = Math.floor(color1RGB.b + (color2RGB.b - color1RGB.b) * noiseValue);\n\n                const index = (y * scaledWidth + x) * 4;\n                data[index] = r;\n                data[index + 1] = g;\n                data[index + 2] = b;\n                data[index + 3] = 255;\n            }\n        }\n\n        // Clear canvas and draw scaled image data\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        \n        // Create temporary canvas for the generated texture\n        const tempCanvas = document.createElement('canvas');\n        tempCanvas.width = scaledWidth;\n        tempCanvas.height = scaledHeight;\n        const tempCtx = tempCanvas.getContext('2d');\n        tempCtx.putImageData(imageData, 0, 0);\n        \n        // Draw scaled version to preview canvas\n        if (this.filterType === 'pixelated') {\n            ctx.imageSmoothingEnabled = false;\n        } else {\n            ctx.imageSmoothingEnabled = true;\n        }\n        \n        ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);\n    }\n\n    generateSeamlessNoise(s, t) {\n        // Use the torus mapping technique for true seamless noise\n        const R = this.scale / (2 * Math.PI); // Major radius\n        const r = this.scale / (4 * Math.PI); // Minor radius\n\n        // Map 2D coordinates to 4D torus\n        const nx = R + r * Math.cos(s * 2 * Math.PI / this.scale);\n        const ny = r * Math.sin(s * 2 * Math.PI / this.scale);\n        const nz = R + r * Math.cos(t * 2 * Math.PI / this.scale);\n        const nw = r * Math.sin(t * 2 * Math.PI / this.scale);\n\n        // Sample 4D noise and return\n        return this.noise4D(nx, ny, nz, nw);\n    }\n\n    noise4D(x, y, z, w) {\n        // Simple 4D noise by combining 2D noise samples\n        const xy = this.perlinNoise(x, y);\n        const zw = this.perlinNoise(z, w);\n        const xz = this.perlinNoise(x, z);\n        const yw = this.perlinNoise(y, w);\n\n        return (xy + zw + xz + yw) / 4;\n    }\n\n    generateNoise(x, y) {\n        const scaledX = x * this.scale;\n        const scaledY = y * this.scale;\n\n        switch (this.noiseType) {\n            case 'perlin':\n                return this.perlinNoise(scaledX, scaledY);\n            case 'simplex':\n                return this.simplexNoise(scaledX, scaledY);\n            case 'fractal':\n                return this.fractalNoise(scaledX, scaledY);\n            case 'ridged':\n                return this.ridgedNoise(scaledX, scaledY);\n            case 'cellular':\n                return this.cellularNoise(scaledX, scaledY);\n            case 'random':\n                return Math.random();\n            default:\n                return this.perlinNoise(scaledX, scaledY);\n        }\n    }\n\n    // Simplified noise implementations\n    perlinNoise(x, y) {\n        // Simple pseudo-perlin noise\n        const xi = Math.floor(x) & 255;\n        const yi = Math.floor(y) & 255;\n        const xf = x - Math.floor(x);\n        const yf = y - Math.floor(y);\n\n        const u = this.fade(xf);\n        const v = this.fade(yf);\n\n        const n00 = this.grad(this.hash(xi + this.hash(yi)), xf, yf);\n        const n01 = this.grad(this.hash(xi + this.hash(yi + 1)), xf, yf - 1);\n        const n10 = this.grad(this.hash(xi + 1 + this.hash(yi)), xf - 1, yf);\n        const n11 = this.grad(this.hash(xi + 1 + this.hash(yi + 1)), xf - 1, yf - 1);\n\n        const nx0 = this.lerp(n00, n10, u);\n        const nx1 = this.lerp(n01, n11, u);\n\n        return (this.lerp(nx0, nx1, v) + 1) / 2; // Normalize to 0-1\n    }\n\n    fractalNoise(x, y) {\n        let value = 0;\n        let amplitude = 1;\n        let frequency = 1;\n        let maxValue = 0;\n\n        for (let i = 0; i < this.octaves; i++) {\n            value += this.perlinNoise(x * frequency, y * frequency) * amplitude;\n            maxValue += amplitude;\n            amplitude *= this.persistence;\n            frequency *= this.lacunarity;\n        }\n\n        return value / maxValue;\n    }\n\n    simplexNoise(x, y) {\n        // Simplified simplex noise approximation\n        return (this.perlinNoise(x * 0.8, y * 0.8) + this.perlinNoise(x * 1.2, y * 1.2)) / 2;\n    }\n\n    ridgedNoise(x, y) {\n        return 1 - Math.abs(this.perlinNoise(x, y) * 2 - 1);\n    }\n\n    cellularNoise(x, y) {\n        // Simple cellular/Voronoi approximation\n        const cellSize = 20;\n        const cellX = Math.floor(x / cellSize);\n        const cellY = Math.floor(y / cellSize);\n        \n        let minDist = Infinity;\n        for (let dx = -1; dx <= 1; dx++) {\n            for (let dy = -1; dy <= 1; dy++) {\n                const pointX = (cellX + dx) * cellSize + (this.hash(cellX + dx + this.hash(cellY + dy)) % cellSize);\n                const pointY = (cellY + dy) * cellSize + (this.hash(cellY + dy + this.hash(cellX + dx)) % cellSize);\n                const dist = Math.sqrt((x - pointX) ** 2 + (y - pointY) ** 2);\n                minDist = Math.min(minDist, dist);\n            }\n        }\n        \n        return Math.min(1, minDist / cellSize);\n    }\n\n    // Helper functions for noise generation\n    hash(n) {\n        return Math.floor(Math.abs(Math.sin(n + this.seed) * 43758.5453123)) % 256;\n    }\n\n    fade(t) {\n        return t * t * t * (t * (t * 6 - 15) + 10);\n    }\n\n    lerp(a, b, t) {\n        return a + t * (b - a);\n    }\n\n    grad(hash, x, y) {\n        const h = hash & 15;\n        const u = h < 8 ? x : y;\n        const v = h < 4 ? y : h == 12 || h == 14 ? x : 0;\n        return ((h & 1) == 0 ? u : -u) + ((h & 2) == 0 ? v : -v);\n    }\n\n    hexToRgb(hex) {\n        const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n        return result ? {\n            r: parseInt(result[1], 16),\n            g: parseInt(result[2], 16),\n            b: parseInt(result[3], 16)\n        } : { r: 0, g: 0, b: 0 };\n    }\n\n    async saveToFileBrowser() {\n        try {\n            // Check if file browser is available\n            if (!window.fileBrowser) {\n                this.showNotification('File browser not available', 'error');\n                return;\n            }\n\n            // Generate the texture data\n            const textureData = this.generateFullResolutionTexture();\n            \n            // Create filename\n            const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');\n            const filename = `texture_${this.noiseType}_${this.textureWidth}x${this.textureHeight}_${timestamp}.png`;\n            \n            // Determine save path (current directory in file browser or /Textures)\n            let savePath;\n            if (window.fileBrowser.currentPath && window.fileBrowser.currentPath !== '/') {\n                savePath = `${window.fileBrowser.currentPath}/${filename}`;\n            } else {\n                // Create Textures folder if it doesn't exist\n                const texturesPath = '/Textures';\n                const exists = await window.fileBrowser.exists(texturesPath);\n                if (!exists) {\n                    await window.fileBrowser.createDirectory(texturesPath);\n                }\n                savePath = `${texturesPath}/${filename}`;\n            }\n\n            // Save to file browser\n            const success = await window.fileBrowser.writeFile(savePath, textureData);\n            \n            if (success) {\n                this.showNotification(`Texture saved to: ${savePath}`, 'success');\n                \n                // Refresh file browser if we're in the save directory\n                if (window.fileBrowser.currentPath === savePath.substring(0, savePath.lastIndexOf('/'))) {\n                    await window.fileBrowser.refreshFiles();\n                }\n            } else {\n                this.showNotification('Failed to save texture to file browser', 'error');\n            }\n            \n        } catch (error) {\n            console.error('Error saving texture to file browser:', error);\n            this.showNotification(`Error saving texture: ${error.message}`, 'error');\n        }\n    }\n\n    generateFullResolutionTexture() {\n        // Create a full-resolution canvas\n        const fullCanvas = document.createElement('canvas');\n        fullCanvas.width = this.textureWidth;\n        fullCanvas.height = this.textureHeight;\n        const fullCtx = fullCanvas.getContext('2d');\n\n        // Set filtering based on user preference\n        if (this.filterType === 'pixelated') {\n            fullCtx.imageSmoothingEnabled = false;\n        } else {\n            fullCtx.imageSmoothingEnabled = true;\n        }\n\n        // Generate full-resolution texture with seamless support\n        const imageData = fullCtx.createImageData(fullCanvas.width, fullCanvas.height);\n        const data = imageData.data;\n\n        const color1RGB = this.hexToRgb(this.color1);\n        const color2RGB = this.hexToRgb(this.color2);\n\n        for (let y = 0; y < fullCanvas.height; y++) {\n            for (let x = 0; x < fullCanvas.width; x++) {\n                let nx = x / fullCanvas.width;\n                let ny = y / fullCanvas.height;\n\n                let noiseValue;\n\n                if (this.seamless) {\n                    // Generate seamless noise using the same torus mapping\n                    const s = nx * this.textureWidth / this.scale;\n                    const t = ny * this.textureHeight / this.scale;\n                    noiseValue = this.generateSeamlessNoise(s, t);\n                } else {\n                    noiseValue = this.generateNoise(nx, ny);\n                }\n                \n                if (this.colorRandomness > 0) {\n                    const randomOffset = (Math.random() - 0.5) * this.colorRandomness * 2;\n                    noiseValue = Math.max(0, Math.min(1, noiseValue + randomOffset));\n                }\n\n                const r = Math.floor(color1RGB.r + (color2RGB.r - color1RGB.r) * noiseValue);\n                const g = Math.floor(color1RGB.g + (color2RGB.g - color1RGB.g) * noiseValue);\n                const b = Math.floor(color1RGB.b + (color2RGB.b - color1RGB.b) * noiseValue);\n\n                const index = (y * fullCanvas.width + x) * 4;\n                data[index] = r;\n                data[index + 1] = g;\n                data[index + 2] = b;\n                data[index + 3] = 255;\n            }\n        }\n\n        fullCtx.putImageData(imageData, 0, 0);\n        \n        // Return as data URL\n        return fullCanvas.toDataURL('image/png');\n    }\n\n    saveTexture() {\n        // Generate full resolution texture\n        const textureData = this.generateFullResolutionTexture();\n        \n        // Convert data URL to blob and download\n        fetch(textureData)\n            .then(res => res.blob())\n            .then(blob => {\n                const url = URL.createObjectURL(blob);\n                const a = document.createElement('a');\n                a.href = url;\n                a.download = `texture_${this.noiseType}_${this.textureWidth}x${this.textureHeight}.png`;\n                document.body.appendChild(a);\n                a.click();\n                document.body.removeChild(a);\n                URL.revokeObjectURL(url);\n            });\n    }\n\n    showNotification(message, type = 'info') {\n        // Use FileBrowser's notification system if available\n        if (window.fileBrowser && typeof window.fileBrowser.showNotification === 'function') {\n            window.fileBrowser.showNotification(message, type);\n        } else {\n            // Fallback to console\n            console.log(`${type.toUpperCase()}: ${message}`);\n        }\n    }\n\n    exposeProperties() {\n        this.exposeProperty('textureWidth', 'number', this.textureWidth);\n        this.exposeProperty('textureHeight', 'number', this.textureHeight);\n        this.exposeProperty('noiseType', 'string', this.noiseType);\n        this.exposeProperty('color1', 'color', this.color1);\n        this.exposeProperty('color2', 'color', this.color2);\n        this.exposeProperty('colorRandomness', 'number', this.colorRandomness);\n        this.exposeProperty('scale', 'number', this.scale);\n        this.exposeProperty('octaves', 'number', this.octaves);\n        this.exposeProperty('persistence', 'number', this.persistence);\n        this.exposeProperty('seed', 'number', this.seed);\n        this.exposeProperty('seamless', 'boolean', this.seamless);\n        this.exposeProperty('pixelScale', 'number', this.pixelScale);\n        this.exposeProperty('filterType', 'string', this.filterType);\n    }\n\n    onShow() {\n        this.generateTexture();\n    }\n\n    onResize(width, height) {\n        // Optionally adjust preview canvas size when window is resized\n        if (this.previewCanvas) {\n            const maxSize = Math.min(width - 400, height - 200, 400);\n            this.previewCanvas.style.maxWidth = `${maxSize}px`;\n            this.previewCanvas.style.maxHeight = `${maxSize}px`;\n        }\n    }\n}\n\n// Export to global scope\nwindow.TextureGeneratorWindow = TextureGeneratorWindow;",
      "type": "file",
      "name": "TextureGeneratorWindow.js",
      "parentPath": "/Assets/assets",
      "created": 1757910491838,
      "modified": 1757910491838
    }
  ],
  "metadata": {
    "exportedBy": "Dark Matter JS Game Engine",
    "exportVersion": "1.0",
    "engineVersion": "1.0.0"
  }
}