{
  "name": "Basic Drawing Module",
  "description": "A bunch of modules for drawing different shapes",
  "version": "1.0.0",
  "author": "SynKrown",
  "timestamp": 1758692873247,
  "icon": {
    "data": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAQAElEQVR4AYT9B6BtWVXmi3/fXPucmyqSqgoqkKtEESgEEbVbfbbPrIhizgptImkjhjZnoA1twtgqksUIiCgGJBlAcllAQQFFQeV0694T9hr/3zfWPrcKff/35lljzpHHmGPONdfae9+C8U0vPVHf9NKd+hbgm8G/9WUn6ltedry+dQOPf/nxesLLbqsnvPy2evzLbqn//vJb69tefkt9+8tvavi2l90IfQP4DfUdf3nDMr7shvqOwMuvr+9quK6ehOwpf3ldBZ76l9fXk//yI/WkV3y4nvyKj9RTT8GH67v/8sP1Pa+4ur7nr66qp/3Vh4CMwCuvqu995dX1tIx/9cH6PmRP/+v31/f/9Qeqx7/5QH3fX19ZPwD9/X/z/vqBhivrBxl/8G/ex/i++qFXXQlkfF/98KsC760f/pv31o+86or6UaDHv72ifgz48b99T/34372nfuzv3sX4rvqJv393/cTfBcDh/cTfv6t+Gvqn4f/sq99VgZ/5R3j/eHn93GveVT+X8dWX1zMYG14D/pp/r2cwPvM1l9WzXgu85h31zH98Rz2L8VmveSfjZfXzr31H/a/Xvp3x7fULrwOgfwH6FxveVr/02gN4a/3S699Sv/S6t9Qvv/6t9Svgv8L4a69/c/3aG95cz379v9WzGX/9DW+q33jDG+vZr39T/Tpj8N9k/M03/Ev9NjAky5bKFbRhGLbgAUtvWaWJPqPho00vDVQHDmxDW2MZ0CwhUuxtgxceRGMklvEWOSJV2xQ24UhCHj9oqrRpIFzoJItJ5Vn20MJLlJKNo1ybUeALDNkQXPEWVOCYKyCyk63EjCcTH1LJwzZjuJKCBobI3lJGdCOIWrIZIFWltjAD12DkwnzphWGJ/JGh3vzJ0jTWSuxF31r+UBJ8ZmrDsWQbEF6GxqJMqtZILoHEt+QxN6+wFfVqVfhCxzIyiSmYXAuyQoCLBm2rDeKsE7BgNURp2QgVVMEz+YwdSzRLi741FKLoAZwSXyYhOzIpdtHJaISo6KBhKRkpTJYd3RmypAGQWyZna5OHFfsQ8TVgBx8oDCHDxGa0yEmpgyApfMksiGjDWOAXFJ6ACqNHRGp9WImzFBxukVMmLuG3ZEaxq73hF3RcFjESZ3i9bCAUJwJyRWPJB+vOFY4wWvSHIrTiSUrc2ISmXEIqU4/QI3GNekB3tNbBH5OBWYqPwh98dhdeBoEdI/BMLtCLOqSJBWjcIg+jKRxYi766JbUhg5fCb32oCSKJeY7MGowHMkIpCU0lhTc8a5okK62UHIxkoNi+8RV9UcBMVLT4L8aIcirUpuiawy3FV81rNAD8KItQYuqZPoUAn9tGMnLLzFeKv2hZIgPLjJnHRIFDDBgDW8UW5aCYh6RG0oEvFZkjbFtZU99MAtPil0UxOQ0tzT0UcnKjHrgGV+sOYk+OQqVrvkEn9GIfUfSjY2YofHMRU4uuxFjqOYiGcMQgGad4IpE4iaEjRCcB7LgjErzWaSWECdKgdlzYDyY84LFnOun2RYKaZugZxbWW4oDinPUGkYYZmEV1jJJk0rI0wLmEz0DbQhv5AECZIBi+uKTw8GFHw5hUOGKdFrwyrOnIBb1CELsCdzYNdCVWaNHQFx6iEwiZ+cVh60lI4XLFbEhaEXbAFTmIzTrja1AbBeAhlpq3GKXW8YWo+aGNbnwk5sDnAQ8zxT78jGNkHtYg+MABV/ug47JW8EEUWHxKjnEcSRoxNEgrNLIkFTpYnFbv2pJxZruDRS44gZgNcLNDWTUwoWNFJ8E6VvLEXuj0ZJEeXLnDG29FpCV8lDwyAk5kSWwkG7wkmY7Jt3+KnGgLVNvOFLDmfVLYV80zvFm1vgME7jUbIadDMWbh0YtuNQ4PGmNs1woPZzI5JM0SLQEZQpMVUwt3TuRwG8x8Y5N8o14oB3AkZhqXjFb+wjdWgQEHAXGjRf4LE+msykYFKyJFJ7EFXqxTj+Qv4pi6yOTEFZ3Bqoz4wda2ghPHCaUh4avAA1KEMUqQ+LAts13cgRYdY2OsMoLKKA7u2Cwc7KYrPIRGadKQKCCdhB8r1iLXRJljAgeRN0DxwLhSgHXLnIkRQ/hFgPGsHPfFYjkTpzgGn8ALnDCozprh6WChkcEUTyNh3fGL4s1ARpQ1ozuzSeKjslGwWXhsBqyaj//qrEsi18xRZFnk2CD4vNilluGLFj5ViFYDhgJhKA479PHddM+v1D5LS8sILP7WrZ+bp8uVjhyZjCI/4CeFrIdlZc6J31VnHeKbAwCPXEgjl20cWFHKglpSj0G6QEy59bvT0sBJGFN0UQzJLKmJoCRwo1gEFZyMkfVmIUPUOzZVOKCYXIwK7bl5STyTi+2gwMqdywKEJyZueFkUgxcVqEOHpaNHgMOqo+BHDoEfAt+W4dfhQxqAD0d2RD58TD5yFDgiHT4iHwKOIENeR45IvfmXDGfiFhukiJXY1Yu2VgaRbQNz9cJQ0/Cjn5e+mVwXQOTBHJkn9SsKaJtalFCJBTLJNnThhk0y1G2ylBc/mCDExmCSKbVli4Y+/QQxQTNA1SKzNGT+8EfcRogg6rYoEVplcC8ygxJAJZLTpjUT+UL6AIveCK/gzIt+LbTgFAGZDrFKSyELLtOIHZhtxbwkZeMt+nPzlIJzV865m1kEbRahDm1rZrGKRS5GbW+rkOWIrzwG2CwGan8tYx9cjDN3duQNtU8S3N3wTByTTyUOOM5U2ys2x7IhlDjEEPJKHkCBz9qTWPTa3CgQfW1cgDPzylByBhY/Na871TqbZKbQlEHZLKhIcQCvelOVDhY0tqaeVTiLHCACvk3drUlLQwVkbqgoB9AVmgNNBlCrm0mm40HHWftuSS0m4QNk1dx0g0ySsI2A47l94KRHrAwePxUZBYpa54As9gHbyrE1iN858XyP2BRXARYsi5pCFz5m7urKnRogrDYLLRY6YDaAiOuNbXxMLJLW+6p9Frv1GLPggMLbbJAc+YXcQEbFF7ZrbOOz8KvB4clGyGYIzEwoaayRmckmrsFFfKa2zC0TalDXPF1hl4Uu+JgpzcbTgAOjsEdFWegJfkZTG0outFAvrUC4TtHZQJEvDPx0QiXbMhbqvhhm8iJwCj5w2gvOLgstomKKUqkXG8uWQ4HSS+ye1KHx1sGXWUBrv2WQCsBCBz/4JIcObzgN6cDDjO3MM1PkkMKYBTA2YgGKRRfHcY5vcbxHlsWcWfjanzVYy7EumUVUYE1oFm1rGjr7orvp/IfdR+ddej/dCzj/4ffX+YwXPPwBuhf4PQMPfYDOe+j9dM+H3V8XPOR+uusFd9Vqsswims0nchH+ZiD+w5uRVWjAR3m8HDok81ipXrSihNx15C5OBIfHPPEo2ypXEgTPCKhk5LlyI5ii4SFk17hrjQKm8AqYqUjxqMRXanTKWloh7Qu1+CLQRlqyS0qNiRedEYcB5kLCsEi0DSw5f+hnjH6P8ERj/yvO48+dQBQL6RxzgMQwahsCcIl6IkeE/cHkwkcNPhwSY+2VQpuCJ6cUuY93Fl3Jbd6TWXSx6DnGB2MWvlA+fOYR3fPh99Z5D7+Pzn3YvXXPh95Hd/+YC3TkjNO13i/NewFpvVvADJQKvHbIGVntzejMrG/p8Nln6u4Pvq/uxYY4/9IHsGEu1r3BjxzjfYD5ZpGzqGKBTezOJyM5zmwCcTKJRUx9UtiZN3KzERQdUSdG4weUhZzVdYDw5s4HVSALNqiXQwCpeTEK26kka2nhReeUHwKbYs7ogqJn2YFS/MXKdGwAvCQZFAdOEwA9RDGdFaVksoyw0UvvljjoArgxd4Lgu0PMajuiF0US0yz8B5J83BjdHimOKI65g4vFLcZ5TFof2Za4qyaKqvjIncidnoWPbvyc99CLdN7DLtS9HnKR7nLh3VQs5HyS3FnY/Z3qRV6zwAustb+zr/3dffjB97QHvd5ZM+42P3R0duHtn5i1fxI9/MXnes+6x33upQs4LS689P66z0PvL6ZHarNmHiNFfgaUOmQD84iovHAyF6YPm5owD0eeeqVC1D7ziB/bKRMkQmqVzZCbZsCOi15Q+CikbOryoWqQQDNaUvTkRG82IWIuNIwymGjxmXCjFySKMDlPtMyoNG8CieYNDPQmnLQxvE4EvcSIzPZizmxBO9TMwi76yLBxAAM3c0ZnVvwQUHl+ynzhmxe51aTRheIsp6ijNwGTomDnstjnsOj3/PiLJO7sXnQWfI/F3ztZ2mfh90+wyDu72jvJwgJ7J3YWHN7+7TvaP3lS+yd2tWbcO3GScecU7MFbw9vfOYnernZ3drS/t8u4r102zz6x9nfX2iP2BR//AF1w6cW6iMcHNy9zYYLkaPI1p1M2hVZ8HXP4sJRV7OnO1CmLEVj06eHNDOaktHjF4Day0tzDTInQR2VQtQlms+ngopt+A6yR0ImeaKbWI8lFzBpiglQNIxmbRTSC4FmM4Ngop4GymEyInSJFB90eCWKg9ZAjZAJIIidCRbflJpARkDkys/jiaEo+zIhwLDB8LhUft2prS30XsejmWT4YxUbYOratez30Qp3P4iffXvQ9aX9X2uUOzR27d2JP+yxwFnXNos0sdGCfxVyzAdaM+8dP9kLvH9/V/u0n1TR6a+R7oU+c0Dr07YzRB+aTO623d/KE9sH3GPeIs7e7w4Yg5sl91XpFbstmOJr3AWoyc7fnhVKcBmYO+XSSl1fuCapTTGumNqwKi5mapAapi0HYP2JxFBGa1M/KX+rdi586Bij8iJKlrFdAaBJAYozMhCgY1pBt9Z8lEDgz48C/aASml2IhGgGiB6biJTF8x4pNIcZy0eNAtArQwWNVIWZl1w00Nt6bV9gud/M+7mblWdof3w5vKwuu9VoTj4AULKfQGRfcRedceqHucr9zxNNBa+7y9Y40c5fv7OxxVwMs9n7uWhZnzSJmMbOwOzfdqpPX3aDd62/Uzg03aPfGm7R3483auwFg3AX2b7pFuzfdpIzrm25mjOzGttm99gbt3XiL9o6fUHyu2QyJs8+Jsp8Nkw0Hvpc8dk9qzWNjvbevuz3gIl3w8It5JN1DTFAzm7hPAuY2gh87JOVEYFEiN5vFrPgwJaJ+qegAnalVAaB9DWo5WMCCCgzG3gz4CT5GHAitDaBUZnPGB7g9K3qtILH4gOEs6z7DL5kEJLM4JbJnBDcol9kQyt1LEuK5vbyEGG3JRh9fsakkBM0lJTi94UnWYLLLxAoJNnlGsuDiLhncJYNxzWfy0889Q+ex8IfPPk1zFn131j7P8j2O3l0Kvb+7q9yZa45psQBZmBPX3KgTLO7uzSzarcc1o7OpiTIOJppsLRr4BJK8JuZjbksePmRYGohtq23y0e+2W7V/y83av/4GnWRT7J84zmLvaM2my+NjLycCG2G9d1K72YzEXe+tddrZZ+nCh1+iM849SyZecSLMzK8C1KGOHu5TQC0rBurBRRJUq9Q1BcOYuknmaVVgYAAAEABJREFUL2Shn7yrj4tZgtm6JTSsNNKXWKuCA9JzceOhtDT8ZI6KYpyU0gu1AqJudWQJWoqe7cbNZpi9JN3JgDMDmY2RYygeFm/FMJMiI0WuLDuFyDdxASpAiFl5XoqieDV0Txb+6DlnaOYZW7yZr7nb1yz6Hgs9U+hi0de521mAnetu1M6NN2q+5XYmaU0iP0I5m8kSpPIyNUDMbk+uJIOuaMVoTRRyGAnjJMGTJkuwNJMTdeo5xE/mN996m/ZuuEk7bIa947ezEXa1n1zI6eC9Ie8Re2yEmXeGM887Rxd8wiXEEX5IjtySn3Ma5AZgI2RRM3+xaKZGXUNULTc7py3WSV2m9kwFEoVwsMExdK7MidEl1DRA+SSsaOIKCo/IQJSvwgfeuMIMS4uO0uKoNjTO4iIVaeO5+Y3yaIhUcMwvfvbia3hJqZQx/bIJ0vvYUc0UoTjTUwgItKxzL71A53zcvbTmRKg9aebO3+POn3lTnzlua3N3nbg2i86xfdtxJY5rSKwSpZIpBqHVBYI9yG+y4QNE6YuFZtcpHLPiyW6dycQP3NApXhbF4ccnNplnXoITZ5ERlg2wxyPk5HXkwybYZxPskOde4OQe7yhsDvB5d49PKg/QvR/5QFIlQjaWZmXuoHxFfVjxX+E1hozYiTOgk3dxAxnEKyn5DXJl8dKrDnrmWtyEqDWn6wBhx1JdL8geB7xxQAj14fSB0mDCQqEkZcL2UEayJ5hokQRASXRQJCWrJgu1RZajr49WFqjnxkejPBOz8F4TkOfisbsd46Pc+RILXiy+eMtec+fv8REsC79PAff3dnie36Q9ntvJYyIbwjJ/fHitLJTJIfFyp5KGnIDkVDxfU8gZutgQxaikxxzX5DUDoU03AKaKeYnpNxCk50MkxhZpBdE5QIaZ+e/zzrF3/c2a8x7CSbXPhsinkDUnQR5Z+2zkPBruw2lw5KzTJB4T4kVXnIjxUccOy/xV74jSRF4GEiLQG5mcM2+2gIr5hh9I7piCFiK8WOp3Asj4Fj6deaNkIGyrNLDYsAU7UOqJS4rCAqLNOBa8gLW0ggdOIp1nurAQFs6zuxN45pnXH4UObak49vKy5/A4Ac699Hydfs+zNPORaXmjL+3yVp2jfuao38+bNsf8Pi9rB7mk8ErWiUfswTQIm3VSd5ksfGXxIyDrQpdMwVDR0sLLe0GogWR4KHuy2DAKrTZW2qBL4Y3PiXgDOrFSq2kM0OgWBwsz5xGxf/1NyztKNgHz2M0mZi57nAq7bIS73vs83ecTP0apj5g7BZA4Fde8DM98BE7omTyS8yDIRDw8q/laMxJvMydEsqGpSXQGRmS0yQkpMtvoSEYnugMeTpgJE3K8ImhGFCUUAZQgFcgL3xAaHWdW7z4EptC41uJjUTA+2ahLAiyG+GZsHV1s85WtSHzmTr8XR34f9eAzH+dm7obimVkcl/s87/eu5W7iLTy+ja1xPwkEoDZQXMTqSeOTgCKMTAXM1IzMsmZysMnd0SzZVk4JG56EpuAFr3SyGLCBCoI8HMnYpwYwyQBagmcRQbbFB1h1YckleutbbtVONgKPrzUfG/dZ/DXzm9kMGde80N7nkR+Lk1kk2WBsvdrSzI9P6kYW5DLDF1GLdYpvgzvy8MmroEOSRgaohWMd/FXKI2e9GqRIKBUCqYkw4ng0pW4TPfr0S3iTjIY4noTDtXCAtjatljFHGru5SHbmS53OMRJWrbA/fNYRvoO/oDd9ZfFPimflWmsWfea43L3pNu3zkiVOidgSLsE7VhGt8MucGzNTHSw0RC4oo9sWiUhdq1/oKpUptY6NDmBbAw4Uc8ETwYLjBG4Bkph8x0Jg3poYlIb2xnZmHJpgRi+27ZN5uv0VHy1v4SPoLcwv7wO7mjfzXLPR18z3woc/UIeO5mPwrDlz5pQUhe2Px/hIzcxjbpTIiY7LYCZgYCSoFBMxJcmUQMqgPMoh1S0INsEbBSfMjHahPDSQuJhagqKRCcBCJgVHohyTGcUijERDd2DjQgdNw88dvmYTZAJm0QODka/6+G7+HJ110V2UO3/Nix6Pdu3v7akoRIqRu94UKG5s4xHHEnGLaS4g4g3YRioF2fBJIsVgaHYXDkeoQ8/CHeBYcFRrAeOcqzhWJ5k/ybwn2FTDMws7iA0/i2/cxJo5UxDlFOxYKiHCMFewWdGkQy0ygDt/j9Og8l0Cp8Eec8xm3+dxMPPx9u4XX6hzLjlfox8Ha0qID+LM+Toc76DMZAbDM0GX+atplOWEFbISm0ibuIpIljUs5oEwVAZyRipmCYW1FTJQggSZhRdl8UTAAmDCmzGqRQcnRWbFYsde7N5Er+x+Pt6QMQmsMS8Fv+fD7qnB0cbHfGXx93nRm/d2td7d0Q5ftuxddzP6M1DtP7u3j1RiFzPO0i1AGmQu4lvWMoo4PCD6Tb6UlnnYyMkxBQga6E2CXe6ePGcJqMhnNoH44iQxBptgQmcAYj6RCz8dC1mPKVECIVc2eMKiQ0S49ORNT16QFCA30f7Nt2qPd4SZd4NdNsLM5l/v72nmcbDFaXkRp0F881FIRT1N/PWRLRV+G4iTx7E4EWBSAWnkHYQQ2ehmnIBBwqfmSh4VTfLruUcJnVzoue+E4idco6ghJeNBYFPMFD50koqduSvUrdAIQrkKKZugmCSY8vt4F4SCTmgl8Xtces9+1yGMZt729/l4VzwLi2Nwhy9w6tbblYTbY2Ikl/hVwQfU0emtRQ+eo10S+iNMbHqCSpvRA8hpQHZx0BnyMkVsklc2GGwJvcwtfjzUjzgG9nTuRnF4zcJUkYvmEPgQ+WUhTvlgcxQ8Gw1SQzViuROAwWaZ81GRTzP9BRabf2YjiBNi5lvEfCq56NIHxjuui7hrRi5eDnHLhffUGldCy0IGl4EY0giP2JlbABTRLLs0DHpwsaFCNi/CRTFeZzZExStuZ0ZwjBaduYMsHaLw0RKeMr9w5i3uQviiONRCxfPsnIfei7Fknve5++e87PHKnwnv8FWt7XjBHB18tTkJOw4iw7mBjoOwtQ/00LEGtrqjhQfERNjPk5SJcojITHzAk6WJkUt2SbhYnBQvc02w+My3UUYy5G5Br+RBBvhhKdjnMxJrZr4mQJGFTcfmTx9omnyGjG4pXzwFO3nTjap8XORG2M8jkMdC5ZHAR+OL+Cq5F5A42UFltnZOTzzM4bXjWe0b3MpfkJluZp5SNvesGYtCWmALnnnGbqA5evIkD9IGWb6ox0PqEmVhuuhhYYCrgEZRIjWotYRXb20rzTNSjqt7POQ8FSNbWflWdfmSZ1/7HP27vOhZFhmKNRLmmJIkhUz8xKgImTBcWG6dLCz1UBfcmHD1kDgUunF4mZMgSBHbhMEjvov5TBtBoa/8O4Toj6FsihS48hI7MIYvW56sOY5Ckw+UDG56x974Rz4MwoUISVHT8GdwmMSa8OOF0mAie3xtPXP3r6nHmptivb/PCQnwLnAfHgfOTUO8mcdB8fGQGahMNfIIEEsIwwmmwmsRTLKtMcAD4ZOX7tRCuvkiB5CujuY2Fse+wDsICeuUfPGAFqzSMAOJ5I6q7Hbi5avdmd1rFqIo4N0vuTtGVnKd+S298szPjyY89/Z53psCGDumkSjALJkLgE0AAQU/VGQAFFz6WTNxzEYbFKjnwMPRyR0QRaiMaHaO6NizEos1kJJUggdEQGAlWhGS3EkNTsm2jF+4yryEHy4hkBQZORlpmNSuOOKhuCxbwkipFXsLHLZEtfBbIOQm5rDLj1Azd//Mo2DmJJjzKOC9YE0e93rwfXExy63LyJdFHQr7Nd+jZI6gixyXg6BmTs5EEeTmTBqdd+RMLLLwCkcjyLJRSjEkGqOVv/joxAtLwAz4lhBUHFWhNytzLl5gZo57agy91tGz+VaLL37Mm/7yr3H2+2PQzDN/N4vfvoo+RZl1EFcsGo84dRwmbVuDjE2kglaAIIk54Fk0lA1vWejQwh7fyZENEp1MdNX65JsYcRBgATBXClXoV5sNDeKKVgi5Oqyw75g4jHgQU20QCUz84Q5d8Nw8GKbIouVUISzrXeSGnHkgVvyn/ns338zL8J7yKNjvzcApwIuhp6HT736WxGYoHOTG8rFjkDPZlMTVORDDcISOwiQRgy+8CK0VuZqgRh6zjCNdJhNAHk2JiaUgxMZlAbC0tOghhseRT5DsUrErBT4BzuoxnnH+2co/ku0jn4kUx1zx6r9//S0aJEAe9CWBxGcKKxLImLgIiAHFooiJiGYgOj0ijZ1TPXxE1DTCkDEb6YgS2QSeAgbvMXrAxOaa4ity4sPSGJYHmowZFDlZD1OtpKy0wjPEho9IkQ8L7QJEqowRJCFBAwNJkwUNNM78UpP9m29T14kTck291tws+br4zPPvrpw+M5uADCj1LPF7ivElbAWfYHIWhqxO+dzEzo0xWBOZBBASVgO7McQIj3kLvpwOQfwEz6618ocSV4tRNniu4jALXjgfPKvEmGfWeQ89XxlneDPHfvFcK55xezfcQnqERy/2bt8mCUtIDIZ7sOp8MqnS0qKh6DOp4q7OjzIoxmwBpRUajChP6DA0jYkqk2pqpi+U1DFG0MAmJ6GcIotcqI8iEpvDIkySoz6qWeFXdBAsOHJ00g98CP4AQkc522WAZCHbf/sq1AJwiBG/e/ywlE0w8+mg+lGw1sz7wAWPuLg/mVQWO1Aik+o5mIXBA94XOieT43mWYKoPIyZT5Icqkll0yunUOSJrhmhxNLCI0NBJnEGZU/A4mQntTRI6elR5wetdhuK5Dz+fzNDMAUHieZ5lInt8pZti5yVz4GzgnKH9YqYgmchgW376ve+iz7/krrrnGVsiS00UWjFmNkWhzJjrYFS3ZIa6TKEs3Cj+B3Yp/IAwecefZDyaXsqmpY+7LqbAyB7WDCZ4bl2xgQp7h2sphRyLB3pisymMfCATLXIh2ZD9yWIkd/JoFygkr8QTLXpGEJ97vBMUn5T2uWlSvznvA3xszr8tIITMZjXx6jC/IDIK5sw7TXjBCz8JM/A7kRoFARMlNONahCYzUK7Ot+AswUsxhC/HGsRy99kQIFAzDhJilviyJztyFDSJnHHP07Xmrl8+6qHNJMRxtsOPOSKpLn5elIhXJJ0FL+wyNmCShP7hfTfo4+9xmr7hYefrBz/9Pnr6f71IEwLM0CgNkOQbfxkD8Z9xKWqoeZNruKHXggGMLgQumAdz42o/YYxCDij6hXqK0Api/aERcBXzDdeZA3i0SQ85NixyZU7oRYeh61+ZPxpZJONskR302CGPj/hKPrs33ijza2E+GeQxUDw+sxHOOveu7FnmMsfzrDWP3yKHpB9be+MzJ2CYkFzMWdQNO2MXPjYT6FAIgsc4eOTwm2x2dwXL8ka3OPphJE9MkDHhGBy+62kyG2DdsFZxhO3eeit2aBMQTbytsZHwlm4Z01O4uM9zDlW+NOoZoi+a9dKe2FgAABAASURBVL2ffB9dcvcjGsR2uDgbqZgRb67YhyV0opKcAubuyEiI5TTBpriLwushyvBwLsWJBDoxv5nMlnyjIqjAoMi2YZEEfS6UJeQV4pSP0mQJNqGiS02yadDBXHl/mWyN6MDPFT/OBkF95/htEjXc5xEqHqUzG+LYPc5SnufreU+oSTi3Td+YCLTwFyGRZnjIoTN/CEKYgQDkOaA0IN0ECFcmEbCjaGXIUVpk6AbC8NYvFr53n6xzuVuDz2s0+DSQO3/NaF4A8aCBk8GjxYYaAPHITiYxvBFVcvORcSf++eXXKnx3D0a+j3nQedqaTFGNLozkEnt8DXaNmUjh1JZSBdzhv+T8WZs7cZbRVVqJvKSZeK2LrZC1PTtj4NeiRIxCJ7lm0XAgsakcPtC2yAfxB6PwUzOfhPji5hsf8RC1H5xGb9DZxl40EmAOMjlBxR9i2Vb74SVwzcfqvBOsOU0Dgr6AL4kog9Qbfdaakzgx884m1gRziVxkaUAwA4k8o0Nq8IjnUAUOpwNLHC10obGMIZwwoKTCcXKdefYXTlHTyDGDxvZpk2YKplOLz04n4f0b+KYLecWQsS8SKYqHRyVueHGXBAunXSzG99x0e0TEZUidSDg2X8O3igoOEF7BQWUm3KOWZgRF3KK44bgskeNM/l0ol5rV8uoTB7HkHIwEJEcs0JnhBao9JiELHGM3SMk9PovNM8bQN7Porzj92Xrsgy/RH7zpLdiJQuMDOwHlUsb46RHS4dAtsnDDmLXPo6A4AWbeB8wNVcAMnHb2mZqTcObDPOf8k3PmgqsYNmSjp57Jj9QyiDJpWVtiwAzdCcbQJHAAmYyQlNaaSdjgArdohw6J6EyFSZHAXe5/DxGbd8FZxfEvEt658SbkEqYKUthWkGbgZblkW5aUXeoxq+LIRMq/ByTBan0UkiCa55x2RHP4KmxmBNKwkAh+6FaUkC8gZIm8AcSxX7ecePgKiotWNxs9Ie1wsCEfetadPguO0IyiddyuYCl37JXnvUhff+mDiWe96GN/XV/7tm/kK/493Jey2Y1uxiyKqYdbgqOE4uQYmtELXXRS2Kbf5zsCc/yveZ8SN1YBZ190DhJykrgRGQ/xDWzmgo8iZ4qhxENJWQSHsBtHW5L5K41MYgknwdHSSjbp4SgKYKS6FlWQ+Doyzofg8pn/rPueJfaAxN0vfuQxi7/mO1+XNOIMZOBreGgZzSisRUMJzyAoB9eGLyXpHXY65iKwcMEo7RMsC2ioCebEmLyyYYfCjZ8SorAX7xTGgGQeH6JE0uM+7t769kc/SN/xqI/Vt3/Sx+rbAo96kJ7wiQ/S4x/5IH0r8PhP/Fj990c+WJ/zgAuxFHnjN4tPUu2fDZs8z9je0rd8wqX6+xP/rPBlKYGf9+Df1wAVi5shKUQUfBlZAHxlQRyDGBemQOQNbMh8xF5T1wL2qa14DKzZBOd9zH1FQZgnHtCbt7biGnrueeJJOSREzkNLLBuvJVJcK2jnJ5qVv6KH4MKlslNBm5cCRsOrQ8wZKV9DhnfkjGPSWpq58020vPjt83m/q0zQ2GOgOMnuJzst0N6UJMRGow7UqZRmuiT2K2+4Ui/992vQCUfaYdKXffgm/Y9PfYDue9ZhDS18YWyDM2La3N4k4ZEX9dKl97qbvvPRl+g7Hv0xevInP0jnnn60s2Nftj7WMW08XdPdSRfd5Uw94VEfr2/9xAfrzCOHSL+Y3kxY6wzuvMc95OOYk/WD93iartr9IDgXq/3Hb3+rpkGWLECc55QwUXvfkJtNAK4BKEGVVgptaG/sxE+o+zfzOGUDZBMUH6+z8CveMUztxOInI6342Rj/mIqzDWcVlDxBXXS5Sg7u4KLmjA6kk2NOb5III1DMhhXOMECZWBZetLvxXX8KLR7Ga+7W4oha8102KkhjIHxtIEnCEhU3E8sk8Ya8AClZwpYJuQCIpMuvv00//9r36Fmvebee97YP6kHnna1IvuRjL9QTP+n+Wp6D4Sx+FtvSCttM5kmffIme/Kkfo0dfdPdw7gToF2SCMsRDALT9J7fYh74DrC/juf74T3xo32HHDq/0pR/3MSrm9hc3/Lk+84zP0Jn7Z+uT3/kI/d1Nf6vjvMGnoplrbqa8qMZXFsAdpegdlkCU1vlTwOgudm5Rara/s6tsgDUbIads8PMedD/xuqJ8MsgmqIkzEfsYFesyZX6uuGZKVk6CutPERoIkaCaRZIPHGG0uA7N6k3HcD579xRhdZq0VX0Tk3/gVz+vBFxUzO3P/luOY1wJsGHfwws+AZ3yVmgffkjqmxGiSk0zyiLScmkm1+t0CB7r++K5srIDYRboFnpxi0/PiFFINfRd3exbfsv6f28KPn9jVf1IazTnB2/yi2SSqi+a3PIJNwEczGHrR9S/S59/183WSb++8sv7x4n/WRfNDNGcuxI+n+DCmGWHhjLqSe+YlGJFlLSZ0Almo5BYQekOzdDtfFfMuUDwGzGlYHG0rHslGllgMqu1D7bJ4VIafGimbgFzETsG9kkOAYisx20AEiVBRBLjIa60+1jnjjZMCBhDjY+edvtjx7J9JpPiiYv/22zEvRW7TV6mVMppUeoQTtkoeJdmdBNqSLMc/emhDRbd6FC2F/MXXvktUljjSL7z6Mn3nJz9AT+UO74lgl0V/4qMfiLaIsECI+Nt9/9dp5z2P0t4VnxxWQ/ik0PhHd9XkYd6ui5xOOfPik+XQl176cfqMt32hvuyuX6bjJ05q17s6tnVU19x2m/7hvVeSY21yp474KENnzlkpvBunuFPi54RArKbhN4JuZOHlTo18vbOj4kYrHm3ZAGKhz7roXNVcogMyI3B8BIOhLHxG27IB0QodrgEtWaLyskG4yFVJbskTLZTr6DbkWqKn0+nnnIVf7k4Cm2RmHgHziR21C3zEX/SStB1GKb1IrMkIS/DolFZylJEnvqIMPRi5epM0r6TnvfVK/fxrLtdT/svHyEYKfNcnX6wnfcolcdSAWo9CnBNr9z2P1rx3Od5Fzfa18+5P1M5Hfkgi2CndxeJU/39uulqZ7j+fuEHx0yCJcEqzrPtu37ff9LW11pnbp+vaW4/rle9+l1aTNSFP7PioHKOWRDB7g0AGzXEPW8FhqSZ6l7LhU5O8O7QdbHGTiRtuzQ1X1LzmtY6ddRq6pY7BWs1Hj6kYK4G56y0rV9Wsyl/IDbDHEroiV7IzCgMqgUPHAAGcwbG8OJgzmZLWLL5YfPFCOK93lUVn3oqt8cMcwGETbDC73sWScucbXvShuGrRI+lFBk3yUREdl041iGuP7+mJj76fIkuOzLaHhVY3QxgssPueTwHDZzHkSnDeRXTbK5QhOqhH8lHwDWedJyqrRxw5+xTfpzBCQvzWxb+gaRo6tjqqD99yq/7yXZejUT01I+9aDOHGyvw7zqYwkYvGHtTEYyu6IIsKwmFpMAqFrANuFJ2Z3wbE4mfeM5tBrIPHkHnmZ5FDx260nVXUkmyxlUJNkuLWksYimCWSsiwB7l0TbA3FoiMTzVAJeu7DLmQoNoSVYGuOoTU/ZUIQrBroZLzHRJ0IDnJtfEkUCfPhGZUKKZBcEgkj6pFAEjZJPCDsCvkvv+E9iLDTndpHkQtRbKroixyiiStcFC4L0tr54BPUQVsPXgLbuoEXLUGKFtOCeO8uz2Bo0PT4aGWtmOiHbr5Ff3X5u5WjOFyRY/J1nBt1Xv2Ti2KM3ywkXBGKk0JaNj6jaCQ5sE/MNXdtbFJKAmbBVLeSB+8B+9x4Re0D9/r4+6NGLdu3sYakthWMsVPA9cC3xR850+MPAzFD+Cr+kKHGRUHolaTH5qtGXCrygc3Apth5OYIquxAHttU62AYNFZfhOUlQhIOJDhIYcYai2f2ZnPGxsLAMHwKMHrd3usKbiW2Dkcd/UtjoRsQDEzF6G94yWExBbb77rpQItpU/LUY6e7VqNHoIJJTvvXWaDppBUq+3fugjuvrWW/S373mPfDA/PPZc0BHvT5m/2pHiBr3NKGXa4uYFmRW91GSK8yHurWq52QTxF7ZwFHyGJxZfqQPjABSg9sWL+syaFfWMjXmmWFaRVzG/AmNhFT9jDEtcJbEbZlAAwignWMRlL3z61eEptkr84vjPy19+vsQcqdjN1oi+1Q1UHiVDk4+cv0pfyAMMKZwZSSzJNQoejnuM3gKhbeupn3Jx0lNXCH8g+qiGEy552hYhF9CdWoS43D7/N9rFnSQ6yYZ2IYTp6DEmjeDX758IdQre+pGr9TfvvkJ9o2go/04hlqGToD3ULuhib4PA4X6gL+WOnFmwzGuCk0WJ89R3gOQkgB1XUFLM42HNj2z5VjCPgjmPAxZ/deSQCsdmU2QzDOpSrGP0DX/0RqjFR055FmRUZlYiES8Cpc10pSTFzCQcYq/cdXd/0D3FesFDh6BFoRIQX4pu/Nn4Ki32JCDAJCOawye44pDYAxBgdAoLo5MrYyCy0PGLWkLoiY96AGgJde0c39effedVKhw/9yuulMIUrePFQ8Fh0XLKKCVdeO0oi7PN0Yn6na9r93fxZ+wk3PYoGlPVXafD+pUb/h2KzHr+eUxCMmdl1UqiqIsNxskbFqKCVxihy2AGC4R5gyKT8rLnELBtd+zRkiJzaHRxicasFS9/2QDrjMTNaXzPi+8t5RMCfg3M6IukgwsPyaWdpvbEiGxEOA0RZlZa6K4dDqJcRw8jI28cce9rrNHqHSfE2CQ4Mkut1yP0QsxiHpoIjgfFtzo4WvOi32HSkVAmNyT0FlAm0BQ0SeX7++/6JBYfc0O/5tkf1KGjK33hL99TH3zj7frK512Idun9/3QLoxS3Atu+35s1+5Ca0QFWsve1uu9rYeEMyR1X6dytbeUE+F/XXQbbuugdL4O2fuf6K5r+72cv/4n3H7zpjfgpWTMznJFxFS4ZBDcFjp9s8py0RtY09cmdH5XkSDag1TdYbijUqHN6fDHPbCjlphENJxNFjZ44gc0mzKcCsQ6DPBCRa3Ip1aGj4II7M+IPRyZgZhw9vIkNIBXG+A2CWJ2M0rAxlJCLpOdIOQ2Ut002QXFU7t50czTaNmJFjq2xGURJvRG2juGTA2QJESOMzWUURxSgl1xIGpzM07f+U/h83zqz9OHLTuhTHn++fu2zP6Bf+az360+edp1+5bM/qN963Pt10SPP1Icuu/MmkI7c71U6dP/X6tD9Xge8Rtv3+1cNEZB5dd6JUnQUfMuTRIJPvVs+VpauvORzUSl9013vq7SB7Kqbb5I3cxU2RU2WvKNRcvwq/i0bKPjopY6ZeJM1kwMLlZvCyLlyJ6eGOdEkJgoYx2iha2UBcxLD0n7+vQA/tydUeDP+Ijd+An3oLULF3vGFhyUHBdMwIjolIHk280BBJdDqyUR2+j3PbHnhtCfIBsiR0z6klhlnZkLRT4FLaSVnB5N125KdZfVZSRCjYg0RLVwZvdhLhmsl1tmHIrcEryQMjFZ5AAAQAElEQVSdc/ER/frnXUmt2JY8k/qfbjOeuFU6ftuOzruEFzYUFz8Y5AoBL+gCpbCk+JV6ILb+Y0Pceoytg/w1771CU+ZayXpW7ujkvcwJBXb6YG451ikiDGE6y0wDM0WXbSZBi43B2qFWUVLkotmS8VMyNbC6saqpd9IcfAoQL5lzxs2anH3huaRQojDYxAK7xMjig4YTaJRumI5rCQrSNGOST+FD58ihzDp6jzNww17Cf/WzpwhSGiSYKwURiz9iH8MSbCuTJT8laSNsEXqWZDzaYFRgSAoqyIyLXSn41zzsfjpoc44+dPJxWIxO18ISVdRvPuZqOHhzk0jg02szBF3AzUqchf5/73EnHOci61LsbDMCCRdcggZY1DFSxVJabxDmPtBBlceiFj1JyQI2I7gBsgqdgsU6coWBTy4mhQdoVJkuGtSueJEsTqQz+OFqTrHjQ2qzrjvKhXF8gSotI55YUJT7zmRaeFeOttC1GjJ/RQDiaVgaWBo98+zpFxBoJQJjsRsnCws6fPakWejYjDgIG37FXrQi+WH0C4DGjzMAFT1oofsVH3+RYg67rzFtCsuEUJMwMkG8lFVHToMQLXyGyE9B6A24jbXpN8z/r6E2CuQ2ETQ+BskVc8mG+MpLH6GvAL4c+LKHfsISNncx+omUb/0O6oUZCxh/i1PS7bs3cxfzjmQzk/aTUxpXMiedOVELnWJt2klOAW7K9o/hwsdLasUacM+0D236+DX2jAUrsBHhMBPBVD60pQQVyQ+yY44dK12peAbdLocvGjqCB0k/SyD5xtChYsgYeXw1SIotai1JzPgskhLQspLEXXS3/MNHWa0Ia/E56z6P5ifhPkcR5RmMQv7J2BP+5AK95DveR5qlzj9+DqDt6bjCYrjjIsQBYeL5gDgYYSQvRPqqhz6SL4DwsJnbIy+8jx7HgsOJ+MBCj3vYI5vuhUNIRsjSQ4BlLriVuKFIWJEkRvY2i4PGcjU/sVjMcBZraX2STzh8adVsToDiJMAZGylaMy+CvMSjPFAw3k02I2sVQCXryiDY6hal7J7qYMZRyYbLxpDF2tGxvvniofh5EoniJAuIGiFEQ4fTIH0zGhFoSSiZ55jg2XTMNLn0BCWFRRAtbdZn3e+cRtFcZKEgrKHP/dF7aByWzOIP/Aj4jKedSSDrMb/KRyLRCEn/UdcpFn50AILLdaCYfE6RBzoHDEYuPZYF/4pPyB3/cN337neTjSJXZAd+JOviu5+Hdzxy52ZDFjwY6kcseEn0ksyCDfQoyEo9DUUQt4O5LXc+2uiFj4a0u9uoWHxx42TZ8KCKjsAYsZCxV7e59SvriXw0FYFRjiY4c2h2AlNnONKRu5ymaRYmhbMgQBQHNIGDHoAIKjzgkSFyCTIXGwoUmyEaSbVN9Ikf7wuEWxIJXHz3s3TQ4EgRkYXZdX/03ZfrCS+5SN/+iguBC/TtL79AD/y0M3T7zXta/Bz00rx3XOsb3wN/c7Uf8HaqeFQRb/+aN6uWIAi50CsGmLlQhBF6oRo7QFsPTjQOIPN88L0u1CDfhWe8L5pV3D4FzgVTRQ2MPeXRhiVKqzzbxefvrmckEbKAqLM8EH16sHnwVRicdpezlM0l6IwjNlHGN1OkF3ZGR4zYu1lShK0cwxjJvWAMOiOfAHBidlqcitanL/agUWGAYDEz6egc+O1I+Iv/8AbauEKfTcRJAaIkW+gg4sJPcgAEpYMW4+BxhMpjn5Wffa0bP8AxCP/Wa/gCB/7RM7fwB4PrwETYjLPvr355hZ9QGQ4gejt/cImmezxEOy/6pAN2j0uuUnSURowMpwDf0WFYphoBi5sYUW075hJ5EjOeWHq0IpVyesbQEguCBoqRYCLDi7wgBjgDvdAbYk9pBVV8GptZ+IOan3XuXeFyJSkMuq6MiRlfSPpKivggFIqGlQAMst2QZ0Wcih224rvx/uIB9UyMNCVzBeDFuWisv4i1qED3xIhklA29JBOk4ADELpIfxBxwTKw2LunzH3ivKAKJVkhBawMM8RfJ2RccgRI/UW+3Tu6kZtypG7WPDOM5pwOCGEOC4YLsyfHI11yGjnToca9tdhNg9/yL9+m2vb2e10xyr7v+Fh16yb8p8me/7xrKM/NpeM5UdcEbX69uzEvMSUog9WKllhN0FtOSMt82im7o1i9YJiflphcEegzUqOdlKbWyjcgsSZGRVF23WeIG3d5iW5TAoZEmnhgNiyF9Q+gRzCQlAszcjTkBeuGNhJUkjhiULoHjzOgqRxDelrfO0sJnhIelTu00CjvwlWMt8+Qx2L7MkdY6kQsF7AzoTnj+LV4kGCgtMTKvRIlq8PgMHrmxDa/pIIEIAltnCLHMV7nx0zqitU5p/2+/m1mlYNKtv/VwBFyRAR/6vAt12taWfvKdV+vr3vBBfdJdz9DOYx+i6U/foW+96O4syNANu3s643Wv0wcufdQmXeNgc+Ejc5tMdSlmatFK3C2wGh0bdc8sCbUdvNekPtk0USijUOZzDnLw+Ig8tUBCDgRhUokTHmEwswY2IxPXrEo88OjgQuGPIM1AEIa64SweGFhZFEutiGwQLUUvkkxySSIQvoQHC09zBwcFJ534ghgdrGQ+wkQLpWUQjUTpkblh0Q0n4FaVzN/S2wseM1ClESnDApYO+KKtb/vQ4mNI8y3vhbO50Au2/RnP1AbVdPb5YTWQrcQqRfaDDzpXz3nUBdCSSlp/4YMyY+xK9zh0WLd8Uh4daHK1AmrLBcPGpJR5ecyyw5NA4aGFP9ZHWaScEq2DMGN1wdFVfMwahX54DJPpWIvizgcjLELqHfZgrjCU9WlZ65TMX+j4HQaz0ws2wo1jiNj2oLRFRWGUJPOZs/EQILZ7IgwSndlxii/sbCu5hGdmmUVr50orWRug0EmoEw+CuABcyLYMfuVtu5p+5wpt/f6VeuGVfO0Hbwb+4xXd8A7G6bR7EQUODn3GvRccUvG6c0OylYJLOvJpP0mfK9YYoP3Jlz0/DOUXUJFLPld/7gf/HJ71+A+8XDMn2g7P4szrJbdeBj/XYqt2U12OU6erZxayhCtF3EC9sqBmhc1pLOLmioyP83HYdRSy+AkI64IWMygWfmY0RgeAWEu90YwjcZsQxwgGwVmXkmDGmR2zha6BCoqRhYt+6+UZHd3itwAYzTZIgqsTwZ5EcNXJrtAw/oUsyUFGG+CKITFISeFzQCrxMOfg2SxrdODG36E/eL/u95Kr5JWZ5lpf9XfXavW7l2NKTHTuuNwRww2Ev759+U/NEststLrtA2EDs9Yr3iE2eUT/5Eu/Hn6uUocv6R8v+QqJJE7yDvESfiSaxtDLzv8Cfc2Vr9CzL/icPpq3x6Qf+/Br9SVnXKKltXWmBJSKRS8yx13Xxk6eBb96c+TmEHLlhDy1MvhAz+IPewEGirs+N3RvFhBnleG5JFNASyp8JQIoV0FHaGJnnLvGhJGGJfwvEBmEKVLYcSOQdowibM0Qc4Li0l6E5rhScEnUQbIwTXgcimDoNg9b4wchZAEoxo6kM4egygTRw0PUeviRt9ykub/kgIxuAJ+etnTGH+ZnYPinrjqFEaBxHzqtx+4Q71/1rxQg7q2RLxPgadOOft0bN1jkoJ0UIzpHVlv6krtejAAC1nMu+ix65hmSqfzQuY9GBquvMNX/WliZDxMMZyJ34TN4lPMe1fWTBZtZFXMteUip5ZDV9gyi1QbYg2pWFh7/w9ag1tHNZmsZdOExOFniabmxmqbDJuLC0AgZcWKcJTFLymIjUIOkily1kFFAd9GHKBSg0SIHa7CQwRs2fKWhh5tg6Ak9LT+s4HdOcSI5GIMDP/7GG9TPuQ3f8MgWC+t2fgMPDWu5PorYsKb8HLzgSX7r4i9WkdN8/P0KrbRaDE/8/sNCNaRokZOyTo3atGb27BbGYq7o6U7try/nl0dkqdMQ9R4RYkx9JmLaQ7aB8CJT1wQG9bGEXqL0RsEeTkSSZqkJBkybFo0auQXVPe4ZM5OFCxEl4WqJIwyEM3JYBEjMriI3nlMblhnhCyBdjc1Dye1tCZQFH5ZGv8FGc5aTPIWOtYdkSYljDYXdOMwsRiwcB9AZdKdmw4RuPfDkZsMjT2uZHOI7LoMGGBBr/7ZrtWwg9d0l5rz3ux8nHzufGYUXRRYH/tZX/lOIDeCkFjQDlOIvONo6aMln4an9RSey/F6STW1b+ddCHhs5yqDSBELtFbAU4547XV4GRf0w1YQoPoMLJLU2o5VGzxV/tsUFk9rjLDniQvETuWipu2QNFEeXDk7SYICNoPu5k8nEIJWGsng/oXZoQxhmJXEU8CXRDeExgkRlLJIIb2z0UwDYaEXdMgXHoYYkR4dj3hK06QOdhua8dKJkEopPxwO2sS82waKFyf/TRbpbp/G1cfxjNxlr8EPf9HZNHh2redgOS9O0AlsuwimACbkuvBe+6bX64397rf70rW/Qn7zldfrTt71+EdAbEPECM5/N/6xlRQyYcY6caWgYOrUjd4MnBiKRDmC+4OGsoIbRZWB6JvPAUP/vDKLoGBBjwm/wwknh0xgMwwF6hJdoPQHYQm4WMroM+EbafLIOM0/sFDa7Mw46CYLhX4GB8lhN4YjcGWecBMRCMQqHVSQsYLMhSgpbOR3iJATGxR1gRjMhUQyRdItEkCCY5dr5uvs3R/TkT9ySjY4nvfuxd3xs051bQQQYliv6YAwHrkkTxnLZERi/C500Sa3zrhCw3/Gh9yv1GDJj4YYALMKfZkO8+XW64fgt2uN36r+57E36i7e/Dh2hiQvUenqMQzQmQWXUQrx81PGOjpAPYlrCRxj4QK94mWZQwUr0SDXwSKJZ1KxN5F1TbB1AdxCocYQGT7yBrPUNEigE2U3ZnaGjlNGmL5GI0AAsDXiGYqAfABRZ5R9ADJLsyUnwAxhLWrRAkgQJB5taY1Jxhxf2iDhljCjTM1KDiztV2vna+8pTPCOj6LH5h88+R/c+/VDrHHRxEz9uxtI3etAt6aSi+D9gNtnEgUVSPFBtAd3Vt9xILpYH+ggNrwFla9ar3/NWvfzt/6Tju/xSivcJRaNAxppIqnF0BzLb9DjBB0h6aiTZVhpnAEH6giw59hW07sDZKFGPheEK37FIDRqls41fK+LBMHTQStA+VXDjbCaI2HmKtjYNJwPNgrQt5oRKqJItxWFAJnQB6DGEVOSwW8eyBoxMLJNpG3ji2E/IlkN7zDIxX/TWy5TCKc0Sl/a++t7a/4b7aw/Y//r76ZPO4SOcPrpFL5wlh/RQmwHsP10H+geCO6tGtsCSyf91yUOURGY+Bc0seGSi2hkzn4Gwb6ANL/zI+25eCA3seqGguTRGu9REbUTLjcD0Y4Y3GLmoyVJZLEgw8qhHV2h5WN74cRB0om9JqXWcxSb6LaKyoo2BITsAJcl2J5cJjFZAFStOaeX/AAmxPMITeqKVTJ9AjbCBMjHDHHRZxMhwsYhBitPhS2lZcAAAEABJREFUQCfM0j6D2x/JKLExj5luPH5SH9VaACfFBe8XQkjhQf+pGa7v4N4JvYPZYe4g///oLAqLsCC++OM/iSUs2QsPRI2lY449vwFR8T9jwUXd1lhlMZa8SzH3hIyLtUMa3VJYcQNbYuEdyJxZE29qLEdait1ErKxj/IUx7+xroLeolAQ+UDQ5hGecOw4s3PNgwl4jQUgB7b6SeiAJC4PjH7xeFQeJgrNpDNmOiqIzcxc3kURhw1RaUEEkRuGfXBQzacCe5fyZJBnFZigmGT9JdsUXPnY0tDTUclJEFZTB2dha57+Ts6B1pxZPgQ0L+Qb7qCHs+GrmKaSpTReNoHcWlh770E+GCS/z7ZxDbmhyLubaC4088wndN1UKgGpqqsaLSmBHDSYml2i18eeNPJO0La5Y9ij0D8Dh0g0ZX9YNH75OoED8LsOSCzh67Z5xSBpTguSbp+aSjNVObPdIToqzk/2ffVNwNgECaRpCRcpEuasXvGT4ywSWHi2xV/A+Y2a5d4KlxCwGLc3QcBcCbUPY1m/9y5s3PAZ4Unfd7159rU4+5LHaediX68SDH6sTH/9YCcmioTs1OMQSsgVEgwd9ig0HMv1/gNZYeItJ4+F+3oMeKbMQYWe2AVJGHkwydVHqy3z6rkax4HZNwEUbAKz0yhj2AJkmNDFqf2FKeBGSjJVOA2Hq6aHGRS4DjZO33AKjZFuWTsmmYSgJtlhJ/LHeYFx3CCCU3ZI7sMcwMglUbOOMEIxT6EP87p6TA5pwMis9JJmMECv4Uoq1ujWzxLmj8COXzN86uasbsWzBM1DwS3duSdwwwt3/b98qZUMaBpMvkjrOhuhNC+vUFTneTtGNkMH+vvYu/9AiaZ0WKPEXbNNHBnBtGMuw4lvBux07UyQJSIMC4zU3bM9d3SiyWa/kx6xRUVGziDL/5YDIbO4AT2sVdWhHrYA2PkYSY7StU+uzWik3nQTP9MYPYOhiLPzYIh9rWOGKbACp+egIvpLMgpcOdrV3l//cG1V14aMIjMFhhsH2aYclLIcnxTlEX/GzIPQkUBkSrQUpEVY1ZBvJLBAALeQdR4IFLWnC8W//y7/J4H0FAfbyb+GwL34+hWxR8QuN+VaQ6gkRwyKJ7t7OCe0HTt6u/RMntD5+u268+Ad0y2f9Qv4njfk9f187612dnHd0cr2jPR4r6/xDy/a86ZJSQIvfcB99vwcTR0rNREtc2007NJANEpypSCw+1Wt5FsJ2NFBhzPyRl/LXbDCha8VGtMSJSSAbfTrCGmAnboTmYZHRQxoEnPZ2JUsDZtREAw2rYYwcMyiHGY5t8nIbTHw0g4BdgADDB0cnDqfJ8NBgkWGRA7ISvIWPpPHokpdCi6wnuBBs8FmOrYpR+HaD5L4GY26AFc4/cttxMeigrY4coWihCrfW8iflhyKIeGQo3fax360TD/+fOvGIH9btj/gR3f4JP6rjl/6Qbv3EHxNPL83M4eP+9lI9/JWP1iNe9Sl65N99KvBf9Mi//VRd+jefonffzlfFohEGhyAffYX9hR/3KSJxRW7ReK8qEncqzsIo2QTPOEs9Dwyd70SgM8/BkT+GaHigRqiCC11rEh7Qp+9r0ynqFn+WJpyOYTGgrZalQBM/2hlObizJsgHRLHChh2MnWbn/RPARz/BOfQ8QiaXdG27GShpxMqzBn1tX5LTsWtzhglkx4Z67F5lSbYQhWXk8ohMe4lyGEz6frsCK3Av2rBQxMV7xrndDG+BCNAR+aCWRi0RseII1f/6n4SYEwLXO/0/BOtMHyImaK7f8OIENwTL3+NrjV741Gz5HKzu5/6XNmrvxfkcviHt1wx8hGs3YoZuSvuBBbAJqtiFTGdJBC5txJ0Wy4Muykjm5oouGPIwuVAXICz9cIt2Gxi10okA6YQTmWYPFmgYzmEYUdOL65UYZhqYuFEO2NcnqWsKzRH6Fo4wwkKiIhp6WTwOChYIlcqMrDVk3f+BarTygBVh4Vb4RXBxbAwf2rKEi8RIIQZgQdPwzNCtFEM02Lty81sJkspoexDPAjYEPAaXf+qd/znwk7EQ78q8v1mARS2hSDP3XR+rYT34XFMICwM68/Fk6650/pzPf+rM6880/q7Pe+jM68z3P0JlX/JzEkT/t7Oidn/ZGvfNz/k1v/7/fqLd8+j/rzcBbPusNettn/pNsx9FHwQEna3BKgN5nXfIoSGoVBepJ0sp8lqTht9QaNSkyi78pic6oUAEchhL84fRA/AQoHiwtdtEqmW9j+wQnyBhSNu/1V39YA8U+gTZ+ECEUre4EkvGLrmWJBbPMmzhxlAYFTVIUdggK5QTPr4MVK4JOY2gr/zNxnBqxi4rBTRxbtFkZbcuFFzZHiclGAWlOCFTVdyUIbtEDQUZFZAVfABfaYpf/4b++ER0UYJvh8FtfoqNvebGOMB75pe+Fs1zUEgQlfKSPPxh9RVbw73rVz+suV/2iCAQVLbgZoMQ8FDwgoeIG3akZPMCATDq0ta1j20cUYkhKzkKhcdHic85YYcupdweBF72NQeoiHiOpN2ylDoGFDgd9runoUZl1GBTOsIeGMsaluVGND9uyAfQdSJcxSowDGYNkjjuRoG2Fmd1h6IkXJzxIshynw8rzavKQBiHRF2jsKR85lmQuVwalGYVMwM2Zuw8tdGaFLjQEf7EZ8BNfyESzY1k6ynb/6oc/TC9+Ex8NLXU8elQkdLLrDyDSFpXuaNgI4FI2wce+6tH6mFc+DLxgewH8qLHSqUYdEitwincn5GVve3WHC+vTH/hIyjK0LIx6XplncsmcJ+Y2jCY3gxoBR8hBpvxqmMWPnjW0tIM8wpVETSYEkdom1iTjZ8RQadSyhbNWJ3fDUGrpxGxK0CIio0SUVCI7kdFh0OFPg66TbVWmPiHkc+31l31A5q+y84BpNSkQKaTwGOnGyrAD+zITDmZb/WeSSDGgJsDgsJQRiYJjrH505BQiv8c99CG4tx7z8R+n3/vnNyz/40wopURkCHZwxZqC4XP8n8u0Aqbf+3dN/wf43cs0/e47wd+pmXl7a0u3/fy9deMvXqibfuk+uukX762bf+HejPfVTb9woZR88aM7t7jf0C97xz8oC/zSt/+9KquI7HN4HxieOvfkZU6/obTCnZUbyNRXJTEtSeZR4Z4bLEEqdXAWFX9oNd3vZFGAl1NzbA2ZU3GMScNDH3n3B5V1s4eMTjbFALGsbgxcoCXYjNKQZvI3iGGWOqleLEvtKKORSRrWnP8SZbLyRcWYJhFb22ce05Al5AmqIShrGIh/bRqFzGITUPksjBidlIgcCGwgmuFHx+2HnCx91cMubeneeq3nvfmNWg3rj976Zr34rW8iFjptmA5AH+aCoMcNDI5Oqr04Z54458VPvPgJVBgUuRZR0ORuRIUE5vUeHC0tfhes+170+IwGNfvLy/5eeZEsfH3WJXxTOAuMNyKX0gax818xJ5+Os+FH1i5A+vTrhS+h3gCbZEJbpIRqaev008CtwVpko9hW/reEbSu1EwOKDHWKzqZSmKLBpteIXuaf4juTyV2BWftpQck7ebO0pgEjAuSF5QBgahmZEkWwBtJ4NXlQgU1Ai8aEs/C8BbXOCAvBCMXYCaIjFiKul1DW47jj8a733XC9XviWfyOkAayGlP8RpRe85V+V/15faW1Ezo3j6Rsu1vobLtH66wHw/a+7WPvfeLHW3/hAjd1ZPCZ12pOu0FlPep/OeuL7dPaTrtRZT3qvzn7ywhtTPmngjPzolcX7m3//J730bX8fksylhBzpyP2vL3+1btu5TblDLzj7nghLUsnkqimzgLzzhc3iuuCWnP/8KoxANUsHKAVVwDAGJ++YhozjaYItq5hMZCyBpt2TMvxlg1hd2/iTlWYG2xqGkV0nzWolidEIJkDK4o52nOQBFvm6t7xXE8ZalcZqaAqceRrraiVBHDCu1S0skKiDUgqhUhuQFsYsGEpxl00IuyTuHd2VLzq2Vyv91eWX67VXvk/W0sgEfKhvVY7e11zxbr34zf+iy6/NfxpOMVBrXfwoAJ2rJdC29bbPfqPe/pn/LBk/osHPPSA8y86lUw3Zn7/tH/QyYGfvhEbk8CJP3RpC4OB1V/yL3n/DB/Ux5z1Qq2mlMayen8QiAYwH10A/nOQVH00mYZClgplpEW+xiN6U70BY/DFN4iLPoave+V7iSO4/1gQf7K0NRQRy5RIYOZRsNC38opWdkwSRyvxFKc/HghE6MIPnmpBjK4+h0Ukwrswb+sQbQjQANszUqymN6A94bJz4JTpDwc/E4GfjJRCQyaEuzBHAmKXPu+RBeuG/vVk33n4bompQJocHUSQU+yKdHt/yoQ/oRW9+g17w5tfrptuPN687mwHIGCjhK4mNxQ20uoFQkzB393e501+jv3jrPzC+WtPGwoxRjRue9Op8yZWpkBr25PXuj7xHb3z/v+kzHvDJil5mm3eE4n0mm9bUJze7hDf0nZdwalTgxYYWrf/xKHT2j3CSDSJZ49A2tceO9B2Al9rZVsoSvYUW+ViIYbsBSiN61BAh+JJ1dLS0Yi8UskLohgmrLYo5Ek2IsDl5fX5w8LIDV5PGlrV9+mGE2ImBIAOvDPQFCL8S5QbUbeDHYNVQd+h48ZFEn/umf1H1L41C7lMAkyDhzfizQhT+UOAa4uDWX1/+Nv3RW16vl7zlDXrRm16jV73rLfrILdfz6+E+5rOSULF6x3nEXf7h93F3v1Z/9tZ/ZMGBt79af/XON+B28X+qqHhPtBQ4JyfrqIwoIqkMQFHemQ14k151eR4VC39I6MQ6o7rFT3wXjgq10RoWewFMSslts/mqafXiTxrTRO0njSGduPG4iprZ2Ema+LrbGsp6GXleKQrnAdFQo1f7G8KwRM5AXxBcCEeT6Uw3wUmy0Y/klquuJQCSYQ2ymKah7e2t1hJtOdp4xlJgxSEJZKKEQyrFhxuTwo//6IXXMhTn3C3YcumgpbSFT8K2XfSTPeo8goaWu4fFxSCPE3dhZ03M+iZOkde+7zK99O2v15++9bX60ze/hsV+rV512Rt12bUf1Jp4eMBdaVmAwssG8JP8EDYPd4xSYoRvGVGlV2TmLk6exbwDlpWWPnPt+kA4q+PYFWIYOIs+zoTztkqM5iHeOnxUg1qPrrmRD9304WvUMY0JhbENDSigxZUlRHASp4QKgoXXxXGTdEEqNnQaKJYGlh7Idk/IzWMrkPS8y8e7yKbBblxpxUmwdeYRdKQkHy+ixTRu81gYRM6cD2SQrR95QxgUm7o1P3oLX0033thMz3aIYooGiFVLrBTLSC2ss1k2uFxkD5PLzTOYlPnFLqHdHOaOrlunGdjBa3SGC47fDglvsSudGg8EyAo9A+2fea1kDTaHBt5TiM6fekpISv14kMipoImFbm6Q+B48+wc1HtPUtRYatcNNhp/MoQji/ICHT0uCZMoFVmgycJ3C0BF55snDUCYWSgQAABAASURBVIiWK6kkWEZRUNsI3A5W3CHGouAL/nX//gESXYm5KImZl8HtrRX6c/NiNUHFz0CfVIlZcAIM+EmSQ4YoocI4S5BeOtlgjlmJviF3afIrJoFYiJvP7d945EJWKTxC59EATODx0QOzxqivYmHCDyRKy0FiHz+ubDTywkcbbDq3jyJmNaftwKr1wpuRwcjFhho9EoUFE5+2FD0mUO0Hb8SBlKnLzMIv7LwKRqM0bR2izgYGdS9A+vB7r0RfMn+p8cQvmCM4oMS0FDQeMo5hJYYcNj4Y1Y18l4lKSUAIckyRkw4MCod82JRHEoie1P8rIdmVOJ4Yt7ZXOnK308nd6EmyltaL0UEUXjZDEoVDGSos4Q2409W2Sf0OucmhsOiFAV9s5rZ39+AVH9UFcnTJhvRQbUGErenwm5q7RwH+gU6Bb9gZrKZjk8IaOvratPDDS35qzYN+hkK50GaYyadYYKXFgByWaaCHvFnIslnbJ9aFznT66coXP4PTdjCZ7Nn1yX2JzTQ8MVpjbw9tq33gdIBEz5KCx5+IjzsZXq5hUIOhSy8tYzHHamLA4JIGl6WJIAjl/Fm69l0flG3N3PiDE6AYp2nS4JOBEwkYsjwA0Zh8CjCRIGzclvpNOjQhBbPtmFjiHExANIeX0emEZsmncCn6Il5Gwqlx+uicAuiFj22FSLdAdMIJxG2PyQtITr244H3CdBx1/APd+I2nj/LjgVK1npj7wRwqdxaAFFlpYBRcOOPCe0lhNFhj4qRl8VfcZIMaD8Zr3k/tx1B82ta03pdtYGiEb4lLNj15a9PM57VsKgQamdjCR2nMoLOiO9pI6BQgEUbT5Ma9tyMYCLks3XTl1ZpYfAFja6Vpa9Khs4+hay3+S8xIFcdwJkn2UDd4yyJvNCnSHf+tgDdhSobfd71KMheQUd3ghc/Q7HTs9J4CYTLGNtBR0IOt3D2ZbOSBdoWf1slIbuE1bbAAA+vWoeOjZdHN5kS++CkdLErkixvq2oWfFWOji1lSUlrroejOu8T6KTrZKNPpZ2piwQffhzg31rBu/MBHtORu9bN/b1dxOTAam3UKwwOuC92MYh2y9MkcnKsxo5kCD1Zi4EBA1EwyWCi0o7mRb61JUFgNS8Du7ScZJ5mdOU0rFRshX4AcOvuobMuisYBxEZx0mPgMH4AxYDDgquBVh0xxUMIwV7Ip4SoEAM2kCqx1YgwY3oEO5KIfpawYuuExECc90PxS84MDXgLLbi5jaSk0Y+QMWkRaEmUIHT62sSeNFgVfkGqT9KaGWECHArCNXk6Vg/wHvOjw1FQWf5XF53v/ibp6EvlbJ44fl1mUwIA58bW22TW2xdXQPsiZtEijgHCkgYJtiOIeaD4vGlGUlz9LnYwsG8hGQA9Uk+On5JPHJVZ0OLrSNW99D7oc5qzmFpsgp8DEOA5vEZ9AYpqlGINJZkPQkUAciIYQW8mpN3qOe2BW4iaOaCw9/hoRHoXCog9LcERzIEa4BG1ueAKzwbhiRP3CwV8xRioFiQoJgFYGdQNtMzqmvchaIPCNGjo4Wxi6o9kYHZCgedeKng0BYjy0aTYHSL//MZqfl6csPnd+3/1b0qAQH7yMb0SxNXZinG6/nWEIUcsTKicHruUQgfiDsLtqnTAkNq5Wcnpw9WLPinEkFRoH2KFhsKEFl0KJltEeOnnNTRrTkDrpSYMXwkOnH1GSrjhEMbZi8c1k88SZww+w+ENOQlKP5IBeaWkFLz5ijxuo8C1XRm3ojyKaN0Sz1HaMPTFJC4o+yFgotY6W5uQEesCzDMWFSfIA62vDbanTW+k1tDRIQmKEv/g8yHdEC/ZClzwUjozBkOUxtDp2TNPWSoM7f+LozwIfv+64xpCGWfDJSgHChyVhJxpcmS4A2VdwWKf4JrBt/CgN0XJBkAwC/KPMyQCnr0pfnADWJIKjP524XWIsMsjkbr3uZnlM8lQajNm9gcN3O0O21d+Y8fFnzIO8YyEtR5+gRaGsfA4evemWMmOmaC6ADhdaop6noOnmG1016FQLz1BufnpD6YBiI8aRHe4C6UW789jxYUTNbaul9zIOLY264s4tc1h0i43gDUD5TUgoMfe5aUPlVEgMJR8Y0+lnKIs/eJ8KuDfApFuuvx47/ODUHto6cVyxG6GHxCDMldangKrpA14/MhEOuOENcLVxMueOC614AbHyJxbHrRO9OTpYTUCk4+QJNoRkhypd87Yr5DFJ21ZeCM3v7WNa6cjZpysaU7WhbGmMEs6VYlhmKGWTJBW0eDxExEbI4ykAyXwO5qBlF4cpYS0cALnwi2L8pDhCOqCVhiIXHAEGiCn1GN2A0kwHGMkBwNlc8f8fUBYutq1L4EWjsEZvk3sWGepgyqRrRSF2jUDA0daZZ2rFKTqlhtOkaYscKdhV//7e1vCw7KHUHkx299Quo/C7gIWONjwtzTZcVMiJymosRZw7KUsw6LgDu2BMJFQWpeAVRRy16FhDE/LQ/XYPLpxbvA+8g0RzPOXo4jEwtieN7W0dPvs0PEjRyVvyCNY2XuIPdUtO2b3kmAPh1IK3cWskExIBX3oQS7hqABOkSDGomC6mVuQdwrD6wjo4xZSCiGZFjx48V2ItoxkWcOtALiNuEiMlYB8EjUhoNZ7RcBpmWI1g1AYw0ETc18Tij4napm5sArP4tnV1vnRDz8OyA9LEmkyhD6AnjBsDXNlYRJEO6M3YdHyAYCqK3GoSDFGqFCnTzs0eJ1mB8BrHAlvZBqRsji0+BdhDxgC2JOv4h27QYBOYTdAnAUdYToM+CYYkFBM1NbBovBCYt598l19MTDANb7RuOEVmWITfwmRawo0Er4GuF0CbVsvoBMFPyMDCTR/DxQ+maoge7EQT7UC/WohuAqIjxsTKJm2c7GYYvXFj14KiPo5YDg+dZafHGxzuHpsRWa7pDB6V06SRY79vGmuifjdfdYOc2o4h8yeWfjp5mxRbwLby2CU7HbQRxEKFTmIEYDZFblnL4KRAkrLswIwWlwEmk8XFRjm1xWcS1h7BmmmUcvfbQw7T0PkFiuTFxxVP0m033SrtzRpMYIK3dWhLKyY1MR6+y+kiBL5qM84aojFJTbPWjFdfd4se/7QX6luf9mI9/nteqCd89wv0eOBbn/p8ffN3P1/f8tQX6JuBb3rKC/RNjN/I+A2M3/CUF+obwL+O8Wuf+kJ9DeNXP+VF+uonvVBf/eQX6aueFHixvurJL9ZXP+XFjH/U8JVP/iN95ZNfoq984h83fMUT/1Rf/sQ/0VcAX/6kP9HjgC974p/py6Af+51/qsd+x5/qS7/zz/RY4EuAx37Xn+tLkH9Jxu/6Cz3mu16qL/r2P9cXfcdLdf3Nu8op6Uw6QNV7I1BjZq3ib5xxuiYWftoejLz48evqGEPrE6UTtx1HLYaSba12blVkiBmtYapXos1AQTOgbtYlAIUdfXTgC8BNM7CU4kgUPcxBF71haW6VUp5dIwx0OC7gzqRc2FnGw5jUo7IJSpLdSVzzrg+wH4YGm8BMbhzalrMJtlY6fNZpksw1p5fYlUVh1rNY7Ofpf/7MyzTzfUPx3bbGUJlA+K1FG7uSwFGPqUIVtGiFXifQNDEKOMAj25DVuik/DHQqEF50YWUo9GeQAkiyY6GiJkVD3nzQig2CnAJiFIWJ7Td+/yv1hd/+Mu3xTV3xEtyF7YxjKa3OPEMrPupNqc02i88mGBN142vVa/NtHzFsy6yB849RBt4N7UaIVEob0KP5kcFJQr0JwDfXwZ0vrGxrDIs1ndUzi5+q5eVLoobgmxEF5XiOA8IKe6UZZOCIXSJOeYkFa6fDCu8qvh8YFMLsaGcjHJokJmgmejjfFmIvWo01ca1v+/6XQK26PElHyIsfoWQ2wSAybsvJYgGlwcugtlr4TAMqONyNvOILxWWMDOjjDR34//lCvmEWPmbsdWdIHvDbH6OjJBq50m+uzQZD94uf+FcEsnJCCj9Rn848XROLP1j8HP0TpyXHK9Khq9/1PtZgaDDvbAjPa624SWzqwCXjy/gHJgWXGLRsQLKdSoKBmtKcLjQwYIYemWKA8sKOQbRK5m7PnW+cZyGDkwf8mKGTClPiKQnhZQKS02pvnwQIToAkzQx0NZ8MpsHOZnJjWmm1ta1pe0sTnxC2+XRANPGE0bc87UUSd4nxdb97na37nX9XnXXaIUnEJJ6p3IMfeIG6Ub2B3mM//aGa5xKd7sZL5oweJdH9LzxX9zo3/4+fsRWZWve8x5k6/5yzNeeYaSfWuXc/W3cnBxS48MN1n3st/3tCknXheZv/4WX49zjrqNLOP/duKuKfe4+7oCE98N7nEMCq9a5OOzzhRzK5fuV/u1T7+/sQog1KMemLnvhKdIdmD+UHnomTcTq0UqA3ATfJEIt/+fJljyyZeWYNtuZ83WtoabIBIR6MVN6iFbSECBjkuNCitZhxIOQih4KS8piX+WuyvDCYgqtkFhfNxBaioCIU2pIdmJVmLX+TpTjc3uG3AmvhxsfgLfZt70U2Kbvc2fEs/ji0pdXhlVZ3PabjxcbJnS5aSf/2+z+sd135ER09sqVfe/pXwJTuzYL+1c9/p8Zqi3yGbn7lz+tFf/cWPevJX8pk13rPi36SmPw28de/oBtvvE3zDgVLikken297zg/p/Vddq+f++DfqX/7P0yUmcfnzf0TXXHujPvyyn5X3+d5jbBH7B/SRlz1DHkPP+/FvVk6glz7r2/SOF/y4xrTSW57zA/I06R2Mkf3Tbz1dn/LQ+2nN9xvf/EX/VcWpcuMrn6nnvPxf9Lrffho0wZXyFZuvdOsei3bGaZo4DVe5GXgkjr45KBo+PvKu92sIHDPb4tJW/idnQFJf48syvQSr10cHDXZ4kjX4IziYNoBQBV5KC9Vx2LsaWJm7PsdHaHPn9ybAYFGuDsS+6DHygQfjzpq1wl7GnQWntMXXk/3iAzUoZNbg6re+V2O3pDwOeAwMHgODk+Aw7wZP/J4Xo4mx0pbx+N/9si573o/r8T/9hxK5veF3/ocu+qLv03Uv/WlJQ895xet1w18+Ux9zn/MRl2zY8CeQ6247oauvv5XMSlQ9AiWPMU362h/5Pd2fuzz8k/yIcq+7naZtNiRHkh5033P0+d/zvzlquZM5lh71DT+rf/v9H9QnPfgB2l6tZPz/1h+/mr402Axmw8DUi3/6CdpnAyeF3/z+r9Tpn/Zk5NbTf/UlMpOv1JFURPvy7/xzQm1pxdyzCUZ/3rfWJ2dd8+4rZQ/Z1pjMqGXxiSiLi2X1kOKPfuCbAb43EErgSzCLlkVjcGxgFza4VwBPTKS1ZlSUMMobfnaOUES/eQeBmj+KSdUmh1nZCJlgAgxZcZwct06ckFh8WehY4X/48vfr9iuv0+Do0yFrdZhCsAHGtN3xUyyD7fMoOPbpT9Gx//tpOv6qX+y7axpD1/7lszQRcLC0t/Lx85zPfZo+8eLzJRY2uSV8vxtqAAAQAElEQVSHJDbzs3Wt9xQ92zI+e3OvtvUpD7mfbrj1NhW8wd2qraN63duvkKctvebZ360/+qknaGbxf+P7vkZb09BF591d7/rANbrH536vrnn5z+hpv/hC5c7f39+VbK3J9ZzPfppOvPpXme6kJ/z0c3XNK58lVenFP/XtxBngVv9RU5PV1uFtrTj6zc2AkW7+wA26/soPtQ7rLnuZyTYvfW1HzSd4w5NksUZDU3LHe4XB2IPUg22iGNyaqNfibdFEJCGJCaKSKCYpagLLnR2Bg4M0D1zgVEXKyxq4w3O1DfNEXGyK5ioBGnC6zSeDFCt0pRul47fdpus4DaZppf2VtLNVeAskTUauF7/qjXr2/3icfuk7vkBnfuZT9avf86W622d9j878v56q+z/2B/Vln/Zxeur/eqF+9we+Rud87tPlsdL/fuHfkFnpjE9/kp75xMfo67/gv0ieNAO41K+9+FX6kW/8LF3BYt73i/8n+Uq///LX6mq+wr7y6huUDfO7f/aPusfnfK/u+t+erGuuvxF76xef/0o9+vHP0s7JHf3en/+jirzj71df9Heq3RP6pef/LXNe6WzyfM2bLlPaPT/7u/Wyn/8OXfq1PyFrpj5wMcqNIg+tV7PGNIEOXXPZB7TD1+rD1A8oLJJcFr9RajY8ekHjKBgTVaFeuB3IEUcVMACzrwIn+lxNOX13IGzw9pUF76Simi9eVGABKU7VLXRpWgEwHSccycTN1LLR8UWg2CM0OtNkjehJ2to5oZmfKwc8w2Q9lP8u/yO8F6zh7QDuXYRy4YocHv9Tz9V3PPMFesov/pGS63c980U9xuV1N53Qi171Fm1tb+vrf+z3yCEfS60f/I2X4gANcnj6L/+Zfv9lb1DcGn+C/f3P/gv98G++VFfxaBA6ge/+BfzXWt/+s89Viv7UX3oJ2iThLf3gs1+KfenHfudlWu/vKe0pv/jHGRp+6DdfJnNy/djvvFzWGl7pDe/8YI+zrc996q/pQ9ffgj9YuYzfjEmKjW/m/ZF/f7+cQoZPjjYdtdreO0n9DAzZk3rRJUWsFCQI/toWE7MbmqU0yzPg4LOcmgcHuJR6ZN0NgUjcxbgfTGAWQnXLpjD5OhQJc/qSRCm7TZTcjhsUmN6Izmbx+SynMcHA0Hi33T63d/c0uFvMpAU/euSsG97yfq351lCtFX+ilTDDc6MHXY+xiTByGdYpRK1vG7aljMQpxuDqtvClzYhsTBN2DkdK7/TdgTAzL2DGgq0NUBLspNAlYofPeEA7iMNYAHMV8TJ3T0O3vPcjuvqd79PgzwinAUYuE0f+Vu0KtmSJKQAWKhoQNuzNiAUqAwgTEI0hOmMIvpQuKyUaIvoKC4AqaSgz4cuJ6mOiWFq4KhQKUUaUpsKQSaYHTQCE6MBo+xncEIwExhJ6yDZJDzFfRvHMWuvgt2tCtJw5a+9mTgheCKUlVUIgjhfdqRVSb5JgAEUJeQF3XIXW9Tx/Ca3r/uqZStGvfcUzZHblh1/+c0lbRQEf/dD7N++NeZMv6Z9///s02/rUh91fkOjNOsS7yZGjR/oLnMEz+9W8HySrqgQXkchDm4ZR2Ax3MILh017mFSuzMmNrSzPfkgbXkAwvBZp2bqNWhV83TGY0cjJioN/I4JdLOfequbMOMvFi2dzIUN3IqsfQCzghAWuxxSG2XJiBW8lslnMyiAZvcFS59Y0ek6o4RcYV2ZgMxgV7oIgGerM0rBxVmacnaXXyOPTo4AMNI//1n/z8TtrGnqtANijUcpEZCM7JhV6YamlNNRqd87/sR/Xoh99f/+sFf90+P/+7f7ll//Cmy6GZ7rr0mjdfoTf9/tNIrQDLBpAuN4IprvVXv/SdesGPf50G+f3u079cdz/rGH6MAwauO6JCwKbnskwfmYNRo+CwVKaHft6zPlXOIwDaI11p2r1VwQ9gjCESwwMjZglqKDH3xi25oeT+U9jdlfd1cMQXHAgNWQMDi0ZnRWKN4nkSVDQz7SLBKItTYQw0ERpje07fWi2PAxzmDp5Y+BxrCOGWJo2gQMm2VvgZjJlcNoqZxBYvhwPwhO6wOPR4T+C7AKwwkjP+RwgzEH6luzMsjIi5v/QZlz5AH7mR78yZ32c96kF6/5/+pH75RX8rkce1r/g53cjp8JCv+gl97Ff+qD7wZz+lV7z+rdz11p8/8zt18988C7x08fl31yMuuUiHjxzSF33qw3TLbSd10CgTc91QCRoU3xlKMFjtCrHhZeHgIpm1jzElkLkbVnxnss2jcfLQZMuMYwzFLBAXwtDwQ9sQRE5vHrugcd1qA6ZhMEDTLxdya2O28EnMhofusEGszZKZ0RKLTQ7qF7OQoRXXYseIRJOgNSy48JnNnM/AOJ7gFPoVWpJJXNFLHJCJSU9j4KMWXyfyq1ZpWg398jMewy4u4ooRIwZhdwoqjAXCXrA799Wqt9xyXD/GC9pvveQfWxj8/M//Pv3Dm94jstU5vOWf/d+eKpGbNeleX/B9+r5ffWnHPYs3+XzqGDZ6T9e5n/d03v73dMZnPEWP+KZnSHjIFegMT3UgpaUdjAsl27KGRP97z/h0bTF/A9u7t2ma1rKRAyC5FtCi7+SILHnb6UtWWnWNbIurIdzgGRH2kJttcqOtEw9NpgMGoHy7FJWEzB2a0ezgCMlTBiGcnD9bMwss5I5iAGOeDh0zJ8iycWb8SuYkscQoTTGIHTCGtZqkmB/iJDjEx6B8Pfy/n/GFKs34Koz6UjfuGrmxOzpUhK87GJhBlBCQJ6iUmA2LDIaCtSvT58oId/GPNbGahUwLU0vDbyMRWLVRujMXptokKjpoaODzD57xX3Voa6VD+zs6zMveNCbmPzTwY3LssayuPaa8oJHqDA1hQCU7iOEFoNGPBFEP6cgsAzdY5PFSGuFYbT+yI0o0ww8TJ6ShNNvNZFAfRaFmkYhxGNdYQrtXfHkN8WxZqDBJceRmmMIhavwgihcFHyjaCIhpWwPGYMwJcHj3pFZ8efNLP/eFetZPfQ4bhliZGQ5REaYSvcMmB22aw2uFxkJRIISJwZDrQBJcZKNFi34AlujVzUo+Nvz4FDSw9PCCw7cdTGmDzsQSkDvO5Bep0MhJ+Ds//Sn6g2d8mg7x8e7QfIK7PlIAxcyfUJpwAkcDm1RZzFnxY7wE4IuGSWOnxtwsUQQ6dnTQGIWnQOT44mKBhISB2pG+Ms/c8JiqiTAdlUEPLOoY4GhoKHd+jvqM3CdKy90eVXLFkh4nSUSelSQ7MLzoBg9vgsgutK0UYBpDK2DCwyHgyN6ODvHZ/Fk/8Xl65o99pn7+xz9Dz/rRT9czf+jT9Iwf/C/6OeAZ//NT9Ywf+FT9wW8/Ti94wdfr+S/8ej33+V+t5z73K/SHf/gVes4ffjn44/S853yZnvcHX6I/BJ77B49p/HmMz3/OYxV4AfznAy+A94LnfIle8IePgf+YHl/wnC/WC/8QeO5j9GLgj573JXrJC75Ef/SCx+qPX/ClevHzH6tf++FH6Fd/+JH6tR/5BP3aj36Cnv1jj9Bv/MQj9ds//Sj93s98kv7gmf+FLzzXOqzbxTe/2mKlpzGU96bBaJvKWmIVQJm9FuAGG2GoJUipLf1CSRHZ2G3ABmcDIkFm9amOD4u/yIaUIetmLS2nNSpCALuPavfGSxyz6FHIonXoXlBrWTgtLQERzmKx4STAAaijVA/ZJAIbgSHNS1SStOwhU4jslmllbfEV8TY/kBxeTTpSezqC79WhQ9oKHD6k7SPbOnTkMC9mwNFDuvnq6/WRyz+oa/k27ZYrrtHh7aM6evQ0HTt6TMdOO11HTzsNOL3xY8dO12nwjh2FB5wOnHYsesfgn6Zj4KcdRQc4duS0xQ82R6CPHDuNj4VHdcsHb9CN7/mwbuRz/M3AocPkQV6Hewx+pHPb5kuqQ+z2o7yRH10NHdo+rC3mlJOup5t52+ICGGVJpdC9MTTUBOzcUAc1bDm8+ECjVTIGIguIVsRmEGEk9Ll6DB4IbbpRXhZPaTD6aGecSWZmgWeO9+JbLljShBKOB7IkO7DNCEudpMW4gLAFU+RB2Vo68J1kB0bGPmOOoWkMbK1MfrARVika35UfopBHeKwcmWcdOrSlw4ePaJu38m0Kvp1NAW+bz+jbjBMFvu6KD+o6NsT1775K170L/F1XaeeG27Q9rVjQYzpy9KiOstBH+Hy/3RvpiI4cOdp+jxw+Cn5Y22OlkzfdquuvuLrhhiuuYrxKN155lSYPHWLBD20f0mEWtfGjbMpjWzp87BCylY5qX0e9i3zo0PakbWCLOU3T0MDewz1XWVxukBmB3Ai58UKndpZgdS8qJPNrYW7Kma4UDbq+rIF9NDOKFhw1ZYSUWQjHKMSGO6ZIASNEQ4WgUEgSsCV28BSew521NKs3ASwjs6H5SJKF7IWWxHoKUfsbcxQ5ZaDS979fw59tcUmy0oaHkrwZJ4o1TVPfNdvguXsO8X5waM3jgZeoVYrKl0crNsnEOG1va1qttNra0uAUGeAT9hP4iVuP65r3XKWr3nGFPvT29+oq4ENvf58+9I736Sq+jbvqHfDe+V596DJoTpJr3nu1TvDl1LRK/C1trbaBlRJji5+vtw5ta2JcHVlp6/CWtoh5eN7X4fkkR/2utvh1b4v4W6tJKzbeNFg6JrrMTbJNJ9oyVmqxUHfIuDmyvGgwlCwqXqDUUDRTIyE0ncENL9JlKNlwAiMc8AwBdDMc6CI239BZXkkmiDn6s14qVPgSKLxicaF4PBQ6kknOotElhtGDikkGeSzbALGmcKFbAJ47vjQTqWABXNHDCL+JIg30hyc1BJ8mTWNoNZZxGkP57LzFS+PW7o4GJ8Rgk3gDE4s+tlbyaqUxTUDGoalxaBZmTNZYLbws9ITuNK00DfjI4mMFz+h4a2hsI4vdmDRNQ1uciof2eK7vHdf2+natsFnhfzUmrcaWgk9jaBpDYwPGdyZp8WdpsnvCrL/ABFtpwZuHnPJIAy4MM7RO81ui1DOPByOPuKEVhWoBlr2ALFp4DLk4HuJaEdTayrEyszjti86cCoPFxR4doxYopTUPZPS7AwiXgWVS6ODcHNuwuEIzsAEqmwdZgS+zh4+hQ7tkMjL0UitTpEmsgaYJPIBgNQ1NY2iATygf4oeabX5w6k2xw2LwEglbAz2PFeO0wCrj0DQNjeAssDiaTYDWPRgn9MaQgQFMllZstO0dFptF3+Lz+4qfgoetVcPQNKwBxHfwaQzoIdsNA5mlxmEJidJsN49OYLAK4ILfJQkKiHXJCZ06ZbEjxkDRSZd62tYALLXooI98gTs4SkM3eWkGCR3gZpJY1OwssVgQ7WySNMQjoBUguKKTdPO4SCJGM5uI9e27UvhNYh0cnwYGwp4Ehl0E4yg8aMvYLWAzBkbBBR9mMwwKDbAiKfSKhZoGNLIVMI3gAMls73J3shlyl26dvI1fJNkYfAWdf1mzsHvvpgAABOJJREFUyiLyOTz4dk4RNs8WutFbsbhbfC272rlVGbd6xJY7PgubnCcPNqW1Io9BzEDnMyYNcraZiUXewAYnpRDNGzpomRs4ul0jlILa9NQEidpAS4OriARiuvhZ6FriYr9o0nMzDQstLa10B45e1iX2XV7RwlDf8bO2mEi04xwfMo8FZfFhJq/BaAK0DFxA8NpsDpzKbo4UXp4pbCZMIMmEy8o2kPJ+EIyaotuX0gZdNpzRs9NLDD3RgXI4A8Y0Rm8KDzNavRjwozPgWWregDdNA/uAGQ9AbCyhAz0G+AKrxg2NzGr9ydJqwAPGBibGwBBCsRCMg1hitC0uWVKPPW/muBktC4qrGrNTibAWGncLH5bBUnNQ1iNyoEIVtPERXGhBQ5q1VBoLtjwipCPbZyNXw5KjNESrVpLMHZpJzuz2eBw4GUYFfpIRjRzlbIaKBsCIRosdPAvOYuMSbQJgYB4jWeiYCWsTFlVFH1JCJw6KLrxMtFo5WtVi25tRNHj0DtB5mMUfGmMwehnRHwru5k2TNcJjnMZAx72YY2z4Q60Xehpj0Y0MmDYwYj+86IHbbj11c6I1pg3fDs8KTbcMpY9qlpWrmPvyxHRICgvbwEYfVGkZG+7EN7kvRmgQk14HdJMYHDl0Fx09cnedffp9ZcOIPcMo7k5rrb7bNsxsiPgUSYmPND1Iyse4lQ4ayqwyPhR9s/BZPMHgkumcRcyInjICIwJcgErZKBhxKbESM5NxB6yYyI5moNDJZZkhfmwr+o0Pwy3ZVtBB19B0FhQIr2lxZ3vRDY9NMUbkUm8UEsk4RQZMBEEsD2OjbqYPMMj9l9iBUBkjuQN6TtxQqGoB9AyXyYPxIj6R93KCtILpgeii1QQZakiy3UA6Gg4HnuBJ9KKUxGfIdcA9sXOjal7rpluvgI3cDFzDLIIxi598PMtOHKGBYmNkLcIjpshVeRoUhstlXhyJh5IzuelAUspdr8GIj4iyB3DJllhjOoPGK4BghltwYdIjNxRQAWQiRwSSydQ9BAWZtTT08YMYPniYd9IzfhYQ8o+Ggd7AcDDaRh5QNzClFnKTDAuCmiByLSP+F0JScKUljw2QW7DI4oGqUbTMfQ4LZXDm6DjpUeoYojlgtU1qkVo34IJYM/VFg6vQYUBG0nIvKDphCXtLN912hbIW2jiHJTaQob0IUB4BFNpxiQWmEzoEh43UGEntPwtMEtmZ/VGRieIJWWzQgRbNAbpZxYTRwGbmo6XhqX2LO7JENDRKy4kCbSk6TSPJIkZHzAItSVbyjU5DVlFS4yoRSW1DPOErsNAbHfhhhy9a7IQd6B0XClxShCAZ1C1EI0sXEiD5pjP16C55Si3Cd+hkRiGUxlRaJpBFVpp55JYKcSFbQGCxWfhkyUYRbRDELYMw/OCgxYncLsDDcrrgG8BMYaV+ILPS4kxIZs2JpeDh5QueUlp6wAQiYQP5JCD0JQtTgBQz+1rL0ikQLcHyGHG47cZwG9Fs7A4yDjuACAUlB8V5CFmLjwIrydbSipwByLACCk7XGwElSCg1iOYDjHxbv+P7DklQqAIWdMFsL5bM38j6iijIASPzgYeqSIx9URnUIdJ1zFJqorQsKDYxz3xNhNgaWY+Rb/DKCMRNoDSHAgqrGQCNgKFtGy8oyY5H0oC0rP8fAAAA//9Pd5NsAAAABklEQVQDAEN6CM7SoBSEAAAAAElFTkSuQmCC",
    "originalName": "Generated Image September 24, 2025 - 5_47PM.png",
    "size": 30098
  },
  "directories": [],
  "totalFiles": 13,
  "totalDirectories": 0,
  "files": [
    {
      "path": "/DrawArrow.js",
      "content": "class DrawArrow extends Module {\r\n    static namespace = \"Drawing\";\r\n    static description = \"Directional arrow for UI and gameplay\";\r\n    static allowMultiple = false;\r\n    static iconClass = \"fas fa-arrow-right\";\r\n    static iconColor = \"#a200ffff\";\r\n\r\n    constructor() {\r\n        super(\"DrawArrow\");\r\n\r\n        this.fillColor = \"#44ff44\";\r\n        this.outlineColor = \"#228822\";\r\n        this.outlineWidth = 2;\r\n        this.filled = true;\r\n        this.outlined = true;\r\n        this.arrowType = \"standard\";\r\n        \r\n        this.exposeProperty(\"fillColor\", \"color\", this.fillColor, {\r\n            description: \"Arrow fill color\",\r\n            onChange: (val) => { this.fillColor = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"outlineColor\", \"color\", this.outlineColor, {\r\n            description: \"Arrow outline color\",\r\n            onChange: (val) => { this.outlineColor = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"outlineWidth\", \"number\", this.outlineWidth, {\r\n            description: \"Outline thickness\",\r\n            onChange: (val) => { this.outlineWidth = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"filled\", \"boolean\", this.filled, {\r\n            description: \"Fill the arrow\",\r\n            onChange: (val) => { this.filled = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"outlined\", \"boolean\", this.outlined, {\r\n            description: \"Draw outline\",\r\n            onChange: (val) => { this.outlined = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"arrowType\", \"enum\", this.arrowType, {\r\n            description: \"Arrow style\",\r\n            options: [\"standard\", \"thick\", \"pointed\"],\r\n            onChange: (val) => { this.arrowType = val; }\r\n        });\r\n    }\r\n\r\n    style(style) {\r\n        style.startGroup(\"Arrow Style\", false, { \r\n            backgroundColor: 'rgba(68,255,68,0.1)',\r\n            borderRadius: '6px',\r\n            padding: '8px'\r\n        });\r\n        \r\n        style.exposeProperty(\"arrowType\", \"enum\", this.arrowType, {\r\n            description: \"Style of the arrow\",\r\n            options: [\"standard\", \"thick\", \"pointed\"],\r\n            style: { label: \"Arrow Type\" }\r\n        });\r\n        \r\n        style.endGroup();\r\n        \r\n        style.startGroup(\"Arrow Appearance\", false, { \r\n            backgroundColor: 'rgba(68,255,68,0.1)',\r\n            borderRadius: '6px',\r\n            padding: '8px'\r\n        });\r\n        \r\n        style.exposeProperty(\"fillColor\", \"color\", this.fillColor, {\r\n            style: { label: \"Fill Color\" }\r\n        });\r\n        \r\n        style.exposeProperty(\"outlineColor\", \"color\", this.outlineColor, {\r\n            style: { label: \"Outline Color\" }\r\n        });\r\n        \r\n        style.exposeProperty(\"outlineWidth\", \"number\", this.outlineWidth, {\r\n            min: 0,\r\n            max: 20,\r\n            step: 1,\r\n            style: { label: \"Outline Width\", slider: true }\r\n        });\r\n        \r\n        style.exposeProperty(\"filled\", \"boolean\", this.filled, {\r\n            style: { label: \"Filled\" }\r\n        });\r\n        \r\n        style.exposeProperty(\"outlined\", \"boolean\", this.outlined, {\r\n            style: { label: \"Outlined\" }\r\n        });\r\n        \r\n        style.endGroup();\r\n        style.addHelpText(\"Great for directions, UI navigation, and gameplay indicators\");\r\n    }\r\n\r\n    draw(ctx) {\r\n        const pos = this.gameObject.getWorldPosition();\r\n        const scale = this.gameObject.scale;\r\n        \r\n        ctx.save();\r\n        \r\n        ctx.beginPath();\r\n        \r\n        if (this.arrowType === \"standard\") {\r\n            ctx.moveTo(-25, -8);\r\n            ctx.lineTo(15, -8);\r\n            ctx.lineTo(15, -15);\r\n            ctx.lineTo(30, 0);\r\n            ctx.lineTo(15, 15);\r\n            ctx.lineTo(15, 8);\r\n            ctx.lineTo(-25, 8);\r\n        } else if (this.arrowType === \"thick\") {\r\n            ctx.moveTo(-25, -12);\r\n            ctx.lineTo(10, -12);\r\n            ctx.lineTo(10, -18);\r\n            ctx.lineTo(30, 0);\r\n            ctx.lineTo(10, 18);\r\n            ctx.lineTo(10, 12);\r\n            ctx.lineTo(-25, 12);\r\n        } else if (this.arrowType === \"pointed\") {\r\n            ctx.moveTo(-30, -5);\r\n            ctx.lineTo(15, -5);\r\n            ctx.lineTo(15, -15);\r\n            ctx.lineTo(35, 0);\r\n            ctx.lineTo(15, 15);\r\n            ctx.lineTo(15, 5);\r\n            ctx.lineTo(-30, 5);\r\n        }\r\n        \r\n        ctx.closePath();\r\n        \r\n        if (this.filled) {\r\n            ctx.fillStyle = this.fillColor;\r\n            ctx.fill();\r\n        }\r\n        \r\n        if (this.outlined && this.outlineWidth > 0) {\r\n            ctx.strokeStyle = this.outlineColor;\r\n            ctx.lineWidth = this.outlineWidth;\r\n            ctx.stroke();\r\n        }\r\n        \r\n        ctx.restore();\r\n    }\r\n\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            fillColor: this.fillColor,\r\n            outlineColor: this.outlineColor,\r\n            outlineWidth: this.outlineWidth,\r\n            filled: this.filled,\r\n            outlined: this.outlined,\r\n            arrowType: this.arrowType\r\n        };\r\n    }\r\n\r\n    fromJSON(data) {\r\n        super.fromJSON(data);\r\n        if (!data) return;\r\n        \r\n        this.fillColor = data.fillColor || \"#44ff44\";\r\n        this.outlineColor = data.outlineColor || \"#228822\";\r\n        this.outlineWidth = data.outlineWidth || 2;\r\n        this.filled = data.filled !== undefined ? data.filled : true;\r\n        this.outlined = data.outlined !== undefined ? data.outlined : true;\r\n        this.arrowType = data.arrowType || \"standard\";\r\n    }\r\n}\r\n\r\nwindow.DrawArrow = DrawArrow;",
      "type": "file",
      "name": "DrawArrow.js",
      "parentPath": "/",
      "created": 1758692649668,
      "modified": 1758692649668
    },
    {
      "path": "/DrawCapsule.js",
      "content": "class DrawCapsule extends Module {\r\n    static namespace = \"Drawing\";\r\n    static description = \"Draws a filled capsule at the GameObject's position\";\r\n    static iconColor = \"#a200ffff\";\r\n\r\n    constructor() {\r\n        super(\"DrawCapsule\");\r\n\r\n        /** @type {number} Width of the capsule */\r\n        this.width = 30;\r\n        /** @type {number} Height of the capsule */\r\n        this.height = 60;\r\n        /** @type {Vector2} Offset from the GameObject's center */\r\n        this.offset = new Vector2(0, 0);\r\n        /** @type {string} Fill color */\r\n        this.color = \"#ffffff\";\r\n        /** @type {boolean} Whether to fill the capsule */\r\n        this.fill = true;\r\n        /** @type {boolean} Whether to draw an outline */\r\n        this.outline = false;\r\n        /** @type {string} Outline color */\r\n        this.outlineColor = \"#000000\";\r\n        /** @type {number} Outline width */\r\n        this.outlineWidth = 2;\r\n        /** @type {string} Orientation of the capsule */\r\n        this.orientation = \"vertical\"; // \"vertical\" or \"horizontal\"\r\n\r\n        // Expose all properties with onChange handlers\r\n        this.exposeProperty(\"width\", \"number\", this.width, { \r\n            min: 1, \r\n            description: \"Capsule width\",\r\n            onChange: (val) => this.width = val\r\n        });\r\n\r\n        this.exposeProperty(\"height\", \"number\", this.height, { \r\n            min: 1, \r\n            description: \"Capsule height\",\r\n            onChange: (val) => this.height = val\r\n        });\r\n        \r\n        this.exposeProperty(\"offset\", \"vector2\", this.offset, { \r\n            description: \"Offset from center\",\r\n            onChange: (val) => this.offset = val\r\n        });\r\n        \r\n        this.exposeProperty(\"color\", \"color\", this.color, { \r\n            description: \"Fill color\",\r\n            onChange: (val) => this.color = val\r\n        });\r\n        \r\n        this.exposeProperty(\"fill\", \"boolean\", this.fill, { \r\n            description: \"Fill capsule\",\r\n            onChange: (val) => this.fill = val\r\n        });\r\n        \r\n        this.exposeProperty(\"outline\", \"boolean\", this.outline, { \r\n            description: \"Show outline\",\r\n            onChange: (val) => this.outline = val\r\n        });\r\n        \r\n        this.exposeProperty(\"outlineColor\", \"color\", this.outlineColor, { \r\n            description: \"Outline color\",\r\n            onChange: (val) => this.outlineColor = val\r\n        });\r\n        \r\n        this.exposeProperty(\"outlineWidth\", \"number\", this.outlineWidth, { \r\n            description: \"Outline thickness\",\r\n            min: 0,\r\n            max: 20,\r\n            step: 0.5,\r\n            onChange: (val) => this.outlineWidth = val\r\n        });\r\n\r\n        this.exposeProperty(\"orientation\", \"enum\", this.orientation, {\r\n            options: [\"vertical\", \"horizontal\"],\r\n            description: \"Capsule orientation\",\r\n            onChange: (val) => this.orientation = val\r\n        });\r\n    }\r\n\r\n    getBoundingBox() {\r\n        // Calculate bounding box based on dimensions and offset\r\n        const x = this.offset.x - this.width / 2;\r\n        const y = this.offset.y - this.height / 2;\r\n        return {\r\n            x: x,\r\n            y: y,\r\n            width: this.width,\r\n            height: this.height\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Draw the capsule centered at the GameObject,\r\n     * then translated by offset.\r\n     */\r\n    draw(ctx, pixiDisplayObject) {\r\n        if (!this.enabled) return;\r\n\r\n        // Use the actual width and height directly\r\n        const radius = Math.min(this.width, this.height) / 2;\r\n        const isVertical = this.orientation === \"vertical\";\r\n        \r\n        let rectWidth, rectHeight, straightLength;\r\n        \r\n        if (isVertical) {\r\n            // Vertical: height is the main dimension, width determines the radius\r\n            rectWidth = this.width;\r\n            rectHeight = Math.max(0, this.height - this.width); // Subtract both end caps\r\n            straightLength = rectHeight;\r\n        } else {\r\n            // Horizontal: width is the main dimension, height determines the radius  \r\n            rectWidth = Math.max(0, this.width - this.height); // Subtract both end caps\r\n            rectHeight = this.height;\r\n            straightLength = rectWidth;\r\n        }\r\n\r\n        // PIXI path\r\n        if (window.engine && window.engine.usePixi && ctx instanceof window.PixiRenderer) {\r\n            const graphics = pixiDisplayObject || ctx.graphics;\r\n            graphics.clear();\r\n\r\n            // Helper to convert color string to hex\r\n            function toHex(color) {\r\n                if (window.PIXI && window.PIXI.utils && window.PIXI.utils.string2hex) {\r\n                    return window.PIXI.utils.string2hex(color);\r\n                }\r\n                if (typeof color === \"string\" && color.startsWith(\"#\")) {\r\n                    return parseInt(color.slice(1), 16);\r\n                }\r\n                return 0xffffff;\r\n            }\r\n\r\n            // Fill\r\n            if (this.fill) {\r\n                graphics.beginFill(toHex(this.color));\r\n            }\r\n            // Outline\r\n            if (this.outline) {\r\n                graphics.lineStyle(this.outlineWidth, toHex(this.outlineColor));\r\n            }\r\n\r\n            if (isVertical) {\r\n                // Vertical capsule\r\n                if (straightLength > 0) {\r\n                    graphics.drawRect(this.offset.x - rectWidth/2, this.offset.y - straightLength/2, rectWidth, straightLength);\r\n                }\r\n                // Top semicircle\r\n                graphics.drawCircle(this.offset.x, this.offset.y - straightLength/2, radius);\r\n                // Bottom semicircle\r\n                graphics.drawCircle(this.offset.x, this.offset.y + straightLength/2, radius);\r\n            } else {\r\n                // Horizontal capsule\r\n                if (straightLength > 0) {\r\n                    graphics.drawRect(this.offset.x - straightLength/2, this.offset.y - rectHeight/2, straightLength, rectHeight);\r\n                }\r\n                // Left semicircle\r\n                graphics.drawCircle(this.offset.x - straightLength/2, this.offset.y, radius);\r\n                // Right semicircle\r\n                graphics.drawCircle(this.offset.x + straightLength/2, this.offset.y, radius);\r\n            }\r\n\r\n            graphics.endFill();\r\n            ctx.render();\r\n            return;\r\n        }\r\n\r\n        // Canvas 2D rendering\r\n        ctx.save();\r\n        ctx.translate(this.offset.x, this.offset.y);\r\n\r\n        // Begin the capsule path\r\n        ctx.beginPath();\r\n\r\n        if (isVertical) {\r\n            // Vertical capsule\r\n            const halfLength = straightLength / 2;\r\n            \r\n            if (straightLength > 0) {\r\n                // Rectangle portion exists\r\n                ctx.moveTo(-radius, -halfLength);\r\n                ctx.lineTo(radius, -halfLength);\r\n                ctx.arc(0, -halfLength, radius, 0, Math.PI, true);\r\n                ctx.lineTo(-radius, halfLength);\r\n                ctx.arc(0, halfLength, radius, Math.PI, 0, true);\r\n            } else {\r\n                // Just a circle when height <= width\r\n                ctx.arc(0, 0, radius, 0, Math.PI * 2);\r\n            }\r\n        } else {\r\n            // Horizontal capsule\r\n            const halfLength = straightLength / 2;\r\n            \r\n            if (straightLength > 0) {\r\n                // Rectangle portion exists\r\n                ctx.moveTo(-halfLength, -radius);\r\n                ctx.arc(-halfLength, 0, radius, -Math.PI/2, Math.PI/2, true);\r\n                ctx.lineTo(halfLength, radius);\r\n                ctx.arc(halfLength, 0, radius, Math.PI/2, -Math.PI/2, true);\r\n            } else {\r\n                // Just a circle when width <= height\r\n                ctx.arc(0, 0, radius, 0, Math.PI * 2);\r\n            }\r\n        }\r\n\r\n        ctx.closePath();\r\n        \r\n        // Fill if enabled\r\n        if (this.fill) {\r\n            ctx.fillStyle = this.color;\r\n            ctx.fill();\r\n        }\r\n        \r\n        // Draw outline if enabled\r\n        if (this.outline) {\r\n            ctx.strokeStyle = this.outlineColor;\r\n            ctx.lineWidth = this.outlineWidth;\r\n            ctx.stroke();\r\n        }\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    /**\r\n     * Alternative drawing method using separate shapes (useful for debugging)\r\n     */\r\n    drawSeparate(ctx) {\r\n        if (!this.enabled) return;\r\n\r\n        ctx.save();\r\n        ctx.translate(this.offset.x, this.offset.y);\r\n\r\n        // Determine capsule properties\r\n        let capsuleWidth, capsuleHeight, isVertical;\r\n        \r\n        if (this.orientation === \"vertical\") {\r\n            capsuleWidth = Math.min(this.width, this.height);\r\n            capsuleHeight = Math.max(this.width, this.height);\r\n            isVertical = true;\r\n        } else {\r\n            capsuleWidth = Math.max(this.width, this.height);\r\n            capsuleHeight = Math.min(this.width, this.height);\r\n            isVertical = false;\r\n        }\r\n\r\n        const radius = Math.min(capsuleWidth, capsuleHeight) / 2;\r\n        const straightLength = Math.max(capsuleWidth, capsuleHeight) - (radius * 2);\r\n\r\n        if (isVertical) {\r\n            const halfLength = straightLength / 2;\r\n            \r\n            // Draw rectangle body\r\n            ctx.beginPath();\r\n            ctx.rect(-capsuleWidth/2, -halfLength, capsuleWidth, straightLength);\r\n            if (this.fill) {\r\n                ctx.fillStyle = this.color;\r\n                ctx.fill();\r\n            }\r\n            if (this.outline) {\r\n                ctx.strokeStyle = this.outlineColor;\r\n                ctx.lineWidth = this.outlineWidth;\r\n                ctx.stroke();\r\n            }\r\n\r\n            // Draw top semicircle\r\n            ctx.beginPath();\r\n            ctx.arc(0, -halfLength, radius, Math.PI, 0, false);\r\n            if (this.fill) {\r\n                ctx.fillStyle = this.color;\r\n                ctx.fill();\r\n            }\r\n            if (this.outline) {\r\n                ctx.strokeStyle = this.outlineColor;\r\n                ctx.lineWidth = this.outlineWidth;\r\n                ctx.stroke();\r\n            }\r\n\r\n            // Draw bottom semicircle\r\n            ctx.beginPath();\r\n            ctx.arc(0, halfLength, radius, 0, Math.PI, false);\r\n            if (this.fill) {\r\n                ctx.fillStyle = this.color;\r\n                ctx.fill();\r\n            }\r\n            if (this.outline) {\r\n                ctx.strokeStyle = this.outlineColor;\r\n                ctx.lineWidth = this.outlineWidth;\r\n                ctx.stroke();\r\n            }\r\n        } else {\r\n            const halfLength = straightLength / 2;\r\n            \r\n            // Draw rectangle body\r\n            ctx.beginPath();\r\n            ctx.rect(-halfLength, -capsuleHeight/2, straightLength, capsuleHeight);\r\n            if (this.fill) {\r\n                ctx.fillStyle = this.color;\r\n                ctx.fill();\r\n            }\r\n            if (this.outline) {\r\n                ctx.strokeStyle = this.outlineColor;\r\n                ctx.lineWidth = this.outlineWidth;\r\n                ctx.stroke();\r\n            }\r\n\r\n            // Draw left semicircle\r\n            ctx.beginPath();\r\n            ctx.arc(-halfLength, 0, radius, Math.PI/2, -Math.PI/2, false);\r\n            if (this.fill) {\r\n                ctx.fillStyle = this.color;\r\n                ctx.fill();\r\n            }\r\n            if (this.outline) {\r\n                ctx.strokeStyle = this.outlineColor;\r\n                ctx.lineWidth = this.outlineWidth;\r\n                ctx.stroke();\r\n            }\r\n\r\n            // Draw right semicircle\r\n            ctx.beginPath();\r\n            ctx.arc(halfLength, 0, radius, -Math.PI/2, Math.PI/2, false);\r\n            if (this.fill) {\r\n                ctx.fillStyle = this.color;\r\n                ctx.fill();\r\n            }\r\n            if (this.outline) {\r\n                ctx.strokeStyle = this.outlineColor;\r\n                ctx.lineWidth = this.outlineWidth;\r\n                ctx.stroke();\r\n            }\r\n        }\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            width: this.width,\r\n            height: this.height,\r\n            offset: this.offset.toJSON(),\r\n            color: this.color,\r\n            fill: this.fill,\r\n            outline: this.outline,\r\n            outlineColor: this.outlineColor,\r\n            outlineWidth: this.outlineWidth,\r\n            orientation: this.orientation\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Override to handle deserialization\r\n     * @param {Object} data Serialized data\r\n     */\r\n    fromJSON(data) {\r\n        super.fromJSON(data);\r\n        this.width = data.width || this.width;\r\n        this.height = data.height || this.height;\r\n        this.offset = Vector2.fromJSON(data.offset) || this.offset;\r\n        this.color = data.color || this.color;\r\n        this.fill = data.fill !== undefined ? data.fill : this.fill;\r\n        this.outline = data.outline !== undefined ? data.outline : this.outline;\r\n        this.outlineColor = data.outlineColor || this.outlineColor;\r\n        this.outlineWidth = data.outlineWidth || this.outlineWidth;\r\n        this.orientation = data.orientation || this.orientation;\r\n    }\r\n}\r\n\r\nwindow.DrawCapsule = DrawCapsule;",
      "type": "file",
      "name": "DrawCapsule.js",
      "parentPath": "/",
      "created": 1758692649670,
      "modified": 1758692649670
    },
    {
      "path": "/DrawCircle.js",
      "content": "class DrawCircle extends Module {\r\n    static namespace   = \"Drawing\";\r\n    static description = \"Draws a filled circle at the GameObject's position\";\r\n    static iconColor = \"#a200ffff\";\r\n\r\n    constructor() {\r\n        super(\"DrawCircle\");\r\n\r\n        /** @type {number} Radius of the circle */\r\n        this.radius = 25;\r\n        /** @type {Vector2} Offset from the GameObject's center */\r\n        this.offset = new Vector2(0, 0);\r\n        /** @type {string} Fill color */\r\n        this.color = \"#ffffff\";\r\n        /** @type {boolean} Whether to fill the circle */\r\n        this.fill = true;\r\n        /** @type {boolean} Whether to draw an outline */\r\n        this.outline = false;\r\n        /** @type {string} Outline color */\r\n        this.outlineColor = \"#000000\";\r\n        /** @type {number} Outline width */\r\n        this.outlineWidth = 2;\r\n\r\n        // Expose all properties with onChange handlers\r\n        this.exposeProperty(\"radius\", \"number\", this.radius, { \r\n            min: 0, \r\n            description: \"Circle radius\",\r\n            onChange: (val) => this.radius = val\r\n        });\r\n        \r\n        this.exposeProperty(\"offset\", \"vector2\", this.offset, { \r\n            description: \"Offset from center\",\r\n            onChange: (val) => this.offset = val\r\n        });\r\n        \r\n        this.exposeProperty(\"color\", \"color\", this.color, { \r\n            description: \"Fill color\",\r\n            onChange: (val) => this.color = val\r\n        });\r\n        \r\n        this.exposeProperty(\"fill\", \"boolean\", this.fill, { \r\n            description: \"Fill circle\",\r\n            onChange: (val) => this.fill = val\r\n        });\r\n        \r\n        this.exposeProperty(\"outline\", \"boolean\", this.outline, { \r\n            description: \"Show outline\",\r\n            onChange: (val) => this.outline = val\r\n        });\r\n        \r\n        this.exposeProperty(\"outlineColor\", \"color\", this.outlineColor, { \r\n            description: \"Outline color\",\r\n            onChange: (val) => this.outlineColor = val\r\n        });\r\n        \r\n        this.exposeProperty(\"outlineWidth\", \"number\", this.outlineWidth, { \r\n            description: \"Outline thickness\",\r\n            min: 0,\r\n            max: 20,\r\n            step: 0.5,\r\n            onChange: (val) => this.outlineWidth = val\r\n        });\r\n    }\r\n\r\n    getBoundingBox() {\r\n        // Calculate bounding box based on radius and offset\r\n        const x = this.offset.x - this.radius;\r\n        const y = this.offset.y - this.radius;\r\n        return {\r\n            x: x,\r\n            y: y,\r\n            width: this.radius * 2,\r\n            height: this.radius * 2\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Draw the circle centered at the GameObject,\r\n     * then translated by offset.\r\n     */\r\n    draw(ctx, pixiDisplayObject) {\r\n        if (!this.enabled) return;\r\n\r\n        // PIXI path\r\n        if (window.engine && window.engine.usePixi && ctx instanceof window.PixiRenderer) {\r\n            const graphics = pixiDisplayObject || ctx.graphics;\r\n            graphics.clear();\r\n\r\n            // Helper to convert color string to hex\r\n            function toHex(color) {\r\n                if (window.PIXI && window.PIXI.utils && window.PIXI.utils.string2hex) {\r\n                    return window.PIXI.utils.string2hex(color);\r\n                }\r\n                // Fallback: handle #RRGGBB or #RGB\r\n                if (typeof color === \"string\" && color.startsWith(\"#\")) {\r\n                    return parseInt(color.slice(1), 16);\r\n                }\r\n                // Default to white\r\n                return 0xffffff;\r\n            }\r\n\r\n            // Fill\r\n            if (this.fill) {\r\n                graphics.beginFill(toHex(this.color));\r\n            }\r\n            // Outline\r\n            if (this.outline) {\r\n                graphics.lineStyle(this.outlineWidth, toHex(this.outlineColor));\r\n            }\r\n            graphics.drawCircle(this.offset.x, this.offset.y, this.radius);\r\n            graphics.endFill();\r\n            ctx.render();\r\n            return;\r\n        }\r\n\r\n        ctx.save();\r\n        ctx.translate(this.offset.x, this.offset.y);\r\n\r\n        // Draw the circle path\r\n        ctx.beginPath();\r\n        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);\r\n        \r\n        // Fill if enabled\r\n        if (this.fill) {\r\n            ctx.fillStyle = this.color;\r\n            ctx.fill();\r\n        }\r\n        \r\n        // Draw outline if enabled\r\n        if (this.outline) {\r\n            ctx.strokeStyle = this.outlineColor;\r\n            ctx.lineWidth = this.outlineWidth;\r\n            ctx.stroke();\r\n        }\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            radius: this.radius,\r\n            offset: this.offset.toJSON(),\r\n            color: this.color,\r\n            fill: this.fill,\r\n            outline: this.outline,\r\n            outlineColor: this.outlineColor,\r\n            outlineWidth: this.outlineWidth\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Override to handle deserialization\r\n     * @param {Object} data Serialized data\r\n     */\r\n    fromJSON(data) {\r\n        super.fromJSON(data);\r\n        this.radius = data.radius || this.radius;\r\n        this.offset = Vector2.fromJSON(data.offset) || this.offset;\r\n        this.color = data.color || this.color;\r\n        this.fill = data.fill !== undefined ? data.fill : this.fill;\r\n        this.outline = data.outline !== undefined ? data.outline : this.outline;\r\n        this.outlineColor = data.outlineColor || this.outlineColor;\r\n        this.outlineWidth = data.outlineWidth || this.outlineWidth;\r\n    }\r\n}\r\n\r\nwindow.DrawCircle = DrawCircle;",
      "type": "file",
      "name": "DrawCircle.js",
      "parentPath": "/",
      "created": 1758692649670,
      "modified": 1758692649670
    },
    {
      "path": "/DrawDiamond.js",
      "content": "class DrawDiamond extends Module {\r\n    static namespace = \"Drawing\";\r\n    static description = \"Sparkling diamond for gems and valuables\";\r\n    static allowMultiple = false;\r\n    static iconClass = \"fas fa-gem\";\r\n    static iconColor = \"#a200ffff\";\r\n\r\n    constructor() {\r\n        super(\"DrawDiamond\");\r\n\r\n        this.fillColor = \"#88ddff\";\r\n        this.outlineColor = \"#2288cc\";\r\n        this.outlineWidth = 2;\r\n        this.filled = true;\r\n        this.outlined = true;\r\n        this.sparkle = true;\r\n        this.facets = true;\r\n        \r\n        this.exposeProperty(\"fillColor\", \"color\", this.fillColor, {\r\n            description: \"Diamond fill color\",\r\n            onChange: (val) => { this.fillColor = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"outlineColor\", \"color\", this.outlineColor, {\r\n            description: \"Diamond outline color\",\r\n            onChange: (val) => { this.outlineColor = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"outlineWidth\", \"number\", this.outlineWidth, {\r\n            description: \"Outline thickness\",\r\n            onChange: (val) => { this.outlineWidth = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"filled\", \"boolean\", this.filled, {\r\n            description: \"Fill the diamond\",\r\n            onChange: (val) => { this.filled = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"outlined\", \"boolean\", this.outlined, {\r\n            description: \"Draw outline\",\r\n            onChange: (val) => { this.outlined = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"sparkle\", \"boolean\", this.sparkle, {\r\n            description: \"Add sparkle effect\",\r\n            onChange: (val) => { this.sparkle = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"facets\", \"boolean\", this.facets, {\r\n            description: \"Show facet lines\",\r\n            onChange: (val) => { this.facets = val; }\r\n        });\r\n    }\r\n\r\n    style(style) {\r\n        style.startGroup(\"Diamond Appearance\", false, { \r\n            backgroundColor: 'rgba(136,221,255,0.1)',\r\n            borderRadius: '6px',\r\n            padding: '8px'\r\n        });\r\n        \r\n        style.exposeProperty(\"fillColor\", \"color\", this.fillColor, {\r\n            style: { label: \"Fill Color\" }\r\n        });\r\n        \r\n        style.exposeProperty(\"outlineColor\", \"color\", this.outlineColor, {\r\n            style: { label: \"Outline Color\" }\r\n        });\r\n        \r\n        style.exposeProperty(\"outlineWidth\", \"number\", this.outlineWidth, {\r\n            min: 0,\r\n            max: 20,\r\n            step: 1,\r\n            style: { label: \"Outline Width\", slider: true }\r\n        });\r\n        \r\n        style.exposeProperty(\"filled\", \"boolean\", this.filled, {\r\n            style: { label: \"Filled\" }\r\n        });\r\n        \r\n        style.exposeProperty(\"outlined\", \"boolean\", this.outlined, {\r\n            style: { label: \"Outlined\" }\r\n        });\r\n        \r\n        style.exposeProperty(\"sparkle\", \"boolean\", this.sparkle, {\r\n            style: { label: \"Sparkle Effect\" }\r\n        });\r\n        \r\n        style.exposeProperty(\"facets\", \"boolean\", this.facets, {\r\n            style: { label: \"Show Facets\" }\r\n        });\r\n        \r\n        style.endGroup();\r\n        style.addHelpText(\"Ideal for gems, currency, and precious items\");\r\n    }\r\n\r\n    draw(ctx) {\r\n        const pos = this.gameObject.getWorldPosition();\r\n        const scale = this.gameObject.scale;\r\n        \r\n        ctx.save();\r\n        \r\n        // Diamond path\r\n        ctx.beginPath();\r\n        ctx.moveTo(0, -25);     // Top point\r\n        ctx.lineTo(-15, -10);   // Top left\r\n        ctx.lineTo(-20, 10);    // Bottom left\r\n        ctx.lineTo(0, 25);      // Bottom point\r\n        ctx.lineTo(20, 10);     // Bottom right\r\n        ctx.lineTo(15, -10);    // Top right\r\n        ctx.closePath();\r\n        \r\n        if (this.filled) {\r\n            // Create gradient for gem effect\r\n            const gradient = ctx.createLinearGradient(-20, -25, 20, 25);\r\n            gradient.addColorStop(0, this.fillColor);\r\n            gradient.addColorStop(0.5, 'rgba(255,255,255,0.3)');\r\n            gradient.addColorStop(1, this.fillColor);\r\n            ctx.fillStyle = gradient;\r\n            ctx.fill();\r\n        }\r\n        \r\n        if (this.outlined && this.outlineWidth > 0) {\r\n            ctx.strokeStyle = this.outlineColor;\r\n            ctx.lineWidth = this.outlineWidth;\r\n            ctx.stroke();\r\n        }\r\n        \r\n        if (this.facets) {\r\n            ctx.strokeStyle = 'rgba(255,255,255,0.3)';\r\n            ctx.lineWidth = 1;\r\n            ctx.beginPath();\r\n            ctx.moveTo(0, -25);\r\n            ctx.lineTo(0, 25);\r\n            ctx.moveTo(-15, -10);\r\n            ctx.lineTo(15, -10);\r\n            ctx.stroke();\r\n        }\r\n        \r\n        if (this.sparkle) {\r\n            ctx.fillStyle = 'white';\r\n            ctx.fillRect(-2, -15, 4, 2);\r\n            ctx.fillRect(-1, -17, 2, 6);\r\n            ctx.fillRect(8, -5, 3, 1);\r\n            ctx.fillRect(9, -7, 1, 4);\r\n        }\r\n        \r\n        ctx.restore();\r\n    }\r\n\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            fillColor: this.fillColor,\r\n            outlineColor: this.outlineColor,\r\n            outlineWidth: this.outlineWidth,\r\n            filled: this.filled,\r\n            outlined: this.outlined,\r\n            sparkle: this.sparkle,\r\n            facets: this.facets\r\n        };\r\n    }\r\n\r\n    fromJSON(data) {\r\n        super.fromJSON(data);\r\n        if (!data) return;\r\n        \r\n        this.fillColor = data.fillColor || \"#88ddff\";\r\n        this.outlineColor = data.outlineColor || \"#2288cc\";\r\n        this.outlineWidth = data.outlineWidth || 2;\r\n        this.filled = data.filled !== undefined ? data.filled : true;\r\n        this.outlined = data.outlined !== undefined ? data.outlined : true;\r\n        this.sparkle = data.sparkle !== undefined ? data.sparkle : true;\r\n        this.facets = data.facets !== undefined ? data.facets : true;\r\n    }\r\n}\r\n\r\nwindow.DrawDiamond = DrawDiamond;",
      "type": "file",
      "name": "DrawDiamond.js",
      "parentPath": "/",
      "created": 1758692649670,
      "modified": 1758692649670
    },
    {
      "path": "/DrawGrid.js",
      "content": "class DrawGrid extends Module {\r\n    static namespace = \"Drawing\";\r\n    static description = \"Draws an infinite, scalable grid optimized for viewport rendering\";\r\n    static allowMultiple = true;\r\n    static iconClass = \"fas fa-th\";\r\n    static iconColor = \"#a200ffff\";\r\n\r\n    constructor() {\r\n        super(\"DrawGrid\");\r\n\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.cellWidth = 50;\r\n        this.cellHeight = 50;\r\n        this.lineColor = \"#cccccc\";\r\n        this.lineThickness = 1;\r\n        this.showVertical = true;\r\n        this.showHorizontal = true;\r\n        this.glow = false;\r\n        this.glowColor = \"#00ffff\";\r\n        this.glowBlur = 8;\r\n        this.infinite = true;\r\n        this.width = 800;  // Used when infinite is false\r\n        this.height = 600; // Used when infinite is false\r\n\r\n        this.exposeProperty(\"x\", \"number\", this.x, {\r\n            description: \"Grid X offset position\",\r\n            onChange: val => { this.x = val; }\r\n        });\r\n        this.exposeProperty(\"y\", \"number\", this.y, {\r\n            description: \"Grid Y offset position\",\r\n            onChange: val => { this.y = val; }\r\n        });\r\n        this.exposeProperty(\"cellWidth\", \"number\", this.cellWidth, {\r\n            description: \"Cell width\",\r\n            onChange: val => { this.cellWidth = Math.max(1, val); }\r\n        });\r\n        this.exposeProperty(\"cellHeight\", \"number\", this.cellHeight, {\r\n            description: \"Cell height\",\r\n            onChange: val => { this.cellHeight = Math.max(1, val); }\r\n        });\r\n        this.exposeProperty(\"lineColor\", \"color\", this.lineColor, {\r\n            description: \"Grid line color\",\r\n            onChange: val => { this.lineColor = val; }\r\n        });\r\n        this.exposeProperty(\"lineThickness\", \"number\", this.lineThickness, {\r\n            description: \"Line thickness\",\r\n            onChange: val => { this.lineThickness = Math.max(0.1, val); }\r\n        });\r\n        this.exposeProperty(\"showVertical\", \"boolean\", this.showVertical, {\r\n            description: \"Show vertical lines\",\r\n            onChange: val => { this.showVertical = val; }\r\n        });\r\n        this.exposeProperty(\"showHorizontal\", \"boolean\", this.showHorizontal, {\r\n            description: \"Show horizontal lines\",\r\n            onChange: val => { this.showHorizontal = val; }\r\n        });\r\n        this.exposeProperty(\"glow\", \"boolean\", this.glow, {\r\n            description: \"Enable glow effect\",\r\n            onChange: val => { this.glow = val; }\r\n        });\r\n        this.exposeProperty(\"glowColor\", \"color\", this.glowColor, {\r\n            description: \"Glow color\",\r\n            onChange: val => { this.glowColor = val; }\r\n        });\r\n        this.exposeProperty(\"glowBlur\", \"number\", this.glowBlur, {\r\n            description: \"Glow blur amount\",\r\n            onChange: val => { this.glowBlur = val; }\r\n        });\r\n        this.exposeProperty(\"infinite\", \"boolean\", this.infinite, {\r\n            description: \"Enable infinite grid generation\",\r\n            onChange: val => { this.infinite = val; }\r\n        });\r\n        this.exposeProperty(\"width\", \"number\", this.width, {\r\n            description: \"Grid width (when not infinite)\",\r\n            onChange: val => { this.width = val; }\r\n        });\r\n        this.exposeProperty(\"height\", \"number\", this.height, {\r\n            description: \"Grid height (when not infinite)\",\r\n            onChange: val => { this.height = val; }\r\n        });\r\n    }\r\n\r\n    style(style) {\r\n        style.startGroup(\"Grid Position\", false, {\r\n            backgroundColor: 'rgba(200,200,255,0.1)',\r\n            borderRadius: '6px',\r\n            padding: '8px'\r\n        });\r\n        style.exposeProperty(\"x\", \"number\", this.x, { min: -10000, max: 10000 });\r\n        style.exposeProperty(\"y\", \"number\", this.y, { min: -10000, max: 10000 });\r\n        style.exposeProperty(\"infinite\", \"boolean\", this.infinite);\r\n        if (!this.infinite) {\r\n            style.exposeProperty(\"width\", \"number\", this.width, { min: 1, max: 10000 });\r\n            style.exposeProperty(\"height\", \"number\", this.height, { min: 1, max: 10000 });\r\n        }\r\n        style.endGroup();\r\n\r\n        style.startGroup(\"Cells\", false, {\r\n            backgroundColor: 'rgba(150,255,200,0.1)',\r\n            borderRadius: '6px',\r\n            padding: '8px'\r\n        });\r\n        style.exposeProperty(\"cellWidth\", \"number\", this.cellWidth, { min: 1, max: 1000 });\r\n        style.exposeProperty(\"cellHeight\", \"number\", this.cellHeight, { min: 1, max: 1000 });\r\n        style.endGroup();\r\n\r\n        style.startGroup(\"Lines\", false, {\r\n            backgroundColor: 'rgba(200,255,200,0.1)',\r\n            borderRadius: '6px',\r\n            padding: '8px'\r\n        });\r\n        style.exposeProperty(\"lineColor\", \"color\", this.lineColor);\r\n        style.exposeProperty(\"lineThickness\", \"number\", this.lineThickness, { min: 0.1, max: 20 });\r\n        style.exposeProperty(\"showVertical\", \"boolean\", this.showVertical);\r\n        style.exposeProperty(\"showHorizontal\", \"boolean\", this.showHorizontal);\r\n        style.endGroup();\r\n\r\n        style.startGroup(\"Glow\", false, {\r\n            backgroundColor: 'rgba(0,255,255,0.1)',\r\n            borderRadius: '6px',\r\n            padding: '8px'\r\n        });\r\n        style.exposeProperty(\"glow\", \"boolean\", this.glow);\r\n        style.exposeProperty(\"glowColor\", \"color\", this.glowColor);\r\n        style.exposeProperty(\"glowBlur\", \"number\", this.glowBlur, { min: 0, max: 50 });\r\n        style.endGroup();\r\n    }\r\n\r\n    draw(ctx) {\r\n        // Get viewport with fallback\r\n        const vp = window.engine?.viewport || { \r\n            x: 0, \r\n            y: 0, \r\n            width: ctx.canvas.width, \r\n            height: ctx.canvas.height \r\n        };\r\n\r\n        this.gameObject.position.x = 0;\r\n        this.gameObject.position.y = 0;\r\n\r\n        // Early exit if no lines to show\r\n        if (!this.showVertical && !this.showHorizontal) return;\r\n\r\n        ctx.save();\r\n        ctx.strokeStyle = this.lineColor;\r\n        ctx.lineWidth = this.lineThickness;\r\n        \r\n        // Apply glow effect\r\n        if (this.glow) {\r\n            ctx.shadowColor = this.glowColor;\r\n            ctx.shadowBlur = this.glowBlur;\r\n        }\r\n\r\n        // Determine grid bounds\r\n        let minX, maxX, minY, maxY;\r\n        \r\n        if (this.infinite) {\r\n            // For infinite grid, use viewport bounds with some padding\r\n            const padding = Math.max(this.cellWidth, this.cellHeight);\r\n            minX = vp.x - padding;\r\n            maxX = vp.x + vp.width + padding;\r\n            minY = vp.y - padding;\r\n            maxY = vp.y + vp.height + padding;\r\n        } else {\r\n            // For bounded grid, use grid bounds intersected with viewport\r\n            minX = Math.max(this.x, vp.x);\r\n            maxX = Math.min(this.x + this.width, vp.x + vp.width);\r\n            minY = Math.max(this.y, vp.y);\r\n            maxY = Math.min(this.y + this.height, vp.y + vp.height);\r\n            \r\n            // Early exit if grid is completely outside viewport\r\n            if (minX >= maxX || minY >= maxY) {\r\n                ctx.restore();\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Draw vertical lines\r\n        if (this.showVertical && this.cellWidth > 0) {\r\n            // Calculate first vertical line position\r\n            const firstVertical = this.infinite \r\n                ? Math.floor((minX - this.x) / this.cellWidth) * this.cellWidth + this.x\r\n                : this.x;\r\n            \r\n            const verticalEnd = this.infinite ? maxX : Math.min(this.x + this.width, maxX);\r\n            const verticalTop = this.infinite ? minY : Math.max(this.y, minY);\r\n            const verticalBottom = this.infinite ? maxY : Math.min(this.y + this.height, maxY);\r\n            \r\n            for (let gx = firstVertical; gx <= verticalEnd; gx += this.cellWidth) {\r\n                if (gx < minX) continue;\r\n                if (!this.infinite && (gx < this.x || gx > this.x + this.width)) continue;\r\n                \r\n                ctx.beginPath();\r\n                ctx.moveTo(gx, verticalTop);\r\n                ctx.lineTo(gx, verticalBottom);\r\n                ctx.stroke();\r\n            }\r\n        }\r\n\r\n        // Draw horizontal lines  \r\n        if (this.showHorizontal && this.cellHeight > 0) {\r\n            // Calculate first horizontal line position\r\n            const firstHorizontal = this.infinite\r\n                ? Math.floor((minY - this.y) / this.cellHeight) * this.cellHeight + this.y\r\n                : this.y;\r\n                \r\n            const horizontalEnd = this.infinite ? maxY : Math.min(this.y + this.height, maxY);\r\n            const horizontalLeft = this.infinite ? minX : Math.max(this.x, minX);\r\n            const horizontalRight = this.infinite ? maxX : Math.min(this.x + this.width, maxX);\r\n            \r\n            for (let gy = firstHorizontal; gy <= horizontalEnd; gy += this.cellHeight) {\r\n                if (gy < minY) continue;\r\n                if (!this.infinite && (gy < this.y || gy > this.y + this.height)) continue;\r\n                \r\n                ctx.beginPath();\r\n                ctx.moveTo(horizontalLeft, gy);\r\n                ctx.lineTo(horizontalRight, gy);\r\n                ctx.stroke();\r\n            }\r\n        }\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            x: this.x,\r\n            y: this.y,\r\n            width: this.width,\r\n            height: this.height,\r\n            cellWidth: this.cellWidth,\r\n            cellHeight: this.cellHeight,\r\n            lineColor: this.lineColor,\r\n            lineThickness: this.lineThickness,\r\n            showVertical: this.showVertical,\r\n            showHorizontal: this.showHorizontal,\r\n            glow: this.glow,\r\n            glowColor: this.glowColor,\r\n            glowBlur: this.glowBlur,\r\n            infinite: this.infinite\r\n        };\r\n    }\r\n\r\n    fromJSON(data) {\r\n        super.fromJSON(data);\r\n        if (!data) return;\r\n        this.x = data.x || 0;\r\n        this.y = data.y || 0;\r\n        this.width = data.width || 800;\r\n        this.height = data.height || 600;\r\n        this.cellWidth = data.cellWidth || 50;\r\n        this.cellHeight = data.cellHeight || 50;\r\n        this.lineColor = data.lineColor || \"#cccccc\";\r\n        this.lineThickness = data.lineThickness || 1;\r\n        this.showVertical = data.showVertical !== undefined ? data.showVertical : true;\r\n        this.showHorizontal = data.showHorizontal !== undefined ? data.showHorizontal : true;\r\n        this.glow = data.glow || false;\r\n        this.glowColor = data.glowColor || \"#00ffff\";\r\n        this.glowBlur = data.glowBlur || 8;\r\n        this.infinite = data.infinite !== undefined ? data.infinite : true;\r\n    }\r\n}\r\n\r\nwindow.DrawGrid = DrawGrid;",
      "type": "file",
      "name": "DrawGrid.js",
      "parentPath": "/",
      "created": 1758692649670,
      "modified": 1758692649670
    },
    {
      "path": "/DrawHeart.js",
      "content": "class DrawHeart extends Module {\r\n    static namespace = \"Drawing\";\r\n    static description = \"Scalable heart shape for health/love indicators\";\r\n    static allowMultiple = false;\r\n    static iconClass = \"fas fa-heart\";\r\n    static iconColor = \"#a200ffff\";\r\n\r\n    constructor() {\r\n        super(\"DrawHeart\");\r\n\r\n        this.fillColor = \"#ff4444\";\r\n        this.outlineColor = \"#aa0000\";\r\n        this.outlineWidth = 2;\r\n        this.filled = true;\r\n        this.outlined = true;\r\n        \r\n        // Gradient properties\r\n        this.useGradient = false;\r\n        this.gradientColor1 = \"#ff6b6b\";\r\n        this.gradientColor2 = \"#c44569\";\r\n        this.gradientType = \"radial\"; // \"linear\" or \"radial\"\r\n        this.gradientAngle = 0; // for linear gradients\r\n        \r\n        // Independent scaling properties\r\n        this.horizontalScale = 1.0;\r\n        this.verticalScale = 1.0;\r\n        \r\n        this.exposeProperty(\"fillColor\", \"color\", this.fillColor, {\r\n            description: \"Heart fill color (used when gradient is off)\",\r\n            onChange: (val) => { this.fillColor = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"outlineColor\", \"color\", this.outlineColor, {\r\n            description: \"Heart outline color\",\r\n            onChange: (val) => { this.outlineColor = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"outlineWidth\", \"number\", this.outlineWidth, {\r\n            description: \"Outline thickness\",\r\n            onChange: (val) => { this.outlineWidth = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"filled\", \"boolean\", this.filled, {\r\n            description: \"Fill the heart\",\r\n            onChange: (val) => { this.filled = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"outlined\", \"boolean\", this.outlined, {\r\n            description: \"Draw outline\",\r\n            onChange: (val) => { this.outlined = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"useGradient\", \"boolean\", this.useGradient, {\r\n            description: \"Use gradient fill instead of solid color\",\r\n            onChange: (val) => { this.useGradient = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"gradientColor1\", \"color\", this.gradientColor1, {\r\n            description: \"First gradient color\",\r\n            onChange: (val) => { this.gradientColor1 = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"gradientColor2\", \"color\", this.gradientColor2, {\r\n            description: \"Second gradient color\",\r\n            onChange: (val) => { this.gradientColor2 = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"gradientType\", \"string\", this.gradientType, {\r\n            description: \"Gradient type (linear or radial)\",\r\n            onChange: (val) => { this.gradientType = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"gradientAngle\", \"number\", this.gradientAngle, {\r\n            description: \"Gradient angle in degrees (for linear gradients)\",\r\n            onChange: (val) => { this.gradientAngle = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"horizontalScale\", \"number\", this.horizontalScale, {\r\n            description: \"Independent horizontal scaling\",\r\n            onChange: (val) => { this.horizontalScale = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"verticalScale\", \"number\", this.verticalScale, {\r\n            description: \"Independent vertical scaling\",\r\n            onChange: (val) => { this.verticalScale = val; }\r\n        });\r\n    }\r\n\r\n    style(style) {\r\n        style.startGroup(\"Heart Appearance\", false, { \r\n            backgroundColor: 'rgba(255,68,68,0.1)',\r\n            borderRadius: '6px',\r\n            padding: '8px'\r\n        });\r\n        \r\n        style.exposeProperty(\"fillColor\", \"color\", this.fillColor, {\r\n            description: \"Color of the heart fill (when gradient is off)\",\r\n            style: { label: \"Fill Color\" }\r\n        });\r\n        \r\n        style.exposeProperty(\"outlineColor\", \"color\", this.outlineColor, {\r\n            description: \"Color of the heart outline\",\r\n            style: { label: \"Outline Color\" }\r\n        });\r\n        \r\n        style.exposeProperty(\"outlineWidth\", \"number\", this.outlineWidth, {\r\n            description: \"Thickness of the outline\",\r\n            min: 0,\r\n            max: 20,\r\n            step: 1,\r\n            style: { label: \"Outline Width\", slider: true }\r\n        });\r\n        \r\n        style.exposeProperty(\"filled\", \"boolean\", this.filled, {\r\n            description: \"Whether to fill the heart with color\",\r\n            style: { label: \"Filled\" }\r\n        });\r\n        \r\n        style.exposeProperty(\"outlined\", \"boolean\", this.outlined, {\r\n            description: \"Whether to draw an outline\",\r\n            style: { label: \"Outlined\" }\r\n        });\r\n        \r\n        style.endGroup();\r\n        \r\n        style.startGroup(\"Gradient Options\", false, { \r\n            backgroundColor: 'rgba(196,69,105,0.1)',\r\n            borderRadius: '6px',\r\n            padding: '8px'\r\n        });\r\n        \r\n        style.exposeProperty(\"useGradient\", \"boolean\", this.useGradient, {\r\n            description: \"Use gradient fill instead of solid color\",\r\n            style: { label: \"Use Gradient\" }\r\n        });\r\n        \r\n        style.exposeProperty(\"gradientColor1\", \"color\", this.gradientColor1, {\r\n            description: \"First gradient color\",\r\n            style: { label: \"Gradient Color 1\" }\r\n        });\r\n        \r\n        style.exposeProperty(\"gradientColor2\", \"color\", this.gradientColor2, {\r\n            description: \"Second gradient color\",\r\n            style: { label: \"Gradient Color 2\" }\r\n        });\r\n        \r\n        style.exposeProperty(\"gradientType\", \"select\", this.gradientType, {\r\n            description: \"Type of gradient to apply\",\r\n            options: [\"linear\", \"radial\"],\r\n            style: { label: \"Gradient Type\" }\r\n        });\r\n        \r\n        style.exposeProperty(\"gradientAngle\", \"number\", this.gradientAngle, {\r\n            description: \"Angle in degrees for linear gradients\",\r\n            min: 0,\r\n            max: 360,\r\n            step: 15,\r\n            style: { label: \"Gradient Angle\", slider: true }\r\n        });\r\n        \r\n        style.endGroup();\r\n        \r\n        style.startGroup(\"Scaling\", false, { \r\n            backgroundColor: 'rgba(107,107,255,0.1)',\r\n            borderRadius: '6px',\r\n            padding: '8px'\r\n        });\r\n        \r\n        style.exposeProperty(\"horizontalScale\", \"number\", this.horizontalScale, {\r\n            description: \"Independent horizontal scaling factor\",\r\n            min: 0.1,\r\n            max: 3.0,\r\n            step: 0.1,\r\n            style: { label: \"Horizontal Scale\", slider: true }\r\n        });\r\n        \r\n        style.exposeProperty(\"verticalScale\", \"number\", this.verticalScale, {\r\n            description: \"Independent vertical scaling factor\",\r\n            min: 0.1,\r\n            max: 3.0,\r\n            step: 0.1,\r\n            style: { label: \"Vertical Scale\", slider: true }\r\n        });\r\n        \r\n        style.endGroup();\r\n        \r\n        style.addHelpText(\"Perfect for health indicators and UI elements. Use gradient for more visual appeal!\");\r\n    }\r\n\r\n    createGradient(ctx, bounds) {\r\n        let gradient;\r\n        \r\n        if (this.gradientType === \"radial\") {\r\n            const centerX = bounds.centerX;\r\n            const centerY = bounds.centerY;\r\n            const radius = Math.max(bounds.width, bounds.height) / 2;\r\n            gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);\r\n        } else {\r\n            // Linear gradient\r\n            const angleRad = (this.gradientAngle * Math.PI) / 180;\r\n            const cos = Math.cos(angleRad);\r\n            const sin = Math.sin(angleRad);\r\n            \r\n            const x1 = bounds.centerX - (cos * bounds.width) / 2;\r\n            const y1 = bounds.centerY - (sin * bounds.height) / 2;\r\n            const x2 = bounds.centerX + (cos * bounds.width) / 2;\r\n            const y2 = bounds.centerY + (sin * bounds.height) / 2;\r\n            \r\n            gradient = ctx.createLinearGradient(x1, y1, x2, y2);\r\n        }\r\n        \r\n        gradient.addColorStop(0, this.gradientColor1);\r\n        gradient.addColorStop(1, this.gradientColor2);\r\n        \r\n        return gradient;\r\n    }\r\n\r\n    draw(ctx) {\r\n        ctx.save();\r\n        \r\n        // Apply position and combined scaling\r\n        ctx.scale(this.horizontalScale, this.verticalScale);\r\n        \r\n        // Create proper heart shape using mathematical heart curve\r\n        const size = 20; // Base size multiplier\r\n        \r\n        ctx.beginPath();\r\n        \r\n        // Use parametric heart equations for a perfect heart shape\r\n        // Heart equation: x = 16sin³(t), y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)\r\n        const steps = 100;\r\n        let firstPoint = true;\r\n        \r\n        for (let i = 0; i <= steps; i++) {\r\n            const t = (i / steps) * 2 * Math.PI;\r\n            \r\n            // Heart curve equations (scaled and adjusted)\r\n            const x = size * Math.pow(Math.sin(t), 3);\r\n            const y = -size * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t)) / 16;\r\n            \r\n            if (firstPoint) {\r\n                ctx.moveTo(x, y);\r\n                firstPoint = false;\r\n            } else {\r\n                ctx.lineTo(x, y);\r\n            }\r\n        }\r\n        \r\n        ctx.closePath();\r\n        \r\n        if (this.filled) {\r\n            if (this.useGradient) {\r\n                // Calculate bounds for gradient\r\n                const bounds = {\r\n                    centerX: 0,\r\n                    centerY: -size * 0.5,\r\n                    width: size * 2.5,\r\n                    height: size * 2\r\n                };\r\n                \r\n                ctx.fillStyle = this.createGradient(ctx, bounds);\r\n            } else {\r\n                ctx.fillStyle = this.fillColor;\r\n            }\r\n            ctx.fill();\r\n        }\r\n        \r\n        if (this.outlined && this.outlineWidth > 0) {\r\n            ctx.strokeStyle = this.outlineColor;\r\n            ctx.lineWidth = this.outlineWidth;\r\n            ctx.stroke();\r\n        }\r\n        \r\n        ctx.restore();\r\n    }\r\n\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            fillColor: this.fillColor,\r\n            outlineColor: this.outlineColor,\r\n            outlineWidth: this.outlineWidth,\r\n            filled: this.filled,\r\n            outlined: this.outlined,\r\n            useGradient: this.useGradient,\r\n            gradientColor1: this.gradientColor1,\r\n            gradientColor2: this.gradientColor2,\r\n            gradientType: this.gradientType,\r\n            gradientAngle: this.gradientAngle,\r\n            horizontalScale: this.horizontalScale,\r\n            verticalScale: this.verticalScale\r\n        };\r\n    }\r\n\r\n    fromJSON(data) {\r\n        super.fromJSON(data);\r\n        if (!data) return;\r\n        \r\n        this.fillColor = data.fillColor || \"#ff4444\";\r\n        this.outlineColor = data.outlineColor || \"#aa0000\";\r\n        this.outlineWidth = data.outlineWidth || 2;\r\n        this.filled = data.filled !== undefined ? data.filled : true;\r\n        this.outlined = data.outlined !== undefined ? data.outlined : true;\r\n        \r\n        this.useGradient = data.useGradient !== undefined ? data.useGradient : false;\r\n        this.gradientColor1 = data.gradientColor1 || \"#ff6b6b\";\r\n        this.gradientColor2 = data.gradientColor2 || \"#c44569\";\r\n        this.gradientType = data.gradientType || \"radial\";\r\n        this.gradientAngle = data.gradientAngle !== undefined ? data.gradientAngle : 0;\r\n        \r\n        this.horizontalScale = data.horizontalScale !== undefined ? data.horizontalScale : 1.0;\r\n        this.verticalScale = data.verticalScale !== undefined ? data.verticalScale : 1.0;\r\n    }\r\n}\r\n\r\nwindow.DrawHeart = DrawHeart;",
      "type": "file",
      "name": "DrawHeart.js",
      "parentPath": "/",
      "created": 1758692649670,
      "modified": 1758692649670
    },
    {
      "path": "/DrawIcon.js",
      "content": "class DrawIcon extends Module {\r\n    static namespace = \"Drawing\";\r\n    static description = \"Draws a Font Awesome icon at the GameObject's position\";\r\n    static allowMultiple = false;\r\n    static iconClass = \"fas fa-icons\";\r\n    static iconColor = \"#a200ffff\";\r\n\r\n    constructor() {\r\n        super(\"IconDrawModule\");\r\n\r\n        this.icon = \"fas fa-star\";\r\n        this.size = 48;\r\n        this.color = \"#FFD700\";\r\n        this.opacity = 1.0;\r\n\r\n        this.exposeProperty(\"icon\", \"string\", this.icon, {\r\n            description: \"Font Awesome icon class (e.g. 'fas fa-star')\",\r\n            onChange: val => { this.icon = val; }\r\n        });\r\n        this.exposeProperty(\"size\", \"number\", this.size, {\r\n            description: \"Icon size in pixels\",\r\n            min: 8, max: 256, step: 1,\r\n            onChange: val => { this.size = val; }\r\n        });\r\n        this.exposeProperty(\"color\", \"color\", this.color, {\r\n            description: \"Icon color\",\r\n            onChange: val => { this.color = val; }\r\n        });\r\n        this.exposeProperty(\"opacity\", \"number\", this.opacity, {\r\n            description: \"Icon opacity\",\r\n            min: 0, max: 1, step: 0.01,\r\n            onChange: val => { this.opacity = val; }\r\n        });\r\n\r\n        // Create a hidden DOM element for rendering the icon to canvas\r\n        this._iconElem = document.createElement(\"i\");\r\n        this._iconElem.style.position = \"absolute\";\r\n        this._iconElem.style.visibility = \"hidden\";\r\n        document.body.appendChild(this._iconElem);\r\n    }\r\n\r\n    style(style) {\r\n        style.startGroup(\"Icon Settings\", false, {\r\n            backgroundColor: 'rgba(255,215,0,0.08)',\r\n            borderRadius: '6px',\r\n            padding: '8px'\r\n        });\r\n        style.exposeProperty(\"icon\", \"string\", this.icon, {\r\n            label: \"Icon Class\",\r\n            description: \"Font Awesome icon class\"\r\n        });\r\n        style.exposeProperty(\"size\", \"number\", this.size, {\r\n            label: \"Size (px)\", min: 8, max: 256, step: 1\r\n        });\r\n        style.exposeProperty(\"color\", \"color\", this.color, {\r\n            label: \"Color\"\r\n        });\r\n        style.exposeProperty(\"opacity\", \"number\", this.opacity, {\r\n            label: \"Opacity\", min: 0, max: 1, step: 0.01\r\n        });\r\n        style.endGroup();\r\n        style.addDivider();\r\n        style.addHelpText(\r\n            \"Use any Font Awesome icon class, e.g. 'fas fa-star'. \" +\r\n            \"See <a href='https://fontawesome.com/icons' target='_blank'>Font Awesome Icons</a>.\"\r\n        );\r\n    }\r\n\r\n    draw(ctx) {\r\n        // Prepare icon element\r\n        this._iconElem.className = this.icon;\r\n        this._iconElem.style.fontSize = this.size + \"px\";\r\n        this._iconElem.style.color = this.color;\r\n        this._iconElem.style.opacity = this.opacity;\r\n\r\n        // Render icon to SVG, then to canvas\r\n        // Get bounding box\r\n        const svgNS = \"http://www.w3.org/2000/svg\";\r\n        const svg = document.createElementNS(svgNS, \"svg\");\r\n        svg.setAttribute(\"width\", this.size);\r\n        svg.setAttribute(\"height\", this.size);\r\n\r\n        // Use foreignObject to render HTML icon\r\n        const fo = document.createElementNS(svgNS, \"foreignObject\");\r\n        fo.setAttribute(\"width\", \"100%\");\r\n        fo.setAttribute(\"height\", \"100%\");\r\n        fo.appendChild(this._iconElem.cloneNode(true));\r\n        svg.appendChild(fo);\r\n\r\n        // Serialize SVG and draw to canvas\r\n        const img = new window.Image();\r\n        const svgData = new XMLSerializer().serializeToString(svg);\r\n        img.src = \"data:image/svg+xml;base64,\" + btoa(svgData);\r\n\r\n        // Draw image when loaded\r\n        const pos = this.gameObject.position;\r\n        img.onload = () => {\r\n            ctx.save();\r\n            ctx.globalAlpha = this.opacity;\r\n            ctx.drawImage(img, -this.size / 2, -this.size / 2, this.size, this.size);\r\n            ctx.restore();\r\n        };\r\n    }\r\n\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            icon: this.icon,\r\n            size: this.size,\r\n            color: this.color,\r\n            opacity: this.opacity\r\n        };\r\n    }\r\n\r\n    fromJSON(data) {\r\n        super.fromJSON(data);\r\n        if (!data) return;\r\n        this.icon = data.icon || \"fas fa-star\";\r\n        this.size = data.size || 48;\r\n        this.color = data.color || \"#FFD700\";\r\n        this.opacity = data.opacity ?? 1.0;\r\n    }\r\n}\r\n\r\nwindow.DrawIcon = DrawIcon;",
      "type": "file",
      "name": "DrawIcon.js",
      "parentPath": "/",
      "created": 1758692649670,
      "modified": 1758692649670
    },
    {
      "path": "/DrawLine.js",
      "content": "class DrawLine extends Module {\r\n    static namespace = \"Drawing\";\r\n    static description = \"Draws a customizable line with color, thickness, and glow\";\r\n    static allowMultiple = true;\r\n    static iconClass = \"fas fa-minus\";\r\n    static iconColor = \"#a200ffff\";\r\n\r\n    constructor() {\r\n        super(\"DrawLine\");\r\n\r\n        this.x1 = 0;\r\n        this.y1 = 0;\r\n        this.x2 = 100;\r\n        this.y2 = 0;\r\n        this.color = \"#ffffff\";\r\n        this.thickness = 2;\r\n\r\n        // Glow properties\r\n        this.glow = false;\r\n        this.glowColor = \"#00ffff\";\r\n        this.glowBlur = 10;\r\n\r\n        this.exposeProperty(\"x1\", \"number\", this.x1, {\r\n            description: \"Start X position\",\r\n            onChange: val => { this.x1 = val; }\r\n        });\r\n        this.exposeProperty(\"y1\", \"number\", this.y1, {\r\n            description: \"Start Y position\",\r\n            onChange: val => { this.y1 = val; }\r\n        });\r\n        this.exposeProperty(\"x2\", \"number\", this.x2, {\r\n            description: \"End X position\",\r\n            onChange: val => { this.x2 = val; }\r\n        });\r\n        this.exposeProperty(\"y2\", \"number\", this.y2, {\r\n            description: \"End Y position\",\r\n            onChange: val => { this.y2 = val; }\r\n        });\r\n        this.exposeProperty(\"color\", \"color\", this.color, {\r\n            description: \"Line color\",\r\n            onChange: val => { this.color = val; }\r\n        });\r\n        this.exposeProperty(\"thickness\", \"number\", this.thickness, {\r\n            description: \"Line thickness\",\r\n            onChange: val => { this.thickness = val; }\r\n        });\r\n        this.exposeProperty(\"glow\", \"boolean\", this.glow, {\r\n            description: \"Enable glow effect\",\r\n            onChange: val => { this.glow = val; }\r\n        });\r\n        this.exposeProperty(\"glowColor\", \"color\", this.glowColor, {\r\n            description: \"Glow color\",\r\n            onChange: val => { this.glowColor = val; }\r\n        });\r\n        this.exposeProperty(\"glowBlur\", \"number\", this.glowBlur, {\r\n            description: \"Glow blur amount\",\r\n            onChange: val => { this.glowBlur = val; }\r\n        });\r\n    }\r\n\r\n    style(style) {\r\n        style.startGroup(\"Line\", false, {\r\n            backgroundColor: 'rgba(100,255,255,0.1)',\r\n            borderRadius: '6px',\r\n            padding: '8px'\r\n        });\r\n        style.exposeProperty(\"x1\", \"number\", this.x1, { min: -1000, max: 1000 });\r\n        style.exposeProperty(\"y1\", \"number\", this.y1, { min: -1000, max: 1000 });\r\n        style.exposeProperty(\"x2\", \"number\", this.x2, { min: -1000, max: 1000 });\r\n        style.exposeProperty(\"y2\", \"number\", this.y2, { min: -1000, max: 1000 });\r\n        style.exposeProperty(\"color\", \"color\", this.color);\r\n        style.exposeProperty(\"thickness\", \"number\", this.thickness, { min: 1, max: 50 });\r\n        style.endGroup();\r\n\r\n        style.startGroup(\"Glow\", false, {\r\n            backgroundColor: 'rgba(0,255,255,0.1)',\r\n            borderRadius: '6px',\r\n            padding: '8px'\r\n        });\r\n        style.exposeProperty(\"glow\", \"boolean\", this.glow);\r\n        style.exposeProperty(\"glowColor\", \"color\", this.glowColor);\r\n        style.exposeProperty(\"glowBlur\", \"number\", this.glowBlur, { min: 0, max: 50 });\r\n        style.endGroup();\r\n    }\r\n\r\n    draw(ctx) {\r\n        ctx.save();\r\n\r\n        ctx.strokeStyle = this.color;\r\n        ctx.lineWidth = this.thickness;\r\n\r\n        if (this.glow) {\r\n            ctx.shadowColor = this.glowColor;\r\n            ctx.shadowBlur = this.glowBlur;\r\n        }\r\n\r\n        ctx.beginPath();\r\n        ctx.moveTo(this.x1, this.y1);\r\n        ctx.lineTo(this.x2, this.y2);\r\n        ctx.stroke();\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            x1: this.x1,\r\n            y1: this.y1,\r\n            x2: this.x2,\r\n            y2: this.y2,\r\n            color: this.color,\r\n            thickness: this.thickness,\r\n            glow: this.glow,\r\n            glowColor: this.glowColor,\r\n            glowBlur: this.glowBlur\r\n        };\r\n    }\r\n\r\n    fromJSON(data) {\r\n        super.fromJSON(data);\r\n        if (!data) return;\r\n        this.x1 = data.x1 || 0;\r\n        this.y1 = data.y1 || 0;\r\n        this.x2 = data.x2 || 100;\r\n        this.y2 = data.y2 || 0;\r\n        this.color = data.color || \"#ffffff\";\r\n        this.thickness = data.thickness || 2;\r\n        this.glow = data.glow || false;\r\n        this.glowColor = data.glowColor || \"#00ffff\";\r\n        this.glowBlur = data.glowBlur || 10;\r\n    }\r\n}\r\n\r\nwindow.DrawLine = DrawLine;",
      "type": "file",
      "name": "DrawLine.js",
      "parentPath": "/",
      "created": 1758692649670,
      "modified": 1758692649670
    },
    {
      "path": "/DrawPolygon.js",
      "content": "class DrawPolygon extends Module {\r\n    static namespace   = \"Drawing\";\r\n    static description = \"Draws a filled polygon at the GameObject's position\";\r\n    static iconColor = \"#a200ffff\";\r\n\r\n    constructor() {\r\n        super(\"DrawPolygon\");\r\n        // Default triangle\r\n        this.vertices = [\r\n            new Vector2(0, -50),\r\n            new Vector2(50, 50),\r\n            new Vector2(-50, 50)\r\n        ];\r\n        this.offset   = new Vector2(0,0);\r\n        this.color    = \"#ffffff\";\r\n        this.fill     = true;\r\n        this.outline  = false;\r\n        this.outlineColor = \"#000000\";\r\n        this.outlineWidth = 2;\r\n\r\n        this.exposeProperty(\"vertices\", \"polygon\", this.vertices, {\r\n            description: \"Array of Vector2 points (min 3)\",\r\n            minItems: 3,\r\n            onChange: (val) => {\r\n                this.vertices = val;\r\n                // Only call _onVerticesChanged if gameObject exists\r\n                if (this.gameObject) {\r\n                    this._onVerticesChanged();\r\n                }\r\n            }\r\n        });\r\n        \r\n        // Remaining property exposures...\r\n        this.exposeProperty(\"offset\", \"vector2\", this.offset, { \r\n            description: \"Offset from center\",\r\n            onChange: (val) => this.offset = val\r\n        });\r\n        \r\n        this.exposeProperty(\"color\", \"color\", this.color, { \r\n            description: \"Fill color\",\r\n            onChange: (val) => this.color = val\r\n        });\r\n        \r\n        this.exposeProperty(\"fill\", \"boolean\", this.fill, { \r\n            description: \"Fill polygon\",\r\n            onChange: (val) => this.fill = val\r\n        });\r\n        \r\n        this.exposeProperty(\"outline\", \"boolean\", this.outline, { \r\n            description: \"Show outline\",\r\n            onChange: (val) => this.outline = val\r\n        });\r\n        \r\n        this.exposeProperty(\"outlineColor\", \"color\", this.outlineColor, { \r\n            description: \"Stroke color\",\r\n            onChange: (val) => this.outlineColor = val\r\n        });\r\n        \r\n        this.exposeProperty(\"outlineWidth\", \"number\", this.outlineWidth, { \r\n            description: \"Outline thickness\", \r\n            min: 0,\r\n            max: 20,\r\n            step: 0.5,\r\n            onChange: (val) => this.outlineWidth = val\r\n        });\r\n    }\r\n\r\n    getBoundingBox() {\r\n        if (!this.vertices || this.vertices.length < 3) return null;\r\n        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;\r\n        for (const v of this.vertices) {\r\n            minX = Math.min(minX, v.x);\r\n            minY = Math.min(minY, v.y);\r\n            maxX = Math.max(maxX, v.x);\r\n            maxY = Math.max(maxY, v.y);\r\n        }\r\n        return {\r\n            x: minX,\r\n            y: minY,\r\n            width: maxX - minX,\r\n            height: maxY - minY\r\n        };\r\n    }\r\n\r\n    _onVerticesChanged() {\r\n        // Safety check: only continue if gameObject exists\r\n        if (!this.gameObject) return;\r\n        \r\n        // if there's a Rigidbody on this object, sync its polygon verts\r\n        try {\r\n            const rb = this.gameObject.getModule(\"RigidBody\") || \r\n                     (typeof RigidBody !== 'undefined' ? this.gameObject.getModule(RigidBody) : null);\r\n            \r\n            if (rb) {\r\n                rb.vertices = this.vertices.slice();\r\n                rb.rebuildBody();\r\n            }\r\n        } catch (e) {\r\n            console.warn(\"Error syncing polygon vertices with RigidBody:\", e);\r\n        }\r\n    }\r\n\r\n    draw(ctx) {\r\n        if (!this.enabled || this.vertices.length < 3) return;\r\n        ctx.save();\r\n        ctx.translate(this.offset.x, this.offset.y);\r\n        \r\n        // Draw fill\r\n        if(this.fill) {\r\n            ctx.fillStyle = this.color;\r\n            ctx.beginPath();\r\n            ctx.moveTo(this.vertices[0].x, this.vertices[0].y);\r\n            for (let i = 1; i < this.vertices.length; i++) {\r\n                ctx.lineTo(this.vertices[i].x, this.vertices[i].y);\r\n            }\r\n            ctx.closePath();\r\n            ctx.fill();\r\n        }\r\n        \r\n        // Draw outline if enabled\r\n        if (this.outline) {\r\n            ctx.strokeStyle = this.outlineColor;\r\n            ctx.lineWidth = this.outlineWidth;\r\n            ctx.beginPath();\r\n            ctx.moveTo(this.vertices[0].x, this.vertices[0].y);\r\n            for (let i = 1; i < this.vertices.length; i++) {\r\n                ctx.lineTo(this.vertices[i].x, this.vertices[i].y);\r\n            }\r\n            ctx.closePath();\r\n            ctx.stroke();\r\n        }\r\n        \r\n        ctx.restore();\r\n    }\r\n\r\n    /**\r\n     * Called when the module is attached to a game object\r\n     * This is a good place to sync vertices with RigidBody\r\n     */\r\n    onAttach() {\r\n        // Now it's safe to sync with RigidBody if needed\r\n        if (this.vertices && this.vertices.length >= 3) {\r\n            this._onVerticesChanged();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Ensure Vector2 objects are properly serialized\r\n     */\r\n    toJSON() {\r\n        const json = super.toJSON();\r\n        \r\n        // Serialize vertices array - ensure each Vector2 is represented as an object\r\n        if (this.vertices && Array.isArray(this.vertices)) {\r\n            json.vertices = this.vertices.map(v => ({\r\n                x: v.x || 0,\r\n                y: v.y || 0\r\n            }));\r\n        }\r\n        \r\n        // Serialize offset Vector2\r\n        if (this.offset) {\r\n            json.offset = {\r\n                x: this.offset.x || 0,\r\n                y: this.offset.y || 0\r\n            };\r\n        }\r\n        \r\n        return json;\r\n    }\r\n\r\n    /**\r\n     * Ensure Vector2 objects are properly reconstructed from serialized data\r\n     * @param {Object} json - Serialized data\r\n     */\r\n    fromJSON(json) {\r\n        super.fromJSON(json);\r\n        \r\n        // Reconstruct vertices array - check for valid data first\r\n        if (json.vertices && Array.isArray(json.vertices)) {\r\n            try {\r\n                this.vertices = json.vertices.map(v => new Vector2(v.x || 0, v.y || 0));\r\n            } catch (e) {\r\n                console.warn(\"Error reconstructing polygon vertices:\", e);\r\n                // Fallback to default triangle\r\n                this.vertices = [\r\n                    new Vector2(0, -50),\r\n                    new Vector2(50, 50),\r\n                    new Vector2(-50, 50)\r\n                ];\r\n            }\r\n        }\r\n        \r\n        // Reconstruct offset Vector2 - check for valid data first\r\n        if (json.offset && typeof json.offset === 'object') {\r\n            try {\r\n                this.offset = new Vector2(json.offset.x || 0, json.offset.y || 0);\r\n            } catch (e) {\r\n                console.warn(\"Error reconstructing polygon offset:\", e);\r\n                this.offset = new Vector2(0, 0);\r\n            }\r\n        }\r\n        \r\n        // Don't call _onVerticesChanged here, as the gameObject may not be set yet\r\n        // It will be called in onAttach\r\n        \r\n        return this;\r\n    }\r\n    \r\n    /**\r\n     * Set a vertex at a specific index\r\n     * @param {number} index - Index of the vertex to modify\r\n     * @param {Vector2|Object} value - New vertex value\r\n     */\r\n    setVertex(index, value) {\r\n        if (!this.vertices || index < 0 || index >= this.vertices.length) {\r\n            console.warn(`Vertex index out of bounds: ${index}`);\r\n            return;\r\n        }\r\n        \r\n        // Ensure we're working with a Vector2\r\n        const vertex = value instanceof Vector2 ? value : new Vector2(value.x || 0, value.y || 0);\r\n        \r\n        // Update the vertex\r\n        this.vertices[index] = vertex;\r\n        \r\n        // Trigger any necessary updates - only if we have a gameObject\r\n        if (this.gameObject) {\r\n            this._onVerticesChanged();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add a new vertex to the polygon\r\n     * @param {Vector2|Object} vertex - New vertex to add\r\n     * @param {number} [index] - Optional position to insert (defaults to end)\r\n     */\r\n    addVertex(vertex, index = undefined) {\r\n        if (!this.vertices) {\r\n            this.vertices = [];\r\n        }\r\n        \r\n        // Ensure we're working with a Vector2\r\n        const newVertex = vertex instanceof Vector2 ? vertex : new Vector2(vertex.x || 0, vertex.y || 0);\r\n        \r\n        if (index !== undefined) {\r\n            // Insert at specific position\r\n            this.vertices.splice(index, 0, newVertex);\r\n        } else {\r\n            // Add to end\r\n            this.vertices.push(newVertex);\r\n        }\r\n        \r\n        // Trigger any necessary updates - only if we have a gameObject\r\n        if (this.gameObject) {\r\n            this._onVerticesChanged();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove a vertex at the specified index\r\n     * @param {number} index - Index of vertex to remove\r\n     */\r\n    removeVertex(index) {\r\n        if (!this.vertices || index < 0 || index >= this.vertices.length) {\r\n            console.warn(`Vertex index out of bounds: ${index}`);\r\n            return;\r\n        }\r\n        \r\n        // Don't allow removing if we'll have fewer than 3 vertices\r\n        if (this.vertices.length <= 3) {\r\n            console.warn(\"Cannot remove vertex: polygon must have at least 3 vertices\");\r\n            return;\r\n        }\r\n        \r\n        // Remove the vertex\r\n        this.vertices.splice(index, 1);\r\n        \r\n        // Trigger any necessary updates - only if we have a gameObject\r\n        if (this.gameObject) {\r\n            this._onVerticesChanged();\r\n        }\r\n    }\r\n\r\n    toJSON() {\r\n        const json = super.toJSON();\r\n        json.vertices = this.vertices.map(v => v.toJSON());\r\n        json.offset = this.offset.toJSON();\r\n        json.color = this.color;\r\n        json.fill = this.fill;\r\n        json.outline = this.outline;\r\n        json.outlineColor = this.outlineColor;\r\n        json.outlineWidth = this.outlineWidth;\r\n        return json;\r\n    }\r\n\r\n    fromJSON(json) {\r\n        super.fromJSON(json);\r\n        this.vertices = json.vertices.map(v => Vector2.fromJSON(v));\r\n        this.offset = Vector2.fromJSON(json.offset) || new Vector2(0, 0);\r\n        this.color = json.color || \"#ffffff\";\r\n        this.fill = json.fill !== undefined ? json.fill : true;\r\n        this.outline = json.outline !== undefined ? json.outline : false;\r\n        this.outlineColor = json.outlineColor || \"#000000\";\r\n        this.outlineWidth = json.outlineWidth || 2;\r\n        \r\n        // Call _onVerticesChanged to sync with RigidBody if needed\r\n        if (this.gameObject) {\r\n            this._onVerticesChanged();\r\n        }\r\n        \r\n        return this;\r\n    }\r\n}\r\n\r\n// Register the module globally\r\nwindow.DrawPolygon = DrawPolygon;",
      "type": "file",
      "name": "DrawPolygon.js",
      "parentPath": "/",
      "created": 1758692649671,
      "modified": 1758692649671
    },
    {
      "path": "/DrawRectangle.js",
      "content": "class DrawRectangle extends Module {\r\n    static namespace   = \"Drawing\";\r\n    static description = \"Draws a filled rectangle at the GameObject's position\";\r\n    static iconColor = \"#a200ffff\";\r\n\r\n    constructor() {\r\n        super(\"DrawRectangle\");\r\n\r\n        /** @type {number} Full width of the rectangle */\r\n        this.width = 50;\r\n        /** @type {number} Full height of the rectangle */\r\n        this.height = 50;\r\n        /** @type {Vector2} Offset from the GameObject's center */\r\n        this.offset = new Vector2(0, 0);\r\n        /** @type {string} Fill color */\r\n        this.color = \"#ffffff\";\r\n        /** @type {boolean} Whether to fill the rectangle */\r\n        this.fill = true;\r\n        /** @type {boolean} Whether to draw an outline */\r\n        this.outline = false;\r\n        /** @type {string} Outline color */\r\n        this.outlineColor = \"#000000\";\r\n        /** @type {number} Outline width */\r\n        this.outlineWidth = 2;\r\n\r\n        this.exposeProperty(\"width\", \"number\", this.width, { \r\n            min: 0, \r\n            description: \"Rectangle width\",\r\n            onChange: (val) => this.width = val\r\n        });\r\n        \r\n        this.exposeProperty(\"height\", \"number\", this.height, { \r\n            min: 0, \r\n            description: \"Rectangle height\",\r\n            onChange: (val) => this.height = val\r\n        });\r\n        \r\n        this.exposeProperty(\"offset\", \"vector2\", this.offset, { \r\n            description: \"Offset from center\",\r\n            onChange: (val) => this.offset = val\r\n        });\r\n        \r\n        this.exposeProperty(\"color\", \"color\", this.color, { \r\n            description: \"Fill color\",\r\n            onChange: (val) => this.color = val\r\n        });\r\n        \r\n        this.exposeProperty(\"fill\", \"boolean\", this.fill, { \r\n            description: \"Fill rectangle\",\r\n            onChange: (val) => this.fill = val\r\n        });\r\n        \r\n        this.exposeProperty(\"outline\", \"boolean\", this.outline, { \r\n            description: \"Show outline\",\r\n            onChange: (val) => this.outline = val\r\n        });\r\n        \r\n        this.exposeProperty(\"outlineColor\", \"color\", this.outlineColor, { \r\n            description: \"Outline color\",\r\n            onChange: (val) => this.outlineColor = val\r\n        });\r\n        \r\n        this.exposeProperty(\"outlineWidth\", \"number\", this.outlineWidth, { \r\n            description: \"Outline thickness\",\r\n            min: 0,\r\n            max: 20,\r\n            step: 0.5,\r\n            onChange: (val) => this.outlineWidth = val\r\n        });\r\n    }\r\n\r\n    getBoundingBox() {\r\n        if (!this.gameObject) return null;\r\n        // Calculate bounding box based on width, height and offset\r\n        const x = this.gameObject.position.x + this.offset.x - this.width / 2;\r\n        const y = this.gameObject.position.y + this.offset.y - this.height / 2;\r\n        return {\r\n            x: x,\r\n            y: y,\r\n            width: this.width,\r\n            height: this.height\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Draw the rectangle centered at the GameObject,\r\n     * then translated by offset.\r\n     */\r\n    draw(ctx) {\r\n        if (!this.enabled) return;\r\n\r\n        ctx.save();\r\n        // apply offset relative to object center\r\n        ctx.translate(this.offset.x, this.offset.y);\r\n\r\n        // Draw the rectangle path\r\n        ctx.beginPath();\r\n        ctx.rect(-this.width/2, -this.height/2, this.width, this.height);\r\n        \r\n        // Fill if enabled\r\n        if (this.fill) {\r\n            ctx.fillStyle = this.color;\r\n            ctx.fill();\r\n        }\r\n        \r\n        // Draw outline if enabled\r\n        if (this.outline) {\r\n            ctx.strokeStyle = this.outlineColor;\r\n            ctx.lineWidth = this.outlineWidth;\r\n            ctx.stroke();\r\n        }\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            width: this.width,\r\n            height: this.height,\r\n            offset:  { x: this.offset.x, y: this.offset.y },\r\n            color: this.color,\r\n            fill: this.fill,\r\n            outline: this.outline,\r\n            outlineColor: this.outlineColor,\r\n            outlineWidth: this.outlineWidth\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Override to handle serialization\r\n     * @returns {Object} Serialized data\r\n     */\r\n    fromJSON(data) {\r\n        super.fromJSON(data);\r\n        if (data.width !== undefined) this.width = data.width;\r\n        if (data.height !== undefined) this.height = data.height;\r\n        if (data.offset) this.offset = data.offset;\r\n        if (data.color !== undefined) this.color = data.color;\r\n        if (data.fill !== undefined) this.fill = data.fill;\r\n        if (data.outline !== undefined) this.outline = data.outline;\r\n        if (data.outlineColor !== undefined) this.outlineColor = data.outlineColor;\r\n        if (data.outlineWidth !== undefined) this.outlineWidth = data.outlineWidth;\r\n    }\r\n}\r\n\r\n// make it available to the engine\r\nwindow.DrawRectangle = DrawRectangle;",
      "type": "file",
      "name": "DrawRectangle.js",
      "parentPath": "/",
      "created": 1758692649672,
      "modified": 1758692649672
    },
    {
      "path": "/DrawShield.js",
      "content": "class DrawShield extends Module {\r\n    static namespace = \"Drawing\";\r\n    static description = \"Classic shield shape for defense/protection icons\";\r\n    static allowMultiple = false;\r\n    static iconClass = \"fas fa-shield-alt\";\r\n    static iconColor = \"#a200ffff\";\r\n\r\n    constructor() {\r\n        super(\"DrawShield\");\r\n\r\n        this.fillColor = \"#4488ff\";\r\n        this.outlineColor = \"#2266cc\";\r\n        this.outlineWidth = 3;\r\n        this.filled = true;\r\n        this.outlined = true;\r\n        this.gloss = true;\r\n        this.topPoints = 3; // Number of curved points at the top\r\n        \r\n        this.exposeProperty(\"fillColor\", \"color\", this.fillColor, {\r\n            description: \"Shield fill color\",\r\n            onChange: (val) => { this.fillColor = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"outlineColor\", \"color\", this.outlineColor, {\r\n            description: \"Shield outline color\",\r\n            onChange: (val) => { this.outlineColor = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"outlineWidth\", \"number\", this.outlineWidth, {\r\n            description: \"Outline thickness\",\r\n            onChange: (val) => { this.outlineWidth = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"filled\", \"boolean\", this.filled, {\r\n            description: \"Fill the shield\",\r\n            onChange: (val) => { this.filled = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"outlined\", \"boolean\", this.outlined, {\r\n            description: \"Draw outline\",\r\n            onChange: (val) => { this.outlined = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"gloss\", \"boolean\", this.gloss, {\r\n            description: \"Add glossy effect\",\r\n            onChange: (val) => { this.gloss = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"topPoints\", \"number\", this.topPoints, {\r\n            description: \"Number of curved points at the top\",\r\n            onChange: (val) => { this.topPoints = Math.max(1, Math.min(7, Math.round(val))); }\r\n        });\r\n    }\r\n\r\n    style(style) {\r\n        style.startGroup(\"Shield Appearance\", false, { \r\n            backgroundColor: 'rgba(68,136,255,0.1)',\r\n            borderRadius: '6px',\r\n            padding: '8px'\r\n        });\r\n        \r\n        style.exposeProperty(\"fillColor\", \"color\", this.fillColor, {\r\n            style: { label: \"Fill Color\" }\r\n        });\r\n        \r\n        style.exposeProperty(\"outlineColor\", \"color\", this.outlineColor, {\r\n            style: { label: \"Outline Color\" }\r\n        });\r\n        \r\n        style.exposeProperty(\"outlineWidth\", \"number\", this.outlineWidth, {\r\n            min: 0,\r\n            max: 20,\r\n            step: 1,\r\n            style: { label: \"Outline Width\", slider: true }\r\n        });\r\n        \r\n        style.exposeProperty(\"filled\", \"boolean\", this.filled, {\r\n            style: { label: \"Filled\" }\r\n        });\r\n        \r\n        style.exposeProperty(\"outlined\", \"boolean\", this.outlined, {\r\n            style: { label: \"Outlined\" }\r\n        });\r\n        \r\n        style.exposeProperty(\"gloss\", \"boolean\", this.gloss, {\r\n            style: { label: \"Glossy Effect\" }\r\n        });\r\n        \r\n        style.exposeProperty(\"topPoints\", \"number\", this.topPoints, {\r\n            min: 1,\r\n            max: 7,\r\n            step: 1,\r\n            style: { label: \"Top Points\", slider: true }\r\n        });\r\n        \r\n        style.endGroup();\r\n        style.addHelpText(\"Perfect for armor, defense, and protection indicators. Adjust top points for different shield styles.\");\r\n    }\r\n\r\n    draw(ctx) {\r\n        ctx.save();\r\n        \r\n        // Calculate shield dimensions\r\n        const width = 50;\r\n        const height = 70;\r\n        const topY = -35;\r\n        const bottomY = 35;\r\n        \r\n        // Shield path with curved points at top\r\n        ctx.beginPath();\r\n        \r\n        // Create the top edge with curved points\r\n        const pointWidth = width / this.topPoints;\r\n        const pointHeight = 8; // Height of each curved point\r\n        \r\n        // Start from the left edge\r\n        ctx.moveTo(-width/2, topY);\r\n        \r\n        // Draw curved points across the top\r\n        for (let i = 0; i < this.topPoints; i++) {\r\n            const startX = -width/2 + (i * pointWidth);\r\n            const endX = -width/2 + ((i + 1) * pointWidth);\r\n            const midX = (startX + endX) / 2;\r\n            \r\n            // Create a curved point using quadratic curve\r\n            ctx.quadraticCurveTo(midX, topY + pointHeight, endX, topY);\r\n        }\r\n        \r\n        // Right side of shield\r\n        ctx.bezierCurveTo(width/2, topY, width/2, -10, width/2, 10);\r\n        ctx.bezierCurveTo(width/2, 25, width/2 - 10, bottomY - 5, 0, bottomY);\r\n        \r\n        // Left side of shield (mirrored)\r\n        ctx.bezierCurveTo(-width/2 + 10, bottomY - 5, -width/2, 25, -width/2, 10);\r\n        ctx.bezierCurveTo(-width/2, -10, -width/2, topY, -width/2, topY);\r\n        \r\n        ctx.closePath();\r\n        \r\n        if (this.filled) {\r\n            ctx.fillStyle = this.fillColor;\r\n            ctx.fill();\r\n            \r\n            if (this.gloss) {\r\n                // Add glossy highlight\r\n                const gradient = ctx.createLinearGradient(-20, -30, 20, 10);\r\n                gradient.addColorStop(0, 'rgba(255,255,255,0.4)');\r\n                gradient.addColorStop(0.5, 'rgba(255,255,255,0.1)');\r\n                gradient.addColorStop(1, 'rgba(255,255,255,0)');\r\n                ctx.fillStyle = gradient;\r\n                ctx.fill();\r\n            }\r\n        }\r\n        \r\n        if (this.outlined && this.outlineWidth > 0) {\r\n            ctx.strokeStyle = this.outlineColor;\r\n            ctx.lineWidth = this.outlineWidth;\r\n            ctx.stroke();\r\n        }\r\n        \r\n        ctx.restore();\r\n    }\r\n\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            fillColor: this.fillColor,\r\n            outlineColor: this.outlineColor,\r\n            outlineWidth: this.outlineWidth,\r\n            filled: this.filled,\r\n            outlined: this.outlined,\r\n            gloss: this.gloss,\r\n            topPoints: this.topPoints\r\n        };\r\n    }\r\n\r\n    fromJSON(data) {\r\n        super.fromJSON(data);\r\n        if (!data) return;\r\n        \r\n        this.fillColor = data.fillColor || \"#4488ff\";\r\n        this.outlineColor = data.outlineColor || \"#2266cc\";\r\n        this.outlineWidth = data.outlineWidth || 3;\r\n        this.filled = data.filled !== undefined ? data.filled : true;\r\n        this.outlined = data.outlined !== undefined ? data.outlined : true;\r\n        this.gloss = data.gloss !== undefined ? data.gloss : true;\r\n        this.topPoints = data.topPoints || 3;\r\n    }\r\n}\r\n\r\nwindow.DrawShield = DrawShield;",
      "type": "file",
      "name": "DrawShield.js",
      "parentPath": "/",
      "created": 1758692649672,
      "modified": 1758692649672
    },
    {
      "path": "/DrawStar.js",
      "content": "class DrawStar extends Module {\r\n    static namespace = \"Drawing\";\r\n    static description = \"Scalable star shape for ratings and pickups\";\r\n    static allowMultiple = false;\r\n    static iconClass = \"fas fa-star\";\r\n    static iconColor = \"#a200ffff\";\r\n\r\n    constructor() {\r\n        super(\"DrawStar\");\r\n\r\n        this.fillColor = \"#ffdd00\";\r\n        this.outlineColor = \"#cc8800\";\r\n        this.outlineWidth = 2;\r\n        this.filled = true;\r\n        this.outlined = true;\r\n        this.points = 5;\r\n        this.innerRadius = 0.4;\r\n        \r\n        this.exposeProperty(\"fillColor\", \"color\", this.fillColor, {\r\n            description: \"Star fill color\",\r\n            onChange: (val) => { this.fillColor = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"outlineColor\", \"color\", this.outlineColor, {\r\n            description: \"Star outline color\",\r\n            onChange: (val) => { this.outlineColor = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"outlineWidth\", \"number\", this.outlineWidth, {\r\n            description: \"Outline thickness\",\r\n            onChange: (val) => { this.outlineWidth = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"filled\", \"boolean\", this.filled, {\r\n            description: \"Fill the star\",\r\n            onChange: (val) => { this.filled = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"outlined\", \"boolean\", this.outlined, {\r\n            description: \"Draw outline\",\r\n            onChange: (val) => { this.outlined = val; }\r\n        });\r\n        \r\n        this.exposeProperty(\"points\", \"number\", this.points, {\r\n            description: \"Number of points\",\r\n            onChange: (val) => { this.points = Math.max(3, Math.floor(val)); }\r\n        });\r\n        \r\n        this.exposeProperty(\"innerRadius\", \"number\", this.innerRadius, {\r\n            description: \"Inner radius ratio\",\r\n            onChange: (val) => { this.innerRadius = Math.max(0.1, Math.min(0.9, val)); }\r\n        });\r\n    }\r\n\r\n    style(style) {\r\n        style.startGroup(\"Star Shape\", false, { \r\n            backgroundColor: 'rgba(255,221,0,0.1)',\r\n            borderRadius: '6px',\r\n            padding: '8px'\r\n        });\r\n        \r\n        style.exposeProperty(\"points\", \"number\", this.points, {\r\n            description: \"Number of star points\",\r\n            min: 3,\r\n            max: 12,\r\n            step: 1,\r\n            style: { label: \"Points\", slider: true }\r\n        });\r\n        \r\n        style.exposeProperty(\"innerRadius\", \"number\", this.innerRadius, {\r\n            description: \"Inner radius as ratio of outer radius\",\r\n            min: 0.1,\r\n            max: 0.9,\r\n            step: 0.05,\r\n            style: { label: \"Inner Radius\", slider: true }\r\n        });\r\n        \r\n        style.endGroup();\r\n        \r\n        style.startGroup(\"Star Appearance\", false, { \r\n            backgroundColor: 'rgba(255,221,0,0.1)',\r\n            borderRadius: '6px',\r\n            padding: '8px'\r\n        });\r\n        \r\n        style.exposeProperty(\"fillColor\", \"color\", this.fillColor, {\r\n            style: { label: \"Fill Color\" }\r\n        });\r\n        \r\n        style.exposeProperty(\"outlineColor\", \"color\", this.outlineColor, {\r\n            style: { label: \"Outline Color\" }\r\n        });\r\n        \r\n        style.exposeProperty(\"outlineWidth\", \"number\", this.outlineWidth, {\r\n            min: 0,\r\n            max: 20,\r\n            step: 1,\r\n            style: { label: \"Outline Width\", slider: true }\r\n        });\r\n        \r\n        style.exposeProperty(\"filled\", \"boolean\", this.filled, {\r\n            style: { label: \"Filled\" }\r\n        });\r\n        \r\n        style.exposeProperty(\"outlined\", \"boolean\", this.outlined, {\r\n            style: { label: \"Outlined\" }\r\n        });\r\n        \r\n        style.endGroup();\r\n        style.addHelpText(\"Great for collectibles, ratings, and decorative elements\");\r\n    }\r\n\r\n    draw(ctx) {\r\n        const pos = this.gameObject.getWorldPosition();\r\n        const scale = this.gameObject.scale;\r\n        \r\n        ctx.save();\r\n        \r\n        const outerRadius = 30;\r\n        const innerRadius = outerRadius * this.innerRadius;\r\n        const angleStep = (Math.PI * 2) / this.points;\r\n        \r\n        ctx.beginPath();\r\n        for (let i = 0; i < this.points * 2; i++) {\r\n            const angle = i * (angleStep / 2) - Math.PI / 2;\r\n            const radius = i % 2 === 0 ? outerRadius : innerRadius;\r\n            const x = Math.cos(angle) * radius;\r\n            const y = Math.sin(angle) * radius;\r\n            \r\n            if (i === 0) {\r\n                ctx.moveTo(x, y);\r\n            } else {\r\n                ctx.lineTo(x, y);\r\n            }\r\n        }\r\n        ctx.closePath();\r\n        \r\n        if (this.filled) {\r\n            ctx.fillStyle = this.fillColor;\r\n            ctx.fill();\r\n        }\r\n        \r\n        if (this.outlined && this.outlineWidth > 0) {\r\n            ctx.strokeStyle = this.outlineColor;\r\n            ctx.lineWidth = this.outlineWidth;\r\n            ctx.stroke();\r\n        }\r\n        \r\n        ctx.restore();\r\n    }\r\n\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            fillColor: this.fillColor,\r\n            outlineColor: this.outlineColor,\r\n            outlineWidth: this.outlineWidth,\r\n            filled: this.filled,\r\n            outlined: this.outlined,\r\n            points: this.points,\r\n            innerRadius: this.innerRadius\r\n        };\r\n    }\r\n\r\n    fromJSON(data) {\r\n        super.fromJSON(data);\r\n        if (!data) return;\r\n        \r\n        this.fillColor = data.fillColor || \"#ffdd00\";\r\n        this.outlineColor = data.outlineColor || \"#cc8800\";\r\n        this.outlineWidth = data.outlineWidth || 2;\r\n        this.filled = data.filled !== undefined ? data.filled : true;\r\n        this.outlined = data.outlined !== undefined ? data.outlined : true;\r\n        this.points = data.points || 5;\r\n        this.innerRadius = data.innerRadius || 0.4;\r\n    }\r\n}\r\n\r\nwindow.DrawStar = DrawStar;",
      "type": "file",
      "name": "DrawStar.js",
      "parentPath": "/",
      "created": 1758692649672,
      "modified": 1758692649672
    },
    {
      "path": "/DrawText.js",
      "content": "class DrawText extends Module {\r\n    static namespace = \"Drawing\";\r\n    static description = \"Draws customizable text with shadows, outlines, gradients and effects\";\r\n    static allowMultiple = true;\r\n    static iconClass = \"fas fa-font\";\r\n    static iconColor = \"#a200ffff\";\r\n\r\n    constructor() {\r\n        super(\"DrawText\");\r\n\r\n        // Text content and basic properties\r\n        this.text = \"Hello World\";\r\n        this.fontSize = 32;\r\n        this.fontFamily = \"Arial\";\r\n        this.fontWeight = \"normal\";\r\n        this.fontStyle = \"normal\";\r\n        \r\n        // Colors and fill\r\n        this.fillColor = \"#ffffff\";\r\n        this.useGradient = false;\r\n        this.gradientStartColor = \"#ff0000\";\r\n        this.gradientEndColor = \"#0000ff\";\r\n        this.gradientAngle = 0;\r\n        \r\n        // Outline\r\n        this.hasOutline = false;\r\n        this.outlineColor = \"#000000\";\r\n        this.outlineWidth = 2;\r\n        \r\n        // Shadow\r\n        this.hasShadow = false;\r\n        this.shadowColor = \"#000000\";\r\n        this.shadowOffsetX = 2;\r\n        this.shadowOffsetY = 2;\r\n        this.shadowBlur = 4;\r\n        \r\n        // Text alignment and positioning\r\n        this.textAlign = \"center\";\r\n        this.textBaseline = \"middle\";\r\n        this.lineHeight = 1.2;\r\n        this.letterSpacing = 0;\r\n        this.wordSpacing = 0;\r\n        \r\n        // Effects\r\n        this.opacity = 1.0;\r\n        this.rotation = 0;\r\n        this.skewX = 0;\r\n        this.skewY = 0;\r\n        this.scaleX = 1.0;\r\n        this.scaleY = 1.0;\r\n        \r\n        // Animation effects\r\n        this.wave = false;\r\n        this.waveAmplitude = 5;\r\n        this.waveFrequency = 2;\r\n        this.waveSpeed = 2;\r\n        this.rainbow = false;\r\n        this.rainbowSpeed = 1;\r\n        \r\n        // Text wrapping\r\n        this.maxWidth = 0; // 0 = no wrapping\r\n        this.wordWrap = true;\r\n        \r\n        // Background\r\n        this.hasBackground = false;\r\n        this.backgroundColor = \"#000000\";\r\n        this.backgroundPadding = 10;\r\n        this.backgroundRadius = 0;\r\n        \r\n        this.time = 0; // For animations\r\n\r\n        this.exposeAllProperties();\r\n    }\r\n\r\n    exposeAllProperties() {\r\n        // Text Content\r\n        this.exposeProperty(\"text\", \"string\", this.text, {\r\n            description: \"Text content to display\",\r\n            onChange: (val) => { this.text = val; }\r\n        });\r\n\r\n        // Font Properties\r\n        this.exposeProperty(\"fontSize\", \"number\", this.fontSize, {\r\n            description: \"Font size in pixels\",\r\n            onChange: (val) => { this.fontSize = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"fontFamily\", \"select\", this.fontFamily, {\r\n            description: \"Font family\",\r\n            options: [\"Arial\", \"Helvetica\", \"Times New Roman\", \"Courier New\", \"Georgia\", \"Verdana\", \"Comic Sans MS\", \"Impact\", \"Trebuchet MS\"],\r\n            onChange: (val) => { this.fontFamily = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"fontWeight\", \"enum\", this.fontWeight, {\r\n            description: \"Font weight\",\r\n            options: [\"normal\", \"bold\", \"lighter\", \"bolder\", \"100\", \"200\", \"300\", \"400\", \"500\", \"600\", \"700\", \"800\", \"900\"],\r\n            onChange: (val) => { this.fontWeight = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"fontStyle\", \"enum\", this.fontStyle, {\r\n            description: \"Font style\",\r\n            options: [\"normal\", \"italic\", \"oblique\"],\r\n            onChange: (val) => { this.fontStyle = val; }\r\n        });\r\n\r\n        // Colors\r\n        this.exposeProperty(\"fillColor\", \"color\", this.fillColor, {\r\n            description: \"Text fill color\",\r\n            onChange: (val) => { this.fillColor = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"useGradient\", \"boolean\", this.useGradient, {\r\n            description: \"Use gradient fill instead of solid color\",\r\n            onChange: (val) => { this.useGradient = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"gradientStartColor\", \"color\", this.gradientStartColor, {\r\n            description: \"Gradient start color\",\r\n            onChange: (val) => { this.gradientStartColor = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"gradientEndColor\", \"color\", this.gradientEndColor, {\r\n            description: \"Gradient end color\",\r\n            onChange: (val) => { this.gradientEndColor = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"gradientAngle\", \"number\", this.gradientAngle, {\r\n            description: \"Gradient angle in degrees\",\r\n            onChange: (val) => { this.gradientAngle = val; }\r\n        });\r\n\r\n        // Outline\r\n        this.exposeProperty(\"hasOutline\", \"boolean\", this.hasOutline, {\r\n            description: \"Enable text outline\",\r\n            onChange: (val) => { this.hasOutline = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"outlineColor\", \"color\", this.outlineColor, {\r\n            description: \"Outline color\",\r\n            onChange: (val) => { this.outlineColor = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"outlineWidth\", \"number\", this.outlineWidth, {\r\n            description: \"Outline width in pixels\",\r\n            onChange: (val) => { this.outlineWidth = val; }\r\n        });\r\n\r\n        // Shadow\r\n        this.exposeProperty(\"hasShadow\", \"boolean\", this.hasShadow, {\r\n            description: \"Enable text shadow\",\r\n            onChange: (val) => { this.hasShadow = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"shadowColor\", \"color\", this.shadowColor, {\r\n            description: \"Shadow color\",\r\n            onChange: (val) => { this.shadowColor = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"shadowOffsetX\", \"number\", this.shadowOffsetX, {\r\n            description: \"Shadow horizontal offset\",\r\n            onChange: (val) => { this.shadowOffsetX = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"shadowOffsetY\", \"number\", this.shadowOffsetY, {\r\n            description: \"Shadow vertical offset\",\r\n            onChange: (val) => { this.shadowOffsetY = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"shadowBlur\", \"number\", this.shadowBlur, {\r\n            description: \"Shadow blur radius\",\r\n            onChange: (val) => { this.shadowBlur = val; }\r\n        });\r\n\r\n        // Alignment\r\n        this.exposeProperty(\"textAlign\", \"enum\", this.textAlign, {\r\n            description: \"Text horizontal alignment\",\r\n            options: [\"left\", \"center\", \"right\", \"start\", \"end\"],\r\n            onChange: (val) => { this.textAlign = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"textBaseline\", \"enum\", this.textBaseline, {\r\n            description: \"Text vertical alignment\",\r\n            options: [\"top\", \"hanging\", \"middle\", \"alphabetic\", \"ideographic\", \"bottom\"],\r\n            onChange: (val) => { this.textBaseline = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"lineHeight\", \"number\", this.lineHeight, {\r\n            description: \"Line height multiplier for multi-line text\",\r\n            onChange: (val) => { this.lineHeight = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"letterSpacing\", \"number\", this.letterSpacing, {\r\n            description: \"Letter spacing in pixels\",\r\n            onChange: (val) => { this.letterSpacing = val; }\r\n        });\r\n\r\n        // Effects\r\n        this.exposeProperty(\"opacity\", \"number\", this.opacity, {\r\n            description: \"Text opacity (0-1)\",\r\n            onChange: (val) => { this.opacity = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"rotation\", \"number\", this.rotation, {\r\n            description: \"Text rotation in degrees\",\r\n            onChange: (val) => { this.rotation = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"skewX\", \"number\", this.skewX, {\r\n            description: \"Horizontal skew in degrees\",\r\n            onChange: (val) => { this.skewX = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"skewY\", \"number\", this.skewY, {\r\n            description: \"Vertical skew in degrees\",\r\n            onChange: (val) => { this.skewY = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"scaleX\", \"number\", this.scaleX, {\r\n            description: \"Horizontal scale multiplier\",\r\n            onChange: (val) => { this.scaleX = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"scaleY\", \"number\", this.scaleY, {\r\n            description: \"Vertical scale multiplier\",\r\n            onChange: (val) => { this.scaleY = val; }\r\n        });\r\n\r\n        // Animation Effects\r\n        this.exposeProperty(\"wave\", \"boolean\", this.wave, {\r\n            description: \"Enable wave animation effect\",\r\n            onChange: (val) => { this.wave = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"waveAmplitude\", \"number\", this.waveAmplitude, {\r\n            description: \"Wave effect amplitude\",\r\n            onChange: (val) => { this.waveAmplitude = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"waveFrequency\", \"number\", this.waveFrequency, {\r\n            description: \"Wave effect frequency\",\r\n            onChange: (val) => { this.waveFrequency = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"waveSpeed\", \"number\", this.waveSpeed, {\r\n            description: \"Wave animation speed\",\r\n            onChange: (val) => { this.waveSpeed = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"rainbow\", \"boolean\", this.rainbow, {\r\n            description: \"Enable rainbow color animation\",\r\n            onChange: (val) => { this.rainbow = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"rainbowSpeed\", \"number\", this.rainbowSpeed, {\r\n            description: \"Rainbow animation speed\",\r\n            onChange: (val) => { this.rainbowSpeed = val; }\r\n        });\r\n\r\n        // Text Wrapping\r\n        this.exposeProperty(\"maxWidth\", \"number\", this.maxWidth, {\r\n            description: \"Maximum width for text wrapping (0 = no wrapping)\",\r\n            onChange: (val) => { this.maxWidth = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"wordWrap\", \"boolean\", this.wordWrap, {\r\n            description: \"Enable word wrapping\",\r\n            onChange: (val) => { this.wordWrap = val; }\r\n        });\r\n\r\n        // Background\r\n        this.exposeProperty(\"hasBackground\", \"boolean\", this.hasBackground, {\r\n            description: \"Enable text background\",\r\n            onChange: (val) => { this.hasBackground = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"backgroundColor\", \"color\", this.backgroundColor, {\r\n            description: \"Background color\",\r\n            onChange: (val) => { this.backgroundColor = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"backgroundPadding\", \"number\", this.backgroundPadding, {\r\n            description: \"Background padding in pixels\",\r\n            onChange: (val) => { this.backgroundPadding = val; }\r\n        });\r\n\r\n        this.exposeProperty(\"backgroundRadius\", \"number\", this.backgroundRadius, {\r\n            description: \"Background border radius\",\r\n            onChange: (val) => { this.backgroundRadius = val; }\r\n        });\r\n    }\r\n\r\n    style(style) {\r\n        style.startGroup(\"Text Content\", false, {\r\n            backgroundColor: 'rgba(100,150,255,0.1)',\r\n            borderRadius: '6px',\r\n            padding: '8px'\r\n        });\r\n        style.exposeProperty(\"text\", \"string\", this.text);\r\n        style.endGroup();\r\n\r\n        style.startGroup(\"Font Properties\", false, {\r\n            backgroundColor: 'rgba(150,100,255,0.1)',\r\n            borderRadius: '6px',\r\n            padding: '8px'\r\n        });\r\n        style.exposeProperty(\"fontSize\", \"number\", this.fontSize, { min: 1, max: 200 });\r\n        style.exposeProperty(\"fontFamily\", \"enum\", this.fontFamily, {\r\n            options: [\"Arial\", \"Helvetica\", \"Times New Roman\", \"Courier New\", \"Georgia\", \"Verdana\", \"Comic Sans MS\", \"Impact\", \"Trebuchet MS\"]\r\n        });\r\n        style.exposeProperty(\"fontWeight\", \"enum\", this.fontWeight, {\r\n            options: [\"normal\", \"bold\", \"lighter\", \"bolder\", \"100\", \"200\", \"300\", \"400\", \"500\", \"600\", \"700\", \"800\", \"900\"]\r\n        });\r\n        style.exposeProperty(\"fontStyle\", \"enum\", this.fontStyle, {\r\n            options: [\"normal\", \"italic\", \"oblique\"]\r\n        });\r\n        style.endGroup();\r\n\r\n        style.startGroup(\"Colors & Fill\", false, {\r\n            backgroundColor: 'rgba(255,150,100,0.1)',\r\n            borderRadius: '6px',\r\n            padding: '8px'\r\n        });\r\n        style.exposeProperty(\"fillColor\", \"color\", this.fillColor);\r\n        style.exposeProperty(\"useGradient\", \"boolean\", this.useGradient);\r\n        style.exposeProperty(\"gradientStartColor\", \"color\", this.gradientStartColor);\r\n        style.exposeProperty(\"gradientEndColor\", \"color\", this.gradientEndColor);\r\n        style.exposeProperty(\"gradientAngle\", \"number\", this.gradientAngle, { min: 0, max: 360 });\r\n        style.exposeProperty(\"rainbow\", \"boolean\", this.rainbow);\r\n        style.exposeProperty(\"rainbowSpeed\", \"number\", this.rainbowSpeed, { min: 0.1, max: 5 });\r\n        style.endGroup();\r\n\r\n        style.startGroup(\"Outline\", false, {\r\n            backgroundColor: 'rgba(255,100,150,0.1)',\r\n            borderRadius: '6px',\r\n            padding: '8px'\r\n        });\r\n        style.exposeProperty(\"hasOutline\", \"boolean\", this.hasOutline);\r\n        style.exposeProperty(\"outlineColor\", \"color\", this.outlineColor);\r\n        style.exposeProperty(\"outlineWidth\", \"number\", this.outlineWidth, { min: 0, max: 20 });\r\n        style.endGroup();\r\n\r\n        style.startGroup(\"Shadow\", false, {\r\n            backgroundColor: 'rgba(100,255,150,0.1)',\r\n            borderRadius: '6px',\r\n            padding: '8px'\r\n        });\r\n        style.exposeProperty(\"hasShadow\", \"boolean\", this.hasShadow);\r\n        style.exposeProperty(\"shadowColor\", \"color\", this.shadowColor);\r\n        style.exposeProperty(\"shadowOffsetX\", \"number\", this.shadowOffsetX, { min: -50, max: 50 });\r\n        style.exposeProperty(\"shadowOffsetY\", \"number\", this.shadowOffsetY, { min: -50, max: 50 });\r\n        style.exposeProperty(\"shadowBlur\", \"number\", this.shadowBlur, { min: 0, max: 50 });\r\n        style.endGroup();\r\n\r\n        style.startGroup(\"Alignment & Spacing\", false, {\r\n            backgroundColor: 'rgba(150,255,100,0.1)',\r\n            borderRadius: '6px',\r\n            padding: '8px'\r\n        });\r\n        style.exposeProperty(\"textAlign\", \"enum\", this.textAlign, {\r\n            options: [\"left\", \"center\", \"right\", \"start\", \"end\"]\r\n        });\r\n        style.exposeProperty(\"textBaseline\", \"enum\", this.textBaseline, {\r\n            options: [\"top\", \"hanging\", \"middle\", \"alphabetic\", \"ideographic\", \"bottom\"]\r\n        });\r\n        style.exposeProperty(\"lineHeight\", \"number\", this.lineHeight, { min: 0.5, max: 3, step: 0.1 });\r\n        style.exposeProperty(\"letterSpacing\", \"number\", this.letterSpacing, { min: -10, max: 20 });\r\n        style.endGroup();\r\n\r\n        style.startGroup(\"Transform Effects\", false, {\r\n            backgroundColor: 'rgba(255,255,100,0.1)',\r\n            borderRadius: '6px',\r\n            padding: '8px'\r\n        });\r\n        style.exposeProperty(\"opacity\", \"number\", this.opacity, { min: 0, max: 1, step: 0.01 });\r\n        style.exposeProperty(\"rotation\", \"number\", this.rotation, { min: -180, max: 180 });\r\n        style.exposeProperty(\"skewX\", \"number\", this.skewX, { min: -45, max: 45 });\r\n        style.exposeProperty(\"skewY\", \"number\", this.skewY, { min: -45, max: 45 });\r\n        style.exposeProperty(\"scaleX\", \"number\", this.scaleX, { min: 0.1, max: 3, step: 0.1 });\r\n        style.exposeProperty(\"scaleY\", \"number\", this.scaleY, { min: 0.1, max: 3, step: 0.1 });\r\n        style.endGroup();\r\n\r\n        style.startGroup(\"Animation Effects\", false, {\r\n            backgroundColor: 'rgba(100,255,255,0.1)',\r\n            borderRadius: '6px',\r\n            padding: '8px'\r\n        });\r\n        style.exposeProperty(\"wave\", \"boolean\", this.wave);\r\n        style.exposeProperty(\"waveAmplitude\", \"number\", this.waveAmplitude, { min: 0, max: 50 });\r\n        style.exposeProperty(\"waveFrequency\", \"number\", this.waveFrequency, { min: 0.1, max: 10 });\r\n        style.exposeProperty(\"waveSpeed\", \"number\", this.waveSpeed, { min: 0.1, max: 10 });\r\n        style.endGroup();\r\n\r\n        style.startGroup(\"Text Wrapping\", false, {\r\n            backgroundColor: 'rgba(255,100,255,0.1)',\r\n            borderRadius: '6px',\r\n            padding: '8px'\r\n        });\r\n        style.exposeProperty(\"maxWidth\", \"number\", this.maxWidth, { min: 0, max: 2000 });\r\n        style.exposeProperty(\"wordWrap\", \"boolean\", this.wordWrap);\r\n        style.endGroup();\r\n\r\n        style.startGroup(\"Background\", false, {\r\n            backgroundColor: 'rgba(200,200,200,0.1)',\r\n            borderRadius: '6px',\r\n            padding: '8px'\r\n        });\r\n        style.exposeProperty(\"hasBackground\", \"boolean\", this.hasBackground);\r\n        style.exposeProperty(\"backgroundColor\", \"color\", this.backgroundColor);\r\n        style.exposeProperty(\"backgroundPadding\", \"number\", this.backgroundPadding, { min: 0, max: 50 });\r\n        style.exposeProperty(\"backgroundRadius\", \"number\", this.backgroundRadius, { min: 0, max: 50 });\r\n        style.endGroup();\r\n    }\r\n\r\n    loop(deltaTime) {\r\n        this.time += deltaTime;\r\n    }\r\n\r\n    draw(ctx) {\r\n        ctx.save();\r\n\r\n        // Apply opacity\r\n        ctx.globalAlpha = this.opacity;\r\n\r\n        // Apply transform effects\r\n        if (this.rotation !== 0 || this.skewX !== 0 || this.skewY !== 0 || this.scaleX !== 1 || this.scaleY !== 1) {\r\n            const rad = this.rotation * Math.PI / 180;\r\n            const skewXRad = this.skewX * Math.PI / 180;\r\n            const skewYRad = this.skewY * Math.PI / 180;\r\n            \r\n            ctx.transform(\r\n                this.scaleX * Math.cos(rad),\r\n                this.scaleX * Math.sin(rad) + Math.tan(skewYRad),\r\n                -this.scaleY * Math.sin(rad) + Math.tan(skewXRad),\r\n                this.scaleY * Math.cos(rad),\r\n                0,\r\n                0\r\n            );\r\n        }\r\n\r\n        // Set font\r\n        ctx.font = `${this.fontStyle} ${this.fontWeight} ${this.fontSize}px ${this.fontFamily}`;\r\n        ctx.textAlign = this.textAlign;\r\n        ctx.textBaseline = this.textBaseline;\r\n\r\n        // Handle text wrapping\r\n        const lines = this.getWrappedText(ctx, this.text);\r\n\r\n        // Calculate text metrics for background\r\n        let textWidth = 0;\r\n        let textHeight = lines.length * this.fontSize * this.lineHeight;\r\n        \r\n        if (this.maxWidth > 0) {\r\n            textWidth = this.maxWidth;\r\n        } else {\r\n            for (let line of lines) {\r\n                const lineWidth = ctx.measureText(line).width;\r\n                if (lineWidth > textWidth) textWidth = lineWidth;\r\n            }\r\n        }\r\n\r\n        // Draw background if enabled\r\n        if (this.hasBackground) {\r\n            ctx.save();\r\n            ctx.fillStyle = this.backgroundColor;\r\n            \r\n            let bgX = -textWidth / 2 - this.backgroundPadding;\r\n            let bgY = -textHeight / 2 - this.backgroundPadding;\r\n            let bgWidth = textWidth + this.backgroundPadding * 2;\r\n            let bgHeight = textHeight + this.backgroundPadding * 2;\r\n            \r\n            if (this.textAlign === \"left\") bgX = -this.backgroundPadding;\r\n            if (this.textAlign === \"right\") bgX = -textWidth - this.backgroundPadding;\r\n            \r\n            if (this.backgroundRadius > 0) {\r\n                this.roundRect(ctx, bgX, bgY, bgWidth, bgHeight, this.backgroundRadius);\r\n                ctx.fill();\r\n            } else {\r\n                ctx.fillRect(bgX, bgY, bgWidth, bgHeight);\r\n            }\r\n            ctx.restore();\r\n        }\r\n\r\n        // Set shadow if enabled\r\n        if (this.hasShadow) {\r\n            ctx.shadowColor = this.shadowColor;\r\n            ctx.shadowOffsetX = this.shadowOffsetX;\r\n            ctx.shadowOffsetY = this.shadowOffsetY;\r\n            ctx.shadowBlur = this.shadowBlur;\r\n        }\r\n\r\n        // Draw each line\r\n        for (let i = 0; i < lines.length; i++) {\r\n            const line = lines[i];\r\n            const y = (i - (lines.length - 1) / 2) * this.fontSize * this.lineHeight;\r\n\r\n            if (this.wave) {\r\n                this.drawWaveText(ctx, line, 0, y);\r\n            } else {\r\n                this.drawStyledText(ctx, line, 0, y);\r\n            }\r\n        }\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    getWrappedText(ctx, text) {\r\n        if (this.maxWidth <= 0 || !this.wordWrap) {\r\n            return text.split('\\n');\r\n        }\r\n\r\n        const words = text.split(' ');\r\n        const lines = [];\r\n        let currentLine = '';\r\n\r\n        for (let word of words) {\r\n            const testLine = currentLine + (currentLine ? ' ' : '') + word;\r\n            const testWidth = ctx.measureText(testLine).width;\r\n\r\n            if (testWidth > this.maxWidth && currentLine !== '') {\r\n                lines.push(currentLine);\r\n                currentLine = word;\r\n            } else {\r\n                currentLine = testLine;\r\n            }\r\n        }\r\n\r\n        if (currentLine) {\r\n            lines.push(currentLine);\r\n        }\r\n\r\n        return lines;\r\n    }\r\n\r\n    drawWaveText(ctx, text, x, y) {\r\n        for (let i = 0; i < text.length; i++) {\r\n            const char = text[i];\r\n            const waveOffset = Math.sin((this.time * this.waveSpeed) + (i * this.waveFrequency)) * this.waveAmplitude;\r\n            const charWidth = ctx.measureText(char).width;\r\n            \r\n            ctx.save();\r\n            ctx.translate(x, y + waveOffset);\r\n            this.drawStyledText(ctx, char, 0, 0);\r\n            ctx.restore();\r\n            \r\n            x += charWidth + this.letterSpacing;\r\n        }\r\n    }\r\n\r\n    drawStyledText(ctx, text, x, y) {\r\n        // Set fill style\r\n        if (this.rainbow) {\r\n            const hue = (this.time * this.rainbowSpeed * 360) % 360;\r\n            ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;\r\n        } else if (this.useGradient) {\r\n            const gradient = this.createTextGradient(ctx, text, x, y);\r\n            ctx.fillStyle = gradient;\r\n        } else {\r\n            ctx.fillStyle = this.fillColor;\r\n        }\r\n\r\n        // Draw outline first if enabled\r\n        if (this.hasOutline) {\r\n            ctx.strokeStyle = this.outlineColor;\r\n            ctx.lineWidth = this.outlineWidth;\r\n            ctx.strokeText(text, x, y);\r\n        }\r\n\r\n        // Draw filled text\r\n        ctx.fillText(text, x, y);\r\n    }\r\n\r\n    createTextGradient(ctx, text, x, y) {\r\n        const metrics = ctx.measureText(text);\r\n        const textWidth = metrics.width;\r\n        const textHeight = this.fontSize;\r\n\r\n        const angle = this.gradientAngle * Math.PI / 180;\r\n        const cos = Math.cos(angle);\r\n        const sin = Math.sin(angle);\r\n\r\n        const length = Math.abs(textWidth * cos) + Math.abs(textHeight * sin);\r\n        const startX = x - (length * cos) / 2;\r\n        const startY = y - (length * sin) / 2;\r\n        const endX = x + (length * cos) / 2;\r\n        const endY = y + (length * sin) / 2;\r\n\r\n        const gradient = ctx.createLinearGradient(startX, startY, endX, endY);\r\n        gradient.addColorStop(0, this.gradientStartColor);\r\n        gradient.addColorStop(1, this.gradientEndColor);\r\n\r\n        return gradient;\r\n    }\r\n\r\n    roundRect(ctx, x, y, width, height, radius) {\r\n        ctx.beginPath();\r\n        ctx.moveTo(x + radius, y);\r\n        ctx.lineTo(x + width - radius, y);\r\n        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\r\n        ctx.lineTo(x + width, y + height - radius);\r\n        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);\r\n        ctx.lineTo(x + radius, y + height);\r\n        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);\r\n        ctx.lineTo(x, y + radius);\r\n        ctx.quadraticCurveTo(x, y, x + radius, y);\r\n        ctx.closePath();\r\n    }\r\n\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            text: this.text,\r\n            fontSize: this.fontSize,\r\n            fontFamily: this.fontFamily,\r\n            fontWeight: this.fontWeight,\r\n            fontStyle: this.fontStyle,\r\n            fillColor: this.fillColor,\r\n            useGradient: this.useGradient,\r\n            gradientStartColor: this.gradientStartColor,\r\n            gradientEndColor: this.gradientEndColor,\r\n            gradientAngle: this.gradientAngle,\r\n            hasOutline: this.hasOutline,\r\n            outlineColor: this.outlineColor,\r\n            outlineWidth: this.outlineWidth,\r\n            hasShadow: this.hasShadow,\r\n            shadowColor: this.shadowColor,\r\n            shadowOffsetX: this.shadowOffsetX,\r\n            shadowOffsetY: this.shadowOffsetY,\r\n            shadowBlur: this.shadowBlur,\r\n            textAlign: this.textAlign,\r\n            textBaseline: this.textBaseline,\r\n            lineHeight: this.lineHeight,\r\n            letterSpacing: this.letterSpacing,\r\n            wordSpacing: this.wordSpacing,\r\n            opacity: this.opacity,\r\n            rotation: this.rotation,\r\n            skewX: this.skewX,\r\n            skewY: this.skewY,\r\n            scaleX: this.scaleX,\r\n            scaleY: this.scaleY,\r\n            wave: this.wave,\r\n            waveAmplitude: this.waveAmplitude,\r\n            waveFrequency: this.waveFrequency,\r\n            waveSpeed: this.waveSpeed,\r\n            rainbow: this.rainbow,\r\n            rainbowSpeed: this.rainbowSpeed,\r\n            maxWidth: this.maxWidth,\r\n            wordWrap: this.wordWrap,\r\n            hasBackground: this.hasBackground,\r\n            backgroundColor: this.backgroundColor,\r\n            backgroundPadding: this.backgroundPadding,\r\n            backgroundRadius: this.backgroundRadius\r\n        };\r\n    }\r\n\r\n    fromJSON(data) {\r\n        super.fromJSON(data);\r\n        if (!data) return;\r\n\r\n        this.text = data.text || \"Hello World\";\r\n        this.fontSize = data.fontSize || 32;\r\n        this.fontFamily = data.fontFamily || \"Arial\";\r\n        this.fontWeight = data.fontWeight || \"normal\";\r\n        this.fontStyle = data.fontStyle || \"normal\";\r\n        this.fillColor = data.fillColor || \"#ffffff\";\r\n        this.useGradient = data.useGradient || false;\r\n        this.gradientStartColor = data.gradientStartColor || \"#ff0000\";\r\n        this.gradientEndColor = data.gradientEndColor || \"#0000ff\";\r\n        this.gradientAngle = data.gradientAngle || 0;\r\n        this.hasOutline = data.hasOutline || false;\r\n        this.outlineColor = data.outlineColor || \"#000000\";\r\n        this.outlineWidth = data.outlineWidth || 2;\r\n        this.hasShadow = data.hasShadow || false;\r\n        this.shadowColor = data.shadowColor || \"#000000\";\r\n        this.shadowOffsetX = data.shadowOffsetX || 2;\r\n        this.shadowOffsetY = data.shadowOffsetY || 2;\r\n        this.shadowBlur = data.shadowBlur || 4;\r\n        this.textAlign = data.textAlign || \"center\";\r\n        this.textBaseline = data.textBaseline || \"middle\";\r\n        this.lineHeight = data.lineHeight || 1.2;\r\n        this.letterSpacing = data.letterSpacing || 0;\r\n        this.wordSpacing = data.wordSpacing || 0;\r\n        this.opacity = data.opacity || 1.0;\r\n        this.rotation = data.rotation || 0;\r\n        this.skewX = data.skewX || 0;\r\n        this.skewY = data.skewY || 0;\r\n        this.scaleX = data.scaleX || 1.0;\r\n        this.scaleY = data.scaleY || 1.0;\r\n        this.wave = data.wave || false;\r\n        this.waveAmplitude = data.waveAmplitude || 5;\r\n        this.waveFrequency = data.waveFrequency || 2;\r\n        this.waveSpeed = data.waveSpeed || 2;\r\n        this.rainbow = data.rainbow || false;\r\n        this.rainbowSpeed = data.rainbowSpeed || 1;\r\n        this.maxWidth = data.maxWidth || 0;\r\n        this.wordWrap = data.wordWrap !== undefined ? data.wordWrap : true;\r\n        this.hasBackground = data.hasBackground || false;\r\n        this.backgroundColor = data.backgroundColor || \"#000000\";\r\n        this.backgroundPadding = data.backgroundPadding || 10;\r\n        this.backgroundRadius = data.backgroundRadius || 0;\r\n    }\r\n}\r\n\r\nwindow.DrawText = DrawText;",
      "type": "file",
      "name": "DrawText.js",
      "parentPath": "/",
      "created": 1758692649672,
      "modified": 1758692649672
    }
  ],
  "metadata": {
    "exportedBy": "Dark Matter JS Game Engine",
    "exportVersion": "1.0",
    "engineVersion": "1.0.0",
    "selectionMode": "explicit-directories-only"
  }
}