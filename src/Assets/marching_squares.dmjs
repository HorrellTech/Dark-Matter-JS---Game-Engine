{
  "name": "Marching Squares",
  "description": "An infinite generation marching squares generation module that can interact with Matter.js Rigidbodies",
  "version": "1.0.0",
  "author": "SynKrown",
  "timestamp": 1758693426870,
  "icon": {
    "data": "data:image/png;base64,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",
    "originalName": "Generated Image September 24, 2025 - 5_56PM.png",
    "size": 30509
  },
  "directories": [],
  "totalFiles": 1,
  "totalDirectories": 0,
  "files": [
    {
      "path": "/MarchingCubesTerrain.js",
      "content": "class MarchingCubesTerrain extends Module {\r\n    static namespace = \"Drawing\";\r\n    static description = \"Marching cubes grid-based terrain system with multiple biomes\";\r\n    static allowMultiple = false;\r\n    static iconClass = \"fas fa-mountain\";\r\n\r\n    constructor() {\r\n        super(\"MarchingCubesTerrain\");\r\n\r\n        // Configuration properties\r\n        this.gridSize = 64;\r\n        this.gridResolution = 2;\r\n        this.threshold = 0.5;\r\n        this.noiseScale = 0.015;\r\n        this.noiseOctaves = 4;\r\n        this.noisePersistence = 0.5;\r\n        this.noiseLacunarity = 2.0;\r\n        this.terrainHeight = 100;\r\n        this.lineWidth = 2;\r\n        this.smoothTerrain = true;\r\n        this.seed = 12345;\r\n        this.viewportMargin = 200;\r\n        this.biomeScale = 0.005;\r\n        this.showDebug = false;\r\n\r\n        // Generation type configuration\r\n        this.generationType = \"Random\"; // Random, Maze, HeightConstrained, PerlinNoise, SimplexNoise, Voronoi\r\n        this.mazeComplexity = 0.7; // 0-1, higher values create more complex mazes\r\n        this.minHeight = 500; // Minimum height for HeightConstrained generation\r\n        this.voronoiSites = 50; // Number of sites for Voronoi generation\r\n        this.voronoiRelaxation = 1; // Number of Lloyd relaxation iterations\r\n\r\n        //  Rigidbody management properties\r\n        this.enableRigidbodies = false; // Enable/disable rigidbody generation\r\n        this.rigidbodyRadius = 100; // Default radius for rigidbody activation\r\n        this.activeRigidbodies = new Map(); // Track active rigidbodies by grid key\r\n        this.rigidbodyGridSize = 64; // Size of rigidbody grid cells (larger than terrain grid)\r\n        this.rigidbodyCleanupThreshold = 200; // Distance threshold for cleanup\r\n        this.activeActivationPoints = new Map(); // Track all active activation regions\r\n        this.activationPointId = 0; // Unique ID for activation points\r\n\r\n        // Biome configurations\r\n        this.biomes = {\r\n            grass: {\r\n                name: \"Grass\",\r\n                color: \"#4a7c59\",\r\n                fillColor: this.rgbaStringToHex(\"rgba(105, 69, 54, 0.8)\"),\r\n                heightRange: [0.35, 0.75],\r\n                temperature: \"temperate\",\r\n                humidity: \"moderate\",\r\n                // New color variation properties\r\n                colorVariation: 0.1, // 0-1, amount of random color variation\r\n                darkenAmount: 0.2, // 0-1, how much to darken filled areas\r\n                lightenAmount: 0.1, // 0-1, how much to lighten filled areas\r\n                // Texture generation properties\r\n                textureScale: 0.02, // Scale for texture pattern generation\r\n                textureContrast: 0.3, // 0-1, contrast of texture pattern\r\n                // Square decoration properties\r\n                enableSquares: true, // Enable random squares around cells\r\n                squareCount: 3, // Number of squares per cell\r\n                squareSize: 4, // Size of decorative squares (pixels)\r\n                squareSpacing: 8, // Minimum spacing between squares\r\n                squareOpacity: 0.6 // Opacity of decorative squares\r\n            }/*,\r\n            dirt: {\r\n                name: \"Dirt\",\r\n                color: this.rgbaStringToHex(\"rgba(156, 110, 90, 0.8)\"),\r\n                fillColor: this.rgbaStringToHex(\"rgba(105, 69, 54, 0.8)\"),\r\n                heightRange: [0.35, 0.75],\r\n                temperature: \"warm\",\r\n                humidity: \"dry\",\r\n                // New color variation properties\r\n                colorVariation: 0.4,\r\n                darkenAmount: 0.15,\r\n                lightenAmount: 0.05,\r\n                // Texture generation properties\r\n                textureScale: 0.015,\r\n                textureContrast: 0.6,\r\n                // Square decoration properties\r\n                enableSquares: true,\r\n                squareCount: 2,\r\n                squareSize: 3,\r\n                squareSpacing: 6,\r\n                squareOpacity: 0.5\r\n            },\r\n            stone: {\r\n                name: \"Stone\",\r\n                color: \"#696969\",\r\n                fillColor: this.rgbaStringToHex(\"rgba(105, 105, 105, 0.8)\"),\r\n                heightRange: [0.75, 1.0],\r\n                temperature: \"cold\",\r\n                humidity: \"dry\",\r\n                // New color variation properties\r\n                colorVariation: 0.2,\r\n                darkenAmount: 0.3,\r\n                lightenAmount: 0.05,\r\n                // Texture generation properties\r\n                textureScale: 0.025,\r\n                textureContrast: 0.4,\r\n                // Square decoration properties\r\n                enableSquares: false,\r\n                squareCount: 1,\r\n                squareSize: 2,\r\n                squareSpacing: 4,\r\n                squareOpacity: 0.4\r\n            }*/\r\n        };\r\n\r\n        // Internal state\r\n        this.gridCache = new Map();\r\n        this.activeGrids = new Set();\r\n\r\n        // Fixed marching squares lookup table\r\n        this.marchingSquaresTable = this.initMarchingSquaresTable();\r\n\r\n        this.setupProperties();\r\n    }\r\n\r\n    setupProperties() {\r\n        // Basic terrain properties\r\n        this.exposeProperty(\"gridSize\", \"number\", 20, {\r\n            description: \"Size of each grid cell\",\r\n            onChange: (val) => {\r\n                this.gridSize = Math.max(5, Math.floor(val));\r\n                this.clearCache();\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"gridResolution\", \"number\", 16, {\r\n            description: \"Grid resolution (cells per grid)\",\r\n            onChange: (val) => {\r\n                this.gridResolution = Math.max(4, Math.floor(val));\r\n                this.clearCache();\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"threshold\", \"number\", 0.5, {\r\n            description: \"Terrain generation threshold (0-1)\",\r\n            onChange: (val) => {\r\n                this.threshold = Math.max(0, Math.min(1, val));\r\n                this.clearCache();\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"noiseScale\", \"number\", 0.015, {\r\n            description: \"Noise scale for terrain generation\",\r\n            onChange: (val) => {\r\n                this.noiseScale = Math.max(0.001, val);\r\n                this.clearCache();\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"biomeScale\", \"number\", 0.005, {\r\n            description: \"Scale for biome determination\",\r\n            onChange: (val) => {\r\n                this.biomeScale = Math.max(0.001, val);\r\n                this.clearCache();\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"lineWidth\", \"number\", 1.5, {\r\n            description: \"Line width for terrain edges\",\r\n            onChange: (val) => {\r\n                this.lineWidth = Math.max(0.5, val);\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"smoothTerrain\", \"boolean\", true, {\r\n            description: \"Enable smooth terrain interpolation\",\r\n            onChange: (val) => {\r\n                this.smoothTerrain = val;\r\n                this.clearCache();\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"seed\", \"number\", 12345, {\r\n            description: \"Seed for deterministic terrain generation\",\r\n            onChange: (val) => {\r\n                this.seed = val;\r\n                this.clearCache();\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"showDebug\", \"boolean\", false, {\r\n            description: \"Show debug information\",\r\n            onChange: (val) => {\r\n                this.showDebug = val;\r\n            }\r\n        });\r\n\r\n        // Generation type properties\r\n        this.exposeProperty(\"generationType\", \"select\", \"Random\", {\r\n            description: \"Terrain generation algorithm\",\r\n            //options: [\"Random\", \"Maze\", \"HeightConstrained\", \"PerlinNoise\", \"SimplexNoise\", \"Voronoi\"],\r\n            options: [\"Random\", \"HeightConstrained\", \"SimplexNoise\"],\r\n            onChange: (val) => {\r\n                this.generationType = val;\r\n                this.clearCache();\r\n            }\r\n        });\r\n\r\n        /*this.exposeProperty(\"mazeComplexity\", \"number\", 0.7, {\r\n            description: \"Maze complexity (0-1, higher = more complex)\",\r\n            min: 0,\r\n            max: 1,\r\n            step: 0.1,\r\n            onChange: (val) => {\r\n                this.mazeComplexity = Math.max(0, Math.min(1, val));\r\n                this.clearCache();\r\n            }\r\n        });*/\r\n\r\n        this.exposeProperty(\"minHeight\", \"number\", 500, {\r\n            description: \"Minimum height for HeightConstrained generation\",\r\n            min: 0,\r\n            max: 2000,\r\n            onChange: (val) => {\r\n                this.minHeight = Math.max(0, val);\r\n                this.clearCache();\r\n            }\r\n        });\r\n\r\n        /*this.exposeProperty(\"voronoiSites\", \"number\", 50, {\r\n            description: \"Number of sites for Voronoi generation\",\r\n            min: 10,\r\n            max: 200,\r\n            onChange: (val) => {\r\n                this.voronoiSites = Math.max(10, Math.min(200, val));\r\n                this.clearCache();\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"voronoiRelaxation\", \"number\", 1, {\r\n            description: \"Lloyd relaxation iterations for Voronoi\",\r\n            min: 0,\r\n            max: 5,\r\n            onChange: (val) => {\r\n                this.voronoiRelaxation = Math.max(0, Math.min(5, val));\r\n                this.clearCache();\r\n            }\r\n        });*/\r\n\r\n        this.exposeProperty(\"enableRigidbodies\", \"boolean\", false, {\r\n            description: \"Enable automatic rigidbody generation for terrain\",\r\n            onChange: (val) => {\r\n                this.enableRigidbodies = val;\r\n                if (!val) {\r\n                    this.clearAllRigidbodies();\r\n                }\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"rigidbodyRadius\", \"number\", 100, {\r\n            description: \"Radius for rigidbody activation around objects\",\r\n            min: 10,\r\n            max: 500,\r\n            onChange: (val) => {\r\n                this.rigidbodyRadius = Math.max(10, Math.min(500, val));\r\n            }\r\n        });\r\n\r\n        this.exposeProperty(\"rigidbodyGridSize\", \"number\", 50, {\r\n            description: \"Grid size for rigidbody management\",\r\n            min: 20,\r\n            max: 200,\r\n            onChange: (val) => {\r\n                this.rigidbodyGridSize = Math.max(20, Math.min(200, val));\r\n                this.clearAllRigidbodies();\r\n            }\r\n        });\r\n\r\n        // Biome color properties\r\n        Object.keys(this.biomes).forEach(biomeKey => {\r\n            const biome = this.biomes[biomeKey];\r\n\r\n            this.exposeProperty(`${biomeKey}Color`, \"color\", biome.color, {\r\n                description: `${biome.name} line color`,\r\n                onChange: (val) => {\r\n                    this.biomes[biomeKey].color = val;\r\n                }\r\n            });\r\n\r\n            this.exposeProperty(`${biomeKey}FillColor`, \"color\", biome.fillColor, {\r\n                description: `${biome.name} fill color`,\r\n                onChange: (val) => {\r\n                    this.biomes[biomeKey].fillColor = val;\r\n                }\r\n            });\r\n\r\n            this.exposeProperty(`${biomeKey}MinHeight`, \"number\", biome.heightRange[0], {\r\n                description: `${biome.name} minimum height`,\r\n                onChange: (val) => {\r\n                    this.biomes[biomeKey].heightRange[0] = Math.max(0, val);\r\n                }\r\n            });\r\n\r\n            this.exposeProperty(`${biomeKey}MaxHeight`, \"number\", biome.heightRange[1], {\r\n                description: `${biome.name} maximum height`,\r\n                onChange: (val) => {\r\n                    this.biomes[biomeKey].heightRange[1] = Math.max(0, val);\r\n                }\r\n            });\r\n\r\n            // New color variation properties\r\n            this.exposeProperty(`${biomeKey}ColorVariation`, \"number\", biome.colorVariation, {\r\n                description: `${biome.name} color variation (0-1)`,\r\n                min: 0,\r\n                max: 1,\r\n                step: 0.05,\r\n                onChange: (val) => {\r\n                    this.biomes[biomeKey].colorVariation = Math.max(0, Math.min(1, val));\r\n                }\r\n            });\r\n\r\n            this.exposeProperty(`${biomeKey}DarkenAmount`, \"number\", biome.darkenAmount, {\r\n                description: `${biome.name} fill darken amount (0-1)`,\r\n                min: 0,\r\n                max: 1,\r\n                step: 0.05,\r\n                onChange: (val) => {\r\n                    this.biomes[biomeKey].darkenAmount = Math.max(0, Math.min(1, val));\r\n                }\r\n            });\r\n\r\n            this.exposeProperty(`${biomeKey}LightenAmount`, \"number\", biome.lightenAmount, {\r\n                description: `${biome.name} fill lighten amount (0-1)`,\r\n                min: 0,\r\n                max: 1,\r\n                step: 0.05,\r\n                onChange: (val) => {\r\n                    this.biomes[biomeKey].lightenAmount = Math.max(0, Math.min(1, val));\r\n                }\r\n            });\r\n\r\n            // New texture properties\r\n            this.exposeProperty(`${biomeKey}TextureScale`, \"number\", biome.textureScale, {\r\n                description: `${biome.name} texture pattern scale`,\r\n                min: 0.001,\r\n                max: 0.1,\r\n                step: 0.001,\r\n                onChange: (val) => {\r\n                    this.biomes[biomeKey].textureScale = Math.max(0.001, Math.min(0.1, val));\r\n                }\r\n            });\r\n\r\n            this.exposeProperty(`${biomeKey}TextureContrast`, \"number\", biome.textureContrast, {\r\n                description: `${biome.name} texture contrast (0-1)`,\r\n                min: 0,\r\n                max: 1,\r\n                step: 0.05,\r\n                onChange: (val) => {\r\n                    this.biomes[biomeKey].textureContrast = Math.max(0, Math.min(1, val));\r\n                }\r\n            });\r\n\r\n            // New square decoration properties\r\n            this.exposeProperty(`${biomeKey}EnableSquares`, \"boolean\", biome.enableSquares, {\r\n                description: `Enable ${biome.name} decorative squares`,\r\n                onChange: (val) => {\r\n                    this.biomes[biomeKey].enableSquares = val;\r\n                }\r\n            });\r\n\r\n            this.exposeProperty(`${biomeKey}SquareCount`, \"number\", biome.squareCount, {\r\n                description: `${biome.name} squares per cell`,\r\n                min: 0,\r\n                max: 10,\r\n                onChange: (val) => {\r\n                    this.biomes[biomeKey].squareCount = Math.max(0, Math.floor(val));\r\n                }\r\n            });\r\n\r\n            this.exposeProperty(`${biomeKey}SquareSize`, \"number\", biome.squareSize, {\r\n                description: `${biome.name} square size (pixels)`,\r\n                min: 1,\r\n                max: 20,\r\n                onChange: (val) => {\r\n                    this.biomes[biomeKey].squareSize = Math.max(1, Math.floor(val));\r\n                }\r\n            });\r\n\r\n            this.exposeProperty(`${biomeKey}SquareSpacing`, \"number\", biome.squareSpacing, {\r\n                description: `${biome.name} minimum square spacing`,\r\n                min: 2,\r\n                max: 50,\r\n                onChange: (val) => {\r\n                    this.biomes[biomeKey].squareSpacing = Math.max(2, Math.floor(val));\r\n                }\r\n            });\r\n\r\n            this.exposeProperty(`${biomeKey}SquareOpacity`, \"number\", biome.squareOpacity, {\r\n                description: `${biome.name} square opacity (0-1)`,\r\n                min: 0,\r\n                max: 1,\r\n                step: 0.05,\r\n                onChange: (val) => {\r\n                    this.biomes[biomeKey].squareOpacity = Math.max(0, Math.min(1, val));\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    start() {\r\n        this.gameObject.position.x = 0;\r\n        this.gameObject.position.y = 0;\r\n    }\r\n\r\n    clearCache() {\r\n        this.gridCache.clear();\r\n        this.activeGrids.clear();\r\n    }\r\n\r\n    rgbaToHex(r, g, b, a = 1) {\r\n        // Ensure values are within valid ranges\r\n        r = Math.max(0, Math.min(255, Math.round(r)));\r\n        g = Math.max(0, Math.min(255, Math.round(g)));\r\n        b = Math.max(0, Math.min(255, Math.round(b)));\r\n        a = Math.max(0, Math.min(1, a));\r\n\r\n        // Convert alpha from 0-1 to 0-255\r\n        const alpha = Math.round(a * 255);\r\n\r\n        // Convert to hex\r\n        const toHex = (n) => n.toString(16).padStart(2, '0');\r\n\r\n        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;\r\n    }\r\n\r\n    rgbaStringToHex(rgba) {\r\n        const [r, g, b, a] = rgba.match(/\\d+/g).map(Number);\r\n        return this.rgbaToHex(r, g, b, a);\r\n    }\r\n\r\n    generateBiomeColor(baseColor, variation = 0) {\r\n        if (variation === 0) return baseColor;\r\n        \r\n        // Convert hex to RGB\r\n        const hex = baseColor.replace('#', '');\r\n        const r = parseInt(hex.substr(0, 2), 16);\r\n        const g = parseInt(hex.substr(2, 2), 16);\r\n        const b = parseInt(hex.substr(4, 2), 16);\r\n        \r\n        // Create a seed based on color and position for consistent variation\r\n        const colorSeed = this.seed + r * 1000 + g * 100 + b * 10;\r\n        const random = this.seededRandomGeneral(colorSeed);\r\n        \r\n        // Apply random variation\r\n        const variationAmount = variation * 100;\r\n        const newR = Math.max(0, Math.min(255, r + (random() - 0.5) * variationAmount * 2));\r\n        const newG = Math.max(0, Math.min(255, g + (random() - 0.5) * variationAmount * 2));\r\n        const newB = Math.max(0, Math.min(255, b + (random() - 0.5) * variationAmount * 2));\r\n        \r\n        return this.rgbaToHex(newR, newG, newB);\r\n    }\r\n\r\n    // New method to darken/lighten colors\r\n    adjustColorBrightness(color, darkenAmount = 0, lightenAmount = 0) {\r\n        const hex = color.replace('#', '');\r\n        let r = parseInt(hex.substr(0, 2), 16);\r\n        let g = parseInt(hex.substr(2, 2), 16);\r\n        let b = parseInt(hex.substr(4, 2), 16);\r\n        \r\n        // Apply darkening\r\n        if (darkenAmount > 0) {\r\n            const darkenFactor = 1 - darkenAmount;\r\n            r = Math.floor(r * darkenFactor);\r\n            g = Math.floor(g * darkenFactor);\r\n            b = Math.floor(b * darkenFactor);\r\n        }\r\n        \r\n        // Apply lightening\r\n        if (lightenAmount > 0) {\r\n            const lightenFactor = 1 + lightenAmount;\r\n            r = Math.min(255, Math.floor(r * lightenFactor));\r\n            g = Math.min(255, Math.floor(g * lightenFactor));\r\n            b = Math.min(255, Math.floor(b * lightenFactor));\r\n        }\r\n        \r\n        return this.rgbaToHex(r, g, b);\r\n    }\r\n\r\n    applyTextureOverlay(baseColor, textureIntensity, contrast = 0.5) {\r\n        // Create texture pattern using noise\r\n        const textureColor = this.generateTextureColor(textureIntensity, contrast);\r\n        \r\n        // Apply texture as overlay - mix base color with texture pattern\r\n        const hex = baseColor.replace('#', '');\r\n        const r = parseInt(hex.substr(0, 2), 16);\r\n        const g = parseInt(hex.substr(2, 2), 16);\r\n        const b = parseInt(hex.substr(4, 2), 16);\r\n        \r\n        // Mix base color with texture pattern\r\n        const mixRatio = textureIntensity * 0.3; // Control texture strength\r\n        const texR = Math.floor(r * (1 - mixRatio) + textureColor.r * mixRatio);\r\n        const texG = Math.floor(g * (1 - mixRatio) + textureColor.g * mixRatio);\r\n        const texB = Math.floor(b * (1 - mixRatio) + textureColor.b * mixRatio);\r\n        \r\n        return this.rgbaToHex(texR, texG, texB);\r\n    }\r\n\r\n    generateTextureColor(intensity, contrast) {\r\n        // Create varied texture colors based on intensity\r\n        const baseIntensity = intensity * contrast;\r\n        \r\n        // Generate different texture colors for variety\r\n        const textureVariations = [\r\n            { r: 30, g: 20, b: 10 },   // Dark brown\r\n            { r: 50, g: 40, b: 30 },   // Medium brown\r\n            { r: 20, g: 30, b: 15 },   // Dark green\r\n            { r: 40, g: 35, b: 25 },   // Light brown\r\n            { r: 25, g: 25, b: 35 }    // Dark blue-gray\r\n        ];\r\n        \r\n        // Select texture color based on intensity\r\n        const colorIndex = Math.floor(intensity * textureVariations.length);\r\n        const selectedColor = textureVariations[Math.min(colorIndex, textureVariations.length - 1)];\r\n        \r\n        // Apply intensity variation\r\n        const intensityFactor = 0.7 + baseIntensity * 0.6;\r\n        return {\r\n            r: Math.floor(selectedColor.r * intensityFactor),\r\n            g: Math.floor(selectedColor.g * intensityFactor),\r\n            b: Math.floor(selectedColor.b * intensityFactor)\r\n        };\r\n    }\r\n\r\n    // New method to generate tilable texture pattern\r\n    generateTexturePattern(x, y, scale, contrast) {\r\n        // Create a more complex tilable noise pattern\r\n        const noise1 = this.octaveNoise(x * scale, y * scale);\r\n        const noise2 = this.octaveNoise(x * scale * 2.1, y * scale * 1.7);\r\n        const noise3 = this.octaveNoise(x * scale * 4.3, y * scale * 3.9);\r\n        const noise4 = this.octaveNoise(x * scale * 7.1, y * scale * 5.3);\r\n        \r\n        // Combine noises for more complex texture\r\n        let texture = (noise1 * 0.4 + noise2 * 0.3 + noise3 * 0.2 + noise4 * 0.1);\r\n        \r\n        // Apply contrast and create more variation\r\n        texture = (texture - 0.5) * contrast * 1.5 + 0.5;\r\n        \r\n        // Add some cellular-like patterns for more realistic texture\r\n        const cellular = Math.sin(x * scale * 3) * Math.cos(y * scale * 3) * 0.1;\r\n        texture += cellular;\r\n        \r\n        return Math.max(0, Math.min(1, texture));\r\n    }\r\n\r\n    // New method to generate random squares around a cell\r\n    generateDecorativeSquares(cellX, cellY, cellSize, biome, polygons) {\r\n        const squares = [];\r\n        const squareCount = biome.squareCount;\r\n        const squareSize = biome.squareSize;\r\n        const minSpacing = biome.squareSpacing;\r\n        \r\n        // Create seed based on cell position and biome for consistent generation\r\n        const cellSeed = cellX * 1000000 + cellY * 10000 + this.seed;\r\n        const random = this.seededRandomGeneral(cellSeed);\r\n        \r\n        for (let i = 0; i < squareCount; i++) {\r\n            let attempts = 0;\r\n            let validPosition = false;\r\n            let squareX, squareY;\r\n            \r\n            // Try to find a valid position (not too close to other squares and in filled area)\r\n            while (!validPosition && attempts < 50) {\r\n                squareX = cellX + random() * cellSize;\r\n                squareY = cellY + random() * cellSize;\r\n                \r\n                validPosition = true;\r\n                \r\n                // Check distance from other squares\r\n                for (const existingSquare of squares) {\r\n                    const distance = Math.sqrt(\r\n                        Math.pow(squareX - existingSquare.x, 2) + \r\n                        Math.pow(squareY - existingSquare.y, 2)\r\n                    );\r\n                    \r\n                    if (distance < minSpacing) {\r\n                        validPosition = false;\r\n                        break;\r\n                    }\r\n                }\r\n                \r\n                // Check if all corners of the square are within any filled polygon area\r\n                if (validPosition) {\r\n                    const halfSize = squareSize / 2;\r\n                    const corners = [\r\n                        { x: squareX - halfSize, y: squareY - halfSize }, // Top-left\r\n                        { x: squareX + halfSize, y: squareY - halfSize }, // Top-right\r\n                        { x: squareX + halfSize, y: squareY + halfSize }, // Bottom-right\r\n                        { x: squareX - halfSize, y: squareY + halfSize }  // Bottom-left\r\n                    ];\r\n                    \r\n                    let allCornersInside = true;\r\n                    for (const corner of corners) {\r\n                        let cornerInside = false;\r\n                        for (const polygon of polygons) {\r\n                            if (this.isPointInPolygon(corner.x, corner.y, polygon.points)) {\r\n                                cornerInside = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (!cornerInside) {\r\n                            allCornersInside = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                    \r\n                    if (!allCornersInside) {\r\n                        validPosition = false;\r\n                    }\r\n                }\r\n                \r\n                attempts++;\r\n            }\r\n            \r\n            if (validPosition) {\r\n                // Generate seeded random color variations for this square\r\n                const squareSeed = cellSeed + i * 1000; // Unique seed per square\r\n                const squareRandom = this.seededRandomGeneral(squareSeed);\r\n                \r\n                // Generate random darken/lighten amounts based on biome ranges\r\n                const darkenAmount = squareRandom() * biome.darkenAmount * 2; // 0 to 2x biome amount\r\n                const lightenAmount = squareRandom() * biome.lightenAmount * 2; // 0 to 2x biome amount\r\n                \r\n                squares.push({\r\n                    x: squareX,\r\n                    y: squareY,\r\n                    size: squareSize + random() * squareSize * 0.5, // Vary size slightly\r\n                    opacity: biome.squareOpacity * (0.5 + random() * 0.5), // Vary opacity\r\n                    darkenAmount: darkenAmount,\r\n                    lightenAmount: lightenAmount\r\n                });\r\n            }\r\n        }\r\n        \r\n        return squares;\r\n    }\r\n\r\n    // Fixed marching squares lookup table - corrected bit order and edge connections\r\n    initMarchingSquaresTable() {\r\n        // Each entry contains line segments defined by edge pairs\r\n        // Edges: 0=top, 1=right, 2=bottom, 3=left\r\n        // Corners: TL=8, TR=4, BR=2, BL=1 (binary: TL TR BR BL)\r\n        return [\r\n            [], // 0: 0000 - no corners filled\r\n            [[2, 3]], // 1: 0001 - bottom-left corner\r\n            [[1, 2]], // 2: 0010 - bottom-right corner  \r\n            [[1, 3]], // 3: 0011 - bottom edge\r\n            [[0, 1]], // 4: 0100 - top-right corner\r\n            [[0, 1], [2, 3]], // 5: 0101 - diagonal opposite corners\r\n            [[0, 2]], // 6: 0110 - right edge\r\n            [[0, 3]], // 7: 0111 - missing top-left\r\n            [[0, 3]], // 8: 1000 - top-left corner\r\n            [[0, 2]], // 9: 1001 - left edge\r\n            [[0, 3], [1, 2]], // 10: 1010 - diagonal opposite corners\r\n            [[0, 1]], // 11: 1011 - missing top-right\r\n            [[1, 3]], // 12: 1100 - top edge\r\n            [[1, 2]], // 13: 1101 - missing bottom-right\r\n            [[2, 3]], // 14: 1110 - missing bottom-left\r\n            [] // 15: 1111 - all corners filled\r\n        ];\r\n    }\r\n\r\n    // Improved noise function using multiple octaves\r\n    noise(x, y) {\r\n        // Handle negative coordinates and very large coordinates properly\r\n        const safeX = x === -0 ? 0 : x; // Handle negative zero\r\n        const safeY = y === -0 ? 0 : y; // Handle negative zero\r\n\r\n        let n = Math.sin(safeX * 12.9898 + safeY * 78.233 + this.seed * 37.719) * 43758.5453;\r\n        return (n - Math.floor(n));\r\n    }\r\n\r\n    // Main generation function that dispatches to appropriate algorithm\r\n    generateHeight(x, y) {\r\n        switch (this.generationType) {\r\n            case \"Random\":\r\n                return this.octaveNoise(x, y);\r\n            case \"Maze\":\r\n                return this.generateMazeHeight(x, y);\r\n            case \"HeightConstrained\":\r\n                return this.generateHeightConstrained(x, y);\r\n            case \"PerlinNoise\":\r\n                return this.perlinNoise(x, y);\r\n            case \"SimplexNoise\":\r\n                return this.simplexNoise(x, y);\r\n            case \"Voronoi\":\r\n                return this.voronoiNoise(x, y);\r\n            default:\r\n                return this.octaveNoise(x, y);\r\n        }\r\n    }\r\n\r\n    // Height-constrained generation (only generates terrain above minHeight)\r\n    generateHeightConstrained(x, y) {\r\n        const baseHeight = this.octaveNoise(x, y);\r\n\r\n        // Only generate terrain above the minimum height\r\n        if (y < this.minHeight) {\r\n            // Create a smooth transition zone\r\n            const transitionHeight = 100; // pixels\r\n            const distanceFromMin = this.minHeight - y;\r\n\r\n            if (distanceFromMin < transitionHeight) {\r\n                const fadeFactor = distanceFromMin / transitionHeight;\r\n                return baseHeight * fadeFactor * fadeFactor; // Smooth quadratic fade\r\n            } else {\r\n                return 0; // No terrain below minimum height\r\n            }\r\n        }\r\n\r\n        return baseHeight;\r\n    }\r\n\r\n    // Maze-based height generation with improved randomness\r\n    generateMazeHeight(x, y) {\r\n        // Generate a maze for this grid area\r\n        const gridSize = this.gridSize * this.gridResolution;\r\n        const gridX = Math.floor(x / gridSize);\r\n        const gridY = Math.floor(y / gridSize);\r\n\r\n        // Create a deterministic maze based on grid position and seed\r\n        const mazeSeed = gridX * 10000 + gridY * 100 + this.seed;\r\n        const random = this.seededRandom(mazeSeed);\r\n\r\n        const mazeWidth = Math.floor(this.gridResolution / 2);\r\n        const mazeHeight = Math.floor(this.gridResolution / 2);\r\n\r\n        // Generate maze pattern with improved algorithm\r\n        const maze = this.generateImprovedMazePattern(mazeWidth, mazeHeight, random, this.mazeComplexity);\r\n\r\n        // Convert to height values with more variation\r\n        return this.improvedMazeToHeightPattern(maze, x, y, this.gridSize);\r\n    }\r\n\r\n     // Seeded random number generator for deterministic maze generation\r\n    seededRandom(seed) {\r\n        let x = Math.sin(seed) * 10000;\r\n        return function () {\r\n            x = Math.sin(x) * 10000;\r\n            return x - Math.floor(x);\r\n        };\r\n    }\r\n\r\n    // General seeded random number generator for consistent generation\r\n    seededRandomGeneral(seed) {\r\n        let x = Math.sin(seed) * 10000;\r\n        return function () {\r\n            x = Math.sin(x) * 10000;\r\n            return x - Math.floor(x);\r\n        };\r\n    }\r\n\r\n    // Generate improved maze pattern with more randomness and variation\r\n    generateImprovedMazePattern(width, height, random, complexity = 0.7) {\r\n        const maze = Array(height).fill().map(() => Array(width).fill(1));\r\n\r\n        // Use Prim's algorithm for more organic maze generation\r\n        const frontiers = new Set();\r\n        const visited = new Set();\r\n\r\n        // Start from a random position\r\n        const startX = Math.floor(random() * width);\r\n        const startY = Math.floor(random() * height);\r\n        visited.add(`${startX},${startY}`);\r\n        maze[startY][startX] = 0;\r\n\r\n        // Add initial frontiers\r\n        this.addFrontiers(startX, startY, width, height, frontiers, visited);\r\n\r\n        while (frontiers.size > 0) {\r\n            // Pick random frontier\r\n            const frontierArray = Array.from(frontiers);\r\n            const randomIndex = Math.floor(random() * frontierArray.length);\r\n            const frontier = frontierArray[randomIndex];\r\n            frontiers.delete(frontier);\r\n\r\n            const [x, y] = frontier.split(',').map(Number);\r\n            const neighbors = this.getValidNeighbors(x, y, width, height, visited);\r\n\r\n            if (neighbors.length > 0) {\r\n                // Pick random neighbor\r\n                const neighborIndex = Math.floor(random() * neighbors.length);\r\n                const [nx, ny] = neighbors[neighborIndex];\r\n\r\n                // Carve path\r\n                const wallX = (x + nx) / 2;\r\n                const wallY = (y + ny) / 2;\r\n                maze[wallY][wallX] = 0;\r\n                maze[y][x] = 0;\r\n\r\n                visited.add(frontier);\r\n                this.addFrontiers(x, y, width, height, frontiers, visited);\r\n            }\r\n        }\r\n\r\n        // Add some randomness by removing some walls based on complexity\r\n        if (complexity < 1.0) {\r\n            this.addMazeImperfections(maze, random, complexity);\r\n        }\r\n\r\n        return maze;\r\n    }\r\n\r\n    // Add frontier cells around a carved cell\r\n    addFrontiers(x, y, width, height, frontiers, visited) {\r\n        const directions = [[0, 2], [2, 0], [0, -2], [-2, 0]];\r\n\r\n        directions.forEach(([dx, dy]) => {\r\n            const nx = x + dx;\r\n            const ny = y + dy;\r\n\r\n            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\r\n                const key = `${nx},${ny}`;\r\n                if (!visited.has(key)) {\r\n                    frontiers.add(key);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    // Get valid neighbors for maze generation\r\n    getValidNeighbors(x, y, width, height, visited) {\r\n        const neighbors = [];\r\n        const directions = [[0, 2], [2, 0], [0, -2], [-2, 0]];\r\n\r\n        directions.forEach(([dx, dy]) => {\r\n            const nx = x + dx;\r\n            const ny = y + dy;\r\n\r\n            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\r\n                const key = `${nx},${ny}`;\r\n                if (visited.has(key)) {\r\n                    neighbors.push([nx, ny]);\r\n                }\r\n            }\r\n        });\r\n\r\n        return neighbors;\r\n    }\r\n\r\n    // Add imperfections to make maze less perfect and more varied\r\n    addMazeImperfections(maze, random, complexity) {\r\n        const height = maze.length;\r\n        const width = maze[0].length;\r\n\r\n        // Remove some walls to create loops and alternative paths\r\n        const wallsToRemove = Math.floor((height * width * (1 - complexity)) / 4);\r\n\r\n        for (let i = 0; i < wallsToRemove; i++) {\r\n            const x = Math.floor(random() * width);\r\n            const y = Math.floor(random() * height);\r\n\r\n            // Only remove walls, not paths\r\n            if (maze[y][x] === 1) {\r\n                // Check if removing this wall creates a valid opening\r\n                const neighbors = this.getAdjacentCells(x, y, width, height);\r\n                const pathCount = neighbors.filter(([nx, ny]) => maze[ny][nx] === 0).length;\r\n\r\n                // Only remove if it connects to exactly one path (creates a dead end)\r\n                if (pathCount === 1) {\r\n                    maze[y][x] = 0;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Get adjacent cells (including diagonals)\r\n    getAdjacentCells(x, y, width, height) {\r\n        const cells = [];\r\n        for (let dx = -1; dx <= 1; dx++) {\r\n            for (let dy = -1; dy <= 1; dy++) {\r\n                if (dx === 0 && dy === 0) continue;\r\n                const nx = x + dx;\r\n                const ny = y + dy;\r\n                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\r\n                    cells.push([nx, ny]);\r\n                }\r\n            }\r\n        }\r\n        return cells;\r\n    }\r\n\r\n    // Convert improved maze pattern to height values with more variation\r\n    improvedMazeToHeightPattern(maze, x, y, cellSize) {\r\n        const mazeX = Math.floor(x / cellSize);\r\n        const mazeY = Math.floor(y / cellSize);\r\n\r\n        if (mazeX >= 0 && mazeX < maze[0].length && mazeY >= 0 && mazeY < maze.length) {\r\n            const cellValue = maze[mazeY][mazeX];\r\n\r\n            // Create more varied height patterns\r\n            let baseHeight;\r\n            if (cellValue === 0) {\r\n                // Path cells - vary height based on position and noise\r\n                const positionNoise = this.noise(x * 0.05, y * 0.05);\r\n                const detailNoise = this.noise(x * 0.2, y * 0.2) * 0.3;\r\n                baseHeight = 0.6 + positionNoise * 0.3 + detailNoise;\r\n            } else {\r\n                // Wall cells - vary height for more organic look\r\n                const wallNoise = this.noise(x * 0.08, y * 0.08);\r\n                const heightVariation = this.noise(x * 0.15, y * 0.15) * 0.2;\r\n                baseHeight = 0.1 + wallNoise * 0.2 + heightVariation;\r\n            }\r\n\r\n            // Add some micro-detail\r\n            const microNoise = this.noise(x * 0.5, y * 0.5) * 0.05;\r\n            const finalHeight = Math.max(0, Math.min(1, baseHeight + microNoise));\r\n\r\n            return finalHeight;\r\n        }\r\n\r\n        return 0.1; // Default wall height for out-of-bounds\r\n    }\r\n\r\n    // Multi-octave noise function\r\n    octaveNoise(x, y) {\r\n        let value = 0;\r\n        let amplitude = 1;\r\n        let frequency = this.noiseScale;\r\n        let maxValue = 0;\r\n\r\n        for (let i = 0; i < this.noiseOctaves; i++) {\r\n            value += this.noise(x * frequency, y * frequency) * amplitude;\r\n            maxValue += amplitude;\r\n            amplitude *= this.noisePersistence;\r\n            frequency *= this.noiseLacunarity;\r\n        }\r\n\r\n        return value / maxValue;\r\n    }\r\n\r\n    // Improved Perlin noise function with proper gradients and permutation table\r\n    perlinNoise(x, y) {\r\n        // Create permutation table based on seed for deterministic randomness\r\n        const perm = this.generatePermutationTable(this.seed);\r\n\r\n        // Handle negative coordinates properly for infinite world generation\r\n        const X = ((Math.floor(x) % 256) + 256) % 256;\r\n        const Y = ((Math.floor(y) % 256) + 256) % 256;\r\n\r\n        const xf = x - Math.floor(x);\r\n        const yf = y - Math.floor(y);\r\n\r\n        // Smooth the fractional parts\r\n        const u = this.fade(xf);\r\n        const v = this.fade(yf);\r\n\r\n        // Hash coordinates of the 4 square corners\r\n        const A = perm[X] + Y;\r\n        const AA = perm[A];\r\n        const AB = perm[A + 1];\r\n        const B = perm[X + 1] + Y;\r\n        const BA = perm[B];\r\n        const BB = perm[B + 1];\r\n\r\n        // Add blended results from 4 corners of the square\r\n        const x1 = this.lerp(this.grad(AA, xf, yf), this.grad(BA, xf - 1, yf), u);\r\n        const x2 = this.lerp(this.grad(AB, xf, yf - 1), this.grad(BB, xf - 1, yf - 1), u);\r\n\r\n        return this.lerp(x1, x2, v);\r\n    }\r\n\r\n    // Generate permutation table for Perlin noise\r\n    generatePermutationTable(seed) {\r\n        const p = new Array(256);\r\n        for (let i = 0; i < 256; i++) {\r\n            p[i] = i;\r\n        }\r\n\r\n        // Shuffle using seed\r\n        let n = 0;\r\n        for (let i = 255; i > 0; i--) {\r\n            n = (n + seed + i) % (i + 1);\r\n            const temp = p[i];\r\n            p[i] = p[n];\r\n            p[n] = temp;\r\n        }\r\n\r\n        // Duplicate the array to avoid overflow\r\n        return [...p, ...p];\r\n    }\r\n\r\n    // Fade function for smooth interpolation\r\n    fade(t) {\r\n        return t * t * t * (t * (t * 6 - 15) + 10);\r\n    }\r\n\r\n    // Linear interpolation\r\n    lerp(a, b, t) {\r\n        return a + t * (b - a);\r\n    }\r\n\r\n    // Gradient function for Perlin noise\r\n    grad(hash, x, y) {\r\n        const h = hash & 15;\r\n        const gradX = h < 8 ? (h < 4 ? x : y) : (h === 12 || h === 14 ? x : -y);\r\n        const gradY = h < 4 ? y : (h === 12 || h === 14 ? -x : (h & 2 ? -y : x));\r\n        return (h & 1 ? -gradX : gradX) + (h & 2 ? -gradY : gradY);\r\n    }\r\n\r\n    // Improved Simplex noise implementation\r\n    simplexNoise(x, y) {\r\n        // Simplex constants\r\n        const F2 = 0.5 * (Math.sqrt(3) - 1);\r\n        const G2 = (3 - Math.sqrt(3)) / 6;\r\n        const F3 = 1 / 3;\r\n        const G3 = 1 / 6;\r\n\r\n        // Skew the input space to determine which simplex cell we're in\r\n        const s = (x + y) * F2;\r\n        const xs = x + s;\r\n        const ys = y + s;\r\n        // Handle negative coordinates properly for infinite world generation\r\n        const i = Math.floor(xs < 0 ? xs - 1 : xs);\r\n        const j = Math.floor(ys < 0 ? ys - 1 : ys);\r\n\r\n        // Unskew the cell origin back to (x,y) space\r\n        const t = (i + j) * G2;\r\n        const X0 = i - t;\r\n        const Y0 = j - t;\r\n        const x0 = x - X0;\r\n        const y0 = y - Y0;\r\n\r\n        // Determine which simplex we are in\r\n        const i1 = x0 > y0 ? 1 : 0;\r\n        const j1 = x0 > y0 ? 0 : 1;\r\n\r\n        // Offsets for middle corner in (x,y) unskewed coords\r\n        const x1 = x0 - i1 + G2;\r\n        const y1 = y0 - j1 + G2;\r\n        const x2 = x0 - 1 + 2 * G2;\r\n        const y2 = y0 - 1 + 2 * G2;\r\n\r\n        // Generate permutation table for this seed\r\n        const perm = this.generatePermutationTable(this.seed);\r\n\r\n        // Calculate the contribution from the three corners\r\n        const t0 = 0.5 - x0 * x0 - y0 * y0;\r\n        const n0 = t0 < 0 ? 0 : Math.pow(t0, 4) * this.dot2D(perm[i + perm[j]], x0, y0);\r\n\r\n        const t1 = 0.5 - x1 * x1 - y1 * y1;\r\n        const n1 = t1 < 0 ? 0 : Math.pow(t1, 4) * this.dot2D(perm[i + i1 + perm[j + j1]], x1, y1);\r\n\r\n        const t2 = 0.5 - x2 * x2 - y2 * y2;\r\n        const n2 = t2 < 0 ? 0 : Math.pow(t2, 4) * this.dot2D(perm[i + 1 + perm[j + 1]], x2, y2);\r\n\r\n        // Add contributions from each corner and scale the result\r\n        return 45.0 * (n0 + n1 + n2);\r\n    }\r\n\r\n    // 2D dot product for simplex noise\r\n    dot2D(hash, x, y) {\r\n        const h = hash & 7;\r\n        const u = h < 4 ? x : y;\r\n        const v = h < 4 ? y : x;\r\n        return ((h & 1) ? -u : u) + ((h & 2) ? -2 * v : 2 * v);\r\n    }\r\n\r\n    // Voronoi diagram generation\r\n    voronoiNoise(x, y) {\r\n        let minDist = Infinity;\r\n        let minDist2 = Infinity;\r\n\r\n        // Generate sites based on seed AND world coordinates for infinite generation\r\n        const sites = [];\r\n        const gridSize = 2000; // Size of each Voronoi cell in world units\r\n        const gridX = Math.floor(x / gridSize);\r\n        const gridY = Math.floor(y / gridSize);\r\n\r\n        // Generate sites for current grid and neighboring grids\r\n        for (let gx = gridX - 1; gx <= gridX + 1; gx++) {\r\n            for (let gy = gridY - 1; gy <= gridY + 1; gy++) {\r\n                for (let i = 0; i < this.voronoiSites; i++) {\r\n                    // Include grid coordinates in the seed for unique patterns per grid\r\n                    const siteSeed = gx * 1000000 + gy * 10000 + i * 100 + this.seed;\r\n                    const siteX = gx * gridSize + this.noise(siteSeed, 0) * gridSize;\r\n                    const siteY = gy * gridSize + this.noise(siteSeed + 100, 0) * gridSize;\r\n                    sites.push({ x: siteX, y: siteY });\r\n                }\r\n            }\r\n        }\r\n\r\n        // Apply Lloyd relaxation if enabled\r\n        for (let iter = 0; iter < this.voronoiRelaxation; iter++) {\r\n            sites.forEach(site => {\r\n                let sumX = 0, sumY = 0, count = 0;\r\n                sites.forEach(otherSite => {\r\n                    if (otherSite !== site) {\r\n                        const dx = otherSite.x - site.x;\r\n                        const dy = otherSite.y - site.y;\r\n                        const dist = Math.sqrt(dx * dx + dy * dy);\r\n                        if (dist < 1000) { // Only consider nearby sites\r\n                            sumX += otherSite.x;\r\n                            sumY += otherSite.y;\r\n                            count++;\r\n                        }\r\n                    }\r\n                });\r\n                if (count > 0) {\r\n                    site.x = sumX / count;\r\n                    site.y = sumY / count;\r\n                }\r\n            });\r\n        }\r\n\r\n        // Find closest sites\r\n        sites.forEach(site => {\r\n            const dx = site.x - x * 100;\r\n            const dy = site.y - y * 100;\r\n            const dist = Math.sqrt(dx * dx + dy * dy);\r\n\r\n            if (dist < minDist) {\r\n                minDist2 = minDist;\r\n                minDist = dist;\r\n            } else if (dist < minDist2) {\r\n                minDist2 = dist;\r\n            }\r\n        });\r\n\r\n        // Return F1-F2 distance for more interesting patterns\r\n        return (minDist2 - minDist) / 100;\r\n    }\r\n\r\n    // Maze generation using recursive backtracking\r\n    generateMaze(width, height) {\r\n        const maze = Array(height).fill().map(() => Array(width).fill(1)); // 1 = wall, 0 = path\r\n\r\n        function carve(x, y) {\r\n            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];\r\n            // Shuffle directions for randomness\r\n            for (let i = directions.length - 1; i > 0; i--) {\r\n                const j = Math.floor(Math.random() * (i + 1));\r\n                [directions[i], directions[j]] = [directions[j], directions[i]];\r\n            }\r\n\r\n            directions.forEach(([dx, dy]) => {\r\n                const nx = x + dx * 2;\r\n                const ny = y + dy * 2;\r\n\r\n                if (nx >= 0 && nx < width && ny >= 0 && ny < height && maze[ny][nx] === 1) {\r\n                    maze[y + dy][x + dx] = 0; // Remove wall\r\n                    maze[ny][nx] = 0; // Create path\r\n                    carve(nx, ny);\r\n                }\r\n            });\r\n        }\r\n\r\n        // Start carving from a random position\r\n        const startX = Math.floor(Math.random() * Math.floor(width / 2)) * 2;\r\n        const startY = Math.floor(Math.random() * Math.floor(height / 2)) * 2;\r\n        maze[startY][startX] = 0;\r\n        carve(startX, startY);\r\n\r\n        return maze;\r\n    }\r\n\r\n    // Convert maze to height values\r\n    mazeToHeight(maze, x, y, cellSize) {\r\n        const mazeX = Math.floor(x / cellSize);\r\n        const mazeY = Math.floor(y / cellSize);\r\n\r\n        if (mazeX >= 0 && mazeX < maze[0].length && mazeY >= 0 && mazeY < maze.length) {\r\n            // Add some noise to make it less perfect\r\n            const baseHeight = maze[mazeY][mazeX] === 0 ? 0.8 : 0.2;\r\n            const noise = this.noise(x * 0.1, y * 0.1) * 0.1;\r\n            return Math.max(0, Math.min(1, baseHeight + noise));\r\n        }\r\n\r\n        return 0.2; // Default to wall height\r\n    }\r\n\r\n    // Determine biome based on noise values and height\r\n    getBiome(x, y, height) {\r\n        const biomeNoise = this.octaveNoise(x * this.biomeScale, y * this.biomeScale);\r\n        const temperatureNoise = this.octaveNoise(x * this.biomeScale * 1.3, y * this.biomeScale * 0.7);\r\n        const humidityNoise = this.octaveNoise(x * this.biomeScale * 0.8, y * this.biomeScale * 1.5);\r\n\r\n        /*if (height < 0.5) {\r\n            // Lowland areas\r\n            if (temperatureNoise > 0.7) {\r\n                return 'dirt';\r\n            }\r\n            return biomeNoise < 0.5 ? 'grass' : 'dirt';\r\n        }\r\n\r\n        if (height < 0.75) {\r\n            // Mid-range areas\r\n            if (temperatureNoise > 0.6 && humidityNoise > 0.4) {\r\n                return 'dirt';\r\n            }\r\n            return 'grass';\r\n        }*/\r\n\r\n        // High altitude areas\r\n        return 'grass';\r\n    }\r\n\r\n    // Get grid coordinates for world position\r\n    getGridCoords(worldX, worldY) {\r\n        const gridWorldSize = this.gridSize * this.gridResolution;\r\n        return {\r\n            x: Math.floor(worldX / gridWorldSize),\r\n            y: Math.floor(worldY / gridWorldSize)\r\n        };\r\n    }\r\n\r\n    // Generate grid key\r\n    getGridKey(gridX, gridY) {\r\n        return `${gridX},${gridY}`;\r\n    }\r\n\r\n    // Generate terrain data for a specific grid\r\n    generateGrid(gridX, gridY) {\r\n        const gridKey = this.getGridKey(gridX, gridY);\r\n\r\n        if (this.gridCache.has(gridKey)) {\r\n            return this.gridCache.get(gridKey);\r\n        }\r\n\r\n        const gridWorldSize = this.gridSize * this.gridResolution;\r\n        const gridWorldX = gridX * gridWorldSize;\r\n        const gridWorldY = gridY * gridWorldSize;\r\n\r\n        const cells = [];\r\n\r\n        // Generate grid cells\r\n        for (let cellY = 0; cellY < this.gridResolution; cellY++) {\r\n            for (let cellX = 0; cellX < this.gridResolution; cellX++) {\r\n                const worldX = gridWorldX + cellX * this.gridSize;\r\n                const worldY = gridWorldY + cellY * this.gridSize;\r\n\r\n                // Generate corner height values (clockwise from top-left)\r\n                const tl = this.generateHeight(worldX, worldY);\r\n                const tr = this.generateHeight(worldX + this.gridSize, worldY);\r\n                const br = this.generateHeight(worldX + this.gridSize, worldY + this.gridSize);\r\n                const bl = this.generateHeight(worldX, worldY + this.gridSize);\r\n\r\n                // Determine biome for this cell\r\n                const avgHeight = (tl + tr + br + bl) / 4;\r\n                const biome = this.getBiomeWithTransitions(worldX + this.gridSize / 2, worldY + this.gridSize / 2, avgHeight);\r\n\r\n                const cell = {\r\n                    x: worldX,\r\n                    y: worldY,\r\n                    values: [tl, tr, br, bl], // Store in clockwise order\r\n                    biome: biome,\r\n                    avgHeight: avgHeight,\r\n                    contours: [],\r\n                    polygons: [],\r\n                    // New texture and decoration data\r\n                    texturePattern: this.generateTexturePattern(worldX, worldY, \r\n                        this.biomes[biome].textureScale, this.biomes[biome].textureContrast),\r\n                    decorativeSquares: [] // Initialize as empty array\r\n                };\r\n\r\n                // Generate marching squares contours and polygons\r\n                this.generateContours(cell);\r\n\r\n                // Generate decorative squares AFTER polygons are created\r\n                if (this.biomes[biome].enableSquares) {\r\n                    cell.decorativeSquares = this.generateDecorativeSquares(\r\n                        worldX, worldY, this.gridSize, this.biomes[biome], cell.polygons\r\n                    );\r\n                }\r\n\r\n                cells.push(cell);\r\n            }\r\n        }\r\n\r\n        this.gridCache.set(gridKey, cells);\r\n        return cells;\r\n    }\r\n\r\n    // Generate contours and polygons for a cell using marching squares\r\n    generateContours(cell) {\r\n        const threshold = this.threshold;\r\n\r\n        // Convert values to binary based on threshold\r\n        // Use correct bit positions: TL=8, TR=4, BR=2, BL=1\r\n        const tl = cell.values[0] > threshold ? 8 : 0;\r\n        const tr = cell.values[1] > threshold ? 4 : 0;\r\n        const br = cell.values[2] > threshold ? 2 : 0;\r\n        const bl = cell.values[3] > threshold ? 1 : 0;\r\n\r\n        // Calculate marching squares case\r\n        const caseIndex = tl + tr + br + bl;\r\n        const edges = this.marchingSquaresTable[caseIndex];\r\n\r\n        if (!edges || edges.length === 0) {\r\n            // Check if this is a full cell (all corners above threshold)\r\n            if (caseIndex === 15) {\r\n                // Create full cell polygon\r\n                cell.polygons.push({\r\n                    points: [\r\n                        { x: cell.x, y: cell.y },\r\n                        { x: cell.x + this.gridSize, y: cell.y },\r\n                        { x: cell.x + this.gridSize, y: cell.y + this.gridSize },\r\n                        { x: cell.x, y: cell.y + this.gridSize }\r\n                    ]\r\n                });\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Generate contour lines\r\n        edges.forEach(([start, end]) => {\r\n            const startPos = this.getEdgePosition(start, cell, threshold);\r\n            const endPos = this.getEdgePosition(end, cell, threshold);\r\n\r\n            if (startPos && endPos) {\r\n                cell.contours.push({\r\n                    startX: startPos.x,\r\n                    startY: startPos.y,\r\n                    endX: endPos.x,\r\n                    endY: endPos.y\r\n                });\r\n            }\r\n        });\r\n\r\n        // Create polygons for filled areas\r\n        this.generatePolygons(cell, caseIndex, threshold);\r\n    }\r\n\r\n    // Generate polygons for filled terrain areas\r\n    generatePolygons(cell, caseIndex, threshold) {\r\n        const cellSize = this.gridSize;\r\n        const corners = [\r\n            { x: cell.x, y: cell.y }, // top-left (0)\r\n            { x: cell.x + cellSize, y: cell.y }, // top-right (1)\r\n            { x: cell.x + cellSize, y: cell.y + cellSize }, // bottom-right (2)\r\n            { x: cell.x, y: cell.y + cellSize } // bottom-left (3)\r\n        ];\r\n\r\n        // Get interpolated edge positions\r\n        const getEdgePos = (edge) => this.getEdgePosition(edge, cell, threshold);\r\n\r\n        let polygonPoints = [];\r\n\r\n        // Generate polygon points based on marching squares case\r\n        switch (caseIndex) {\r\n            case 0: // 0000 - empty\r\n                break;\r\n            case 1: // 0001 - bottom-left corner only\r\n                polygonPoints = [corners[3], getEdgePos(2), getEdgePos(3)];\r\n                break;\r\n            case 2: // 0010 - bottom-right corner only\r\n                polygonPoints = [getEdgePos(1), corners[2], getEdgePos(2)];\r\n                break;\r\n            case 3: // 0011 - bottom edge\r\n                polygonPoints = [getEdgePos(1), corners[2], corners[3], getEdgePos(3)];\r\n                break;\r\n            case 4: // 0100 - top-right corner only\r\n                polygonPoints = [getEdgePos(0), corners[1], getEdgePos(1)];\r\n                break;\r\n            case 5: // 0101 - diagonal opposite corners (saddle point)\r\n                // Create two separate triangles to avoid ambiguity\r\n                polygonPoints = [getEdgePos(0), corners[1], getEdgePos(1)];\r\n                cell.polygons.push({ points: polygonPoints.filter(p => p) });\r\n                polygonPoints = [corners[3], getEdgePos(2), getEdgePos(3)];\r\n                break;\r\n            case 6: // 0110 - right edge\r\n                polygonPoints = [getEdgePos(0), corners[1], corners[2], getEdgePos(2)];\r\n                break;\r\n            case 7: // 0111 - missing top-left\r\n                polygonPoints = [getEdgePos(0), corners[1], corners[2], corners[3], getEdgePos(3)];\r\n                break;\r\n            case 8: // 1000 - top-left corner only\r\n                polygonPoints = [corners[0], getEdgePos(0), getEdgePos(3)];\r\n                break;\r\n            case 9: // 1001 - left edge\r\n                polygonPoints = [corners[0], getEdgePos(0), getEdgePos(2), corners[3]];\r\n                break;\r\n            case 10: // 1010 - diagonal opposite corners (saddle point)\r\n                // Create two separate triangles to avoid ambiguity\r\n                polygonPoints = [corners[0], getEdgePos(0), getEdgePos(3)];\r\n                cell.polygons.push({ points: polygonPoints.filter(p => p) });\r\n                polygonPoints = [getEdgePos(1), corners[2], getEdgePos(2)];\r\n                break;\r\n            case 11: // 1011 - missing top-right\r\n                polygonPoints = [corners[0], getEdgePos(0), getEdgePos(1), corners[2], corners[3]];\r\n                break;\r\n            case 12: // 1100 - top edge\r\n                polygonPoints = [corners[0], corners[1], getEdgePos(1), getEdgePos(3)];\r\n                break;\r\n            case 13: // 1101 - missing bottom-right\r\n                polygonPoints = [corners[0], corners[1], getEdgePos(1), getEdgePos(2), corners[3]];\r\n                break;\r\n            case 14: // 1110 - missing bottom-left\r\n                polygonPoints = [corners[0], corners[1], corners[2], getEdgePos(2), getEdgePos(3)];\r\n                break;\r\n            case 15: // 1111 - full cell\r\n                polygonPoints = [corners[0], corners[1], corners[2], corners[3]];\r\n                break;\r\n        }\r\n\r\n        // Add polygon if we have valid points\r\n        if (polygonPoints.length >= 3) {\r\n            // Filter out null positions\r\n            const validPoints = polygonPoints.filter(p => p && p.x !== undefined && p.y !== undefined);\r\n            if (validPoints.length >= 3) {\r\n                cell.polygons.push({ points: validPoints });\r\n            }\r\n        }\r\n    }\r\n\r\n    // Get interpolated position on edge\r\n    getEdgePosition(edge, cell, threshold) {\r\n        const cellSize = this.gridSize;\r\n        let x1, y1, x2, y2, val1, val2;\r\n\r\n        switch (edge) {\r\n            case 0: // Top edge (TL to TR)\r\n                x1 = cell.x; y1 = cell.y; val1 = cell.values[0];\r\n                x2 = cell.x + cellSize; y2 = cell.y; val2 = cell.values[1];\r\n                break;\r\n            case 1: // Right edge (TR to BR)\r\n                x1 = cell.x + cellSize; y1 = cell.y; val1 = cell.values[1];\r\n                x2 = cell.x + cellSize; y2 = cell.y + cellSize; val2 = cell.values[2];\r\n                break;\r\n            case 2: // Bottom edge (BR to BL)\r\n                x1 = cell.x + cellSize; y1 = cell.y + cellSize; val1 = cell.values[2];\r\n                x2 = cell.x; y2 = cell.y + cellSize; val2 = cell.values[3];\r\n                break;\r\n            case 3: // Left edge (BL to TL)\r\n                x1 = cell.x; y1 = cell.y + cellSize; val1 = cell.values[3];\r\n                x2 = cell.x; y2 = cell.y; val2 = cell.values[0];\r\n                break;\r\n            default:\r\n                return null;\r\n        }\r\n\r\n        // Linear interpolation for smooth contours\r\n        let t = 0.5; // Default to middle if no interpolation\r\n        if (this.smoothTerrain && Math.abs(val2 - val1) > 0.001) {\r\n            t = (threshold - val1) / (val2 - val1);\r\n            t = Math.max(0, Math.min(1, t));\r\n        }\r\n\r\n        return {\r\n            x: x1 + t * (x2 - x1),\r\n            y: y1 + t * (y2 - y1)\r\n        };\r\n    }\r\n\r\n    // Get viewport bounds\r\n    /*getViewportBounds() {\r\n        const viewport = window.engine.viewport;\r\n        const viewportX = viewport.x || 0;\r\n        const viewportY = viewport.y || 0;\r\n        const viewportWidth = viewport.width || 800;\r\n        const viewportHeight = viewport.height || 600;\r\n\r\n        const halfWidth = viewportWidth / 2;\r\n        const halfHeight = viewportHeight / 2;\r\n\r\n        return {\r\n            left: viewportX - halfWidth - this.viewportMargin,\r\n            right: viewportX + halfWidth + this.viewportMargin,\r\n            top: viewportY - halfHeight - this.viewportMargin,\r\n            bottom: viewportY + halfHeight + this.viewportMargin,\r\n            centerX: viewportX,\r\n            centerY: viewportY,\r\n            width: viewportWidth,\r\n            height: viewportHeight\r\n        };\r\n    }*/\r\n\r\n    getViewportBounds() {\r\n        const viewport = window.engine.viewport;\r\n        const viewportX = viewport.x || 0;\r\n        const viewportY = viewport.y || 0;\r\n        const viewportWidth = viewport.width || 800;\r\n        const viewportHeight = viewport.height || 600;\r\n\r\n        const halfWidth = viewportWidth / 2;\r\n        const halfHeight = viewportHeight / 2;\r\n\r\n        // Calculate proper viewport bounds with half viewport offset for grid centering\r\n        const left = viewportX - halfWidth - this.viewportMargin;\r\n        const right = viewportX + halfWidth + this.viewportMargin;\r\n        const top = viewportY - halfHeight - this.viewportMargin;\r\n        const bottom = viewportY + halfHeight + this.viewportMargin;\r\n\r\n        return {\r\n            left: left,\r\n            right: right,\r\n            top: top,\r\n            bottom: bottom,\r\n            centerX: viewportX,\r\n            centerY: viewportY,\r\n            width: viewportWidth,\r\n            height: viewportHeight,\r\n            halfWidth: halfWidth,\r\n            halfHeight: halfHeight\r\n        };\r\n    }\r\n\r\n    // Get visible grids for current viewport\r\n    getVisibleGrids(viewportBounds) {\r\n        const gridWorldSize = this.gridSize * this.gridResolution;\r\n\r\n        // Apply half viewport offset to center grid generation on viewport center\r\n        const offsetX = viewportBounds.halfWidth;\r\n        const offsetY = viewportBounds.halfHeight;\r\n\r\n        const minGridX = Math.floor((viewportBounds.left + offsetX) / gridWorldSize);\r\n        const maxGridX = Math.floor((viewportBounds.right + offsetX) / gridWorldSize);\r\n        const minGridY = Math.floor((viewportBounds.top + offsetY) / gridWorldSize);\r\n        const maxGridY = Math.floor((viewportBounds.bottom + offsetY) / gridWorldSize);\r\n\r\n        const visibleGrids = [];\r\n        for (let x = minGridX; x <= maxGridX; x++) {\r\n            for (let y = minGridY; y <= maxGridY; y++) {\r\n                visibleGrids.push({ x, y });\r\n            }\r\n        }\r\n        return visibleGrids;\r\n    }\r\n\r\n    loop(deltaTime) {\r\n        const viewportBounds = this.getViewportBounds();\r\n\r\n        // Update game object position for infinite scrolling\r\n        this.gameObject.position.x = viewportBounds.centerX;\r\n        this.gameObject.position.y = viewportBounds.centerY;\r\n\r\n        // Clear and update active grids\r\n        this.activeGrids.clear();\r\n\r\n        const visibleGrids = this.getVisibleGrids(viewportBounds);\r\n\r\n        // Generate visible grids\r\n        visibleGrids.forEach(grid => {\r\n            const gridKey = this.getGridKey(grid.x, grid.y);\r\n            this.generateGrid(grid.x, grid.y);\r\n            this.activeGrids.add(gridKey);\r\n        });\r\n\r\n        // Clean up distant cached grids to prevent memory leaks\r\n        if (this.gridCache.size > 50) {\r\n            const toDelete = [];\r\n            for (const [key, value] of this.gridCache.entries()) {\r\n                if (!this.activeGrids.has(key)) {\r\n                    toDelete.push(key);\r\n                }\r\n            }\r\n            // Keep only half of the inactive grids\r\n            toDelete.slice(toDelete.length / 2).forEach(key => {\r\n                this.gridCache.delete(key);\r\n            });\r\n        }\r\n\r\n        if (this.showDebug) {\r\n            window.physicsManager.debugDraw = true;\r\n        } else {\r\n            window.physicsManager.debugDraw = false;\r\n        }\r\n\r\n        //if (this.enableRigidbodies && window.physicsManager) {\r\n        // This would be called by other objects that want to activate rigidbodies\r\n        // For example, from a player controller or other moving objects\r\n        // this.activateRigidBodiesRegion(playerX, playerY, this.rigidbodyRadius);\r\n        //}\r\n    }\r\n\r\n    draw(ctx) {\r\n        const viewportBounds = this.getViewportBounds();\r\n        const offsetX = viewportBounds.width / 2 - (viewportBounds.centerX) - viewportBounds.width / 2;\r\n        const offsetY = viewportBounds.height / 2 - (viewportBounds.centerY) - viewportBounds.height / 2;\r\n\r\n        ctx.save();\r\n\r\n        // Group cells by biome for efficient rendering\r\n        const biomeGroups = {};\r\n        let grassCells = []; // Separate grass cells to draw last\r\n\r\n        Object.keys(this.biomes).forEach(biome => {\r\n            biomeGroups[biome] = [];\r\n        });\r\n\r\n        // Collect all visible cells grouped by biome\r\n        this.activeGrids.forEach(gridKey => {\r\n            const cells = this.gridCache.get(gridKey);\r\n            if (cells) {\r\n                cells.forEach(cell => {\r\n                    if (cell.polygons && cell.polygons.length > 0) {\r\n                        if (cell.biome === 'grass') {\r\n                            grassCells.push(cell);\r\n                        } else {\r\n                            biomeGroups[cell.biome].push(cell);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        });\r\n\r\n        // Draw all non-grass biome groups first\r\n        Object.entries(biomeGroups).forEach(([biomeKey, cells]) => {\r\n            if (cells.length === 0 || biomeKey === 'grass') return;\r\n\r\n            const biome = this.biomes[biomeKey];\r\n            this.drawBiomeGroup(ctx, cells, biome, offsetX, offsetY);\r\n        });\r\n\r\n        // Draw grass biome last so its lines appear on top\r\n        if (grassCells.length > 0) {\r\n            const grassBiome = this.biomes.grass;\r\n            this.drawBiomeGroup(ctx, grassCells, grassBiome, offsetX, offsetY);\r\n        }\r\n\r\n        this.drawGridOverlay(ctx, offsetX, offsetY);\r\n\r\n        ctx.restore();\r\n    }\r\n\r\n    drawGridOverlay(ctx, offsetX, offsetY) {\r\n        if (!this.showDebug) return;\r\n\r\n        const viewportBounds = this.getViewportBounds();\r\n        const gridWorldSize = this.gridSize * this.gridResolution;\r\n\r\n        // Draw the existing yellow debug grid\r\n        ctx.strokeStyle = \"rgba(255, 255, 0, 0.5)\";\r\n        ctx.lineWidth = 1;\r\n        ctx.setLineDash([1, 1]);\r\n\r\n        // Draw individual cell grids within each visible grid\r\n        this.activeGrids.forEach(gridKey => {\r\n            const [gridX, gridY] = gridKey.split(',').map(Number);\r\n            const gridWorldX = gridX * gridWorldSize;\r\n            const gridWorldY = gridY * gridWorldSize;\r\n\r\n            // Draw grid cells\r\n            for (let cellY = 0; cellY < this.gridResolution; cellY++) {\r\n                for (let cellX = 0; cellX < this.gridResolution; cellX++) {\r\n                    const cellWorldX = gridWorldX + cellX * this.gridSize;\r\n                    const cellWorldY = gridWorldY + cellY * this.gridSize;\r\n\r\n                    const screenX = cellWorldX + offsetX;\r\n                    const screenY = cellWorldY + offsetY;\r\n\r\n                    // Only draw if cell is visible on screen\r\n                    if (screenX > -this.gridSize && screenX < viewportBounds.width + this.gridSize &&\r\n                        screenY > -this.gridSize && screenY < viewportBounds.height + this.gridSize) {\r\n\r\n                        ctx.strokeRect(screenX, screenY, this.gridSize, this.gridSize);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n\r\n        ctx.setLineDash([]);\r\n\r\n        // NEW: Draw green lines that match the cube lines\r\n        ctx.strokeStyle = \"rgba(0, 255, 0, 0.8)\"; // Green color\r\n        ctx.lineWidth = this.lineWidth;\r\n        ctx.lineCap = 'round';\r\n        ctx.lineJoin = 'round';\r\n        ctx.setLineDash([]); // Solid lines\r\n\r\n        // Draw the actual terrain contour lines in green\r\n        this.activeGrids.forEach(gridKey => {\r\n            const cells = this.gridCache.get(gridKey);\r\n            if (cells) {\r\n                cells.forEach(cell => {\r\n                    // Draw contour lines for this cell\r\n                    if (cell.contours && cell.contours.length > 0) {\r\n                        ctx.beginPath();\r\n                        cell.contours.forEach(contour => {\r\n                            const startX = contour.startX + offsetX;\r\n                            const startY = contour.startY + offsetY;\r\n                            const endX = contour.endX + offsetX;\r\n                            const endY = contour.endY + offsetY;\r\n\r\n                            ctx.moveTo(startX, startY);\r\n                            ctx.lineTo(endX, endY);\r\n                        });\r\n                        ctx.stroke();\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    drawBiomeGroup(ctx, cells, biome, offsetX, offsetY) {\r\n        // Set drawing styles for this biome\r\n        ctx.fillStyle = biome.fillColor;\r\n        ctx.strokeStyle = biome.color;\r\n        ctx.lineWidth = this.lineWidth;\r\n        ctx.lineCap = 'round';\r\n        ctx.lineJoin = 'round';\r\n\r\n        // Draw filled terrain areas with texture and color variation\r\n        cells.forEach(cell => {\r\n            cell.polygons.forEach(polygon => {\r\n                if (polygon.points.length >= 3) {\r\n                    // Generate varied fill color for this cell\r\n                    const baseFillColor = this.generateBiomeColor(biome.fillColor, biome.colorVariation);\r\n                    const adjustedFillColor = this.adjustColorBrightness(\r\n                        baseFillColor, biome.darkenAmount, biome.lightenAmount\r\n                    );\r\n                    \r\n                    // Apply texture as overlay pattern\r\n                    const textureIntensity = cell.texturePattern;\r\n                    const finalFillColor = this.applyTextureOverlay(\r\n                        baseFillColor, textureIntensity, biome.textureContrast\r\n                    );\r\n                    \r\n                    ctx.fillStyle = finalFillColor;\r\n                    \r\n                    // Draw the filled polygon\r\n                    ctx.beginPath();\r\n                    const firstPoint = polygon.points[0];\r\n                    ctx.moveTo(firstPoint.x + offsetX, firstPoint.y + offsetY);\r\n\r\n                    for (let i = 1; i < polygon.points.length; i++) {\r\n                        const point = polygon.points[i];\r\n                        ctx.lineTo(point.x + offsetX, point.y + offsetY);\r\n                    }\r\n\r\n                    ctx.closePath();\r\n                    ctx.fill();\r\n                }\r\n            });\r\n        });\r\n\r\n        // Draw decorative squares\r\n        if (biome.enableSquares) {\r\n            cells.forEach(cell => {\r\n                cell.decorativeSquares.forEach(square => {\r\n                    // Use the stored color information for each square\r\n                    const squareColor = this.adjustColorBrightness(\r\n                        biome.fillColor, \r\n                        square.darkenAmount, \r\n                        square.lightenAmount\r\n                    );\r\n                    \r\n                    ctx.fillStyle = squareColor;\r\n                    ctx.globalAlpha = square.opacity;\r\n                    ctx.fillRect(\r\n                        square.x + offsetX - square.size / 2,\r\n                        square.y + offsetY - square.size / 2,\r\n                        square.size,\r\n                        square.size\r\n                    );\r\n                });\r\n            });\r\n            \r\n            ctx.globalAlpha = 1.0; // Reset alpha\r\n        }\r\n\r\n        // Draw contour lines for terrain edges (unchanged)\r\n        if (this.lineWidth > 0) {\r\n            ctx.strokeStyle = biome.color;\r\n            ctx.beginPath();\r\n            cells.forEach(cell => {\r\n                cell.contours.forEach(contour => {\r\n                    const startX = contour.startX + offsetX;\r\n                    const startY = contour.startY + offsetY;\r\n                    const endX = contour.endX + offsetX;\r\n                    const endY = contour.endY + offsetY;\r\n\r\n                    ctx.moveTo(startX, startY);\r\n                    ctx.lineTo(endX, endY);\r\n                });\r\n            });\r\n            ctx.stroke();\r\n        }\r\n    }\r\n\r\n    // New utility method for color blending\r\n    blendColors(color1, color2, ratio) {\r\n        const hex1 = color1.replace('#', '');\r\n        const hex2 = color2.replace('#', '');\r\n        \r\n        const r1 = parseInt(hex1.substr(0, 2), 16);\r\n        const g1 = parseInt(hex1.substr(2, 2), 16);\r\n        const b1 = parseInt(hex1.substr(4, 2), 16);\r\n        \r\n        const r2 = parseInt(hex2.substr(0, 2), 16);\r\n        const g2 = parseInt(hex2.substr(2, 2), 16);\r\n        const b2 = parseInt(hex2.substr(4, 2), 16);\r\n        \r\n        const r = Math.round(r1 * (1 - ratio) + r2 * ratio);\r\n        const g = Math.round(g1 * (1 - ratio) + g2 * ratio);\r\n        const b = Math.round(b1 * (1 - ratio) + b2 * ratio);\r\n        \r\n        return this.rgbaToHex(r, g, b);\r\n    }\r\n\r\n    expandPolygon(points, expansion = 1) {\r\n        if (points.length < 3) return points;\r\n\r\n        // Calculate polygon center\r\n        let centerX = 0, centerY = 0;\r\n        points.forEach(point => {\r\n            centerX += point.x;\r\n            centerY += point.y;\r\n        });\r\n        centerX /= points.length;\r\n        centerY /= points.length;\r\n\r\n        // Expand each point away from center\r\n        return points.map(point => {\r\n            const dx = point.x - centerX;\r\n            const dy = point.y - centerY;\r\n            const distance = Math.sqrt(dx * dx + dy * dy);\r\n\r\n            if (distance === 0) return point; // Avoid division by zero\r\n\r\n            // Calculate unit vector away from center\r\n            const unitX = dx / distance;\r\n            const unitY = dy / distance;\r\n\r\n            // Move point outward by expansion amount\r\n            return {\r\n                x: point.x + unitX * expansion,\r\n                y: point.y + unitY * expansion\r\n            };\r\n        });\r\n    }\r\n\r\n    drawGizmos(ctx) {\r\n        if (!this.showDebug) return;\r\n\r\n        const viewportBounds = this.getViewportBounds();\r\n\r\n        ctx.fillStyle = \"rgba(0, 0, 0, 0.7)\";\r\n        ctx.fillRect(5, 5, 250, 160);\r\n\r\n        ctx.fillStyle = \"lime\";\r\n        ctx.font = \"12px monospace\";\r\n\r\n        let y = 20;\r\n        const lineHeight = 15;\r\n\r\n        ctx.fillText(`Active Grids: ${this.activeGrids.size}`, 10, y); y += lineHeight;\r\n        ctx.fillText(`Cache Size: ${this.gridCache.size}`, 10, y); y += lineHeight;\r\n        ctx.fillText(`Grid Size: ${this.gridSize}px`, 10, y); y += lineHeight;\r\n        ctx.fillText(`Resolution: ${this.gridResolution}x${this.gridResolution}`, 10, y); y += lineHeight;\r\n        ctx.fillText(`Viewport: ${Math.round(viewportBounds.centerX)}, ${Math.round(viewportBounds.centerY)}`, 10, y); y += lineHeight;\r\n        ctx.fillText(`Noise Scale: ${this.noiseScale.toFixed(3)}`, 10, y); y += lineHeight;\r\n        ctx.fillText(`Threshold: ${this.threshold.toFixed(3)}`, 10, y); y += lineHeight;\r\n\r\n        // Biome legend\r\n        y += 5;\r\n        ctx.fillText(\"Biomes:\", 10, y); y += lineHeight;\r\n        Object.entries(this.biomes).forEach(([key, biome]) => {\r\n            ctx.fillStyle = biome.color;\r\n            ctx.fillRect(15, y - 10, 10, 10);\r\n            ctx.fillStyle = \"lime\";\r\n            ctx.fillText(`${biome.name}`, 30, y);\r\n            y += lineHeight;\r\n        });\r\n\r\n        // Draw grid boundaries\r\n        const gridWorldSize = this.gridSize * this.gridResolution;\r\n        const offsetX = viewportBounds.width / 2 - viewportBounds.centerX;\r\n        const offsetY = viewportBounds.height / 2 - viewportBounds.centerY;\r\n\r\n        ctx.strokeStyle = \"rgba(255, 0, 0, 0.3)\";\r\n        ctx.lineWidth = 1;\r\n        ctx.setLineDash([2, 2]);\r\n\r\n        // Draw visible grid boundaries\r\n        this.activeGrids.forEach(gridKey => {\r\n            const [x, y] = gridKey.split(',').map(Number);\r\n            const worldX = x * gridWorldSize;\r\n            const worldY = y * gridWorldSize;\r\n\r\n            const screenX = worldX + offsetX;\r\n            const screenY = worldY + offsetY;\r\n\r\n            ctx.strokeRect(screenX, screenY, gridWorldSize, gridWorldSize);\r\n        });\r\n\r\n        ctx.setLineDash([]);\r\n    }\r\n\r\n    getBiomeWithTransitions(x, y, height) {\r\n        const centerBiome = this.getBiome(x, y, height);\r\n\r\n        // Check neighboring biomes for smooth transitions\r\n        const neighbors = [\r\n            this.getBiome(x + this.gridSize, y, height),\r\n            this.getBiome(x - this.gridSize, y, height),\r\n            this.getBiome(x, y + this.gridSize, height),\r\n            this.getBiome(x, y - this.gridSize, height)\r\n        ];\r\n\r\n        // If center is different from neighbors, create transition\r\n        const differentNeighbors = neighbors.filter(biome => biome !== centerBiome);\r\n        if (differentNeighbors.length > 0) {\r\n            const transitionNoise = this.octaveNoise(x * this.biomeScale * 2, y * this.biomeScale * 2);\r\n            if (transitionNoise > 0.7) {\r\n                return differentNeighbors[0]; // Transition to neighbor biome\r\n            }\r\n        }\r\n\r\n        return centerBiome;\r\n    }\r\n\r\n    // Public API methods\r\n    getCellAtWorldPosition(worldX, worldY) {\r\n        const gridCoords = this.getGridCoords(worldX, worldY);\r\n        const gridKey = this.getGridKey(gridCoords.x, gridCoords.y);\r\n\r\n        // Generate the grid if it doesn't exist\r\n        const cells = this.generateGrid(gridCoords.x, gridCoords.y);\r\n\r\n        // Find the specific cell within the grid\r\n        const gridWorldSize = this.gridSize * this.gridResolution;\r\n        const gridWorldX = gridCoords.x * gridWorldSize;\r\n        const gridWorldY = gridCoords.y * gridWorldSize;\r\n\r\n        const cellX = Math.floor((worldX - gridWorldX) / this.gridSize);\r\n        const cellY = Math.floor((worldY - gridWorldY) / this.gridSize);\r\n\r\n        // Ensure cell coordinates are within bounds\r\n        if (cellX < 0 || cellX >= this.gridResolution || cellY < 0 || cellY >= this.gridResolution) {\r\n            return null;\r\n        }\r\n\r\n        const cellIndex = cellY * this.gridResolution + cellX;\r\n        return cells[cellIndex] || null;\r\n    }\r\n\r\n    // Get all cells at a world position (for edge cases)\r\n    getCellsAtWorldPosition(worldX, worldY) {\r\n        const cells = [];\r\n        const gridCoords = this.getGridCoords(worldX, worldY);\r\n        const gridKey = this.getGridKey(gridCoords.x, gridCoords.y);\r\n\r\n        // Generate the grid if it doesn't exist\r\n        const gridCells = this.generateGrid(gridCoords.x, gridCoords.y);\r\n\r\n        // Check if the position might be on the edge and need neighboring cells\r\n        const gridWorldSize = this.gridSize * this.gridResolution;\r\n        const gridWorldX = gridCoords.x * gridWorldSize;\r\n        const gridWorldY = gridCoords.y * gridWorldSize;\r\n\r\n        const cellX = Math.floor((worldX - gridWorldX) / this.gridSize);\r\n        const cellY = Math.floor((worldY - gridWorldY) / this.gridSize);\r\n\r\n        // Get the main cell\r\n        if (cellX >= 0 && cellX < this.gridResolution && cellY >= 0 && cellY < this.gridResolution) {\r\n            const cellIndex = cellY * this.gridResolution + cellX;\r\n            cells.push(gridCells[cellIndex]);\r\n        }\r\n\r\n        return cells;\r\n    }\r\n\r\n    // Check collision with terrain at world position\r\n    checkCollision(cellWorldX, cellWorldY, smooth = true) {\r\n        const cell = this.getCellAtWorldPosition(cellWorldX, cellWorldY);\r\n        if (!cell) {\r\n            return { collision: false, biome: null, height: 0 };\r\n        }\r\n\r\n        // Check if point is inside any terrain polygons\r\n        if (cell.polygons && cell.polygons.length > 0) {\r\n            for (const polygon of cell.polygons) {\r\n                if (this.isPointInPolygon(cellWorldX, cellWorldY, polygon.points)) {\r\n                    return {\r\n                        collision: true,\r\n                        biome: cell.biome,\r\n                        height: cell.avgHeight,\r\n                        polygon: polygon\r\n                    };\r\n                }\r\n            }\r\n        }\r\n\r\n        // If smooth is true, also check contour line intersections\r\n        if (smooth && cell.contours && cell.contours.length > 0) {\r\n            for (const contour of cell.contours) {\r\n                if (this.isPointOnLine(cellWorldX, cellWorldY, contour, 2)) { // 2px tolerance\r\n                    return {\r\n                        collision: true,\r\n                        biome: cell.biome,\r\n                        height: cell.avgHeight,\r\n                        contour: contour\r\n                    };\r\n                }\r\n            }\r\n        }\r\n\r\n        return { collision: false, biome: cell.biome, height: cell.avgHeight };\r\n    }\r\n\r\n    // Helper method to check if point is inside polygon\r\n    isPointInPolygon(x, y, points) {\r\n        let inside = false;\r\n        for (let i = 0, j = points.length - 1; i < points.length; j = i++) {\r\n            const xi = points[i].x, yi = points[i].y;\r\n            const xj = points[j].x, yj = points[j].y;\r\n\r\n            if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {\r\n                inside = !inside;\r\n            }\r\n        }\r\n        return inside;\r\n    }\r\n\r\n    // Helper method to check if point is on a line segment\r\n    isPointOnLine(x, y, contour, tolerance = 1) {\r\n        const startX = contour.startX;\r\n        const startY = contour.startY;\r\n        const endX = contour.endX;\r\n        const endY = contour.endY;\r\n\r\n        // Calculate distance from point to line segment\r\n        const A = x - startX;\r\n        const B = y - startY;\r\n        const C = endX - startX;\r\n        const D = endY - startY;\r\n\r\n        const dot = A * C + B * D;\r\n        const lenSq = C * C + D * D;\r\n\r\n        if (lenSq === 0) {\r\n            // Line segment is a point\r\n            return Math.sqrt(A * A + B * B) <= tolerance;\r\n        }\r\n\r\n        const param = dot / lenSq;\r\n\r\n        let xx, yy;\r\n        if (param < 0) {\r\n            xx = startX;\r\n            yy = startY;\r\n        } else if (param > 1) {\r\n            xx = endX;\r\n            yy = endY;\r\n        } else {\r\n            xx = startX + param * C;\r\n            yy = startY + param * D;\r\n        }\r\n\r\n        const dx = x - xx;\r\n        const dy = y - yy;\r\n        return Math.sqrt(dx * dx + dy * dy) <= tolerance;\r\n    }\r\n\r\n    // Advanced collision detection with multiple cells\r\n    checkCollisionAdvanced(worldX, worldY, radius = 0) {\r\n        const results = [];\r\n\r\n        // Check current cell\r\n        const cellResult = this.checkCollision(worldX, worldY, true);\r\n        if (cellResult.collision) {\r\n            results.push(cellResult);\r\n        }\r\n\r\n        // If radius is specified, check neighboring cells\r\n        if (radius > 0) {\r\n            const cells = this.getCellsAtWorldPosition(worldX, worldY);\r\n\r\n            // Check cells within radius\r\n            const checkRadius = Math.ceil(radius / this.gridSize);\r\n            for (let dy = -checkRadius; dy <= checkRadius; dy++) {\r\n                for (let dx = -checkRadius; dx <= checkRadius; dx++) {\r\n                    const checkX = worldX + dx * this.gridSize;\r\n                    const checkY = worldY + dy * this.gridSize;\r\n\r\n                    const neighborResult = this.checkCollision(checkX, checkY, true);\r\n                    if (neighborResult.collision) {\r\n                        results.push(neighborResult);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return results;\r\n    }\r\n\r\n    // Rigidbody API\r\n    /**\r\n     * NEW: Public API function to activate rigidbodies in a region\r\n     * @param {number} id - Unique identifier for the activation point\r\n     * @param {number} worldX - World X position\r\n     * @param {number} worldY - World Y position  \r\n     * @param {number} radius - Radius to activate rigidbodies within\r\n     */\r\n    activateRigidBodiesRegion(id, worldX, worldY, radius = this.rigidbodyRadius) {\r\n        if (!this.enableRigidbodies || !window.physicsManager) {\r\n            return;\r\n        }\r\n\r\n        const activationRadius = radius || this.rigidbodyRadius;\r\n\r\n        // NEW: Track this activation point instead of just using it once\r\n        this.addActivationPoint(id, worldX, worldY, activationRadius);\r\n\r\n        // Get grid bounds for the activation region\r\n        const minX = worldX - activationRadius;\r\n        const maxX = worldX + activationRadius;\r\n        const minY = worldY - activationRadius;\r\n        const maxY = worldY + activationRadius;\r\n\r\n        // Convert world coordinates to rigidbody grid coordinates\r\n        const minGridX = Math.floor(minX / this.rigidbodyGridSize);\r\n        const maxGridX = Math.floor(maxX / this.rigidbodyGridSize);\r\n        const minGridY = Math.floor(minY / this.rigidbodyGridSize);\r\n        const maxGridY = Math.floor(maxY / this.rigidbodyGridSize);\r\n\r\n        // Track which rigidbodies should be active\r\n        const shouldBeActive = new Set();\r\n\r\n        // Generate rigidbodies for grids within the activation radius\r\n        for (let gridY = minGridY; gridY <= maxGridY; gridY++) {\r\n            for (let gridX = minGridX; gridX <= maxGridX; gridX++) {\r\n                const gridKey = this.getRigidbodyGridKey(gridX, gridY);\r\n                shouldBeActive.add(gridKey);\r\n\r\n                // Check if we need to create this rigidbody\r\n                if (!this.activeRigidbodies.has(gridKey)) {\r\n                    this.createRigidbodyForGrid(gridX, gridY);\r\n                }\r\n            }\r\n        }\r\n\r\n        // NEW: Use the tracked activation points for cleanup instead of just current point\r\n        this.cleanupDistantRigidbodiesMultiPoint(shouldBeActive);\r\n    }\r\n\r\n    // NEW: Methods for tracking multiple activation points\r\n    addActivationPoint(id, worldX, worldY, radius) {\r\n        const pointId = id || ++this.activationPointId;\r\n        const activationPoint = {\r\n            id: pointId,\r\n            x: worldX,\r\n            y: worldY,\r\n            radius: radius,\r\n            timestamp: Date.now()\r\n        };\r\n\r\n        this.activeActivationPoints.set(pointId, activationPoint);\r\n\r\n        // Clean up old activation points (older than 30 seconds)\r\n        const thirtySecondsAgo = Date.now() - 30000;\r\n        for (const [id, point] of this.activeActivationPoints.entries()) {\r\n            if (point.timestamp < thirtySecondsAgo) {\r\n                this.activeActivationPoints.delete(id);\r\n            }\r\n        }\r\n\r\n        return pointId;\r\n    }\r\n\r\n    // NEW: Method to update existing activation point or create new one\r\n    updateActivationPoint(id, worldX, worldY, radius) {\r\n        // Check if activation point already exists\r\n        let existingPoint = null;\r\n        for (const [pointId, point] of this.activeActivationPoints.entries()) {\r\n            if (point.customId === id) {\r\n                existingPoint = point;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (existingPoint) {\r\n            // Update existing activation point\r\n            existingPoint.x = worldX;\r\n            existingPoint.y = worldY;\r\n            existingPoint.radius = radius;\r\n            existingPoint.timestamp = Date.now();\r\n        } else {\r\n            // Create new activation point with custom ID\r\n            const pointId = ++this.activationPointId;\r\n            const activationPoint = {\r\n                id: pointId,\r\n                customId: id, // Store the gameObject id for reference\r\n                x: worldX,\r\n                y: worldY,\r\n                radius: radius,\r\n                timestamp: Date.now()\r\n            };\r\n\r\n            this.activeActivationPoints.set(pointId, activationPoint);\r\n        }\r\n\r\n        // Clean up old activation points (older than 30 seconds)\r\n        const thirtySecondsAgo = Date.now() - 30000;\r\n        for (const [pointId, point] of this.activeActivationPoints.entries()) {\r\n            if (point.timestamp < thirtySecondsAgo) {\r\n                this.activeActivationPoints.delete(pointId);\r\n            }\r\n        }\r\n\r\n        return existingPoint ? existingPoint.id : this.activationPointId;\r\n    }\r\n\r\n    /**\r\n     * NEW: Clean up rigidbodies that are too far from ALL activation points\r\n     * @param {Set} shouldBeActive - Set of grid keys that should remain active\r\n     */\r\n    cleanupDistantRigidbodiesMultiPoint(shouldBeActive) {\r\n        const toRemove = [];\r\n\r\n        this.activeRigidbodies.forEach((rigidbodyData, gridKey) => {\r\n            // Skip if this rigidbody should remain active\r\n            if (shouldBeActive.has(gridKey)) {\r\n                rigidbodyData.lastActive = Date.now();\r\n                return;\r\n            }\r\n\r\n            // Check if this rigidbody is within range of ANY activation point\r\n            let isWithinAnyActivationPoint = false;\r\n\r\n            for (const activationPoint of this.activeActivationPoints.values()) {\r\n                const distance = Math.sqrt(\r\n                    Math.pow(rigidbodyData.worldX - activationPoint.x, 2) +\r\n                    Math.pow(rigidbodyData.worldY - activationPoint.y, 2)\r\n                );\r\n\r\n                if (distance <= activationPoint.radius + this.rigidbodyCleanupThreshold) {\r\n                    isWithinAnyActivationPoint = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // Remove if too far from ALL activation points\r\n            if (!isWithinAnyActivationPoint) {\r\n                toRemove.push(gridKey);\r\n            }\r\n        });\r\n\r\n        // Remove distant rigidbodies\r\n        toRemove.forEach(gridKey => {\r\n            this.removeRigidbody(gridKey);\r\n        });\r\n\r\n        if (toRemove.length > 0) {\r\n            console.log(`Cleaned up ${toRemove.length} distant rigidbodies (multi-point cleanup)`);\r\n        }\r\n\r\n        //this.activeActivationPoints.clear(); // Clear after cleanup\r\n    }\r\n\r\n    /**\r\n     * NEW: Get rigidbody grid key for a grid position\r\n     * @param {number} gridX - Grid X coordinate\r\n     * @param {number} gridY - Grid Y coordinate\r\n     * @returns {string} Grid key\r\n     */\r\n    getRigidbodyGridKey(gridX, gridY) {\r\n        return `rb_${gridX},${gridY}`;\r\n    }\r\n\r\n    /**\r\n     * NEW: Create a rigidbody for a specific rigidbody grid\r\n     * @param {number} gridX - Grid X coordinate\r\n     * @param {number} gridY - Grid Y coordinate\r\n     */\r\n    createRigidbodyForGrid(gridX, gridY) {\r\n        if (!window.physicsManager) return;\r\n\r\n        const gridKey = this.getRigidbodyGridKey(gridX, gridY);\r\n\r\n        // Calculate world bounds for this rigidbody grid\r\n        const worldX = gridX * this.rigidbodyGridSize;\r\n        const worldY = gridY * this.rigidbodyGridSize;\r\n        const worldSize = this.rigidbodyGridSize;\r\n\r\n        // FIXED: Get terrain cells using the SAME grid system as rendering\r\n        const overlappingCells = this.getTerrainCellsInBoundsFixed(\r\n            worldX, worldY, worldSize, worldSize\r\n        );\r\n\r\n        if (overlappingCells.length === 0) {\r\n            return;\r\n        }\r\n\r\n        const bodies = [];\r\n\r\n        overlappingCells.forEach(cell => {\r\n            if (cell.polygons && cell.polygons.length > 0) {\r\n                cell.polygons.forEach(polygon => {\r\n                    if (polygon.points && polygon.points.length >= 3) {\r\n                        // FIXED: Create rigidbody for ALL polygons that intersect the bounds\r\n                        // instead of just checking center\r\n                        if (this.polygonIntersectsBounds(polygon.points, worldX, worldY, worldSize)) {\r\n                            const rigidbodyData = this.createPolygonRigidbodyFixed(\r\n                                polygon.points,\r\n                                cell.biome\r\n                            );\r\n\r\n                            if (rigidbodyData && rigidbodyData.body) {\r\n                                window.physicsManager.registerBody(rigidbodyData.body, rigidbodyData.gameObject);\r\n                                bodies.push(rigidbodyData.body);\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        });\r\n\r\n        if (bodies.length > 0) {\r\n            this.activeRigidbodies.set(gridKey, {\r\n                bodies: bodies,\r\n                gridX: gridX,\r\n                gridY: gridY,\r\n                worldX: worldX,\r\n                worldY: worldY,\r\n                lastActive: Date.now()\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * NEW: Create a rigidbody for a single polygon with viewport offset\r\n     * @param {Array} points - Polygon points\r\n     * @param {string} biome - Biome type\r\n     * @param {number} offsetX - X offset\r\n     * @param {number} offsetY - Y offset\r\n     * @returns {Object|null} Rigidbody data or null\r\n     */\r\n    createPolygonRigidbody(points, biome, offsetX, offsetY) {\r\n        if (!window.physicsManager || !points || points.length < 3) {\r\n            return null;\r\n        }\r\n\r\n        try {\r\n            // Calculate the actual center of the polygon\r\n            let centerX = 0, centerY = 0;\r\n            points.forEach(point => {\r\n                centerX += point.x;\r\n                centerY += point.y;\r\n            });\r\n            centerX /= points.length;\r\n            centerY /= points.length;\r\n\r\n            // Apply viewport offset to match visual terrain position\r\n            const viewportBounds = this.getViewportBounds();\r\n            const viewportOffsetX = viewportBounds.width / 2 - viewportBounds.centerX;\r\n            const viewportOffsetY = viewportBounds.height / 2 - viewportBounds.centerY;\r\n\r\n            const physicsCenterX = centerX + viewportOffsetX;\r\n            const physicsCenterY = centerY + viewportOffsetY;\r\n\r\n            // Convert points to be relative to center (Matter.js requirement)\r\n            const relativePoints = points.map(point => ({\r\n                x: point.x - centerX,\r\n                y: point.y - centerY\r\n            }));\r\n\r\n            // Create polygon body at the actual polygon center WITH viewport offset\r\n            const body = Matter.Bodies.fromVertices(physicsCenterX, physicsCenterY, [relativePoints], {\r\n                isStatic: true,\r\n                friction: this.getBiomeFriction(biome),\r\n                restitution: 0.1,\r\n                collisionFilter: {\r\n                    category: 0x0001,\r\n                    mask: 0xFFFFFFFF,\r\n                    group: 0\r\n                },\r\n                render: {\r\n                    fillStyle: this.biomes[biome]?.fillColor || '#666666',\r\n                    strokeStyle: this.biomes[biome]?.color || '#333333',\r\n                    lineWidth: 1\r\n                }\r\n            });\r\n\r\n            Matter.Body.setStatic(body, true);\r\n\r\n            // Create game object at the actual polygon position WITH viewport offset\r\n            const gameObject = this.createRigidbodyGameObject(physicsCenterX, physicsCenterY);\r\n            gameObject.isTerrainRigidbody = true;\r\n            gameObject.terrainBiome = biome;\r\n\r\n            return {\r\n                body: body,\r\n                gameObject: gameObject\r\n            };\r\n        } catch (error) {\r\n            console.error(\"Error creating polygon rigidbody:\", error);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * NEW: Create a game object for rigidbody management\r\n     * @param {number} x - X position\r\n     * @param {number} y - Y position\r\n     * @returns {GameObject} Game object\r\n     */\r\n    createRigidbodyGameObject(x, y) {\r\n        // Create a minimal game object for physics management\r\n        const gameObject = {\r\n            position: new Vector2(x, y),\r\n            angle: 0,\r\n            name: `TerrainRigidbody_${x}_${y}`,\r\n            isTerrainRigidbody: true,\r\n            getWorldPosition: function () { return this.position; },\r\n            setWorldPosition: function (x, y) { this.position.set(x, y); }\r\n        };\r\n        return gameObject;\r\n    }\r\n\r\n    /**\r\n     * NEW: Get terrain cells within specified bounds\r\n     * @param {number} worldX - World X position\r\n     * @param {number} worldY - World Y position\r\n     * @param {number} width - Width of bounds\r\n     * @param {number} height - Height of bounds\r\n     * @returns {Array} Array of terrain cells\r\n     */\r\n    getTerrainCellsInBoundsFixed(worldX, worldY, width, height) {\r\n        const cells = [];\r\n        const minX = worldX;\r\n        const maxX = worldX + width;\r\n        const minY = worldY;\r\n        const maxY = worldY + height;\r\n\r\n        // FIXED: Use the SAME grid system as the terrain rendering\r\n        const terrainGridSize = this.gridSize * this.gridResolution;\r\n        const minTerrainGridX = Math.floor(minX / terrainGridSize);\r\n        const maxTerrainGridX = Math.floor(maxX / terrainGridSize);\r\n        const minTerrainGridY = Math.floor(minY / terrainGridSize);\r\n        const maxTerrainGridY = Math.floor(maxY / terrainGridSize);\r\n\r\n        for (let gridY = minTerrainGridY; gridY <= maxTerrainGridY; gridY++) {\r\n            for (let gridX = minTerrainGridX; gridX <= maxTerrainGridX; gridX++) {\r\n                const terrainCells = this.generateGrid(gridX, gridY);\r\n                if (terrainCells) {\r\n                    // FIXED: Filter cells to only include those that actually intersect our bounds\r\n                    terrainCells.forEach(cell => {\r\n                        if (this.cellIntersectsBounds(cell, minX, minY, maxX - minX, maxY - minY)) {\r\n                            cells.push(cell);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n        }\r\n\r\n        return cells;\r\n    }\r\n\r\n    polygonIntersectsBounds(points, boundsX, boundsY, boundsSize) {\r\n        // Check if any polygon point is within bounds\r\n        for (const point of points) {\r\n            if (point.x >= boundsX && point.x <= boundsX + boundsSize &&\r\n                point.y >= boundsY && point.y <= boundsY + boundsSize) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        // Check if any bound corner is within polygon\r\n        const boundCorners = [\r\n            { x: boundsX, y: boundsY },\r\n            { x: boundsX + boundsSize, y: boundsY },\r\n            { x: boundsX + boundsSize, y: boundsY + boundsSize },\r\n            { x: boundsX, y: boundsY + boundsSize }\r\n        ];\r\n\r\n        for (const corner of boundCorners) {\r\n            if (this.isPointInPolygon(corner.x, corner.y, points)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * FIXED: Check if a terrain cell intersects with bounds\r\n     */\r\n    cellIntersectsBounds(cell, boundsX, boundsY, boundsWidth, boundsHeight) {\r\n        const cellRight = cell.x + this.gridSize;\r\n        const cellBottom = cell.y + this.gridSize;\r\n        const boundsRight = boundsX + boundsWidth;\r\n        const boundsBottom = boundsY + boundsHeight;\r\n\r\n        return !(cell.x >= boundsRight || cellRight <= boundsX ||\r\n            cell.y >= boundsBottom || cellBottom <= boundsY);\r\n    }\r\n\r\n    /**\r\n     * FIXED: Create rigidbody with exact polygon coordinates and viewport offset\r\n     */\r\n    createPolygonRigidbodyFixed(points, biome) {\r\n        if (!window.physicsManager || !points || points.length < 3) {\r\n            return null;\r\n        }\r\n\r\n        try {\r\n            // FIXED: Validate points before creating rigidbody\r\n            const validPoints = points.filter(p =>\r\n                p && typeof p.x === 'number' && typeof p.y === 'number' &&\r\n                !isNaN(p.x) && !isNaN(p.y) && isFinite(p.x) && isFinite(p.y)\r\n            );\r\n\r\n            if (validPoints.length < 3) {\r\n                console.warn(\"Not enough valid points for rigidbody creation\");\r\n                return null;\r\n            }\r\n\r\n            // FIXED: Calculate the actual center of the polygon (world position)\r\n            let centerX = 0, centerY = 0, area = 0;\r\n            for (let i = 0; i < validPoints.length; i++) {\r\n                const j = (i + 1) % validPoints.length;\r\n                const cross = validPoints[i].x * validPoints[j].y - validPoints[j].x * validPoints[i].y;\r\n                area += cross;\r\n                centerX += (validPoints[i].x + validPoints[j].x) * cross;\r\n                centerY += (validPoints[i].y + validPoints[j].y) * cross;\r\n            }\r\n            area /= 2;\r\n            centerX /= (6 * area);\r\n            centerY /= (6 * area);\r\n\r\n            // FIXED: Apply viewport offset to match visual terrain position\r\n            const viewportBounds = this.getViewportBounds();\r\n            const viewportOffsetX = 0;//viewportBounds.width / 2 - viewportBounds.centerX;\r\n            const viewportOffsetY = 0;//viewportBounds.height / 2 - viewportBounds.centerY;\r\n\r\n            const physicsCenterX = centerX + viewportOffsetX;\r\n            const physicsCenterY = centerY + viewportOffsetY;\r\n\r\n            // FIXED: Convert points to be relative to center (Matter.js requirement)\r\n            const relativePoints = validPoints.map(point => ({\r\n                x: point.x - centerX,\r\n                y: point.y - centerY\r\n            }));\r\n\r\n            // FIXED: Create body at WORLD position WITH viewport offset to match visual terrain\r\n            const body = Matter.Bodies.fromVertices(physicsCenterX, physicsCenterY, [relativePoints], {\r\n                isStatic: true,\r\n                friction: this.getBiomeFriction(biome),\r\n                restitution: 0.1,\r\n                collisionFilter: {\r\n                    category: 0x0001,\r\n                    mask: 0xFFFFFFFF,\r\n                    group: 0\r\n                },\r\n                render: {\r\n                    fillStyle: this.biomes[biome]?.fillColor || '#666666',\r\n                    strokeStyle: this.biomes[biome]?.color || '#333333',\r\n                    lineWidth: 1\r\n                }\r\n            });\r\n\r\n\r\n            Matter.Body.setStatic(body, true);\r\n\r\n            // FIXED: Verify the body was created successfully\r\n            if (!body || !body.vertices) {\r\n                console.warn(\"Failed to create Matter.js body\");\r\n                return null;\r\n            }\r\n\r\n            // FIXED: Create game object at WORLD position WITH viewport offset to match visual terrain\r\n            const gameObject = this.createRigidbodyGameObject(physicsCenterX, physicsCenterY);\r\n            gameObject.isTerrainRigidbody = true;\r\n            gameObject.terrainBiome = biome;\r\n\r\n            return {\r\n                body: body,\r\n                gameObject: gameObject\r\n            };\r\n        } catch (error) {\r\n            console.error(\"Error creating polygon rigidbody:\", error, points);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * NEW: Get friction value for biome\r\n     * @param {string} biome - Biome type\r\n     * @returns {number} Friction value\r\n     */\r\n    getBiomeFriction(biome) {\r\n        const frictionMap = {\r\n            grass: 0.7//,\r\n            //dirt: 0.8\r\n        };\r\n        return frictionMap[biome] || 0.7;\r\n    }\r\n\r\n    /**\r\n     * NEW: Clean up rigidbodies that are too far from activation point\r\n     * @param {number} worldX - World X position\r\n     * @param {number} worldY - World Y position\r\n     * @param {number} activationRadius - Activation radius\r\n     * @param {Set} shouldBeActive - Set of grid keys that should remain active\r\n     */\r\n    cleanupDistantRigidbodies(worldX, worldY, activationRadius, shouldBeActive) {\r\n        const toRemove = [];\r\n\r\n        this.activeRigidbodies.forEach((rigidbodyData, gridKey) => {\r\n            // Skip if this rigidbody should remain active\r\n            if (shouldBeActive.has(gridKey)) {\r\n                rigidbodyData.lastActive = Date.now();\r\n                return;\r\n            }\r\n\r\n            // Calculate distance from activation point\r\n            const distance = Math.sqrt(\r\n                Math.pow(rigidbodyData.worldX - worldX, 2) +\r\n                Math.pow(rigidbodyData.worldY - worldY, 2)\r\n            );\r\n\r\n            // Remove if too far away\r\n            if (distance > activationRadius + this.rigidbodyCleanupThreshold) {\r\n                toRemove.push(gridKey);\r\n            }\r\n        });\r\n\r\n        // Remove distant rigidbodies\r\n        toRemove.forEach(gridKey => {\r\n            this.removeRigidbody(gridKey);\r\n        });\r\n\r\n        if (toRemove.length > 0) {\r\n            console.log(`Cleaned up ${toRemove.length} distant rigidbodies`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * NEW: Remove a rigidbody by grid key\r\n     * @param {string} gridKey - Grid key of rigidbody to remove\r\n     */\r\n    removeRigidbody(gridKey) {\r\n        const rigidbodyData = this.activeRigidbodies.get(gridKey);\r\n        if (rigidbodyData && window.physicsManager) {\r\n            // Handle both single body (old format) and array of bodies (new format)\r\n            if (rigidbodyData.body) {\r\n                window.physicsManager.removeBody(rigidbodyData.body);\r\n            } else if (rigidbodyData.bodies) {\r\n                rigidbodyData.bodies.forEach(body => {\r\n                    window.physicsManager.removeBody(body);\r\n                });\r\n            }\r\n            this.activeRigidbodies.delete(gridKey);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * NEW: Clear all rigidbodies\r\n     */\r\n    clearAllRigidbodies() {\r\n        this.activeRigidbodies.forEach((rigidbodyData, gridKey) => {\r\n            this.removeRigidbody(gridKey);\r\n        });\r\n        this.activeRigidbodies.clear();\r\n        console.log(\"Cleared all terrain rigidbodies\");\r\n    }\r\n\r\n    /**\r\n     * NEW: Get rigidbody statistics for debugging\r\n     * @returns {Object} Statistics object\r\n     */\r\n    getRigidbodyStats() {\r\n        return {\r\n            activeCount: this.activeRigidbodies.size,\r\n            enabled: this.enableRigidbodies,\r\n            radius: this.rigidbodyRadius,\r\n            gridSize: this.rigidbodyGridSize,\r\n            enableRigidbodies: this.enableRigidbodies,\r\n            rigidbodyRadius: this.rigidbodyRadius,\r\n            rigidbodyGridSize: this.rigidbodyGridSize\r\n        };\r\n    }\r\n\r\n    toJSON() {\r\n        return {\r\n            ...super.toJSON(),\r\n            gridSize: this.gridSize,\r\n            gridResolution: this.gridResolution,\r\n            threshold: this.threshold,\r\n            noiseScale: this.noiseScale,\r\n            noiseOctaves: this.noiseOctaves,\r\n            noisePersistence: this.noisePersistence,\r\n            noiseLacunarity: this.noiseLacunarity,\r\n            terrainHeight: this.terrainHeight,\r\n            lineWidth: this.lineWidth,\r\n            smoothTerrain: this.smoothTerrain,\r\n            seed: this.seed,\r\n            viewportMargin: this.viewportMargin,\r\n            biomeScale: this.biomeScale,\r\n            showDebug: this.showDebug,\r\n            biomes: this.biomes,\r\n            enableRigidbodies: this.enableRigidbodies,\r\n            rigidbodyRadius: this.rigidbodyRadius,\r\n            rigidbodyGridSize: this.rigidbodyGridSize,\r\n            // New generation type properties\r\n            generationType: this.generationType,\r\n            mazeComplexity: this.mazeComplexity,\r\n            minHeight: this.minHeight,\r\n            voronoiSites: this.voronoiSites,\r\n            voronoiRelaxation: this.voronoiRelaxation\r\n        };\r\n    }\r\n\r\n    fromJSON(data) {\r\n        super.fromJSON(data);\r\n\r\n        if (!data) return;\r\n\r\n        this.gridSize = data.gridSize || 20;\r\n        this.gridResolution = data.gridResolution || 16;\r\n        this.threshold = data.threshold || 0.5;\r\n        this.noiseScale = data.noiseScale || 0.015;\r\n        this.noiseOctaves = data.noiseOctaves || 4;\r\n        this.noisePersistence = data.noisePersistence || 0.5;\r\n        this.noiseLacunarity = data.noiseLacunarity || 2.0;\r\n        this.terrainHeight = data.terrainHeight || 100;\r\n        this.lineWidth = data.lineWidth || 1.5;\r\n        this.smoothTerrain = data.smoothTerrain !== undefined ? data.smoothTerrain : true;\r\n        this.seed = data.seed || 12345;\r\n        this.viewportMargin = data.viewportMargin || 200;\r\n        this.biomeScale = data.biomeScale || 0.005;\r\n        this.showDebug = data.showDebug || false;\r\n\r\n        if (data.biomes) {\r\n            this.biomes = { ...this.biomes, ...data.biomes };\r\n        }\r\n\r\n        this.enableRigidbodies = data.enableRigidbodies || false;\r\n        this.rigidbodyRadius = data.rigidbodyRadius || 100;\r\n        this.rigidbodyGridSize = data.rigidbodyGridSize || 50;\r\n\r\n        // Restore new generation type properties\r\n        this.generationType = data.generationType || \"Random\";\r\n        this.mazeComplexity = data.mazeComplexity !== undefined ? data.mazeComplexity : 0.7;\r\n        this.minHeight = data.minHeight !== undefined ? data.minHeight : 500;\r\n        this.voronoiSites = data.voronoiSites !== undefined ? data.voronoiSites : 50;\r\n        this.voronoiRelaxation = data.voronoiRelaxation !== undefined ? data.voronoiRelaxation : 1;\r\n\r\n        // Restore rigidbodies if they were active\r\n        if (this.enableRigidbodies) {\r\n            // Note: Rigidbodies will be recreated as needed when activateRigidBodiesRegion is called\r\n            console.log(\"Rigidbody system enabled - rigidbodies will be recreated on demand\");\r\n        }\r\n\r\n        this.clearCache();\r\n    }\r\n}\r\n\r\nwindow.MarchingCubesTerrain = MarchingCubesTerrain;",
      "type": "file",
      "name": "MarchingCubesTerrain.js",
      "parentPath": "/",
      "created": 1758693213573,
      "modified": 1758693213573
    }
  ],
  "metadata": {
    "exportedBy": "Dark Matter JS Game Engine",
    "exportVersion": "1.0",
    "engineVersion": "1.0.0",
    "selectionMode": "explicit-directories-only"
  }
}